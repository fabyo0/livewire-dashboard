"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkjimipulsar_github_com"] = self["webpackChunkjimipulsar_github_com"] || []).push([["node_modules_vite_dist_node_chunks_dep-C6EFp3uH_js"],{

/***/ "./node_modules/vite/dist/node/chunks/dep-C6EFp3uH.js":
/*!************************************************************!*\
  !*** ./node_modules/vite/dist/node/chunks/dep-C6EFp3uH.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   i: () => (/* binding */ index$1)\n/* harmony export */ });\n/* harmony import */ var _dep_CB_7IfJ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dep-CB_7IfJ-.js */ \"./node_modules/vite/dist/node/chunks/dep-CB_7IfJ-.js\");\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var _dep_IQS_Za7F_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dep-IQS-Za7F.js */ \"./node_modules/vite/dist/node/chunks/dep-IQS-Za7F.js\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_module__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:module */ \"node:module\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n\n\n\n\n\n\n\n\n\nconst __filename = (0,node_url__WEBPACK_IMPORTED_MODULE_3__.fileURLToPath)(\"file:///var/www/html/livewire-tall/node_modules/vite/dist/node/chunks/dep-C6EFp3uH.js\");\nconst __dirname = (0,node_path__WEBPACK_IMPORTED_MODULE_4__.dirname)(__filename);\nconst require = (0,node_module__WEBPACK_IMPORTED_MODULE_5__.createRequire)(\"file:///var/www/html/livewire-tall/node_modules/vite/dist/node/chunks/dep-C6EFp3uH.js\");\nconst __require = require;\nfunction _mergeNamespaces(n, m) {\n  for (var i = 0; i < m.length; i++) {\n    var e = m[i];\n    if (typeof e !== 'string' && !Array.isArray(e)) { for (var k in e) {\n      if (k !== 'default' && !(k in n)) {\n        n[k] = e[k];\n      }\n    } }\n  }\n  return n;\n}\n\nvar formatImportPrelude$2 = function formatImportPrelude(layer, media, supports) {\n  const parts = [];\n\n  if (typeof layer !== \"undefined\") {\n    let layerParams = \"layer\";\n    if (layer) {\n      layerParams = `layer(${layer})`;\n    }\n\n    parts.push(layerParams);\n  }\n\n  if (typeof supports !== \"undefined\") {\n    parts.push(`supports(${supports})`);\n  }\n\n  if (typeof media !== \"undefined\") {\n    parts.push(media);\n  }\n\n  return parts.join(\" \")\n};\n\nconst formatImportPrelude$1 = formatImportPrelude$2;\n\n// Base64 encode an import with conditions\n// The order of conditions is important and is interleaved with cascade layer declarations\n// Each group of conditions and cascade layers needs to be interpreted in order\n// To achieve this we create a list of base64 encoded imports, where each import contains a stylesheet with another import.\n// Each import can define a single group of conditions and a single cascade layer.\nvar base64EncodedImport = function base64EncodedConditionalImport(prelude, conditions) {\n  conditions.reverse();\n  const first = conditions.pop();\n  let params = `${prelude} ${formatImportPrelude$1(\n    first.layer,\n    first.media,\n    first.supports,\n  )}`;\n\n  for (const condition of conditions) {\n    params = `'data:text/css;base64,${Buffer.from(`@import ${params}`).toString(\n      \"base64\",\n    )}' ${formatImportPrelude$1(\n      condition.layer,\n      condition.media,\n      condition.supports,\n    )}`;\n  }\n\n  return params\n};\n\nconst base64EncodedConditionalImport = base64EncodedImport;\n\nvar applyConditions$1 = function applyConditions(bundle, atRule) {\n  bundle.forEach(stmt => {\n    if (\n      stmt.type === \"charset\" ||\n      stmt.type === \"warning\" ||\n      !stmt.conditions?.length\n    ) {\n      return\n    }\n\n    if (stmt.type === \"import\") {\n      stmt.node.params = base64EncodedConditionalImport(\n        stmt.fullUri,\n        stmt.conditions,\n      );\n      return\n    }\n\n    const { nodes } = stmt;\n    const { parent } = nodes[0];\n\n    const atRules = [];\n\n    // Convert conditions to at-rules\n    for (const condition of stmt.conditions) {\n      if (typeof condition.media !== \"undefined\") {\n        const mediaNode = atRule({\n          name: \"media\",\n          params: condition.media,\n          source: parent.source,\n        });\n\n        atRules.push(mediaNode);\n      }\n\n      if (typeof condition.supports !== \"undefined\") {\n        const supportsNode = atRule({\n          name: \"supports\",\n          params: `(${condition.supports})`,\n          source: parent.source,\n        });\n\n        atRules.push(supportsNode);\n      }\n\n      if (typeof condition.layer !== \"undefined\") {\n        const layerNode = atRule({\n          name: \"layer\",\n          params: condition.layer,\n          source: parent.source,\n        });\n\n        atRules.push(layerNode);\n      }\n    }\n\n    // Add nodes to AST\n    const outerAtRule = atRules.shift();\n    const innerAtRule = atRules.reduce((previous, next) => {\n      previous.append(next);\n      return next\n    }, outerAtRule);\n\n    parent.insertBefore(nodes[0], outerAtRule);\n\n    // remove nodes\n    nodes.forEach(node => {\n      node.parent = undefined;\n    });\n\n    // better output\n    nodes[0].raws.before = nodes[0].raws.before || \"\\n\";\n\n    // wrap new rules with media query and/or layer at rule\n    innerAtRule.append(nodes);\n\n    stmt.type = \"nodes\";\n    stmt.nodes = [outerAtRule];\n    delete stmt.node;\n  });\n};\n\nvar applyRaws$1 = function applyRaws(bundle) {\n  bundle.forEach((stmt, index) => {\n    if (index === 0) return\n\n    if (stmt.parent) {\n      const { before } = stmt.parent.node.raws;\n      if (stmt.type === \"nodes\") stmt.nodes[0].raws.before = before;\n      else stmt.node.raws.before = before;\n    } else if (stmt.type === \"nodes\") {\n      stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || \"\\n\";\n    }\n  });\n};\n\nvar applyStyles$1 = function applyStyles(bundle, styles) {\n  styles.nodes = [];\n\n  // Strip additional statements.\n  bundle.forEach(stmt => {\n    if ([\"charset\", \"import\"].includes(stmt.type)) {\n      stmt.node.parent = undefined;\n      styles.append(stmt.node);\n    } else if (stmt.type === \"nodes\") {\n      stmt.nodes.forEach(node => {\n        node.parent = undefined;\n        styles.append(node);\n      });\n    }\n  });\n};\n\nvar readCache$1 = {exports: {}};\n\nvar pify$2 = {exports: {}};\n\nvar processFn = function (fn, P, opts) {\n\treturn function () {\n\t\tvar that = this;\n\t\tvar args = new Array(arguments.length);\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\n\t\treturn new P(function (resolve, reject) {\n\t\t\targs.push(function (err, result) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else if (opts.multiArgs) {\n\t\t\t\t\tvar results = new Array(arguments.length - 1);\n\n\t\t\t\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\t\t\t\tresults[i - 1] = arguments[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(results);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfn.apply(that, args);\n\t\t});\n\t};\n};\n\nvar pify$1 = pify$2.exports = function (obj, P, opts) {\n\tif (typeof P !== 'function') {\n\t\topts = P;\n\t\tP = Promise;\n\t}\n\n\topts = opts || {};\n\topts.exclude = opts.exclude || [/.+Sync$/];\n\n\tvar filter = function (key) {\n\t\tvar match = function (pattern) {\n\t\t\treturn typeof pattern === 'string' ? key === pattern : pattern.test(key);\n\t\t};\n\n\t\treturn opts.include ? opts.include.some(match) : !opts.exclude.some(match);\n\t};\n\n\tvar ret = typeof obj === 'function' ? function () {\n\t\tif (opts.excludeMain) {\n\t\t\treturn obj.apply(this, arguments);\n\t\t}\n\n\t\treturn processFn(obj, P, opts).apply(this, arguments);\n\t} : {};\n\n\treturn Object.keys(obj).reduce(function (ret, key) {\n\t\tvar x = obj[key];\n\n\t\tret[key] = typeof x === 'function' && filter(key) ? processFn(x, P, opts) : x;\n\n\t\treturn ret;\n\t}, ret);\n};\n\npify$1.all = pify$1;\n\nvar pifyExports = pify$2.exports;\n\nvar fs = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\r\nvar path$3 = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\r\nvar pify = pifyExports;\r\n\r\nvar stat = pify(fs.stat);\r\nvar readFile = pify(fs.readFile);\r\nvar resolve = path$3.resolve;\r\n\r\nvar cache = Object.create(null);\r\n\r\nfunction convert(content, encoding) {\r\n\tif (Buffer.isEncoding(encoding)) {\r\n\t\treturn content.toString(encoding);\r\n\t}\r\n\treturn content;\r\n}\r\n\r\nreadCache$1.exports = function (path, encoding) {\r\n\tpath = resolve(path);\r\n\r\n\treturn stat(path).then(function (stats) {\r\n\t\tvar item = cache[path];\r\n\r\n\t\tif (item && item.mtime.getTime() === stats.mtime.getTime()) {\r\n\t\t\treturn convert(item.content, encoding);\r\n\t\t}\r\n\r\n\t\treturn readFile(path).then(function (data) {\r\n\t\t\tcache[path] = {\r\n\t\t\t\tmtime: stats.mtime,\r\n\t\t\t\tcontent: data\r\n\t\t\t};\r\n\r\n\t\t\treturn convert(data, encoding);\r\n\t\t});\r\n\t}).catch(function (err) {\r\n\t\tcache[path] = null;\r\n\t\treturn Promise.reject(err);\r\n\t});\r\n};\r\n\r\nreadCache$1.exports.sync = function (path, encoding) {\r\n\tpath = resolve(path);\r\n\r\n\ttry {\r\n\t\tvar stats = fs.statSync(path);\r\n\t\tvar item = cache[path];\r\n\r\n\t\tif (item && item.mtime.getTime() === stats.mtime.getTime()) {\r\n\t\t\treturn convert(item.content, encoding);\r\n\t\t}\r\n\r\n\t\tvar data = fs.readFileSync(path);\r\n\r\n\t\tcache[path] = {\r\n\t\t\tmtime: stats.mtime,\r\n\t\t\tcontent: data\r\n\t\t};\r\n\r\n\t\treturn convert(data, encoding);\r\n\t} catch (err) {\r\n\t\tcache[path] = null;\r\n\t\tthrow err;\r\n\t}\r\n\r\n};\r\n\r\nreadCache$1.exports.get = function (path, encoding) {\r\n\tpath = resolve(path);\r\n\tif (cache[path]) {\r\n\t\treturn convert(cache[path].content, encoding);\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nreadCache$1.exports.clear = function () {\r\n\tcache = Object.create(null);\r\n};\n\nvar readCacheExports = readCache$1.exports;\n\nconst anyDataURLRegexp = /^data:text\\/css(?:;(base64|plain))?,/i;\nconst base64DataURLRegexp = /^data:text\\/css;base64,/i;\nconst plainDataURLRegexp = /^data:text\\/css;plain,/i;\n\nfunction isValid(url) {\n  return anyDataURLRegexp.test(url)\n}\n\nfunction contents(url) {\n  if (base64DataURLRegexp.test(url)) {\n    // \"data:text/css;base64,\".length === 21\n    return Buffer.from(url.slice(21), \"base64\").toString()\n  }\n\n  if (plainDataURLRegexp.test(url)) {\n    // \"data:text/css;plain,\".length === 20\n    return decodeURIComponent(url.slice(20))\n  }\n\n  // \"data:text/css,\".length === 14\n  return decodeURIComponent(url.slice(14))\n}\n\nvar dataUrl = {\n  isValid,\n  contents,\n};\n\nconst readCache = readCacheExports;\nconst dataURL$1 = dataUrl;\n\nvar loadContent$1 = function loadContent(filename) {\n  if (dataURL$1.isValid(filename)) {\n    return dataURL$1.contents(filename)\n  }\n\n  return readCache(filename, \"utf-8\")\n};\n\n// external tooling\nconst valueParser = _dep_IQS_Za7F_js__WEBPACK_IMPORTED_MODULE_2__.l;\n\n// extended tooling\nconst { stringify } = valueParser;\n\nvar parseStatements$1 = function parseStatements(result, styles, conditions, from) {\n  const statements = [];\n  let nodes = [];\n\n  styles.each(node => {\n    let stmt;\n    if (node.type === \"atrule\") {\n      if (node.name === \"import\")\n        stmt = parseImport(result, node, conditions, from);\n      else if (node.name === \"charset\")\n        stmt = parseCharset(result, node, conditions, from);\n    }\n\n    if (stmt) {\n      if (nodes.length) {\n        statements.push({\n          type: \"nodes\",\n          nodes,\n          conditions: [...conditions],\n          from,\n        });\n        nodes = [];\n      }\n      statements.push(stmt);\n    } else nodes.push(node);\n  });\n\n  if (nodes.length) {\n    statements.push({\n      type: \"nodes\",\n      nodes,\n      conditions: [...conditions],\n      from,\n    });\n  }\n\n  return statements\n};\n\nfunction parseCharset(result, atRule, conditions, from) {\n  if (atRule.prev()) {\n    return result.warn(\"@charset must precede all other statements\", {\n      node: atRule,\n    })\n  }\n  return {\n    type: \"charset\",\n    node: atRule,\n    conditions: [...conditions],\n    from,\n  }\n}\n\nfunction parseImport(result, atRule, conditions, from) {\n  let prev = atRule.prev();\n\n  // `@import` statements may follow other `@import` statements.\n  if (prev) {\n    do {\n      if (\n        prev.type === \"comment\" ||\n        (prev.type === \"atrule\" && prev.name === \"import\")\n      ) {\n        prev = prev.prev();\n        continue\n      }\n\n      break\n    } while (prev)\n  }\n\n  // All `@import` statements may be preceded by `@charset` or `@layer` statements.\n  // But the `@import` statements must be consecutive.\n  if (prev) {\n    do {\n      if (\n        prev.type === \"comment\" ||\n        (prev.type === \"atrule\" &&\n          (prev.name === \"charset\" || (prev.name === \"layer\" && !prev.nodes)))\n      ) {\n        prev = prev.prev();\n        continue\n      }\n\n      return result.warn(\n        \"@import must precede all other statements (besides @charset or empty @layer)\",\n        { node: atRule },\n      )\n    } while (prev)\n  }\n\n  if (atRule.nodes) {\n    return result.warn(\n      \"It looks like you didn't end your @import statement correctly. \" +\n        \"Child nodes are attached to it.\",\n      { node: atRule },\n    )\n  }\n\n  const params = valueParser(atRule.params).nodes;\n  const stmt = {\n    type: \"import\",\n    uri: \"\",\n    fullUri: \"\",\n    node: atRule,\n    conditions: [...conditions],\n    from,\n  };\n\n  let layer;\n  let media;\n  let supports;\n\n  for (let i = 0; i < params.length; i++) {\n    const node = params[i];\n\n    if (node.type === \"space\" || node.type === \"comment\") continue\n\n    if (node.type === \"string\") {\n      if (stmt.uri) {\n        return result.warn(`Multiple url's in '${atRule.toString()}'`, {\n          node: atRule,\n        })\n      }\n\n      if (!node.value) {\n        return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\n          node: atRule,\n        })\n      }\n\n      stmt.uri = node.value;\n      stmt.fullUri = stringify(node);\n      continue\n    }\n\n    if (node.type === \"function\" && /^url$/i.test(node.value)) {\n      if (stmt.uri) {\n        return result.warn(`Multiple url's in '${atRule.toString()}'`, {\n          node: atRule,\n        })\n      }\n\n      if (!node.nodes?.[0]?.value) {\n        return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\n          node: atRule,\n        })\n      }\n\n      stmt.uri = node.nodes[0].value;\n      stmt.fullUri = stringify(node);\n      continue\n    }\n\n    if (!stmt.uri) {\n      return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\n        node: atRule,\n      })\n    }\n\n    if (\n      (node.type === \"word\" || node.type === \"function\") &&\n      /^layer$/i.test(node.value)\n    ) {\n      if (typeof layer !== \"undefined\") {\n        return result.warn(`Multiple layers in '${atRule.toString()}'`, {\n          node: atRule,\n        })\n      }\n\n      if (typeof supports !== \"undefined\") {\n        return result.warn(\n          `layers must be defined before support conditions in '${atRule.toString()}'`,\n          {\n            node: atRule,\n          },\n        )\n      }\n\n      if (node.nodes) {\n        layer = stringify(node.nodes);\n      } else {\n        layer = \"\";\n      }\n\n      continue\n    }\n\n    if (node.type === \"function\" && /^supports$/i.test(node.value)) {\n      if (typeof supports !== \"undefined\") {\n        return result.warn(\n          `Multiple support conditions in '${atRule.toString()}'`,\n          {\n            node: atRule,\n          },\n        )\n      }\n\n      supports = stringify(node.nodes);\n\n      continue\n    }\n\n    media = stringify(params.slice(i));\n    break\n  }\n\n  if (!stmt.uri) {\n    return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\n      node: atRule,\n    })\n  }\n\n  if (\n    typeof media !== \"undefined\" ||\n    typeof layer !== \"undefined\" ||\n    typeof supports !== \"undefined\"\n  ) {\n    stmt.conditions.push({\n      layer,\n      media,\n      supports,\n    });\n  }\n\n  return stmt\n}\n\n// builtin tooling\nconst path$2 = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\n// placeholder tooling\nlet sugarss;\n\nvar processContent$1 = function processContent(\n  result,\n  content,\n  filename,\n  options,\n  postcss,\n) {\n  const { plugins } = options;\n  const ext = path$2.extname(filename);\n\n  const parserList = [];\n\n  // SugarSS support:\n  if (ext === \".sss\") {\n    if (!sugarss) {\n      /* c8 ignore next 3 */\n      try {\n        sugarss = __require('sugarss');\n      } catch {} // Ignore\n    }\n    if (sugarss)\n      return runPostcss(postcss, content, filename, plugins, [sugarss])\n  }\n\n  // Syntax support:\n  if (result.opts.syntax?.parse) {\n    parserList.push(result.opts.syntax.parse);\n  }\n\n  // Parser support:\n  if (result.opts.parser) parserList.push(result.opts.parser);\n  // Try the default as a last resort:\n  parserList.push(null);\n\n  return runPostcss(postcss, content, filename, plugins, parserList)\n};\n\nfunction runPostcss(postcss, content, filename, plugins, parsers, index) {\n  if (!index) index = 0;\n  return postcss(plugins)\n    .process(content, {\n      from: filename,\n      parser: parsers[index],\n    })\n    .catch(err => {\n      // If there's an error, try the next parser\n      index++;\n      // If there are no parsers left, throw it\n      if (index === parsers.length) throw err\n      return runPostcss(postcss, content, filename, plugins, parsers, index)\n    })\n}\n\nconst path$1 = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\nconst dataURL = dataUrl;\nconst parseStatements = parseStatements$1;\nconst processContent = processContent$1;\nconst resolveId$1 = (id) => id;\nconst formatImportPrelude = formatImportPrelude$2;\n\nasync function parseStyles$1(\n  result,\n  styles,\n  options,\n  state,\n  conditions,\n  from,\n  postcss,\n) {\n  const statements = parseStatements(result, styles, conditions, from);\n\n  for (const stmt of statements) {\n    if (stmt.type !== \"import\" || !isProcessableURL(stmt.uri)) {\n      continue\n    }\n\n    if (options.filter && !options.filter(stmt.uri)) {\n      // rejected by filter\n      continue\n    }\n\n    await resolveImportId(result, stmt, options, state, postcss);\n  }\n\n  let charset;\n  const imports = [];\n  const bundle = [];\n\n  function handleCharset(stmt) {\n    if (!charset) charset = stmt;\n    // charsets aren't case-sensitive, so convert to lower case to compare\n    else if (\n      stmt.node.params.toLowerCase() !== charset.node.params.toLowerCase()\n    ) {\n      throw stmt.node.error(\n        `Incompatible @charset statements:\n  ${stmt.node.params} specified in ${stmt.node.source.input.file}\n  ${charset.node.params} specified in ${charset.node.source.input.file}`,\n      )\n    }\n  }\n\n  // squash statements and their children\n  statements.forEach(stmt => {\n    if (stmt.type === \"charset\") handleCharset(stmt);\n    else if (stmt.type === \"import\") {\n      if (stmt.children) {\n        stmt.children.forEach((child, index) => {\n          if (child.type === \"import\") imports.push(child);\n          else if (child.type === \"charset\") handleCharset(child);\n          else bundle.push(child);\n          // For better output\n          if (index === 0) child.parent = stmt;\n        });\n      } else imports.push(stmt);\n    } else if (stmt.type === \"nodes\") {\n      bundle.push(stmt);\n    }\n  });\n\n  return charset ? [charset, ...imports.concat(bundle)] : imports.concat(bundle)\n}\n\nasync function resolveImportId(result, stmt, options, state, postcss) {\n  if (dataURL.isValid(stmt.uri)) {\n    // eslint-disable-next-line require-atomic-updates\n    stmt.children = await loadImportContent(\n      result,\n      stmt,\n      stmt.uri,\n      options,\n      state,\n      postcss,\n    );\n\n    return\n  } else if (dataURL.isValid(stmt.from.slice(-1))) {\n    // Data urls can't be used as a base url to resolve imports.\n    throw stmt.node.error(\n      `Unable to import '${stmt.uri}' from a stylesheet that is embedded in a data url`,\n    )\n  }\n\n  const atRule = stmt.node;\n  let sourceFile;\n  if (atRule.source?.input?.file) {\n    sourceFile = atRule.source.input.file;\n  }\n  const base = sourceFile\n    ? path$1.dirname(atRule.source.input.file)\n    : options.root;\n\n  const paths = [await options.resolve(stmt.uri, base, options, atRule)].flat();\n\n  // Ensure that each path is absolute:\n  const resolved = await Promise.all(\n    paths.map(file => {\n      return !path$1.isAbsolute(file)\n        ? resolveId$1(file)\n        : file\n    }),\n  );\n\n  // Add dependency messages:\n  resolved.forEach(file => {\n    result.messages.push({\n      type: \"dependency\",\n      plugin: \"postcss-import\",\n      file,\n      parent: sourceFile,\n    });\n  });\n\n  const importedContent = await Promise.all(\n    resolved.map(file => {\n      return loadImportContent(result, stmt, file, options, state, postcss)\n    }),\n  );\n\n  // Merge loaded statements\n  // eslint-disable-next-line require-atomic-updates\n  stmt.children = importedContent.flat().filter(x => !!x);\n}\n\nasync function loadImportContent(\n  result,\n  stmt,\n  filename,\n  options,\n  state,\n  postcss,\n) {\n  const atRule = stmt.node;\n  const { conditions, from } = stmt;\n  const stmtDuplicateCheckKey = conditions\n    .map(condition =>\n      formatImportPrelude(condition.layer, condition.media, condition.supports),\n    )\n    .join(\":\");\n\n  if (options.skipDuplicates) {\n    // skip files already imported at the same scope\n    if (state.importedFiles[filename]?.[stmtDuplicateCheckKey]) {\n      return\n    }\n\n    // save imported files to skip them next time\n    if (!state.importedFiles[filename]) {\n      state.importedFiles[filename] = {};\n    }\n    state.importedFiles[filename][stmtDuplicateCheckKey] = true;\n  }\n\n  if (from.includes(filename)) {\n    return\n  }\n\n  const content = await options.load(filename, options);\n\n  if (content.trim() === \"\" && options.warnOnEmpty) {\n    result.warn(`${filename} is empty`, { node: atRule });\n    return\n  }\n\n  // skip previous imported files not containing @import rules\n  if (\n    options.skipDuplicates &&\n    state.hashFiles[content]?.[stmtDuplicateCheckKey]\n  ) {\n    return\n  }\n\n  const importedResult = await processContent(\n    result,\n    content,\n    filename,\n    options,\n    postcss,\n  );\n\n  const styles = importedResult.root;\n  result.messages = result.messages.concat(importedResult.messages);\n\n  if (options.skipDuplicates) {\n    const hasImport = styles.some(child => {\n      return child.type === \"atrule\" && child.name === \"import\"\n    });\n    if (!hasImport) {\n      // save hash files to skip them next time\n      if (!state.hashFiles[content]) {\n        state.hashFiles[content] = {};\n      }\n\n      state.hashFiles[content][stmtDuplicateCheckKey] = true;\n    }\n  }\n\n  // recursion: import @import from imported file\n  return parseStyles$1(\n    result,\n    styles,\n    options,\n    state,\n    conditions,\n    [...from, filename],\n    postcss,\n  )\n}\n\nfunction isProcessableURL(uri) {\n  // skip protocol base uri (protocol://url) or protocol-relative\n  if (/^(?:[a-z]+:)?\\/\\//i.test(uri)) {\n    return false\n  }\n\n  // check for fragment or query\n  try {\n    // needs a base to parse properly\n    const url = new URL(uri, \"https://example.com\");\n    if (url.search) {\n      return false\n    }\n  } catch {} // Ignore\n\n  return true\n}\n\nvar parseStyles_1 = parseStyles$1;\n\n// builtin tooling\nconst path = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\n// internal tooling\nconst applyConditions = applyConditions$1;\nconst applyRaws = applyRaws$1;\nconst applyStyles = applyStyles$1;\nconst loadContent = loadContent$1;\nconst parseStyles = parseStyles_1;\nconst resolveId = (id) => id;\n\nfunction AtImport(options) {\n  options = {\n    root: process.cwd(),\n    path: [],\n    skipDuplicates: true,\n    resolve: resolveId,\n    load: loadContent,\n    plugins: [],\n    addModulesDirectories: [],\n    warnOnEmpty: true,\n    ...options,\n  };\n\n  options.root = path.resolve(options.root);\n\n  // convert string to an array of a single element\n  if (typeof options.path === \"string\") options.path = [options.path];\n\n  if (!Array.isArray(options.path)) options.path = [];\n\n  options.path = options.path.map(p => path.resolve(options.root, p));\n\n  return {\n    postcssPlugin: \"postcss-import\",\n    async Once(styles, { result, atRule, postcss }) {\n      const state = {\n        importedFiles: {},\n        hashFiles: {},\n      };\n\n      if (styles.source?.input?.file) {\n        state.importedFiles[styles.source.input.file] = {};\n      }\n\n      if (options.plugins && !Array.isArray(options.plugins)) {\n        throw new Error(\"plugins option must be an array\")\n      }\n\n      const bundle = await parseStyles(\n        result,\n        styles,\n        options,\n        state,\n        [],\n        [],\n        postcss,\n      );\n\n      applyRaws(bundle);\n      applyConditions(bundle, atRule);\n      applyStyles(bundle, styles);\n    },\n  }\n}\n\nAtImport.postcss = true;\n\nvar postcssImport = AtImport;\n\nvar index = /*@__PURE__*/(0,_dep_CB_7IfJ_js__WEBPACK_IMPORTED_MODULE_0__.B)(postcssImport);\n\nvar index$1 = /*#__PURE__*/_mergeNamespaces({\n  __proto__: null,\n  default: index\n}, [postcssImport]);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdml0ZS9kaXN0L25vZGUvY2h1bmtzL2RlcC1DNkVGcDN1SC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQWlFO0FBQ25DO0FBQ087QUFDUTs7QUFFbUI7QUFDWDtBQUNjOztBQUVuRSxtQkFBbUIsdURBQW1CLENBQUMsdUZBQWU7QUFDdEQsa0JBQWtCLGtEQUFhO0FBQy9CLGdCQUFnQiwwREFBbUIsQ0FBQyx1RkFBZTtBQUNuRDtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTLEVBQUU7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLDZCQUE2QixTQUFTLE1BQU0saUJBQWlCLE9BQU87QUFDcEU7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxRQUFRO0FBQ3BCLFlBQVksU0FBUzs7QUFFckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7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QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx5QkFBeUIsa0RBQXVCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUV1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2ppbWlwdWxzYXJAZ2l0aHViLmNvbS8uL25vZGVfbW9kdWxlcy92aXRlL2Rpc3Qvbm9kZS9jaHVua3MvZGVwLUM2RUZwM3VILmpzPzdjZWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQiBhcyBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyB9IGZyb20gJy4vZGVwLUNCXzdJZkotLmpzJztcbmltcG9ydCByZXF1aXJlJCQwIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHJlcXVpcmUkJDBfX2RlZmF1bHQgZnJvbSAnZnMnO1xuaW1wb3J0IHsgbCBhcyBsaWIgfSBmcm9tICcuL2RlcC1JUVMtWmE3Ri5qcyc7XG5cbmltcG9ydCB7IGZpbGVVUkxUb1BhdGggYXMgX19janNfZmlsZVVSTFRvUGF0aCB9IGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IGRpcm5hbWUgYXMgX19janNfZGlybmFtZSB9IGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIGFzIF9fY2pzX2NyZWF0ZVJlcXVpcmUgfSBmcm9tICdub2RlOm1vZHVsZSc7XG5cbmNvbnN0IF9fZmlsZW5hbWUgPSBfX2Nqc19maWxlVVJMVG9QYXRoKGltcG9ydC5tZXRhLnVybCk7XG5jb25zdCBfX2Rpcm5hbWUgPSBfX2Nqc19kaXJuYW1lKF9fZmlsZW5hbWUpO1xuY29uc3QgcmVxdWlyZSA9IF9fY2pzX2NyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcbmNvbnN0IF9fcmVxdWlyZSA9IHJlcXVpcmU7XG5mdW5jdGlvbiBfbWVyZ2VOYW1lc3BhY2VzKG4sIG0pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGUgPSBtW2ldO1xuICAgIGlmICh0eXBlb2YgZSAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkoZSkpIHsgZm9yICh2YXIgayBpbiBlKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnICYmICEoayBpbiBuKSkge1xuICAgICAgICBuW2tdID0gZVtrXTtcbiAgICAgIH1cbiAgICB9IH1cbiAgfVxuICByZXR1cm4gbjtcbn1cblxudmFyIGZvcm1hdEltcG9ydFByZWx1ZGUkMiA9IGZ1bmN0aW9uIGZvcm1hdEltcG9ydFByZWx1ZGUobGF5ZXIsIG1lZGlhLCBzdXBwb3J0cykge1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBsZXQgbGF5ZXJQYXJhbXMgPSBcImxheWVyXCI7XG4gICAgaWYgKGxheWVyKSB7XG4gICAgICBsYXllclBhcmFtcyA9IGBsYXllcigke2xheWVyfSlgO1xuICAgIH1cblxuICAgIHBhcnRzLnB1c2gobGF5ZXJQYXJhbXMpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzdXBwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHBhcnRzLnB1c2goYHN1cHBvcnRzKCR7c3VwcG9ydHN9KWApO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBtZWRpYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHBhcnRzLnB1c2gobWVkaWEpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oXCIgXCIpXG59O1xuXG5jb25zdCBmb3JtYXRJbXBvcnRQcmVsdWRlJDEgPSBmb3JtYXRJbXBvcnRQcmVsdWRlJDI7XG5cbi8vIEJhc2U2NCBlbmNvZGUgYW4gaW1wb3J0IHdpdGggY29uZGl0aW9uc1xuLy8gVGhlIG9yZGVyIG9mIGNvbmRpdGlvbnMgaXMgaW1wb3J0YW50IGFuZCBpcyBpbnRlcmxlYXZlZCB3aXRoIGNhc2NhZGUgbGF5ZXIgZGVjbGFyYXRpb25zXG4vLyBFYWNoIGdyb3VwIG9mIGNvbmRpdGlvbnMgYW5kIGNhc2NhZGUgbGF5ZXJzIG5lZWRzIHRvIGJlIGludGVycHJldGVkIGluIG9yZGVyXG4vLyBUbyBhY2hpZXZlIHRoaXMgd2UgY3JlYXRlIGEgbGlzdCBvZiBiYXNlNjQgZW5jb2RlZCBpbXBvcnRzLCB3aGVyZSBlYWNoIGltcG9ydCBjb250YWlucyBhIHN0eWxlc2hlZXQgd2l0aCBhbm90aGVyIGltcG9ydC5cbi8vIEVhY2ggaW1wb3J0IGNhbiBkZWZpbmUgYSBzaW5nbGUgZ3JvdXAgb2YgY29uZGl0aW9ucyBhbmQgYSBzaW5nbGUgY2FzY2FkZSBsYXllci5cbnZhciBiYXNlNjRFbmNvZGVkSW1wb3J0ID0gZnVuY3Rpb24gYmFzZTY0RW5jb2RlZENvbmRpdGlvbmFsSW1wb3J0KHByZWx1ZGUsIGNvbmRpdGlvbnMpIHtcbiAgY29uZGl0aW9ucy5yZXZlcnNlKCk7XG4gIGNvbnN0IGZpcnN0ID0gY29uZGl0aW9ucy5wb3AoKTtcbiAgbGV0IHBhcmFtcyA9IGAke3ByZWx1ZGV9ICR7Zm9ybWF0SW1wb3J0UHJlbHVkZSQxKFxuICAgIGZpcnN0LmxheWVyLFxuICAgIGZpcnN0Lm1lZGlhLFxuICAgIGZpcnN0LnN1cHBvcnRzLFxuICApfWA7XG5cbiAgZm9yIChjb25zdCBjb25kaXRpb24gb2YgY29uZGl0aW9ucykge1xuICAgIHBhcmFtcyA9IGAnZGF0YTp0ZXh0L2NzcztiYXNlNjQsJHtCdWZmZXIuZnJvbShgQGltcG9ydCAke3BhcmFtc31gKS50b1N0cmluZyhcbiAgICAgIFwiYmFzZTY0XCIsXG4gICAgKX0nICR7Zm9ybWF0SW1wb3J0UHJlbHVkZSQxKFxuICAgICAgY29uZGl0aW9uLmxheWVyLFxuICAgICAgY29uZGl0aW9uLm1lZGlhLFxuICAgICAgY29uZGl0aW9uLnN1cHBvcnRzLFxuICAgICl9YDtcbiAgfVxuXG4gIHJldHVybiBwYXJhbXNcbn07XG5cbmNvbnN0IGJhc2U2NEVuY29kZWRDb25kaXRpb25hbEltcG9ydCA9IGJhc2U2NEVuY29kZWRJbXBvcnQ7XG5cbnZhciBhcHBseUNvbmRpdGlvbnMkMSA9IGZ1bmN0aW9uIGFwcGx5Q29uZGl0aW9ucyhidW5kbGUsIGF0UnVsZSkge1xuICBidW5kbGUuZm9yRWFjaChzdG10ID0+IHtcbiAgICBpZiAoXG4gICAgICBzdG10LnR5cGUgPT09IFwiY2hhcnNldFwiIHx8XG4gICAgICBzdG10LnR5cGUgPT09IFwid2FybmluZ1wiIHx8XG4gICAgICAhc3RtdC5jb25kaXRpb25zPy5sZW5ndGhcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChzdG10LnR5cGUgPT09IFwiaW1wb3J0XCIpIHtcbiAgICAgIHN0bXQubm9kZS5wYXJhbXMgPSBiYXNlNjRFbmNvZGVkQ29uZGl0aW9uYWxJbXBvcnQoXG4gICAgICAgIHN0bXQuZnVsbFVyaSxcbiAgICAgICAgc3RtdC5jb25kaXRpb25zLFxuICAgICAgKTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHsgbm9kZXMgfSA9IHN0bXQ7XG4gICAgY29uc3QgeyBwYXJlbnQgfSA9IG5vZGVzWzBdO1xuXG4gICAgY29uc3QgYXRSdWxlcyA9IFtdO1xuXG4gICAgLy8gQ29udmVydCBjb25kaXRpb25zIHRvIGF0LXJ1bGVzXG4gICAgZm9yIChjb25zdCBjb25kaXRpb24gb2Ygc3RtdC5jb25kaXRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIGNvbmRpdGlvbi5tZWRpYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBtZWRpYU5vZGUgPSBhdFJ1bGUoe1xuICAgICAgICAgIG5hbWU6IFwibWVkaWFcIixcbiAgICAgICAgICBwYXJhbXM6IGNvbmRpdGlvbi5tZWRpYSxcbiAgICAgICAgICBzb3VyY2U6IHBhcmVudC5zb3VyY2UsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF0UnVsZXMucHVzaChtZWRpYU5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmRpdGlvbi5zdXBwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBzdXBwb3J0c05vZGUgPSBhdFJ1bGUoe1xuICAgICAgICAgIG5hbWU6IFwic3VwcG9ydHNcIixcbiAgICAgICAgICBwYXJhbXM6IGAoJHtjb25kaXRpb24uc3VwcG9ydHN9KWAsXG4gICAgICAgICAgc291cmNlOiBwYXJlbnQuc291cmNlLFxuICAgICAgICB9KTtcblxuICAgICAgICBhdFJ1bGVzLnB1c2goc3VwcG9ydHNOb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjb25kaXRpb24ubGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uc3QgbGF5ZXJOb2RlID0gYXRSdWxlKHtcbiAgICAgICAgICBuYW1lOiBcImxheWVyXCIsXG4gICAgICAgICAgcGFyYW1zOiBjb25kaXRpb24ubGF5ZXIsXG4gICAgICAgICAgc291cmNlOiBwYXJlbnQuc291cmNlLFxuICAgICAgICB9KTtcblxuICAgICAgICBhdFJ1bGVzLnB1c2gobGF5ZXJOb2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgbm9kZXMgdG8gQVNUXG4gICAgY29uc3Qgb3V0ZXJBdFJ1bGUgPSBhdFJ1bGVzLnNoaWZ0KCk7XG4gICAgY29uc3QgaW5uZXJBdFJ1bGUgPSBhdFJ1bGVzLnJlZHVjZSgocHJldmlvdXMsIG5leHQpID0+IHtcbiAgICAgIHByZXZpb3VzLmFwcGVuZChuZXh0KTtcbiAgICAgIHJldHVybiBuZXh0XG4gICAgfSwgb3V0ZXJBdFJ1bGUpO1xuXG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShub2Rlc1swXSwgb3V0ZXJBdFJ1bGUpO1xuXG4gICAgLy8gcmVtb3ZlIG5vZGVzXG4gICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIG5vZGUucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgIH0pO1xuXG4gICAgLy8gYmV0dGVyIG91dHB1dFxuICAgIG5vZGVzWzBdLnJhd3MuYmVmb3JlID0gbm9kZXNbMF0ucmF3cy5iZWZvcmUgfHwgXCJcXG5cIjtcblxuICAgIC8vIHdyYXAgbmV3IHJ1bGVzIHdpdGggbWVkaWEgcXVlcnkgYW5kL29yIGxheWVyIGF0IHJ1bGVcbiAgICBpbm5lckF0UnVsZS5hcHBlbmQobm9kZXMpO1xuXG4gICAgc3RtdC50eXBlID0gXCJub2Rlc1wiO1xuICAgIHN0bXQubm9kZXMgPSBbb3V0ZXJBdFJ1bGVdO1xuICAgIGRlbGV0ZSBzdG10Lm5vZGU7XG4gIH0pO1xufTtcblxudmFyIGFwcGx5UmF3cyQxID0gZnVuY3Rpb24gYXBwbHlSYXdzKGJ1bmRsZSkge1xuICBidW5kbGUuZm9yRWFjaCgoc3RtdCwgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggPT09IDApIHJldHVyblxuXG4gICAgaWYgKHN0bXQucGFyZW50KSB7XG4gICAgICBjb25zdCB7IGJlZm9yZSB9ID0gc3RtdC5wYXJlbnQubm9kZS5yYXdzO1xuICAgICAgaWYgKHN0bXQudHlwZSA9PT0gXCJub2Rlc1wiKSBzdG10Lm5vZGVzWzBdLnJhd3MuYmVmb3JlID0gYmVmb3JlO1xuICAgICAgZWxzZSBzdG10Lm5vZGUucmF3cy5iZWZvcmUgPSBiZWZvcmU7XG4gICAgfSBlbHNlIGlmIChzdG10LnR5cGUgPT09IFwibm9kZXNcIikge1xuICAgICAgc3RtdC5ub2Rlc1swXS5yYXdzLmJlZm9yZSA9IHN0bXQubm9kZXNbMF0ucmF3cy5iZWZvcmUgfHwgXCJcXG5cIjtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGFwcGx5U3R5bGVzJDEgPSBmdW5jdGlvbiBhcHBseVN0eWxlcyhidW5kbGUsIHN0eWxlcykge1xuICBzdHlsZXMubm9kZXMgPSBbXTtcblxuICAvLyBTdHJpcCBhZGRpdGlvbmFsIHN0YXRlbWVudHMuXG4gIGJ1bmRsZS5mb3JFYWNoKHN0bXQgPT4ge1xuICAgIGlmIChbXCJjaGFyc2V0XCIsIFwiaW1wb3J0XCJdLmluY2x1ZGVzKHN0bXQudHlwZSkpIHtcbiAgICAgIHN0bXQubm9kZS5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICBzdHlsZXMuYXBwZW5kKHN0bXQubm9kZSk7XG4gICAgfSBlbHNlIGlmIChzdG10LnR5cGUgPT09IFwibm9kZXNcIikge1xuICAgICAgc3RtdC5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICBub2RlLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3R5bGVzLmFwcGVuZChub2RlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgcmVhZENhY2hlJDEgPSB7ZXhwb3J0czoge319O1xuXG52YXIgcGlmeSQyID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIHByb2Nlc3NGbiA9IGZ1bmN0aW9uIChmbiwgUCwgb3B0cykge1xuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG5cdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyKTtcblx0XHRcdFx0fSBlbHNlIGlmIChvcHRzLm11bHRpQXJncykge1xuXHRcdFx0XHRcdHZhciByZXN1bHRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xuXHRcdH0pO1xuXHR9O1xufTtcblxudmFyIHBpZnkkMSA9IHBpZnkkMi5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgUCwgb3B0cykge1xuXHRpZiAodHlwZW9mIFAgIT09ICdmdW5jdGlvbicpIHtcblx0XHRvcHRzID0gUDtcblx0XHRQID0gUHJvbWlzZTtcblx0fVxuXG5cdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHRvcHRzLmV4Y2x1ZGUgPSBvcHRzLmV4Y2x1ZGUgfHwgWy8uK1N5bmMkL107XG5cblx0dmFyIGZpbHRlciA9IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgbWF0Y2ggPSBmdW5jdGlvbiAocGF0dGVybikge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJyA/IGtleSA9PT0gcGF0dGVybiA6IHBhdHRlcm4udGVzdChrZXkpO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gb3B0cy5pbmNsdWRlID8gb3B0cy5pbmNsdWRlLnNvbWUobWF0Y2gpIDogIW9wdHMuZXhjbHVkZS5zb21lKG1hdGNoKTtcblx0fTtcblxuXHR2YXIgcmV0ID0gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAob3B0cy5leGNsdWRlTWFpbikge1xuXHRcdFx0cmV0dXJuIG9iai5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblxuXHRcdHJldHVybiBwcm9jZXNzRm4ob2JqLCBQLCBvcHRzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9IDoge307XG5cblx0cmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKGZ1bmN0aW9uIChyZXQsIGtleSkge1xuXHRcdHZhciB4ID0gb2JqW2tleV07XG5cblx0XHRyZXRba2V5XSA9IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nICYmIGZpbHRlcihrZXkpID8gcHJvY2Vzc0ZuKHgsIFAsIG9wdHMpIDogeDtcblxuXHRcdHJldHVybiByZXQ7XG5cdH0sIHJldCk7XG59O1xuXG5waWZ5JDEuYWxsID0gcGlmeSQxO1xuXG52YXIgcGlmeUV4cG9ydHMgPSBwaWZ5JDIuZXhwb3J0cztcblxudmFyIGZzID0gcmVxdWlyZSQkMF9fZGVmYXVsdDtcclxudmFyIHBhdGgkMyA9IHJlcXVpcmUkJDA7XHJcbnZhciBwaWZ5ID0gcGlmeUV4cG9ydHM7XHJcblxyXG52YXIgc3RhdCA9IHBpZnkoZnMuc3RhdCk7XHJcbnZhciByZWFkRmlsZSA9IHBpZnkoZnMucmVhZEZpbGUpO1xyXG52YXIgcmVzb2x2ZSA9IHBhdGgkMy5yZXNvbHZlO1xyXG5cclxudmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuXHJcbmZ1bmN0aW9uIGNvbnZlcnQoY29udGVudCwgZW5jb2RpbmcpIHtcclxuXHRpZiAoQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XHJcblx0XHRyZXR1cm4gY29udGVudC50b1N0cmluZyhlbmNvZGluZyk7XHJcblx0fVxyXG5cdHJldHVybiBjb250ZW50O1xyXG59XHJcblxyXG5yZWFkQ2FjaGUkMS5leHBvcnRzID0gZnVuY3Rpb24gKHBhdGgsIGVuY29kaW5nKSB7XHJcblx0cGF0aCA9IHJlc29sdmUocGF0aCk7XHJcblxyXG5cdHJldHVybiBzdGF0KHBhdGgpLnRoZW4oZnVuY3Rpb24gKHN0YXRzKSB7XHJcblx0XHR2YXIgaXRlbSA9IGNhY2hlW3BhdGhdO1xyXG5cclxuXHRcdGlmIChpdGVtICYmIGl0ZW0ubXRpbWUuZ2V0VGltZSgpID09PSBzdGF0cy5tdGltZS5nZXRUaW1lKCkpIHtcclxuXHRcdFx0cmV0dXJuIGNvbnZlcnQoaXRlbS5jb250ZW50LCBlbmNvZGluZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlYWRGaWxlKHBhdGgpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuXHRcdFx0Y2FjaGVbcGF0aF0gPSB7XHJcblx0XHRcdFx0bXRpbWU6IHN0YXRzLm10aW1lLFxyXG5cdFx0XHRcdGNvbnRlbnQ6IGRhdGFcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHJldHVybiBjb252ZXJ0KGRhdGEsIGVuY29kaW5nKTtcclxuXHRcdH0pO1xyXG5cdH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcclxuXHRcdGNhY2hlW3BhdGhdID0gbnVsbDtcclxuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxucmVhZENhY2hlJDEuZXhwb3J0cy5zeW5jID0gZnVuY3Rpb24gKHBhdGgsIGVuY29kaW5nKSB7XHJcblx0cGF0aCA9IHJlc29sdmUocGF0aCk7XHJcblxyXG5cdHRyeSB7XHJcblx0XHR2YXIgc3RhdHMgPSBmcy5zdGF0U3luYyhwYXRoKTtcclxuXHRcdHZhciBpdGVtID0gY2FjaGVbcGF0aF07XHJcblxyXG5cdFx0aWYgKGl0ZW0gJiYgaXRlbS5tdGltZS5nZXRUaW1lKCkgPT09IHN0YXRzLm10aW1lLmdldFRpbWUoKSkge1xyXG5cdFx0XHRyZXR1cm4gY29udmVydChpdGVtLmNvbnRlbnQsIGVuY29kaW5nKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyhwYXRoKTtcclxuXHJcblx0XHRjYWNoZVtwYXRoXSA9IHtcclxuXHRcdFx0bXRpbWU6IHN0YXRzLm10aW1lLFxyXG5cdFx0XHRjb250ZW50OiBkYXRhXHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiBjb252ZXJ0KGRhdGEsIGVuY29kaW5nKTtcclxuXHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdGNhY2hlW3BhdGhdID0gbnVsbDtcclxuXHRcdHRocm93IGVycjtcclxuXHR9XHJcblxyXG59O1xyXG5cclxucmVhZENhY2hlJDEuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiAocGF0aCwgZW5jb2RpbmcpIHtcclxuXHRwYXRoID0gcmVzb2x2ZShwYXRoKTtcclxuXHRpZiAoY2FjaGVbcGF0aF0pIHtcclxuXHRcdHJldHVybiBjb252ZXJ0KGNhY2hlW3BhdGhdLmNvbnRlbnQsIGVuY29kaW5nKTtcclxuXHR9XHJcblx0cmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5yZWFkQ2FjaGUkMS5leHBvcnRzLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG5cdGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxufTtcblxudmFyIHJlYWRDYWNoZUV4cG9ydHMgPSByZWFkQ2FjaGUkMS5leHBvcnRzO1xuXG5jb25zdCBhbnlEYXRhVVJMUmVnZXhwID0gL15kYXRhOnRleHRcXC9jc3MoPzo7KGJhc2U2NHxwbGFpbikpPywvaTtcbmNvbnN0IGJhc2U2NERhdGFVUkxSZWdleHAgPSAvXmRhdGE6dGV4dFxcL2NzcztiYXNlNjQsL2k7XG5jb25zdCBwbGFpbkRhdGFVUkxSZWdleHAgPSAvXmRhdGE6dGV4dFxcL2NzcztwbGFpbiwvaTtcblxuZnVuY3Rpb24gaXNWYWxpZCh1cmwpIHtcbiAgcmV0dXJuIGFueURhdGFVUkxSZWdleHAudGVzdCh1cmwpXG59XG5cbmZ1bmN0aW9uIGNvbnRlbnRzKHVybCkge1xuICBpZiAoYmFzZTY0RGF0YVVSTFJlZ2V4cC50ZXN0KHVybCkpIHtcbiAgICAvLyBcImRhdGE6dGV4dC9jc3M7YmFzZTY0LFwiLmxlbmd0aCA9PT0gMjFcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odXJsLnNsaWNlKDIxKSwgXCJiYXNlNjRcIikudG9TdHJpbmcoKVxuICB9XG5cbiAgaWYgKHBsYWluRGF0YVVSTFJlZ2V4cC50ZXN0KHVybCkpIHtcbiAgICAvLyBcImRhdGE6dGV4dC9jc3M7cGxhaW4sXCIubGVuZ3RoID09PSAyMFxuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodXJsLnNsaWNlKDIwKSlcbiAgfVxuXG4gIC8vIFwiZGF0YTp0ZXh0L2NzcyxcIi5sZW5ndGggPT09IDE0XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodXJsLnNsaWNlKDE0KSlcbn1cblxudmFyIGRhdGFVcmwgPSB7XG4gIGlzVmFsaWQsXG4gIGNvbnRlbnRzLFxufTtcblxuY29uc3QgcmVhZENhY2hlID0gcmVhZENhY2hlRXhwb3J0cztcbmNvbnN0IGRhdGFVUkwkMSA9IGRhdGFVcmw7XG5cbnZhciBsb2FkQ29udGVudCQxID0gZnVuY3Rpb24gbG9hZENvbnRlbnQoZmlsZW5hbWUpIHtcbiAgaWYgKGRhdGFVUkwkMS5pc1ZhbGlkKGZpbGVuYW1lKSkge1xuICAgIHJldHVybiBkYXRhVVJMJDEuY29udGVudHMoZmlsZW5hbWUpXG4gIH1cblxuICByZXR1cm4gcmVhZENhY2hlKGZpbGVuYW1lLCBcInV0Zi04XCIpXG59O1xuXG4vLyBleHRlcm5hbCB0b29saW5nXG5jb25zdCB2YWx1ZVBhcnNlciA9IGxpYjtcblxuLy8gZXh0ZW5kZWQgdG9vbGluZ1xuY29uc3QgeyBzdHJpbmdpZnkgfSA9IHZhbHVlUGFyc2VyO1xuXG52YXIgcGFyc2VTdGF0ZW1lbnRzJDEgPSBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudHMocmVzdWx0LCBzdHlsZXMsIGNvbmRpdGlvbnMsIGZyb20pIHtcbiAgY29uc3Qgc3RhdGVtZW50cyA9IFtdO1xuICBsZXQgbm9kZXMgPSBbXTtcblxuICBzdHlsZXMuZWFjaChub2RlID0+IHtcbiAgICBsZXQgc3RtdDtcbiAgICBpZiAobm9kZS50eXBlID09PSBcImF0cnVsZVwiKSB7XG4gICAgICBpZiAobm9kZS5uYW1lID09PSBcImltcG9ydFwiKVxuICAgICAgICBzdG10ID0gcGFyc2VJbXBvcnQocmVzdWx0LCBub2RlLCBjb25kaXRpb25zLCBmcm9tKTtcbiAgICAgIGVsc2UgaWYgKG5vZGUubmFtZSA9PT0gXCJjaGFyc2V0XCIpXG4gICAgICAgIHN0bXQgPSBwYXJzZUNoYXJzZXQocmVzdWx0LCBub2RlLCBjb25kaXRpb25zLCBmcm9tKTtcbiAgICB9XG5cbiAgICBpZiAoc3RtdCkge1xuICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICBzdGF0ZW1lbnRzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwibm9kZXNcIixcbiAgICAgICAgICBub2RlcyxcbiAgICAgICAgICBjb25kaXRpb25zOiBbLi4uY29uZGl0aW9uc10sXG4gICAgICAgICAgZnJvbSxcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGVzID0gW107XG4gICAgICB9XG4gICAgICBzdGF0ZW1lbnRzLnB1c2goc3RtdCk7XG4gICAgfSBlbHNlIG5vZGVzLnB1c2gobm9kZSk7XG4gIH0pO1xuXG4gIGlmIChub2Rlcy5sZW5ndGgpIHtcbiAgICBzdGF0ZW1lbnRzLnB1c2goe1xuICAgICAgdHlwZTogXCJub2Rlc1wiLFxuICAgICAgbm9kZXMsXG4gICAgICBjb25kaXRpb25zOiBbLi4uY29uZGl0aW9uc10sXG4gICAgICBmcm9tLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlbWVudHNcbn07XG5cbmZ1bmN0aW9uIHBhcnNlQ2hhcnNldChyZXN1bHQsIGF0UnVsZSwgY29uZGl0aW9ucywgZnJvbSkge1xuICBpZiAoYXRSdWxlLnByZXYoKSkge1xuICAgIHJldHVybiByZXN1bHQud2FybihcIkBjaGFyc2V0IG11c3QgcHJlY2VkZSBhbGwgb3RoZXIgc3RhdGVtZW50c1wiLCB7XG4gICAgICBub2RlOiBhdFJ1bGUsXG4gICAgfSlcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiY2hhcnNldFwiLFxuICAgIG5vZGU6IGF0UnVsZSxcbiAgICBjb25kaXRpb25zOiBbLi4uY29uZGl0aW9uc10sXG4gICAgZnJvbSxcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUltcG9ydChyZXN1bHQsIGF0UnVsZSwgY29uZGl0aW9ucywgZnJvbSkge1xuICBsZXQgcHJldiA9IGF0UnVsZS5wcmV2KCk7XG5cbiAgLy8gYEBpbXBvcnRgIHN0YXRlbWVudHMgbWF5IGZvbGxvdyBvdGhlciBgQGltcG9ydGAgc3RhdGVtZW50cy5cbiAgaWYgKHByZXYpIHtcbiAgICBkbyB7XG4gICAgICBpZiAoXG4gICAgICAgIHByZXYudHlwZSA9PT0gXCJjb21tZW50XCIgfHxcbiAgICAgICAgKHByZXYudHlwZSA9PT0gXCJhdHJ1bGVcIiAmJiBwcmV2Lm5hbWUgPT09IFwiaW1wb3J0XCIpXG4gICAgICApIHtcbiAgICAgICAgcHJldiA9IHByZXYucHJldigpO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBicmVha1xuICAgIH0gd2hpbGUgKHByZXYpXG4gIH1cblxuICAvLyBBbGwgYEBpbXBvcnRgIHN0YXRlbWVudHMgbWF5IGJlIHByZWNlZGVkIGJ5IGBAY2hhcnNldGAgb3IgYEBsYXllcmAgc3RhdGVtZW50cy5cbiAgLy8gQnV0IHRoZSBgQGltcG9ydGAgc3RhdGVtZW50cyBtdXN0IGJlIGNvbnNlY3V0aXZlLlxuICBpZiAocHJldikge1xuICAgIGRvIHtcbiAgICAgIGlmIChcbiAgICAgICAgcHJldi50eXBlID09PSBcImNvbW1lbnRcIiB8fFxuICAgICAgICAocHJldi50eXBlID09PSBcImF0cnVsZVwiICYmXG4gICAgICAgICAgKHByZXYubmFtZSA9PT0gXCJjaGFyc2V0XCIgfHwgKHByZXYubmFtZSA9PT0gXCJsYXllclwiICYmICFwcmV2Lm5vZGVzKSkpXG4gICAgICApIHtcbiAgICAgICAgcHJldiA9IHByZXYucHJldigpO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0Lndhcm4oXG4gICAgICAgIFwiQGltcG9ydCBtdXN0IHByZWNlZGUgYWxsIG90aGVyIHN0YXRlbWVudHMgKGJlc2lkZXMgQGNoYXJzZXQgb3IgZW1wdHkgQGxheWVyKVwiLFxuICAgICAgICB7IG5vZGU6IGF0UnVsZSB9LFxuICAgICAgKVxuICAgIH0gd2hpbGUgKHByZXYpXG4gIH1cblxuICBpZiAoYXRSdWxlLm5vZGVzKSB7XG4gICAgcmV0dXJuIHJlc3VsdC53YXJuKFxuICAgICAgXCJJdCBsb29rcyBsaWtlIHlvdSBkaWRuJ3QgZW5kIHlvdXIgQGltcG9ydCBzdGF0ZW1lbnQgY29ycmVjdGx5LiBcIiArXG4gICAgICAgIFwiQ2hpbGQgbm9kZXMgYXJlIGF0dGFjaGVkIHRvIGl0LlwiLFxuICAgICAgeyBub2RlOiBhdFJ1bGUgfSxcbiAgICApXG4gIH1cblxuICBjb25zdCBwYXJhbXMgPSB2YWx1ZVBhcnNlcihhdFJ1bGUucGFyYW1zKS5ub2RlcztcbiAgY29uc3Qgc3RtdCA9IHtcbiAgICB0eXBlOiBcImltcG9ydFwiLFxuICAgIHVyaTogXCJcIixcbiAgICBmdWxsVXJpOiBcIlwiLFxuICAgIG5vZGU6IGF0UnVsZSxcbiAgICBjb25kaXRpb25zOiBbLi4uY29uZGl0aW9uc10sXG4gICAgZnJvbSxcbiAgfTtcblxuICBsZXQgbGF5ZXI7XG4gIGxldCBtZWRpYTtcbiAgbGV0IHN1cHBvcnRzO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhcmFtc1tpXTtcblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwic3BhY2VcIiB8fCBub2RlLnR5cGUgPT09IFwiY29tbWVudFwiKSBjb250aW51ZVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHN0bXQudXJpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQud2FybihgTXVsdGlwbGUgdXJsJ3MgaW4gJyR7YXRSdWxlLnRvU3RyaW5nKCl9J2AsIHtcbiAgICAgICAgICBub2RlOiBhdFJ1bGUsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGlmICghbm9kZS52YWx1ZSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0Lndhcm4oYFVuYWJsZSB0byBmaW5kIHVyaSBpbiAnJHthdFJ1bGUudG9TdHJpbmcoKX0nYCwge1xuICAgICAgICAgIG5vZGU6IGF0UnVsZSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgc3RtdC51cmkgPSBub2RlLnZhbHVlO1xuICAgICAgc3RtdC5mdWxsVXJpID0gc3RyaW5naWZ5KG5vZGUpO1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcImZ1bmN0aW9uXCIgJiYgL151cmwkL2kudGVzdChub2RlLnZhbHVlKSkge1xuICAgICAgaWYgKHN0bXQudXJpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQud2FybihgTXVsdGlwbGUgdXJsJ3MgaW4gJyR7YXRSdWxlLnRvU3RyaW5nKCl9J2AsIHtcbiAgICAgICAgICBub2RlOiBhdFJ1bGUsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGlmICghbm9kZS5ub2Rlcz8uWzBdPy52YWx1ZSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0Lndhcm4oYFVuYWJsZSB0byBmaW5kIHVyaSBpbiAnJHthdFJ1bGUudG9TdHJpbmcoKX0nYCwge1xuICAgICAgICAgIG5vZGU6IGF0UnVsZSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgc3RtdC51cmkgPSBub2RlLm5vZGVzWzBdLnZhbHVlO1xuICAgICAgc3RtdC5mdWxsVXJpID0gc3RyaW5naWZ5KG5vZGUpO1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoIXN0bXQudXJpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0Lndhcm4oYFVuYWJsZSB0byBmaW5kIHVyaSBpbiAnJHthdFJ1bGUudG9TdHJpbmcoKX0nYCwge1xuICAgICAgICBub2RlOiBhdFJ1bGUsXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIChub2RlLnR5cGUgPT09IFwid29yZFwiIHx8IG5vZGUudHlwZSA9PT0gXCJmdW5jdGlvblwiKSAmJlxuICAgICAgL15sYXllciQvaS50ZXN0KG5vZGUudmFsdWUpXG4gICAgKSB7XG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQud2FybihgTXVsdGlwbGUgbGF5ZXJzIGluICcke2F0UnVsZS50b1N0cmluZygpfSdgLCB7XG4gICAgICAgICAgbm9kZTogYXRSdWxlLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHN1cHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQud2FybihcbiAgICAgICAgICBgbGF5ZXJzIG11c3QgYmUgZGVmaW5lZCBiZWZvcmUgc3VwcG9ydCBjb25kaXRpb25zIGluICcke2F0UnVsZS50b1N0cmluZygpfSdgLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5vZGU6IGF0UnVsZSxcbiAgICAgICAgICB9LFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLm5vZGVzKSB7XG4gICAgICAgIGxheWVyID0gc3RyaW5naWZ5KG5vZGUubm9kZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGF5ZXIgPSBcIlwiO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJiAvXnN1cHBvcnRzJC9pLnRlc3Qobm9kZS52YWx1ZSkpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3VwcG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC53YXJuKFxuICAgICAgICAgIGBNdWx0aXBsZSBzdXBwb3J0IGNvbmRpdGlvbnMgaW4gJyR7YXRSdWxlLnRvU3RyaW5nKCl9J2AsXG4gICAgICAgICAge1xuICAgICAgICAgICAgbm9kZTogYXRSdWxlLFxuICAgICAgICAgIH0sXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgc3VwcG9ydHMgPSBzdHJpbmdpZnkobm9kZS5ub2Rlcyk7XG5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgbWVkaWEgPSBzdHJpbmdpZnkocGFyYW1zLnNsaWNlKGkpKTtcbiAgICBicmVha1xuICB9XG5cbiAgaWYgKCFzdG10LnVyaSkge1xuICAgIHJldHVybiByZXN1bHQud2FybihgVW5hYmxlIHRvIGZpbmQgdXJpIGluICcke2F0UnVsZS50b1N0cmluZygpfSdgLCB7XG4gICAgICBub2RlOiBhdFJ1bGUsXG4gICAgfSlcbiAgfVxuXG4gIGlmIChcbiAgICB0eXBlb2YgbWVkaWEgIT09IFwidW5kZWZpbmVkXCIgfHxcbiAgICB0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIgfHxcbiAgICB0eXBlb2Ygc3VwcG9ydHMgIT09IFwidW5kZWZpbmVkXCJcbiAgKSB7XG4gICAgc3RtdC5jb25kaXRpb25zLnB1c2goe1xuICAgICAgbGF5ZXIsXG4gICAgICBtZWRpYSxcbiAgICAgIHN1cHBvcnRzLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHN0bXRcbn1cblxuLy8gYnVpbHRpbiB0b29saW5nXG5jb25zdCBwYXRoJDIgPSByZXF1aXJlJCQwO1xuXG4vLyBwbGFjZWhvbGRlciB0b29saW5nXG5sZXQgc3VnYXJzcztcblxudmFyIHByb2Nlc3NDb250ZW50JDEgPSBmdW5jdGlvbiBwcm9jZXNzQ29udGVudChcbiAgcmVzdWx0LFxuICBjb250ZW50LFxuICBmaWxlbmFtZSxcbiAgb3B0aW9ucyxcbiAgcG9zdGNzcyxcbikge1xuICBjb25zdCB7IHBsdWdpbnMgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGV4dCA9IHBhdGgkMi5leHRuYW1lKGZpbGVuYW1lKTtcblxuICBjb25zdCBwYXJzZXJMaXN0ID0gW107XG5cbiAgLy8gU3VnYXJTUyBzdXBwb3J0OlxuICBpZiAoZXh0ID09PSBcIi5zc3NcIikge1xuICAgIGlmICghc3VnYXJzcykge1xuICAgICAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3VnYXJzcyA9IF9fcmVxdWlyZSgnc3VnYXJzcycpO1xuICAgICAgfSBjYXRjaCB7fSAvLyBJZ25vcmVcbiAgICB9XG4gICAgaWYgKHN1Z2Fyc3MpXG4gICAgICByZXR1cm4gcnVuUG9zdGNzcyhwb3N0Y3NzLCBjb250ZW50LCBmaWxlbmFtZSwgcGx1Z2lucywgW3N1Z2Fyc3NdKVxuICB9XG5cbiAgLy8gU3ludGF4IHN1cHBvcnQ6XG4gIGlmIChyZXN1bHQub3B0cy5zeW50YXg/LnBhcnNlKSB7XG4gICAgcGFyc2VyTGlzdC5wdXNoKHJlc3VsdC5vcHRzLnN5bnRheC5wYXJzZSk7XG4gIH1cblxuICAvLyBQYXJzZXIgc3VwcG9ydDpcbiAgaWYgKHJlc3VsdC5vcHRzLnBhcnNlcikgcGFyc2VyTGlzdC5wdXNoKHJlc3VsdC5vcHRzLnBhcnNlcik7XG4gIC8vIFRyeSB0aGUgZGVmYXVsdCBhcyBhIGxhc3QgcmVzb3J0OlxuICBwYXJzZXJMaXN0LnB1c2gobnVsbCk7XG5cbiAgcmV0dXJuIHJ1blBvc3Rjc3MocG9zdGNzcywgY29udGVudCwgZmlsZW5hbWUsIHBsdWdpbnMsIHBhcnNlckxpc3QpXG59O1xuXG5mdW5jdGlvbiBydW5Qb3N0Y3NzKHBvc3Rjc3MsIGNvbnRlbnQsIGZpbGVuYW1lLCBwbHVnaW5zLCBwYXJzZXJzLCBpbmRleCkge1xuICBpZiAoIWluZGV4KSBpbmRleCA9IDA7XG4gIHJldHVybiBwb3N0Y3NzKHBsdWdpbnMpXG4gICAgLnByb2Nlc3MoY29udGVudCwge1xuICAgICAgZnJvbTogZmlsZW5hbWUsXG4gICAgICBwYXJzZXI6IHBhcnNlcnNbaW5kZXhdLFxuICAgIH0pXG4gICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAvLyBJZiB0aGVyZSdzIGFuIGVycm9yLCB0cnkgdGhlIG5leHQgcGFyc2VyXG4gICAgICBpbmRleCsrO1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBhcnNlcnMgbGVmdCwgdGhyb3cgaXRcbiAgICAgIGlmIChpbmRleCA9PT0gcGFyc2Vycy5sZW5ndGgpIHRocm93IGVyclxuICAgICAgcmV0dXJuIHJ1blBvc3Rjc3MocG9zdGNzcywgY29udGVudCwgZmlsZW5hbWUsIHBsdWdpbnMsIHBhcnNlcnMsIGluZGV4KVxuICAgIH0pXG59XG5cbmNvbnN0IHBhdGgkMSA9IHJlcXVpcmUkJDA7XG5cbmNvbnN0IGRhdGFVUkwgPSBkYXRhVXJsO1xuY29uc3QgcGFyc2VTdGF0ZW1lbnRzID0gcGFyc2VTdGF0ZW1lbnRzJDE7XG5jb25zdCBwcm9jZXNzQ29udGVudCA9IHByb2Nlc3NDb250ZW50JDE7XG5jb25zdCByZXNvbHZlSWQkMSA9IChpZCkgPT4gaWQ7XG5jb25zdCBmb3JtYXRJbXBvcnRQcmVsdWRlID0gZm9ybWF0SW1wb3J0UHJlbHVkZSQyO1xuXG5hc3luYyBmdW5jdGlvbiBwYXJzZVN0eWxlcyQxKFxuICByZXN1bHQsXG4gIHN0eWxlcyxcbiAgb3B0aW9ucyxcbiAgc3RhdGUsXG4gIGNvbmRpdGlvbnMsXG4gIGZyb20sXG4gIHBvc3Rjc3MsXG4pIHtcbiAgY29uc3Qgc3RhdGVtZW50cyA9IHBhcnNlU3RhdGVtZW50cyhyZXN1bHQsIHN0eWxlcywgY29uZGl0aW9ucywgZnJvbSk7XG5cbiAgZm9yIChjb25zdCBzdG10IG9mIHN0YXRlbWVudHMpIHtcbiAgICBpZiAoc3RtdC50eXBlICE9PSBcImltcG9ydFwiIHx8ICFpc1Byb2Nlc3NhYmxlVVJMKHN0bXQudXJpKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5maWx0ZXIgJiYgIW9wdGlvbnMuZmlsdGVyKHN0bXQudXJpKSkge1xuICAgICAgLy8gcmVqZWN0ZWQgYnkgZmlsdGVyXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGF3YWl0IHJlc29sdmVJbXBvcnRJZChyZXN1bHQsIHN0bXQsIG9wdGlvbnMsIHN0YXRlLCBwb3N0Y3NzKTtcbiAgfVxuXG4gIGxldCBjaGFyc2V0O1xuICBjb25zdCBpbXBvcnRzID0gW107XG4gIGNvbnN0IGJ1bmRsZSA9IFtdO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUNoYXJzZXQoc3RtdCkge1xuICAgIGlmICghY2hhcnNldCkgY2hhcnNldCA9IHN0bXQ7XG4gICAgLy8gY2hhcnNldHMgYXJlbid0IGNhc2Utc2Vuc2l0aXZlLCBzbyBjb252ZXJ0IHRvIGxvd2VyIGNhc2UgdG8gY29tcGFyZVxuICAgIGVsc2UgaWYgKFxuICAgICAgc3RtdC5ub2RlLnBhcmFtcy50b0xvd2VyQ2FzZSgpICE9PSBjaGFyc2V0Lm5vZGUucGFyYW1zLnRvTG93ZXJDYXNlKClcbiAgICApIHtcbiAgICAgIHRocm93IHN0bXQubm9kZS5lcnJvcihcbiAgICAgICAgYEluY29tcGF0aWJsZSBAY2hhcnNldCBzdGF0ZW1lbnRzOlxuICAke3N0bXQubm9kZS5wYXJhbXN9IHNwZWNpZmllZCBpbiAke3N0bXQubm9kZS5zb3VyY2UuaW5wdXQuZmlsZX1cbiAgJHtjaGFyc2V0Lm5vZGUucGFyYW1zfSBzcGVjaWZpZWQgaW4gJHtjaGFyc2V0Lm5vZGUuc291cmNlLmlucHV0LmZpbGV9YCxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvLyBzcXVhc2ggc3RhdGVtZW50cyBhbmQgdGhlaXIgY2hpbGRyZW5cbiAgc3RhdGVtZW50cy5mb3JFYWNoKHN0bXQgPT4ge1xuICAgIGlmIChzdG10LnR5cGUgPT09IFwiY2hhcnNldFwiKSBoYW5kbGVDaGFyc2V0KHN0bXQpO1xuICAgIGVsc2UgaWYgKHN0bXQudHlwZSA9PT0gXCJpbXBvcnRcIikge1xuICAgICAgaWYgKHN0bXQuY2hpbGRyZW4pIHtcbiAgICAgICAgc3RtdC5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJpbXBvcnRcIikgaW1wb3J0cy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSBcImNoYXJzZXRcIikgaGFuZGxlQ2hhcnNldChjaGlsZCk7XG4gICAgICAgICAgZWxzZSBidW5kbGUucHVzaChjaGlsZCk7XG4gICAgICAgICAgLy8gRm9yIGJldHRlciBvdXRwdXRcbiAgICAgICAgICBpZiAoaW5kZXggPT09IDApIGNoaWxkLnBhcmVudCA9IHN0bXQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGltcG9ydHMucHVzaChzdG10KTtcbiAgICB9IGVsc2UgaWYgKHN0bXQudHlwZSA9PT0gXCJub2Rlc1wiKSB7XG4gICAgICBidW5kbGUucHVzaChzdG10KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjaGFyc2V0ID8gW2NoYXJzZXQsIC4uLmltcG9ydHMuY29uY2F0KGJ1bmRsZSldIDogaW1wb3J0cy5jb25jYXQoYnVuZGxlKVxufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlSW1wb3J0SWQocmVzdWx0LCBzdG10LCBvcHRpb25zLCBzdGF0ZSwgcG9zdGNzcykge1xuICBpZiAoZGF0YVVSTC5pc1ZhbGlkKHN0bXQudXJpKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF0b21pYy11cGRhdGVzXG4gICAgc3RtdC5jaGlsZHJlbiA9IGF3YWl0IGxvYWRJbXBvcnRDb250ZW50KFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RtdCxcbiAgICAgIHN0bXQudXJpLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHN0YXRlLFxuICAgICAgcG9zdGNzcyxcbiAgICApO1xuXG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAoZGF0YVVSTC5pc1ZhbGlkKHN0bXQuZnJvbS5zbGljZSgtMSkpKSB7XG4gICAgLy8gRGF0YSB1cmxzIGNhbid0IGJlIHVzZWQgYXMgYSBiYXNlIHVybCB0byByZXNvbHZlIGltcG9ydHMuXG4gICAgdGhyb3cgc3RtdC5ub2RlLmVycm9yKFxuICAgICAgYFVuYWJsZSB0byBpbXBvcnQgJyR7c3RtdC51cml9JyBmcm9tIGEgc3R5bGVzaGVldCB0aGF0IGlzIGVtYmVkZGVkIGluIGEgZGF0YSB1cmxgLFxuICAgIClcbiAgfVxuXG4gIGNvbnN0IGF0UnVsZSA9IHN0bXQubm9kZTtcbiAgbGV0IHNvdXJjZUZpbGU7XG4gIGlmIChhdFJ1bGUuc291cmNlPy5pbnB1dD8uZmlsZSkge1xuICAgIHNvdXJjZUZpbGUgPSBhdFJ1bGUuc291cmNlLmlucHV0LmZpbGU7XG4gIH1cbiAgY29uc3QgYmFzZSA9IHNvdXJjZUZpbGVcbiAgICA/IHBhdGgkMS5kaXJuYW1lKGF0UnVsZS5zb3VyY2UuaW5wdXQuZmlsZSlcbiAgICA6IG9wdGlvbnMucm9vdDtcblxuICBjb25zdCBwYXRocyA9IFthd2FpdCBvcHRpb25zLnJlc29sdmUoc3RtdC51cmksIGJhc2UsIG9wdGlvbnMsIGF0UnVsZSldLmZsYXQoKTtcblxuICAvLyBFbnN1cmUgdGhhdCBlYWNoIHBhdGggaXMgYWJzb2x1dGU6XG4gIGNvbnN0IHJlc29sdmVkID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgcGF0aHMubWFwKGZpbGUgPT4ge1xuICAgICAgcmV0dXJuICFwYXRoJDEuaXNBYnNvbHV0ZShmaWxlKVxuICAgICAgICA/IHJlc29sdmVJZCQxKGZpbGUpXG4gICAgICAgIDogZmlsZVxuICAgIH0pLFxuICApO1xuXG4gIC8vIEFkZCBkZXBlbmRlbmN5IG1lc3NhZ2VzOlxuICByZXNvbHZlZC5mb3JFYWNoKGZpbGUgPT4ge1xuICAgIHJlc3VsdC5tZXNzYWdlcy5wdXNoKHtcbiAgICAgIHR5cGU6IFwiZGVwZW5kZW5jeVwiLFxuICAgICAgcGx1Z2luOiBcInBvc3Rjc3MtaW1wb3J0XCIsXG4gICAgICBmaWxlLFxuICAgICAgcGFyZW50OiBzb3VyY2VGaWxlLFxuICAgIH0pO1xuICB9KTtcblxuICBjb25zdCBpbXBvcnRlZENvbnRlbnQgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICByZXNvbHZlZC5tYXAoZmlsZSA9PiB7XG4gICAgICByZXR1cm4gbG9hZEltcG9ydENvbnRlbnQocmVzdWx0LCBzdG10LCBmaWxlLCBvcHRpb25zLCBzdGF0ZSwgcG9zdGNzcylcbiAgICB9KSxcbiAgKTtcblxuICAvLyBNZXJnZSBsb2FkZWQgc3RhdGVtZW50c1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hdG9taWMtdXBkYXRlc1xuICBzdG10LmNoaWxkcmVuID0gaW1wb3J0ZWRDb250ZW50LmZsYXQoKS5maWx0ZXIoeCA9PiAhIXgpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBsb2FkSW1wb3J0Q29udGVudChcbiAgcmVzdWx0LFxuICBzdG10LFxuICBmaWxlbmFtZSxcbiAgb3B0aW9ucyxcbiAgc3RhdGUsXG4gIHBvc3Rjc3MsXG4pIHtcbiAgY29uc3QgYXRSdWxlID0gc3RtdC5ub2RlO1xuICBjb25zdCB7IGNvbmRpdGlvbnMsIGZyb20gfSA9IHN0bXQ7XG4gIGNvbnN0IHN0bXREdXBsaWNhdGVDaGVja0tleSA9IGNvbmRpdGlvbnNcbiAgICAubWFwKGNvbmRpdGlvbiA9PlxuICAgICAgZm9ybWF0SW1wb3J0UHJlbHVkZShjb25kaXRpb24ubGF5ZXIsIGNvbmRpdGlvbi5tZWRpYSwgY29uZGl0aW9uLnN1cHBvcnRzKSxcbiAgICApXG4gICAgLmpvaW4oXCI6XCIpO1xuXG4gIGlmIChvcHRpb25zLnNraXBEdXBsaWNhdGVzKSB7XG4gICAgLy8gc2tpcCBmaWxlcyBhbHJlYWR5IGltcG9ydGVkIGF0IHRoZSBzYW1lIHNjb3BlXG4gICAgaWYgKHN0YXRlLmltcG9ydGVkRmlsZXNbZmlsZW5hbWVdPy5bc3RtdER1cGxpY2F0ZUNoZWNrS2V5XSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gc2F2ZSBpbXBvcnRlZCBmaWxlcyB0byBza2lwIHRoZW0gbmV4dCB0aW1lXG4gICAgaWYgKCFzdGF0ZS5pbXBvcnRlZEZpbGVzW2ZpbGVuYW1lXSkge1xuICAgICAgc3RhdGUuaW1wb3J0ZWRGaWxlc1tmaWxlbmFtZV0gPSB7fTtcbiAgICB9XG4gICAgc3RhdGUuaW1wb3J0ZWRGaWxlc1tmaWxlbmFtZV1bc3RtdER1cGxpY2F0ZUNoZWNrS2V5XSA9IHRydWU7XG4gIH1cblxuICBpZiAoZnJvbS5pbmNsdWRlcyhmaWxlbmFtZSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBvcHRpb25zLmxvYWQoZmlsZW5hbWUsIG9wdGlvbnMpO1xuXG4gIGlmIChjb250ZW50LnRyaW0oKSA9PT0gXCJcIiAmJiBvcHRpb25zLndhcm5PbkVtcHR5KSB7XG4gICAgcmVzdWx0Lndhcm4oYCR7ZmlsZW5hbWV9IGlzIGVtcHR5YCwgeyBub2RlOiBhdFJ1bGUgfSk7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBza2lwIHByZXZpb3VzIGltcG9ydGVkIGZpbGVzIG5vdCBjb250YWluaW5nIEBpbXBvcnQgcnVsZXNcbiAgaWYgKFxuICAgIG9wdGlvbnMuc2tpcER1cGxpY2F0ZXMgJiZcbiAgICBzdGF0ZS5oYXNoRmlsZXNbY29udGVudF0/LltzdG10RHVwbGljYXRlQ2hlY2tLZXldXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgaW1wb3J0ZWRSZXN1bHQgPSBhd2FpdCBwcm9jZXNzQ29udGVudChcbiAgICByZXN1bHQsXG4gICAgY29udGVudCxcbiAgICBmaWxlbmFtZSxcbiAgICBvcHRpb25zLFxuICAgIHBvc3Rjc3MsXG4gICk7XG5cbiAgY29uc3Qgc3R5bGVzID0gaW1wb3J0ZWRSZXN1bHQucm9vdDtcbiAgcmVzdWx0Lm1lc3NhZ2VzID0gcmVzdWx0Lm1lc3NhZ2VzLmNvbmNhdChpbXBvcnRlZFJlc3VsdC5tZXNzYWdlcyk7XG5cbiAgaWYgKG9wdGlvbnMuc2tpcER1cGxpY2F0ZXMpIHtcbiAgICBjb25zdCBoYXNJbXBvcnQgPSBzdHlsZXMuc29tZShjaGlsZCA9PiB7XG4gICAgICByZXR1cm4gY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIiAmJiBjaGlsZC5uYW1lID09PSBcImltcG9ydFwiXG4gICAgfSk7XG4gICAgaWYgKCFoYXNJbXBvcnQpIHtcbiAgICAgIC8vIHNhdmUgaGFzaCBmaWxlcyB0byBza2lwIHRoZW0gbmV4dCB0aW1lXG4gICAgICBpZiAoIXN0YXRlLmhhc2hGaWxlc1tjb250ZW50XSkge1xuICAgICAgICBzdGF0ZS5oYXNoRmlsZXNbY29udGVudF0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUuaGFzaEZpbGVzW2NvbnRlbnRdW3N0bXREdXBsaWNhdGVDaGVja0tleV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlY3Vyc2lvbjogaW1wb3J0IEBpbXBvcnQgZnJvbSBpbXBvcnRlZCBmaWxlXG4gIHJldHVybiBwYXJzZVN0eWxlcyQxKFxuICAgIHJlc3VsdCxcbiAgICBzdHlsZXMsXG4gICAgb3B0aW9ucyxcbiAgICBzdGF0ZSxcbiAgICBjb25kaXRpb25zLFxuICAgIFsuLi5mcm9tLCBmaWxlbmFtZV0sXG4gICAgcG9zdGNzcyxcbiAgKVxufVxuXG5mdW5jdGlvbiBpc1Byb2Nlc3NhYmxlVVJMKHVyaSkge1xuICAvLyBza2lwIHByb3RvY29sIGJhc2UgdXJpIChwcm90b2NvbDovL3VybCkgb3IgcHJvdG9jb2wtcmVsYXRpdmVcbiAgaWYgKC9eKD86W2Etel0rOik/XFwvXFwvL2kudGVzdCh1cmkpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBjaGVjayBmb3IgZnJhZ21lbnQgb3IgcXVlcnlcbiAgdHJ5IHtcbiAgICAvLyBuZWVkcyBhIGJhc2UgdG8gcGFyc2UgcHJvcGVybHlcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHVyaSwgXCJodHRwczovL2V4YW1wbGUuY29tXCIpO1xuICAgIGlmICh1cmwuc2VhcmNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gY2F0Y2gge30gLy8gSWdub3JlXG5cbiAgcmV0dXJuIHRydWVcbn1cblxudmFyIHBhcnNlU3R5bGVzXzEgPSBwYXJzZVN0eWxlcyQxO1xuXG4vLyBidWlsdGluIHRvb2xpbmdcbmNvbnN0IHBhdGggPSByZXF1aXJlJCQwO1xuXG4vLyBpbnRlcm5hbCB0b29saW5nXG5jb25zdCBhcHBseUNvbmRpdGlvbnMgPSBhcHBseUNvbmRpdGlvbnMkMTtcbmNvbnN0IGFwcGx5UmF3cyA9IGFwcGx5UmF3cyQxO1xuY29uc3QgYXBwbHlTdHlsZXMgPSBhcHBseVN0eWxlcyQxO1xuY29uc3QgbG9hZENvbnRlbnQgPSBsb2FkQ29udGVudCQxO1xuY29uc3QgcGFyc2VTdHlsZXMgPSBwYXJzZVN0eWxlc18xO1xuY29uc3QgcmVzb2x2ZUlkID0gKGlkKSA9PiBpZDtcblxuZnVuY3Rpb24gQXRJbXBvcnQob3B0aW9ucykge1xuICBvcHRpb25zID0ge1xuICAgIHJvb3Q6IHByb2Nlc3MuY3dkKCksXG4gICAgcGF0aDogW10sXG4gICAgc2tpcER1cGxpY2F0ZXM6IHRydWUsXG4gICAgcmVzb2x2ZTogcmVzb2x2ZUlkLFxuICAgIGxvYWQ6IGxvYWRDb250ZW50LFxuICAgIHBsdWdpbnM6IFtdLFxuICAgIGFkZE1vZHVsZXNEaXJlY3RvcmllczogW10sXG4gICAgd2Fybk9uRW1wdHk6IHRydWUsXG4gICAgLi4ub3B0aW9ucyxcbiAgfTtcblxuICBvcHRpb25zLnJvb3QgPSBwYXRoLnJlc29sdmUob3B0aW9ucy5yb290KTtcblxuICAvLyBjb252ZXJ0IHN0cmluZyB0byBhbiBhcnJheSBvZiBhIHNpbmdsZSBlbGVtZW50XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5wYXRoID09PSBcInN0cmluZ1wiKSBvcHRpb25zLnBhdGggPSBbb3B0aW9ucy5wYXRoXTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5wYXRoKSkgb3B0aW9ucy5wYXRoID0gW107XG5cbiAgb3B0aW9ucy5wYXRoID0gb3B0aW9ucy5wYXRoLm1hcChwID0+IHBhdGgucmVzb2x2ZShvcHRpb25zLnJvb3QsIHApKTtcblxuICByZXR1cm4ge1xuICAgIHBvc3Rjc3NQbHVnaW46IFwicG9zdGNzcy1pbXBvcnRcIixcbiAgICBhc3luYyBPbmNlKHN0eWxlcywgeyByZXN1bHQsIGF0UnVsZSwgcG9zdGNzcyB9KSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgaW1wb3J0ZWRGaWxlczoge30sXG4gICAgICAgIGhhc2hGaWxlczoge30sXG4gICAgICB9O1xuXG4gICAgICBpZiAoc3R5bGVzLnNvdXJjZT8uaW5wdXQ/LmZpbGUpIHtcbiAgICAgICAgc3RhdGUuaW1wb3J0ZWRGaWxlc1tzdHlsZXMuc291cmNlLmlucHV0LmZpbGVdID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnBsdWdpbnMgJiYgIUFycmF5LmlzQXJyYXkob3B0aW9ucy5wbHVnaW5zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwbHVnaW5zIG9wdGlvbiBtdXN0IGJlIGFuIGFycmF5XCIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJ1bmRsZSA9IGF3YWl0IHBhcnNlU3R5bGVzKFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIHN0eWxlcyxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIFtdLFxuICAgICAgICBbXSxcbiAgICAgICAgcG9zdGNzcyxcbiAgICAgICk7XG5cbiAgICAgIGFwcGx5UmF3cyhidW5kbGUpO1xuICAgICAgYXBwbHlDb25kaXRpb25zKGJ1bmRsZSwgYXRSdWxlKTtcbiAgICAgIGFwcGx5U3R5bGVzKGJ1bmRsZSwgc3R5bGVzKTtcbiAgICB9LFxuICB9XG59XG5cbkF0SW1wb3J0LnBvc3Rjc3MgPSB0cnVlO1xuXG52YXIgcG9zdGNzc0ltcG9ydCA9IEF0SW1wb3J0O1xuXG52YXIgaW5kZXggPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMocG9zdGNzc0ltcG9ydCk7XG5cbnZhciBpbmRleCQxID0gLyojX19QVVJFX18qL19tZXJnZU5hbWVzcGFjZXMoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGRlZmF1bHQ6IGluZGV4XG59LCBbcG9zdGNzc0ltcG9ydF0pO1xuXG5leHBvcnQgeyBpbmRleCQxIGFzIGkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vite/dist/node/chunks/dep-C6EFp3uH.js\n");

/***/ }),

/***/ "./node_modules/vite/dist/node/chunks/dep-IQS-Za7F.js":
/*!************************************************************!*\
  !*** ./node_modules/vite/dist/node/chunks/dep-IQS-Za7F.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   l: () => (/* binding */ lib)\n/* harmony export */ });\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:module */ \"node:module\");\n\n\n\n\nconst __filename = (0,node_url__WEBPACK_IMPORTED_MODULE_0__.fileURLToPath)(\"file:///var/www/html/livewire-tall/node_modules/vite/dist/node/chunks/dep-IQS-Za7F.js\");\nconst __dirname = (0,node_path__WEBPACK_IMPORTED_MODULE_1__.dirname)(__filename);\nconst require = (0,node_module__WEBPACK_IMPORTED_MODULE_2__.createRequire)(\"file:///var/www/html/livewire-tall/node_modules/vite/dist/node/chunks/dep-IQS-Za7F.js\");\nconst __require = require;\nvar openParentheses = \"(\".charCodeAt(0);\nvar closeParentheses = \")\".charCodeAt(0);\nvar singleQuote = \"'\".charCodeAt(0);\nvar doubleQuote = '\"'.charCodeAt(0);\nvar backslash = \"\\\\\".charCodeAt(0);\nvar slash = \"/\".charCodeAt(0);\nvar comma = \",\".charCodeAt(0);\nvar colon = \":\".charCodeAt(0);\nvar star = \"*\".charCodeAt(0);\nvar uLower = \"u\".charCodeAt(0);\nvar uUpper = \"U\".charCodeAt(0);\nvar plus = \"+\".charCodeAt(0);\nvar isUnicodeRange = /^[a-f0-9?-]+$/i;\n\nvar parse$1 = function(input) {\n  var tokens = [];\n  var value = input;\n\n  var next,\n    quote,\n    prev,\n    token,\n    escape,\n    escapePos,\n    whitespacePos,\n    parenthesesOpenPos;\n  var pos = 0;\n  var code = value.charCodeAt(pos);\n  var max = value.length;\n  var stack = [{ nodes: tokens }];\n  var balanced = 0;\n  var parent;\n\n  var name = \"\";\n  var before = \"\";\n  var after = \"\";\n\n  while (pos < max) {\n    // Whitespaces\n    if (code <= 32) {\n      next = pos;\n      do {\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (code <= 32);\n      token = value.slice(pos, next);\n\n      prev = tokens[tokens.length - 1];\n      if (code === closeParentheses && balanced) {\n        after = token;\n      } else if (prev && prev.type === \"div\") {\n        prev.after = token;\n        prev.sourceEndIndex += token.length;\n      } else if (\n        code === comma ||\n        code === colon ||\n        (code === slash &&\n          value.charCodeAt(next + 1) !== star &&\n          (!parent ||\n            (parent && parent.type === \"function\" && parent.value !== \"calc\")))\n      ) {\n        before = token;\n      } else {\n        tokens.push({\n          type: \"space\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      }\n\n      pos = next;\n\n      // Quotes\n    } else if (code === singleQuote || code === doubleQuote) {\n      next = pos;\n      quote = code === singleQuote ? \"'\" : '\"';\n      token = {\n        type: \"string\",\n        sourceIndex: pos,\n        quote: quote\n      };\n      do {\n        escape = false;\n        next = value.indexOf(quote, next + 1);\n        if (~next) {\n          escapePos = next;\n          while (value.charCodeAt(escapePos - 1) === backslash) {\n            escapePos -= 1;\n            escape = !escape;\n          }\n        } else {\n          value += quote;\n          next = value.length - 1;\n          token.unclosed = true;\n        }\n      } while (escape);\n      token.value = value.slice(pos + 1, next);\n      token.sourceEndIndex = token.unclosed ? next : next + 1;\n      tokens.push(token);\n      pos = next + 1;\n      code = value.charCodeAt(pos);\n\n      // Comments\n    } else if (code === slash && value.charCodeAt(pos + 1) === star) {\n      next = value.indexOf(\"*/\", pos);\n\n      token = {\n        type: \"comment\",\n        sourceIndex: pos,\n        sourceEndIndex: next + 2\n      };\n\n      if (next === -1) {\n        token.unclosed = true;\n        next = value.length;\n        token.sourceEndIndex = next;\n      }\n\n      token.value = value.slice(pos + 2, next);\n      tokens.push(token);\n\n      pos = next + 2;\n      code = value.charCodeAt(pos);\n\n      // Operation within calc\n    } else if (\n      (code === slash || code === star) &&\n      parent &&\n      parent.type === \"function\" &&\n      parent.value === \"calc\"\n    ) {\n      token = value[pos];\n      tokens.push({\n        type: \"word\",\n        sourceIndex: pos - before.length,\n        sourceEndIndex: pos + token.length,\n        value: token\n      });\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      // Dividers\n    } else if (code === slash || code === comma || code === colon) {\n      token = value[pos];\n\n      tokens.push({\n        type: \"div\",\n        sourceIndex: pos - before.length,\n        sourceEndIndex: pos + token.length,\n        value: token,\n        before: before,\n        after: \"\"\n      });\n      before = \"\";\n\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      // Open parentheses\n    } else if (openParentheses === code) {\n      // Whitespaces after open parentheses\n      next = pos;\n      do {\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (code <= 32);\n      parenthesesOpenPos = pos;\n      token = {\n        type: \"function\",\n        sourceIndex: pos - name.length,\n        value: name,\n        before: value.slice(parenthesesOpenPos + 1, next)\n      };\n      pos = next;\n\n      if (name === \"url\" && code !== singleQuote && code !== doubleQuote) {\n        next -= 1;\n        do {\n          escape = false;\n          next = value.indexOf(\")\", next + 1);\n          if (~next) {\n            escapePos = next;\n            while (value.charCodeAt(escapePos - 1) === backslash) {\n              escapePos -= 1;\n              escape = !escape;\n            }\n          } else {\n            value += \")\";\n            next = value.length - 1;\n            token.unclosed = true;\n          }\n        } while (escape);\n        // Whitespaces before closed\n        whitespacePos = next;\n        do {\n          whitespacePos -= 1;\n          code = value.charCodeAt(whitespacePos);\n        } while (code <= 32);\n        if (parenthesesOpenPos < whitespacePos) {\n          if (pos !== whitespacePos + 1) {\n            token.nodes = [\n              {\n                type: \"word\",\n                sourceIndex: pos,\n                sourceEndIndex: whitespacePos + 1,\n                value: value.slice(pos, whitespacePos + 1)\n              }\n            ];\n          } else {\n            token.nodes = [];\n          }\n          if (token.unclosed && whitespacePos + 1 !== next) {\n            token.after = \"\";\n            token.nodes.push({\n              type: \"space\",\n              sourceIndex: whitespacePos + 1,\n              sourceEndIndex: next,\n              value: value.slice(whitespacePos + 1, next)\n            });\n          } else {\n            token.after = value.slice(whitespacePos + 1, next);\n            token.sourceEndIndex = next;\n          }\n        } else {\n          token.after = \"\";\n          token.nodes = [];\n        }\n        pos = next + 1;\n        token.sourceEndIndex = token.unclosed ? next : pos;\n        code = value.charCodeAt(pos);\n        tokens.push(token);\n      } else {\n        balanced += 1;\n        token.after = \"\";\n        token.sourceEndIndex = pos + 1;\n        tokens.push(token);\n        stack.push(token);\n        tokens = token.nodes = [];\n        parent = token;\n      }\n      name = \"\";\n\n      // Close parentheses\n    } else if (closeParentheses === code && balanced) {\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      parent.after = after;\n      parent.sourceEndIndex += after.length;\n      after = \"\";\n      balanced -= 1;\n      stack[stack.length - 1].sourceEndIndex = pos;\n      stack.pop();\n      parent = stack[balanced];\n      tokens = parent.nodes;\n\n      // Words\n    } else {\n      next = pos;\n      do {\n        if (code === backslash) {\n          next += 1;\n        }\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (\n        next < max &&\n        !(\n          code <= 32 ||\n          code === singleQuote ||\n          code === doubleQuote ||\n          code === comma ||\n          code === colon ||\n          code === slash ||\n          code === openParentheses ||\n          (code === star &&\n            parent &&\n            parent.type === \"function\" &&\n            parent.value === \"calc\") ||\n          (code === slash &&\n            parent.type === \"function\" &&\n            parent.value === \"calc\") ||\n          (code === closeParentheses && balanced)\n        )\n      );\n      token = value.slice(pos, next);\n\n      if (openParentheses === code) {\n        name = token;\n      } else if (\n        (uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) &&\n        plus === token.charCodeAt(1) &&\n        isUnicodeRange.test(token.slice(2))\n      ) {\n        tokens.push({\n          type: \"unicode-range\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      } else {\n        tokens.push({\n          type: \"word\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      }\n\n      pos = next;\n    }\n  }\n\n  for (pos = stack.length - 1; pos; pos -= 1) {\n    stack[pos].unclosed = true;\n    stack[pos].sourceEndIndex = value.length;\n  }\n\n  return stack[0].nodes;\n};\n\nvar walk$1 = function walk(nodes, cb, bubble) {\n  var i, max, node, result;\n\n  for (i = 0, max = nodes.length; i < max; i += 1) {\n    node = nodes[i];\n    if (!bubble) {\n      result = cb(node, i, nodes);\n    }\n\n    if (\n      result !== false &&\n      node.type === \"function\" &&\n      Array.isArray(node.nodes)\n    ) {\n      walk(node.nodes, cb, bubble);\n    }\n\n    if (bubble) {\n      cb(node, i, nodes);\n    }\n  }\n};\n\nfunction stringifyNode(node, custom) {\n  var type = node.type;\n  var value = node.value;\n  var buf;\n  var customResult;\n\n  if (custom && (customResult = custom(node)) !== undefined) {\n    return customResult;\n  } else if (type === \"word\" || type === \"space\") {\n    return value;\n  } else if (type === \"string\") {\n    buf = node.quote || \"\";\n    return buf + value + (node.unclosed ? \"\" : buf);\n  } else if (type === \"comment\") {\n    return \"/*\" + value + (node.unclosed ? \"\" : \"*/\");\n  } else if (type === \"div\") {\n    return (node.before || \"\") + value + (node.after || \"\");\n  } else if (Array.isArray(node.nodes)) {\n    buf = stringify$1(node.nodes, custom);\n    if (type !== \"function\") {\n      return buf;\n    }\n    return (\n      value +\n      \"(\" +\n      (node.before || \"\") +\n      buf +\n      (node.after || \"\") +\n      (node.unclosed ? \"\" : \")\")\n    );\n  }\n  return value;\n}\n\nfunction stringify$1(nodes, custom) {\n  var result, i;\n\n  if (Array.isArray(nodes)) {\n    result = \"\";\n    for (i = nodes.length - 1; ~i; i -= 1) {\n      result = stringifyNode(nodes[i], custom) + result;\n    }\n    return result;\n  }\n  return stringifyNode(nodes, custom);\n}\n\nvar stringify_1 = stringify$1;\n\nvar unit;\nvar hasRequiredUnit;\n\nfunction requireUnit () {\n\tif (hasRequiredUnit) return unit;\n\thasRequiredUnit = 1;\n\tvar minus = \"-\".charCodeAt(0);\n\tvar plus = \"+\".charCodeAt(0);\n\tvar dot = \".\".charCodeAt(0);\n\tvar exp = \"e\".charCodeAt(0);\n\tvar EXP = \"E\".charCodeAt(0);\n\n\t// Check if three code points would start a number\n\t// https://www.w3.org/TR/css-syntax-3/#starts-with-a-number\n\tfunction likeNumber(value) {\n\t  var code = value.charCodeAt(0);\n\t  var nextCode;\n\n\t  if (code === plus || code === minus) {\n\t    nextCode = value.charCodeAt(1);\n\n\t    if (nextCode >= 48 && nextCode <= 57) {\n\t      return true;\n\t    }\n\n\t    var nextNextCode = value.charCodeAt(2);\n\n\t    if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {\n\t      return true;\n\t    }\n\n\t    return false;\n\t  }\n\n\t  if (code === dot) {\n\t    nextCode = value.charCodeAt(1);\n\n\t    if (nextCode >= 48 && nextCode <= 57) {\n\t      return true;\n\t    }\n\n\t    return false;\n\t  }\n\n\t  if (code >= 48 && code <= 57) {\n\t    return true;\n\t  }\n\n\t  return false;\n\t}\n\n\t// Consume a number\n\t// https://www.w3.org/TR/css-syntax-3/#consume-number\n\tunit = function(value) {\n\t  var pos = 0;\n\t  var length = value.length;\n\t  var code;\n\t  var nextCode;\n\t  var nextNextCode;\n\n\t  if (length === 0 || !likeNumber(value)) {\n\t    return false;\n\t  }\n\n\t  code = value.charCodeAt(pos);\n\n\t  if (code === plus || code === minus) {\n\t    pos++;\n\t  }\n\n\t  while (pos < length) {\n\t    code = value.charCodeAt(pos);\n\n\t    if (code < 48 || code > 57) {\n\t      break;\n\t    }\n\n\t    pos += 1;\n\t  }\n\n\t  code = value.charCodeAt(pos);\n\t  nextCode = value.charCodeAt(pos + 1);\n\n\t  if (code === dot && nextCode >= 48 && nextCode <= 57) {\n\t    pos += 2;\n\n\t    while (pos < length) {\n\t      code = value.charCodeAt(pos);\n\n\t      if (code < 48 || code > 57) {\n\t        break;\n\t      }\n\n\t      pos += 1;\n\t    }\n\t  }\n\n\t  code = value.charCodeAt(pos);\n\t  nextCode = value.charCodeAt(pos + 1);\n\t  nextNextCode = value.charCodeAt(pos + 2);\n\n\t  if (\n\t    (code === exp || code === EXP) &&\n\t    ((nextCode >= 48 && nextCode <= 57) ||\n\t      ((nextCode === plus || nextCode === minus) &&\n\t        nextNextCode >= 48 &&\n\t        nextNextCode <= 57))\n\t  ) {\n\t    pos += nextCode === plus || nextCode === minus ? 3 : 2;\n\n\t    while (pos < length) {\n\t      code = value.charCodeAt(pos);\n\n\t      if (code < 48 || code > 57) {\n\t        break;\n\t      }\n\n\t      pos += 1;\n\t    }\n\t  }\n\n\t  return {\n\t    number: value.slice(0, pos),\n\t    unit: value.slice(pos)\n\t  };\n\t};\n\treturn unit;\n}\n\nvar parse = parse$1;\nvar walk = walk$1;\nvar stringify = stringify_1;\n\nfunction ValueParser(value) {\n  if (this instanceof ValueParser) {\n    this.nodes = parse(value);\n    return this;\n  }\n  return new ValueParser(value);\n}\n\nValueParser.prototype.toString = function() {\n  return Array.isArray(this.nodes) ? stringify(this.nodes) : \"\";\n};\n\nValueParser.prototype.walk = function(cb, bubble) {\n  walk(this.nodes, cb, bubble);\n  return this;\n};\n\nValueParser.unit = requireUnit();\n\nValueParser.walk = walk;\n\nValueParser.stringify = stringify;\n\nvar lib = ValueParser;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdml0ZS9kaXN0L25vZGUvY2h1bmtzL2RlcC1JUVMtWmE3Ri5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdFO0FBQ1g7QUFDYzs7QUFFbkUsbUJBQW1CLHVEQUFtQixDQUFDLHVGQUFlO0FBQ3RELGtCQUFrQixrREFBYTtBQUMvQixnQkFBZ0IsMERBQW1CLENBQUMsdUZBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLElBQUk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qaW1pcHVsc2FyQGdpdGh1Yi5jb20vLi9ub2RlX21vZHVsZXMvdml0ZS9kaXN0L25vZGUvY2h1bmtzL2RlcC1JUVMtWmE3Ri5qcz9iOWUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZpbGVVUkxUb1BhdGggYXMgX19janNfZmlsZVVSTFRvUGF0aCB9IGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IGRpcm5hbWUgYXMgX19janNfZGlybmFtZSB9IGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIGFzIF9fY2pzX2NyZWF0ZVJlcXVpcmUgfSBmcm9tICdub2RlOm1vZHVsZSc7XG5cbmNvbnN0IF9fZmlsZW5hbWUgPSBfX2Nqc19maWxlVVJMVG9QYXRoKGltcG9ydC5tZXRhLnVybCk7XG5jb25zdCBfX2Rpcm5hbWUgPSBfX2Nqc19kaXJuYW1lKF9fZmlsZW5hbWUpO1xuY29uc3QgcmVxdWlyZSA9IF9fY2pzX2NyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcbmNvbnN0IF9fcmVxdWlyZSA9IHJlcXVpcmU7XG52YXIgb3BlblBhcmVudGhlc2VzID0gXCIoXCIuY2hhckNvZGVBdCgwKTtcbnZhciBjbG9zZVBhcmVudGhlc2VzID0gXCIpXCIuY2hhckNvZGVBdCgwKTtcbnZhciBzaW5nbGVRdW90ZSA9IFwiJ1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgZG91YmxlUXVvdGUgPSAnXCInLmNoYXJDb2RlQXQoMCk7XG52YXIgYmFja3NsYXNoID0gXCJcXFxcXCIuY2hhckNvZGVBdCgwKTtcbnZhciBzbGFzaCA9IFwiL1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgY29tbWEgPSBcIixcIi5jaGFyQ29kZUF0KDApO1xudmFyIGNvbG9uID0gXCI6XCIuY2hhckNvZGVBdCgwKTtcbnZhciBzdGFyID0gXCIqXCIuY2hhckNvZGVBdCgwKTtcbnZhciB1TG93ZXIgPSBcInVcIi5jaGFyQ29kZUF0KDApO1xudmFyIHVVcHBlciA9IFwiVVwiLmNoYXJDb2RlQXQoMCk7XG52YXIgcGx1cyA9IFwiK1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgaXNVbmljb2RlUmFuZ2UgPSAvXlthLWYwLTk/LV0rJC9pO1xuXG52YXIgcGFyc2UkMSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIHZhbHVlID0gaW5wdXQ7XG5cbiAgdmFyIG5leHQsXG4gICAgcXVvdGUsXG4gICAgcHJldixcbiAgICB0b2tlbixcbiAgICBlc2NhcGUsXG4gICAgZXNjYXBlUG9zLFxuICAgIHdoaXRlc3BhY2VQb3MsXG4gICAgcGFyZW50aGVzZXNPcGVuUG9zO1xuICB2YXIgcG9zID0gMDtcbiAgdmFyIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG4gIHZhciBtYXggPSB2YWx1ZS5sZW5ndGg7XG4gIHZhciBzdGFjayA9IFt7IG5vZGVzOiB0b2tlbnMgfV07XG4gIHZhciBiYWxhbmNlZCA9IDA7XG4gIHZhciBwYXJlbnQ7XG5cbiAgdmFyIG5hbWUgPSBcIlwiO1xuICB2YXIgYmVmb3JlID0gXCJcIjtcbiAgdmFyIGFmdGVyID0gXCJcIjtcblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgLy8gV2hpdGVzcGFjZXNcbiAgICBpZiAoY29kZSA8PSAzMikge1xuICAgICAgbmV4dCA9IHBvcztcbiAgICAgIGRvIHtcbiAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIH0gd2hpbGUgKGNvZGUgPD0gMzIpO1xuICAgICAgdG9rZW4gPSB2YWx1ZS5zbGljZShwb3MsIG5leHQpO1xuXG4gICAgICBwcmV2ID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChjb2RlID09PSBjbG9zZVBhcmVudGhlc2VzICYmIGJhbGFuY2VkKSB7XG4gICAgICAgIGFmdGVyID0gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKHByZXYgJiYgcHJldi50eXBlID09PSBcImRpdlwiKSB7XG4gICAgICAgIHByZXYuYWZ0ZXIgPSB0b2tlbjtcbiAgICAgICAgcHJldi5zb3VyY2VFbmRJbmRleCArPSB0b2tlbi5sZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBjb2RlID09PSBjb21tYSB8fFxuICAgICAgICBjb2RlID09PSBjb2xvbiB8fFxuICAgICAgICAoY29kZSA9PT0gc2xhc2ggJiZcbiAgICAgICAgICB2YWx1ZS5jaGFyQ29kZUF0KG5leHQgKyAxKSAhPT0gc3RhciAmJlxuICAgICAgICAgICghcGFyZW50IHx8XG4gICAgICAgICAgICAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSBcImZ1bmN0aW9uXCIgJiYgcGFyZW50LnZhbHVlICE9PSBcImNhbGNcIikpKVxuICAgICAgKSB7XG4gICAgICAgIGJlZm9yZSA9IHRva2VuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwic3BhY2VcIixcbiAgICAgICAgICBzb3VyY2VJbmRleDogcG9zLFxuICAgICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0LFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcG9zID0gbmV4dDtcblxuICAgICAgLy8gUXVvdGVzXG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBzaW5nbGVRdW90ZSB8fCBjb2RlID09PSBkb3VibGVRdW90ZSkge1xuICAgICAgbmV4dCA9IHBvcztcbiAgICAgIHF1b3RlID0gY29kZSA9PT0gc2luZ2xlUXVvdGUgPyBcIidcIiA6ICdcIic7XG4gICAgICB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgc291cmNlSW5kZXg6IHBvcyxcbiAgICAgICAgcXVvdGU6IHF1b3RlXG4gICAgICB9O1xuICAgICAgZG8ge1xuICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgbmV4dCA9IHZhbHVlLmluZGV4T2YocXVvdGUsIG5leHQgKyAxKTtcbiAgICAgICAgaWYgKH5uZXh0KSB7XG4gICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICB3aGlsZSAodmFsdWUuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gYmFja3NsYXNoKSB7XG4gICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgIGVzY2FwZSA9ICFlc2NhcGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlICs9IHF1b3RlO1xuICAgICAgICAgIG5leHQgPSB2YWx1ZS5sZW5ndGggLSAxO1xuICAgICAgICAgIHRva2VuLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoZXNjYXBlKTtcbiAgICAgIHRva2VuLnZhbHVlID0gdmFsdWUuc2xpY2UocG9zICsgMSwgbmV4dCk7XG4gICAgICB0b2tlbi5zb3VyY2VFbmRJbmRleCA9IHRva2VuLnVuY2xvc2VkID8gbmV4dCA6IG5leHQgKyAxO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgcG9zID0gbmV4dCArIDE7XG4gICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICAvLyBDb21tZW50c1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gc2xhc2ggJiYgdmFsdWUuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gc3Rhcikge1xuICAgICAgbmV4dCA9IHZhbHVlLmluZGV4T2YoXCIqL1wiLCBwb3MpO1xuXG4gICAgICB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogXCJjb21tZW50XCIsXG4gICAgICAgIHNvdXJjZUluZGV4OiBwb3MsXG4gICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0ICsgMlxuICAgICAgfTtcblxuICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgIHRva2VuLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgbmV4dCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgdG9rZW4uc291cmNlRW5kSW5kZXggPSBuZXh0O1xuICAgICAgfVxuXG4gICAgICB0b2tlbi52YWx1ZSA9IHZhbHVlLnNsaWNlKHBvcyArIDIsIG5leHQpO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuXG4gICAgICBwb3MgPSBuZXh0ICsgMjtcbiAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIC8vIE9wZXJhdGlvbiB3aXRoaW4gY2FsY1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAoY29kZSA9PT0gc2xhc2ggfHwgY29kZSA9PT0gc3RhcikgJiZcbiAgICAgIHBhcmVudCAmJlxuICAgICAgcGFyZW50LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgcGFyZW50LnZhbHVlID09PSBcImNhbGNcIlxuICAgICkge1xuICAgICAgdG9rZW4gPSB2YWx1ZVtwb3NdO1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiBcIndvcmRcIixcbiAgICAgICAgc291cmNlSW5kZXg6IHBvcyAtIGJlZm9yZS5sZW5ndGgsXG4gICAgICAgIHNvdXJjZUVuZEluZGV4OiBwb3MgKyB0b2tlbi5sZW5ndGgsXG4gICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgfSk7XG4gICAgICBwb3MgKz0gMTtcbiAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIC8vIERpdmlkZXJzXG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBzbGFzaCB8fCBjb2RlID09PSBjb21tYSB8fCBjb2RlID09PSBjb2xvbikge1xuICAgICAgdG9rZW4gPSB2YWx1ZVtwb3NdO1xuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiZGl2XCIsXG4gICAgICAgIHNvdXJjZUluZGV4OiBwb3MgLSBiZWZvcmUubGVuZ3RoLFxuICAgICAgICBzb3VyY2VFbmRJbmRleDogcG9zICsgdG9rZW4ubGVuZ3RoLFxuICAgICAgICB2YWx1ZTogdG9rZW4sXG4gICAgICAgIGJlZm9yZTogYmVmb3JlLFxuICAgICAgICBhZnRlcjogXCJcIlxuICAgICAgfSk7XG4gICAgICBiZWZvcmUgPSBcIlwiO1xuXG4gICAgICBwb3MgKz0gMTtcbiAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIC8vIE9wZW4gcGFyZW50aGVzZXNcbiAgICB9IGVsc2UgaWYgKG9wZW5QYXJlbnRoZXNlcyA9PT0gY29kZSkge1xuICAgICAgLy8gV2hpdGVzcGFjZXMgYWZ0ZXIgb3BlbiBwYXJlbnRoZXNlc1xuICAgICAgbmV4dCA9IHBvcztcbiAgICAgIGRvIHtcbiAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIH0gd2hpbGUgKGNvZGUgPD0gMzIpO1xuICAgICAgcGFyZW50aGVzZXNPcGVuUG9zID0gcG9zO1xuICAgICAgdG9rZW4gPSB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgc291cmNlSW5kZXg6IHBvcyAtIG5hbWUubGVuZ3RoLFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgYmVmb3JlOiB2YWx1ZS5zbGljZShwYXJlbnRoZXNlc09wZW5Qb3MgKyAxLCBuZXh0KVxuICAgICAgfTtcbiAgICAgIHBvcyA9IG5leHQ7XG5cbiAgICAgIGlmIChuYW1lID09PSBcInVybFwiICYmIGNvZGUgIT09IHNpbmdsZVF1b3RlICYmIGNvZGUgIT09IGRvdWJsZVF1b3RlKSB7XG4gICAgICAgIG5leHQgLT0gMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGVzY2FwZSA9IGZhbHNlO1xuICAgICAgICAgIG5leHQgPSB2YWx1ZS5pbmRleE9mKFwiKVwiLCBuZXh0ICsgMSk7XG4gICAgICAgICAgaWYgKH5uZXh0KSB7XG4gICAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0O1xuICAgICAgICAgICAgd2hpbGUgKHZhbHVlLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IGJhY2tzbGFzaCkge1xuICAgICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgICAgZXNjYXBlID0gIWVzY2FwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgKz0gXCIpXCI7XG4gICAgICAgICAgICBuZXh0ID0gdmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHRva2VuLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGVzY2FwZSk7XG4gICAgICAgIC8vIFdoaXRlc3BhY2VzIGJlZm9yZSBjbG9zZWRcbiAgICAgICAgd2hpdGVzcGFjZVBvcyA9IG5leHQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB3aGl0ZXNwYWNlUG9zIC09IDE7XG4gICAgICAgICAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQod2hpdGVzcGFjZVBvcyk7XG4gICAgICAgIH0gd2hpbGUgKGNvZGUgPD0gMzIpO1xuICAgICAgICBpZiAocGFyZW50aGVzZXNPcGVuUG9zIDwgd2hpdGVzcGFjZVBvcykge1xuICAgICAgICAgIGlmIChwb3MgIT09IHdoaXRlc3BhY2VQb3MgKyAxKSB7XG4gICAgICAgICAgICB0b2tlbi5ub2RlcyA9IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwid29yZFwiLFxuICAgICAgICAgICAgICAgIHNvdXJjZUluZGV4OiBwb3MsXG4gICAgICAgICAgICAgICAgc291cmNlRW5kSW5kZXg6IHdoaXRlc3BhY2VQb3MgKyAxLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zbGljZShwb3MsIHdoaXRlc3BhY2VQb3MgKyAxKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi5ub2RlcyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9rZW4udW5jbG9zZWQgJiYgd2hpdGVzcGFjZVBvcyArIDEgIT09IG5leHQpIHtcbiAgICAgICAgICAgIHRva2VuLmFmdGVyID0gXCJcIjtcbiAgICAgICAgICAgIHRva2VuLm5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcInNwYWNlXCIsXG4gICAgICAgICAgICAgIHNvdXJjZUluZGV4OiB3aGl0ZXNwYWNlUG9zICsgMSxcbiAgICAgICAgICAgICAgc291cmNlRW5kSW5kZXg6IG5leHQsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zbGljZSh3aGl0ZXNwYWNlUG9zICsgMSwgbmV4dClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi5hZnRlciA9IHZhbHVlLnNsaWNlKHdoaXRlc3BhY2VQb3MgKyAxLCBuZXh0KTtcbiAgICAgICAgICAgIHRva2VuLnNvdXJjZUVuZEluZGV4ID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW4uYWZ0ZXIgPSBcIlwiO1xuICAgICAgICAgIHRva2VuLm5vZGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gbmV4dCArIDE7XG4gICAgICAgIHRva2VuLnNvdXJjZUVuZEluZGV4ID0gdG9rZW4udW5jbG9zZWQgPyBuZXh0IDogcG9zO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYWxhbmNlZCArPSAxO1xuICAgICAgICB0b2tlbi5hZnRlciA9IFwiXCI7XG4gICAgICAgIHRva2VuLnNvdXJjZUVuZEluZGV4ID0gcG9zICsgMTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICAgICAgdG9rZW5zID0gdG9rZW4ubm9kZXMgPSBbXTtcbiAgICAgICAgcGFyZW50ID0gdG9rZW47XG4gICAgICB9XG4gICAgICBuYW1lID0gXCJcIjtcblxuICAgICAgLy8gQ2xvc2UgcGFyZW50aGVzZXNcbiAgICB9IGVsc2UgaWYgKGNsb3NlUGFyZW50aGVzZXMgPT09IGNvZGUgJiYgYmFsYW5jZWQpIHtcbiAgICAgIHBvcyArPSAxO1xuICAgICAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgcGFyZW50LmFmdGVyID0gYWZ0ZXI7XG4gICAgICBwYXJlbnQuc291cmNlRW5kSW5kZXggKz0gYWZ0ZXIubGVuZ3RoO1xuICAgICAgYWZ0ZXIgPSBcIlwiO1xuICAgICAgYmFsYW5jZWQgLT0gMTtcbiAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnNvdXJjZUVuZEluZGV4ID0gcG9zO1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgICBwYXJlbnQgPSBzdGFja1tiYWxhbmNlZF07XG4gICAgICB0b2tlbnMgPSBwYXJlbnQubm9kZXM7XG5cbiAgICAgIC8vIFdvcmRzXG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQgPSBwb3M7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChjb2RlID09PSBiYWNrc2xhc2gpIHtcbiAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIH0gd2hpbGUgKFxuICAgICAgICBuZXh0IDwgbWF4ICYmXG4gICAgICAgICEoXG4gICAgICAgICAgY29kZSA8PSAzMiB8fFxuICAgICAgICAgIGNvZGUgPT09IHNpbmdsZVF1b3RlIHx8XG4gICAgICAgICAgY29kZSA9PT0gZG91YmxlUXVvdGUgfHxcbiAgICAgICAgICBjb2RlID09PSBjb21tYSB8fFxuICAgICAgICAgIGNvZGUgPT09IGNvbG9uIHx8XG4gICAgICAgICAgY29kZSA9PT0gc2xhc2ggfHxcbiAgICAgICAgICBjb2RlID09PSBvcGVuUGFyZW50aGVzZXMgfHxcbiAgICAgICAgICAoY29kZSA9PT0gc3RhciAmJlxuICAgICAgICAgICAgcGFyZW50ICYmXG4gICAgICAgICAgICBwYXJlbnQudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICBwYXJlbnQudmFsdWUgPT09IFwiY2FsY1wiKSB8fFxuICAgICAgICAgIChjb2RlID09PSBzbGFzaCAmJlxuICAgICAgICAgICAgcGFyZW50LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgcGFyZW50LnZhbHVlID09PSBcImNhbGNcIikgfHxcbiAgICAgICAgICAoY29kZSA9PT0gY2xvc2VQYXJlbnRoZXNlcyAmJiBiYWxhbmNlZClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRva2VuID0gdmFsdWUuc2xpY2UocG9zLCBuZXh0KTtcblxuICAgICAgaWYgKG9wZW5QYXJlbnRoZXNlcyA9PT0gY29kZSkge1xuICAgICAgICBuYW1lID0gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAodUxvd2VyID09PSB0b2tlbi5jaGFyQ29kZUF0KDApIHx8IHVVcHBlciA9PT0gdG9rZW4uY2hhckNvZGVBdCgwKSkgJiZcbiAgICAgICAgcGx1cyA9PT0gdG9rZW4uY2hhckNvZGVBdCgxKSAmJlxuICAgICAgICBpc1VuaWNvZGVSYW5nZS50ZXN0KHRva2VuLnNsaWNlKDIpKVxuICAgICAgKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInVuaWNvZGUtcmFuZ2VcIixcbiAgICAgICAgICBzb3VyY2VJbmRleDogcG9zLFxuICAgICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0LFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcIndvcmRcIixcbiAgICAgICAgICBzb3VyY2VJbmRleDogcG9zLFxuICAgICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0LFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcG9zID0gbmV4dDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvczsgcG9zIC09IDEpIHtcbiAgICBzdGFja1twb3NdLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICBzdGFja1twb3NdLnNvdXJjZUVuZEluZGV4ID0gdmFsdWUubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0YWNrWzBdLm5vZGVzO1xufTtcblxudmFyIHdhbGskMSA9IGZ1bmN0aW9uIHdhbGsobm9kZXMsIGNiLCBidWJibGUpIHtcbiAgdmFyIGksIG1heCwgbm9kZSwgcmVzdWx0O1xuXG4gIGZvciAoaSA9IDAsIG1heCA9IG5vZGVzLmxlbmd0aDsgaSA8IG1heDsgaSArPSAxKSB7XG4gICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICghYnViYmxlKSB7XG4gICAgICByZXN1bHQgPSBjYihub2RlLCBpLCBub2Rlcyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgcmVzdWx0ICE9PSBmYWxzZSAmJlxuICAgICAgbm9kZS50eXBlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkobm9kZS5ub2RlcylcbiAgICApIHtcbiAgICAgIHdhbGsobm9kZS5ub2RlcywgY2IsIGJ1YmJsZSk7XG4gICAgfVxuXG4gICAgaWYgKGJ1YmJsZSkge1xuICAgICAgY2Iobm9kZSwgaSwgbm9kZXMpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5Tm9kZShub2RlLCBjdXN0b20pIHtcbiAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XG4gIHZhciB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gIHZhciBidWY7XG4gIHZhciBjdXN0b21SZXN1bHQ7XG5cbiAgaWYgKGN1c3RvbSAmJiAoY3VzdG9tUmVzdWx0ID0gY3VzdG9tKG5vZGUpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGN1c3RvbVJlc3VsdDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcIndvcmRcIiB8fCB0eXBlID09PSBcInNwYWNlXCIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGJ1ZiA9IG5vZGUucXVvdGUgfHwgXCJcIjtcbiAgICByZXR1cm4gYnVmICsgdmFsdWUgKyAobm9kZS51bmNsb3NlZCA/IFwiXCIgOiBidWYpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgcmV0dXJuIFwiLypcIiArIHZhbHVlICsgKG5vZGUudW5jbG9zZWQgPyBcIlwiIDogXCIqL1wiKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcImRpdlwiKSB7XG4gICAgcmV0dXJuIChub2RlLmJlZm9yZSB8fCBcIlwiKSArIHZhbHVlICsgKG5vZGUuYWZ0ZXIgfHwgXCJcIik7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlLm5vZGVzKSkge1xuICAgIGJ1ZiA9IHN0cmluZ2lmeSQxKG5vZGUubm9kZXMsIGN1c3RvbSk7XG4gICAgaWYgKHR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIHZhbHVlICtcbiAgICAgIFwiKFwiICtcbiAgICAgIChub2RlLmJlZm9yZSB8fCBcIlwiKSArXG4gICAgICBidWYgK1xuICAgICAgKG5vZGUuYWZ0ZXIgfHwgXCJcIikgK1xuICAgICAgKG5vZGUudW5jbG9zZWQgPyBcIlwiIDogXCIpXCIpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeSQxKG5vZGVzLCBjdXN0b20pIHtcbiAgdmFyIHJlc3VsdCwgaTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAoaSA9IG5vZGVzLmxlbmd0aCAtIDE7IH5pOyBpIC09IDEpIHtcbiAgICAgIHJlc3VsdCA9IHN0cmluZ2lmeU5vZGUobm9kZXNbaV0sIGN1c3RvbSkgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ2lmeU5vZGUobm9kZXMsIGN1c3RvbSk7XG59XG5cbnZhciBzdHJpbmdpZnlfMSA9IHN0cmluZ2lmeSQxO1xuXG52YXIgdW5pdDtcbnZhciBoYXNSZXF1aXJlZFVuaXQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVVbml0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkVW5pdCkgcmV0dXJuIHVuaXQ7XG5cdGhhc1JlcXVpcmVkVW5pdCA9IDE7XG5cdHZhciBtaW51cyA9IFwiLVwiLmNoYXJDb2RlQXQoMCk7XG5cdHZhciBwbHVzID0gXCIrXCIuY2hhckNvZGVBdCgwKTtcblx0dmFyIGRvdCA9IFwiLlwiLmNoYXJDb2RlQXQoMCk7XG5cdHZhciBleHAgPSBcImVcIi5jaGFyQ29kZUF0KDApO1xuXHR2YXIgRVhQID0gXCJFXCIuY2hhckNvZGVBdCgwKTtcblxuXHQvLyBDaGVjayBpZiB0aHJlZSBjb2RlIHBvaW50cyB3b3VsZCBzdGFydCBhIG51bWJlclxuXHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXN5bnRheC0zLyNzdGFydHMtd2l0aC1hLW51bWJlclxuXHRmdW5jdGlvbiBsaWtlTnVtYmVyKHZhbHVlKSB7XG5cdCAgdmFyIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuXHQgIHZhciBuZXh0Q29kZTtcblxuXHQgIGlmIChjb2RlID09PSBwbHVzIHx8IGNvZGUgPT09IG1pbnVzKSB7XG5cdCAgICBuZXh0Q29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoMSk7XG5cblx0ICAgIGlmIChuZXh0Q29kZSA+PSA0OCAmJiBuZXh0Q29kZSA8PSA1Nykge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIG5leHROZXh0Q29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoMik7XG5cblx0ICAgIGlmIChuZXh0Q29kZSA9PT0gZG90ICYmIG5leHROZXh0Q29kZSA+PSA0OCAmJiBuZXh0TmV4dENvZGUgPD0gNTcpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICBpZiAoY29kZSA9PT0gZG90KSB7XG5cdCAgICBuZXh0Q29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoMSk7XG5cblx0ICAgIGlmIChuZXh0Q29kZSA+PSA0OCAmJiBuZXh0Q29kZSA8PSA1Nykge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIENvbnN1bWUgYSBudW1iZXJcblx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1zeW50YXgtMy8jY29uc3VtZS1udW1iZXJcblx0dW5pdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgdmFyIHBvcyA9IDA7XG5cdCAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0ICB2YXIgY29kZTtcblx0ICB2YXIgbmV4dENvZGU7XG5cdCAgdmFyIG5leHROZXh0Q29kZTtcblxuXHQgIGlmIChsZW5ndGggPT09IDAgfHwgIWxpa2VOdW1iZXIodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcblxuXHQgIGlmIChjb2RlID09PSBwbHVzIHx8IGNvZGUgPT09IG1pbnVzKSB7XG5cdCAgICBwb3MrKztcblx0ICB9XG5cblx0ICB3aGlsZSAocG9zIDwgbGVuZ3RoKSB7XG5cdCAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXG5cdCAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiA1Nykge1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblxuXHQgICAgcG9zICs9IDE7XG5cdCAgfVxuXG5cdCAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcblx0ICBuZXh0Q29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zICsgMSk7XG5cblx0ICBpZiAoY29kZSA9PT0gZG90ICYmIG5leHRDb2RlID49IDQ4ICYmIG5leHRDb2RlIDw9IDU3KSB7XG5cdCAgICBwb3MgKz0gMjtcblxuXHQgICAgd2hpbGUgKHBvcyA8IGxlbmd0aCkge1xuXHQgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXG5cdCAgICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IDU3KSB7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblxuXHQgICAgICBwb3MgKz0gMTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXHQgIG5leHRDb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MgKyAxKTtcblx0ICBuZXh0TmV4dENvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyArIDIpO1xuXG5cdCAgaWYgKFxuXHQgICAgKGNvZGUgPT09IGV4cCB8fCBjb2RlID09PSBFWFApICYmXG5cdCAgICAoKG5leHRDb2RlID49IDQ4ICYmIG5leHRDb2RlIDw9IDU3KSB8fFxuXHQgICAgICAoKG5leHRDb2RlID09PSBwbHVzIHx8IG5leHRDb2RlID09PSBtaW51cykgJiZcblx0ICAgICAgICBuZXh0TmV4dENvZGUgPj0gNDggJiZcblx0ICAgICAgICBuZXh0TmV4dENvZGUgPD0gNTcpKVxuXHQgICkge1xuXHQgICAgcG9zICs9IG5leHRDb2RlID09PSBwbHVzIHx8IG5leHRDb2RlID09PSBtaW51cyA/IDMgOiAyO1xuXG5cdCAgICB3aGlsZSAocG9zIDwgbGVuZ3RoKSB7XG5cdCAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cblx0ICAgICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXG5cdCAgICAgIHBvcyArPSAxO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiB7XG5cdCAgICBudW1iZXI6IHZhbHVlLnNsaWNlKDAsIHBvcyksXG5cdCAgICB1bml0OiB2YWx1ZS5zbGljZShwb3MpXG5cdCAgfTtcblx0fTtcblx0cmV0dXJuIHVuaXQ7XG59XG5cbnZhciBwYXJzZSA9IHBhcnNlJDE7XG52YXIgd2FsayA9IHdhbGskMTtcbnZhciBzdHJpbmdpZnkgPSBzdHJpbmdpZnlfMTtcblxuZnVuY3Rpb24gVmFsdWVQYXJzZXIodmFsdWUpIHtcbiAgaWYgKHRoaXMgaW5zdGFuY2VvZiBWYWx1ZVBhcnNlcikge1xuICAgIHRoaXMubm9kZXMgPSBwYXJzZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIG5ldyBWYWx1ZVBhcnNlcih2YWx1ZSk7XG59XG5cblZhbHVlUGFyc2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLm5vZGVzKSA/IHN0cmluZ2lmeSh0aGlzLm5vZGVzKSA6IFwiXCI7XG59O1xuXG5WYWx1ZVBhcnNlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uKGNiLCBidWJibGUpIHtcbiAgd2Fsayh0aGlzLm5vZGVzLCBjYiwgYnViYmxlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5WYWx1ZVBhcnNlci51bml0ID0gcmVxdWlyZVVuaXQoKTtcblxuVmFsdWVQYXJzZXIud2FsayA9IHdhbGs7XG5cblZhbHVlUGFyc2VyLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcblxudmFyIGxpYiA9IFZhbHVlUGFyc2VyO1xuXG5leHBvcnQgeyBsaWIgYXMgbCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vite/dist/node/chunks/dep-IQS-Za7F.js\n");

/***/ })

}]);
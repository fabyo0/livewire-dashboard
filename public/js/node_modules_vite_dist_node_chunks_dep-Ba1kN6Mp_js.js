/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkjimipulsar_github_com"] = self["webpackChunkjimipulsar_github_com"] || []).push([["node_modules_vite_dist_node_chunks_dep-Ba1kN6Mp_js"],{

/***/ "./node_modules/postcss/lib/at-rule.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/at-rule.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\n\nclass AtRule extends Container {\n  constructor(defaults) {\n    super(defaults)\n    this.type = 'atrule'\n  }\n\n  append(...children) {\n    if (!this.proxyOf.nodes) this.nodes = []\n    return super.append(...children)\n  }\n\n  prepend(...children) {\n    if (!this.proxyOf.nodes) this.nodes = []\n    return super.prepend(...children)\n  }\n}\n\nmodule.exports = AtRule\nAtRule.default = AtRule\n\nContainer.registerAtRule(AtRule)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvYXQtcnVsZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBYTs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qaW1pcHVsc2FyQGdpdGh1Yi5jb20vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvYXQtcnVsZS5qcz9jZWY1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5sZXQgQ29udGFpbmVyID0gcmVxdWlyZSgnLi9jb250YWluZXInKVxuXG5jbGFzcyBBdFJ1bGUgZXh0ZW5kcyBDb250YWluZXIge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cykge1xuICAgIHN1cGVyKGRlZmF1bHRzKVxuICAgIHRoaXMudHlwZSA9ICdhdHJ1bGUnXG4gIH1cblxuICBhcHBlbmQoLi4uY2hpbGRyZW4pIHtcbiAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgdGhpcy5ub2RlcyA9IFtdXG4gICAgcmV0dXJuIHN1cGVyLmFwcGVuZCguLi5jaGlsZHJlbilcbiAgfVxuXG4gIHByZXBlbmQoLi4uY2hpbGRyZW4pIHtcbiAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgdGhpcy5ub2RlcyA9IFtdXG4gICAgcmV0dXJuIHN1cGVyLnByZXBlbmQoLi4uY2hpbGRyZW4pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBdFJ1bGVcbkF0UnVsZS5kZWZhdWx0ID0gQXRSdWxlXG5cbkNvbnRhaW5lci5yZWdpc3RlckF0UnVsZShBdFJ1bGUpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/at-rule.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/comment.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/comment.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Node = __webpack_require__(/*! ./node */ \"./node_modules/postcss/lib/node.js\")\n\nclass Comment extends Node {\n  constructor(defaults) {\n    super(defaults)\n    this.type = 'comment'\n  }\n}\n\nmodule.exports = Comment\nComment.default = Comment\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvY29tbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsa0RBQVE7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vamltaXB1bHNhckBnaXRodWIuY29tLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL2NvbW1lbnQuanM/M2Y4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKVxuXG5jbGFzcyBDb21tZW50IGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRzKSB7XG4gICAgc3VwZXIoZGVmYXVsdHMpXG4gICAgdGhpcy50eXBlID0gJ2NvbW1lbnQnXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21tZW50XG5Db21tZW50LmRlZmF1bHQgPSBDb21tZW50XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/comment.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/container.js":
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/container.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Comment = __webpack_require__(/*! ./comment */ \"./node_modules/postcss/lib/comment.js\")\nlet Declaration = __webpack_require__(/*! ./declaration */ \"./node_modules/postcss/lib/declaration.js\")\nlet Node = __webpack_require__(/*! ./node */ \"./node_modules/postcss/lib/node.js\")\nlet { isClean, my } = __webpack_require__(/*! ./symbols */ \"./node_modules/postcss/lib/symbols.js\")\n\nlet AtRule, parse, Root, Rule\n\nfunction cleanSource(nodes) {\n  return nodes.map(i => {\n    if (i.nodes) i.nodes = cleanSource(i.nodes)\n    delete i.source\n    return i\n  })\n}\n\nfunction markTreeDirty(node) {\n  node[isClean] = false\n  if (node.proxyOf.nodes) {\n    for (let i of node.proxyOf.nodes) {\n      markTreeDirty(i)\n    }\n  }\n}\n\nclass Container extends Node {\n  append(...children) {\n    for (let child of children) {\n      let nodes = this.normalize(child, this.last)\n      for (let node of nodes) this.proxyOf.nodes.push(node)\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  cleanRaws(keepBetween) {\n    super.cleanRaws(keepBetween)\n    if (this.nodes) {\n      for (let node of this.nodes) node.cleanRaws(keepBetween)\n    }\n  }\n\n  each(callback) {\n    if (!this.proxyOf.nodes) return undefined\n    let iterator = this.getIterator()\n\n    let index, result\n    while (this.indexes[iterator] < this.proxyOf.nodes.length) {\n      index = this.indexes[iterator]\n      result = callback(this.proxyOf.nodes[index], index)\n      if (result === false) break\n\n      this.indexes[iterator] += 1\n    }\n\n    delete this.indexes[iterator]\n    return result\n  }\n\n  every(condition) {\n    return this.nodes.every(condition)\n  }\n\n  getIterator() {\n    if (!this.lastEach) this.lastEach = 0\n    if (!this.indexes) this.indexes = {}\n\n    this.lastEach += 1\n    let iterator = this.lastEach\n    this.indexes[iterator] = 0\n\n    return iterator\n  }\n\n  getProxyProcessor() {\n    return {\n      get(node, prop) {\n        if (prop === 'proxyOf') {\n          return node\n        } else if (!node[prop]) {\n          return node[prop]\n        } else if (\n          prop === 'each' ||\n          (typeof prop === 'string' && prop.startsWith('walk'))\n        ) {\n          return (...args) => {\n            return node[prop](\n              ...args.map(i => {\n                if (typeof i === 'function') {\n                  return (child, index) => i(child.toProxy(), index)\n                } else {\n                  return i\n                }\n              })\n            )\n          }\n        } else if (prop === 'every' || prop === 'some') {\n          return cb => {\n            return node[prop]((child, ...other) =>\n              cb(child.toProxy(), ...other)\n            )\n          }\n        } else if (prop === 'root') {\n          return () => node.root().toProxy()\n        } else if (prop === 'nodes') {\n          return node.nodes.map(i => i.toProxy())\n        } else if (prop === 'first' || prop === 'last') {\n          return node[prop].toProxy()\n        } else {\n          return node[prop]\n        }\n      },\n\n      set(node, prop, value) {\n        if (node[prop] === value) return true\n        node[prop] = value\n        if (prop === 'name' || prop === 'params' || prop === 'selector') {\n          node.markDirty()\n        }\n        return true\n      }\n    }\n  }\n\n  index(child) {\n    if (typeof child === 'number') return child\n    if (child.proxyOf) child = child.proxyOf\n    return this.proxyOf.nodes.indexOf(child)\n  }\n\n  insertAfter(exist, add) {\n    let existIndex = this.index(exist)\n    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse()\n    existIndex = this.index(exist)\n    for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (existIndex < index) {\n        this.indexes[id] = index + nodes.length\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  insertBefore(exist, add) {\n    let existIndex = this.index(exist)\n    let type = existIndex === 0 ? 'prepend' : false\n    let nodes = this.normalize(\n      add,\n      this.proxyOf.nodes[existIndex],\n      type\n    ).reverse()\n    existIndex = this.index(exist)\n    for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (existIndex <= index) {\n        this.indexes[id] = index + nodes.length\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  normalize(nodes, sample) {\n    if (typeof nodes === 'string') {\n      nodes = cleanSource(parse(nodes).nodes)\n    } else if (typeof nodes === 'undefined') {\n      nodes = []\n    } else if (Array.isArray(nodes)) {\n      nodes = nodes.slice(0)\n      for (let i of nodes) {\n        if (i.parent) i.parent.removeChild(i, 'ignore')\n      }\n    } else if (nodes.type === 'root' && this.type !== 'document') {\n      nodes = nodes.nodes.slice(0)\n      for (let i of nodes) {\n        if (i.parent) i.parent.removeChild(i, 'ignore')\n      }\n    } else if (nodes.type) {\n      nodes = [nodes]\n    } else if (nodes.prop) {\n      if (typeof nodes.value === 'undefined') {\n        throw new Error('Value field is missed in node creation')\n      } else if (typeof nodes.value !== 'string') {\n        nodes.value = String(nodes.value)\n      }\n      nodes = [new Declaration(nodes)]\n    } else if (nodes.selector || nodes.selectors) {\n      nodes = [new Rule(nodes)]\n    } else if (nodes.name) {\n      nodes = [new AtRule(nodes)]\n    } else if (nodes.text) {\n      nodes = [new Comment(nodes)]\n    } else {\n      throw new Error('Unknown node type in node creation')\n    }\n\n    let processed = nodes.map(i => {\n      /* c8 ignore next */\n      if (!i[my]) Container.rebuild(i)\n      i = i.proxyOf\n      if (i.parent) i.parent.removeChild(i)\n      if (i[isClean]) markTreeDirty(i)\n\n      if (!i.raws) i.raws = {}\n      if (typeof i.raws.before === 'undefined') {\n        if (sample && typeof sample.raws.before !== 'undefined') {\n          i.raws.before = sample.raws.before.replace(/\\S/g, '')\n        }\n      }\n      i.parent = this.proxyOf\n      return i\n    })\n\n    return processed\n  }\n\n  prepend(...children) {\n    children = children.reverse()\n    for (let child of children) {\n      let nodes = this.normalize(child, this.first, 'prepend').reverse()\n      for (let node of nodes) this.proxyOf.nodes.unshift(node)\n      for (let id in this.indexes) {\n        this.indexes[id] = this.indexes[id] + nodes.length\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  push(child) {\n    child.parent = this\n    this.proxyOf.nodes.push(child)\n    return this\n  }\n\n  removeAll() {\n    for (let node of this.proxyOf.nodes) node.parent = undefined\n    this.proxyOf.nodes = []\n\n    this.markDirty()\n\n    return this\n  }\n\n  removeChild(child) {\n    child = this.index(child)\n    this.proxyOf.nodes[child].parent = undefined\n    this.proxyOf.nodes.splice(child, 1)\n\n    let index\n    for (let id in this.indexes) {\n      index = this.indexes[id]\n      if (index >= child) {\n        this.indexes[id] = index - 1\n      }\n    }\n\n    this.markDirty()\n\n    return this\n  }\n\n  replaceValues(pattern, opts, callback) {\n    if (!callback) {\n      callback = opts\n      opts = {}\n    }\n\n    this.walkDecls(decl => {\n      if (opts.props && !opts.props.includes(decl.prop)) return\n      if (opts.fast && !decl.value.includes(opts.fast)) return\n\n      decl.value = decl.value.replace(pattern, callback)\n    })\n\n    this.markDirty()\n\n    return this\n  }\n\n  some(condition) {\n    return this.nodes.some(condition)\n  }\n\n  walk(callback) {\n    return this.each((child, i) => {\n      let result\n      try {\n        result = callback(child, i)\n      } catch (e) {\n        throw child.addToError(e)\n      }\n      if (result !== false && child.walk) {\n        result = child.walk(callback)\n      }\n\n      return result\n    })\n  }\n\n  walkAtRules(name, callback) {\n    if (!callback) {\n      callback = name\n      return this.walk((child, i) => {\n        if (child.type === 'atrule') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (name instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'atrule' && name.test(child.name)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'atrule' && child.name === name) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  walkComments(callback) {\n    return this.walk((child, i) => {\n      if (child.type === 'comment') {\n        return callback(child, i)\n      }\n    })\n  }\n\n  walkDecls(prop, callback) {\n    if (!callback) {\n      callback = prop\n      return this.walk((child, i) => {\n        if (child.type === 'decl') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (prop instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'decl' && prop.test(child.prop)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'decl' && child.prop === prop) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  walkRules(selector, callback) {\n    if (!callback) {\n      callback = selector\n\n      return this.walk((child, i) => {\n        if (child.type === 'rule') {\n          return callback(child, i)\n        }\n      })\n    }\n    if (selector instanceof RegExp) {\n      return this.walk((child, i) => {\n        if (child.type === 'rule' && selector.test(child.selector)) {\n          return callback(child, i)\n        }\n      })\n    }\n    return this.walk((child, i) => {\n      if (child.type === 'rule' && child.selector === selector) {\n        return callback(child, i)\n      }\n    })\n  }\n\n  get first() {\n    if (!this.proxyOf.nodes) return undefined\n    return this.proxyOf.nodes[0]\n  }\n\n  get last() {\n    if (!this.proxyOf.nodes) return undefined\n    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1]\n  }\n}\n\nContainer.registerParse = dependant => {\n  parse = dependant\n}\n\nContainer.registerRule = dependant => {\n  Rule = dependant\n}\n\nContainer.registerAtRule = dependant => {\n  AtRule = dependant\n}\n\nContainer.registerRoot = dependant => {\n  Root = dependant\n}\n\nmodule.exports = Container\nContainer.default = Container\n\n/* c8 ignore start */\nContainer.rebuild = node => {\n  if (node.type === 'atrule') {\n    Object.setPrototypeOf(node, AtRule.prototype)\n  } else if (node.type === 'rule') {\n    Object.setPrototypeOf(node, Rule.prototype)\n  } else if (node.type === 'decl') {\n    Object.setPrototypeOf(node, Declaration.prototype)\n  } else if (node.type === 'comment') {\n    Object.setPrototypeOf(node, Comment.prototype)\n  } else if (node.type === 'root') {\n    Object.setPrototypeOf(node, Root.prototype)\n  }\n\n  node[my] = true\n\n  if (node.nodes) {\n    node.nodes.forEach(child => {\n      Container.rebuild(child)\n    })\n  }\n}\n/* c8 ignore stop */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvY29udGFpbmVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGNBQWMsbUJBQU8sQ0FBQyx3REFBVztBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyxnRUFBZTtBQUN6QyxXQUFXLG1CQUFPLENBQUMsa0RBQVE7QUFDM0IsTUFBTSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyx3REFBVzs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vamltaXB1bHNhckBnaXRodWIuY29tLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL2NvbnRhaW5lci5qcz83OWU1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5sZXQgQ29tbWVudCA9IHJlcXVpcmUoJy4vY29tbWVudCcpXG5sZXQgRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL2RlY2xhcmF0aW9uJylcbmxldCBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJylcbmxldCB7IGlzQ2xlYW4sIG15IH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuXG5sZXQgQXRSdWxlLCBwYXJzZSwgUm9vdCwgUnVsZVxuXG5mdW5jdGlvbiBjbGVhblNvdXJjZShub2Rlcykge1xuICByZXR1cm4gbm9kZXMubWFwKGkgPT4ge1xuICAgIGlmIChpLm5vZGVzKSBpLm5vZGVzID0gY2xlYW5Tb3VyY2UoaS5ub2RlcylcbiAgICBkZWxldGUgaS5zb3VyY2VcbiAgICByZXR1cm4gaVxuICB9KVxufVxuXG5mdW5jdGlvbiBtYXJrVHJlZURpcnR5KG5vZGUpIHtcbiAgbm9kZVtpc0NsZWFuXSA9IGZhbHNlXG4gIGlmIChub2RlLnByb3h5T2Yubm9kZXMpIHtcbiAgICBmb3IgKGxldCBpIG9mIG5vZGUucHJveHlPZi5ub2Rlcykge1xuICAgICAgbWFya1RyZWVEaXJ0eShpKVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBOb2RlIHtcbiAgYXBwZW5kKC4uLmNoaWxkcmVuKSB7XG4gICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGxldCBub2RlcyA9IHRoaXMubm9ybWFsaXplKGNoaWxkLCB0aGlzLmxhc3QpXG4gICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKSB0aGlzLnByb3h5T2Yubm9kZXMucHVzaChub2RlKVxuICAgIH1cblxuICAgIHRoaXMubWFya0RpcnR5KClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjbGVhblJhd3Moa2VlcEJldHdlZW4pIHtcbiAgICBzdXBlci5jbGVhblJhd3Moa2VlcEJldHdlZW4pXG4gICAgaWYgKHRoaXMubm9kZXMpIHtcbiAgICAgIGZvciAobGV0IG5vZGUgb2YgdGhpcy5ub2Rlcykgbm9kZS5jbGVhblJhd3Moa2VlcEJldHdlZW4pXG4gICAgfVxuICB9XG5cbiAgZWFjaChjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgbGV0IGl0ZXJhdG9yID0gdGhpcy5nZXRJdGVyYXRvcigpXG5cbiAgICBsZXQgaW5kZXgsIHJlc3VsdFxuICAgIHdoaWxlICh0aGlzLmluZGV4ZXNbaXRlcmF0b3JdIDwgdGhpcy5wcm94eU9mLm5vZGVzLmxlbmd0aCkge1xuICAgICAgaW5kZXggPSB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdXG4gICAgICByZXN1bHQgPSBjYWxsYmFjayh0aGlzLnByb3h5T2Yubm9kZXNbaW5kZXhdLCBpbmRleClcbiAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSBicmVha1xuXG4gICAgICB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdICs9IDFcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5pbmRleGVzW2l0ZXJhdG9yXVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGV2ZXJ5KGNvbmRpdGlvbikge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmV2ZXJ5KGNvbmRpdGlvbilcbiAgfVxuXG4gIGdldEl0ZXJhdG9yKCkge1xuICAgIGlmICghdGhpcy5sYXN0RWFjaCkgdGhpcy5sYXN0RWFjaCA9IDBcbiAgICBpZiAoIXRoaXMuaW5kZXhlcykgdGhpcy5pbmRleGVzID0ge31cblxuICAgIHRoaXMubGFzdEVhY2ggKz0gMVxuICAgIGxldCBpdGVyYXRvciA9IHRoaXMubGFzdEVhY2hcbiAgICB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdID0gMFxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBnZXRQcm94eVByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0KG5vZGUsIHByb3ApIHtcbiAgICAgICAgaWYgKHByb3AgPT09ICdwcm94eU9mJykge1xuICAgICAgICAgIHJldHVybiBub2RlXG4gICAgICAgIH0gZWxzZSBpZiAoIW5vZGVbcHJvcF0pIHtcbiAgICAgICAgICByZXR1cm4gbm9kZVtwcm9wXVxuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHByb3AgPT09ICdlYWNoJyB8fFxuICAgICAgICAgICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycgJiYgcHJvcC5zdGFydHNXaXRoKCd3YWxrJykpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVbcHJvcF0oXG4gICAgICAgICAgICAgIC4uLmFyZ3MubWFwKGkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIChjaGlsZCwgaW5kZXgpID0+IGkoY2hpbGQudG9Qcm94eSgpLCBpbmRleClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdldmVyeScgfHwgcHJvcCA9PT0gJ3NvbWUnKSB7XG4gICAgICAgICAgcmV0dXJuIGNiID0+IHtcbiAgICAgICAgICAgIHJldHVybiBub2RlW3Byb3BdKChjaGlsZCwgLi4ub3RoZXIpID0+XG4gICAgICAgICAgICAgIGNiKGNoaWxkLnRvUHJveHkoKSwgLi4ub3RoZXIpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdyb290Jykge1xuICAgICAgICAgIHJldHVybiAoKSA9PiBub2RlLnJvb3QoKS50b1Byb3h5KClcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAnbm9kZXMnKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUubm9kZXMubWFwKGkgPT4gaS50b1Byb3h5KCkpXG4gICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ2ZpcnN0JyB8fCBwcm9wID09PSAnbGFzdCcpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZVtwcm9wXS50b1Byb3h5KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbm9kZVtwcm9wXVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBzZXQobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5vZGVbcHJvcF0gPT09IHZhbHVlKSByZXR1cm4gdHJ1ZVxuICAgICAgICBub2RlW3Byb3BdID0gdmFsdWVcbiAgICAgICAgaWYgKHByb3AgPT09ICduYW1lJyB8fCBwcm9wID09PSAncGFyYW1zJyB8fCBwcm9wID09PSAnc2VsZWN0b3InKSB7XG4gICAgICAgICAgbm9kZS5tYXJrRGlydHkoKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW5kZXgoY2hpbGQpIHtcbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykgcmV0dXJuIGNoaWxkXG4gICAgaWYgKGNoaWxkLnByb3h5T2YpIGNoaWxkID0gY2hpbGQucHJveHlPZlxuICAgIHJldHVybiB0aGlzLnByb3h5T2Yubm9kZXMuaW5kZXhPZihjaGlsZClcbiAgfVxuXG4gIGluc2VydEFmdGVyKGV4aXN0LCBhZGQpIHtcbiAgICBsZXQgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpXG4gICAgbGV0IG5vZGVzID0gdGhpcy5ub3JtYWxpemUoYWRkLCB0aGlzLnByb3h5T2Yubm9kZXNbZXhpc3RJbmRleF0pLnJldmVyc2UoKVxuICAgIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KVxuICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpIHRoaXMucHJveHlPZi5ub2Rlcy5zcGxpY2UoZXhpc3RJbmRleCArIDEsIDAsIG5vZGUpXG5cbiAgICBsZXQgaW5kZXhcbiAgICBmb3IgKGxldCBpZCBpbiB0aGlzLmluZGV4ZXMpIHtcbiAgICAgIGluZGV4ID0gdGhpcy5pbmRleGVzW2lkXVxuICAgICAgaWYgKGV4aXN0SW5kZXggPCBpbmRleCkge1xuICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXggKyBub2Rlcy5sZW5ndGhcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1hcmtEaXJ0eSgpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaW5zZXJ0QmVmb3JlKGV4aXN0LCBhZGQpIHtcbiAgICBsZXQgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpXG4gICAgbGV0IHR5cGUgPSBleGlzdEluZGV4ID09PSAwID8gJ3ByZXBlbmQnIDogZmFsc2VcbiAgICBsZXQgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShcbiAgICAgIGFkZCxcbiAgICAgIHRoaXMucHJveHlPZi5ub2Rlc1tleGlzdEluZGV4XSxcbiAgICAgIHR5cGVcbiAgICApLnJldmVyc2UoKVxuICAgIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KVxuICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpIHRoaXMucHJveHlPZi5ub2Rlcy5zcGxpY2UoZXhpc3RJbmRleCwgMCwgbm9kZSlcblxuICAgIGxldCBpbmRleFxuICAgIGZvciAobGV0IGlkIGluIHRoaXMuaW5kZXhlcykge1xuICAgICAgaW5kZXggPSB0aGlzLmluZGV4ZXNbaWRdXG4gICAgICBpZiAoZXhpc3RJbmRleCA8PSBpbmRleCkge1xuICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXggKyBub2Rlcy5sZW5ndGhcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1hcmtEaXJ0eSgpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbm9ybWFsaXplKG5vZGVzLCBzYW1wbGUpIHtcbiAgICBpZiAodHlwZW9mIG5vZGVzID09PSAnc3RyaW5nJykge1xuICAgICAgbm9kZXMgPSBjbGVhblNvdXJjZShwYXJzZShub2Rlcykubm9kZXMpXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBub2RlcyA9IFtdXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgbm9kZXMgPSBub2Rlcy5zbGljZSgwKVxuICAgICAgZm9yIChsZXQgaSBvZiBub2Rlcykge1xuICAgICAgICBpZiAoaS5wYXJlbnQpIGkucGFyZW50LnJlbW92ZUNoaWxkKGksICdpZ25vcmUnKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZXMudHlwZSA9PT0gJ3Jvb3QnICYmIHRoaXMudHlwZSAhPT0gJ2RvY3VtZW50Jykge1xuICAgICAgbm9kZXMgPSBub2Rlcy5ub2Rlcy5zbGljZSgwKVxuICAgICAgZm9yIChsZXQgaSBvZiBub2Rlcykge1xuICAgICAgICBpZiAoaS5wYXJlbnQpIGkucGFyZW50LnJlbW92ZUNoaWxkKGksICdpZ25vcmUnKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZXMudHlwZSkge1xuICAgICAgbm9kZXMgPSBbbm9kZXNdXG4gICAgfSBlbHNlIGlmIChub2Rlcy5wcm9wKSB7XG4gICAgICBpZiAodHlwZW9mIG5vZGVzLnZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIGZpZWxkIGlzIG1pc3NlZCBpbiBub2RlIGNyZWF0aW9uJylcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGVzLnZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICBub2Rlcy52YWx1ZSA9IFN0cmluZyhub2Rlcy52YWx1ZSlcbiAgICAgIH1cbiAgICAgIG5vZGVzID0gW25ldyBEZWNsYXJhdGlvbihub2RlcyldXG4gICAgfSBlbHNlIGlmIChub2Rlcy5zZWxlY3RvciB8fCBub2Rlcy5zZWxlY3RvcnMpIHtcbiAgICAgIG5vZGVzID0gW25ldyBSdWxlKG5vZGVzKV1cbiAgICB9IGVsc2UgaWYgKG5vZGVzLm5hbWUpIHtcbiAgICAgIG5vZGVzID0gW25ldyBBdFJ1bGUobm9kZXMpXVxuICAgIH0gZWxzZSBpZiAobm9kZXMudGV4dCkge1xuICAgICAgbm9kZXMgPSBbbmV3IENvbW1lbnQobm9kZXMpXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB0eXBlIGluIG5vZGUgY3JlYXRpb24nKVxuICAgIH1cblxuICAgIGxldCBwcm9jZXNzZWQgPSBub2Rlcy5tYXAoaSA9PiB7XG4gICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKCFpW215XSkgQ29udGFpbmVyLnJlYnVpbGQoaSlcbiAgICAgIGkgPSBpLnByb3h5T2ZcbiAgICAgIGlmIChpLnBhcmVudCkgaS5wYXJlbnQucmVtb3ZlQ2hpbGQoaSlcbiAgICAgIGlmIChpW2lzQ2xlYW5dKSBtYXJrVHJlZURpcnR5KGkpXG5cbiAgICAgIGlmICghaS5yYXdzKSBpLnJhd3MgPSB7fVxuICAgICAgaWYgKHR5cGVvZiBpLnJhd3MuYmVmb3JlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoc2FtcGxlICYmIHR5cGVvZiBzYW1wbGUucmF3cy5iZWZvcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaS5yYXdzLmJlZm9yZSA9IHNhbXBsZS5yYXdzLmJlZm9yZS5yZXBsYWNlKC9cXFMvZywgJycpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkucGFyZW50ID0gdGhpcy5wcm94eU9mXG4gICAgICByZXR1cm4gaVxuICAgIH0pXG5cbiAgICByZXR1cm4gcHJvY2Vzc2VkXG4gIH1cblxuICBwcmVwZW5kKC4uLmNoaWxkcmVuKSB7XG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5yZXZlcnNlKClcbiAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgbGV0IG5vZGVzID0gdGhpcy5ub3JtYWxpemUoY2hpbGQsIHRoaXMuZmlyc3QsICdwcmVwZW5kJykucmV2ZXJzZSgpXG4gICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKSB0aGlzLnByb3h5T2Yubm9kZXMudW5zaGlmdChub2RlKVxuICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy5pbmRleGVzKSB7XG4gICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSB0aGlzLmluZGV4ZXNbaWRdICsgbm9kZXMubGVuZ3RoXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5tYXJrRGlydHkoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHB1c2goY2hpbGQpIHtcbiAgICBjaGlsZC5wYXJlbnQgPSB0aGlzXG4gICAgdGhpcy5wcm94eU9mLm5vZGVzLnB1c2goY2hpbGQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJlbW92ZUFsbCgpIHtcbiAgICBmb3IgKGxldCBub2RlIG9mIHRoaXMucHJveHlPZi5ub2Rlcykgbm9kZS5wYXJlbnQgPSB1bmRlZmluZWRcbiAgICB0aGlzLnByb3h5T2Yubm9kZXMgPSBbXVxuXG4gICAgdGhpcy5tYXJrRGlydHkoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgY2hpbGQgPSB0aGlzLmluZGV4KGNoaWxkKVxuICAgIHRoaXMucHJveHlPZi5ub2Rlc1tjaGlsZF0ucGFyZW50ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5wcm94eU9mLm5vZGVzLnNwbGljZShjaGlsZCwgMSlcblxuICAgIGxldCBpbmRleFxuICAgIGZvciAobGV0IGlkIGluIHRoaXMuaW5kZXhlcykge1xuICAgICAgaW5kZXggPSB0aGlzLmluZGV4ZXNbaWRdXG4gICAgICBpZiAoaW5kZXggPj0gY2hpbGQpIHtcbiAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4IC0gMVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubWFya0RpcnR5KClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByZXBsYWNlVmFsdWVzKHBhdHRlcm4sIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRzXG4gICAgICBvcHRzID0ge31cbiAgICB9XG5cbiAgICB0aGlzLndhbGtEZWNscyhkZWNsID0+IHtcbiAgICAgIGlmIChvcHRzLnByb3BzICYmICFvcHRzLnByb3BzLmluY2x1ZGVzKGRlY2wucHJvcCkpIHJldHVyblxuICAgICAgaWYgKG9wdHMuZmFzdCAmJiAhZGVjbC52YWx1ZS5pbmNsdWRlcyhvcHRzLmZhc3QpKSByZXR1cm5cblxuICAgICAgZGVjbC52YWx1ZSA9IGRlY2wudmFsdWUucmVwbGFjZShwYXR0ZXJuLCBjYWxsYmFjaylcbiAgICB9KVxuXG4gICAgdGhpcy5tYXJrRGlydHkoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHNvbWUoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMuc29tZShjb25kaXRpb24pXG4gIH1cblxuICB3YWxrKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaCgoY2hpbGQsIGkpID0+IHtcbiAgICAgIGxldCByZXN1bHRcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKGNoaWxkLCBpKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBjaGlsZC5hZGRUb0Vycm9yKGUpXG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSAmJiBjaGlsZC53YWxrKSB7XG4gICAgICAgIHJlc3VsdCA9IGNoaWxkLndhbGsoY2FsbGJhY2spXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9KVxuICB9XG5cbiAgd2Fsa0F0UnVsZXMobmFtZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayA9IG5hbWVcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnYXRydWxlJykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnYXRydWxlJyAmJiBuYW1lLnRlc3QoY2hpbGQubmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpKSA9PiB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2F0cnVsZScgJiYgY2hpbGQubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHdhbGtDb21tZW50cyhjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpKSA9PiB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgd2Fsa0RlY2xzKHByb3AsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSBwcm9wXG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaSkgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2RlY2wnKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAocHJvcCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHRoaXMud2FsaygoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdkZWNsJyAmJiBwcm9wLnRlc3QoY2hpbGQucHJvcCkpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpKSA9PiB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2RlY2wnICYmIGNoaWxkLnByb3AgPT09IHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICB3YWxrUnVsZXMoc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSBzZWxlY3RvclxuXG4gICAgICByZXR1cm4gdGhpcy53YWxrKChjaGlsZCwgaSkgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ3J1bGUnKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAoc2VsZWN0b3IgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAncnVsZScgJiYgc2VsZWN0b3IudGVzdChjaGlsZC5zZWxlY3RvcikpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhbGsoKGNoaWxkLCBpKSA9PiB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ3J1bGUnICYmIGNoaWxkLnNlbGVjdG9yID09PSBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGdldCBmaXJzdCgpIHtcbiAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLnByb3h5T2Yubm9kZXNbMF1cbiAgfVxuXG4gIGdldCBsYXN0KCkge1xuICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMucHJveHlPZi5ub2Rlc1t0aGlzLnByb3h5T2Yubm9kZXMubGVuZ3RoIC0gMV1cbiAgfVxufVxuXG5Db250YWluZXIucmVnaXN0ZXJQYXJzZSA9IGRlcGVuZGFudCA9PiB7XG4gIHBhcnNlID0gZGVwZW5kYW50XG59XG5cbkNvbnRhaW5lci5yZWdpc3RlclJ1bGUgPSBkZXBlbmRhbnQgPT4ge1xuICBSdWxlID0gZGVwZW5kYW50XG59XG5cbkNvbnRhaW5lci5yZWdpc3RlckF0UnVsZSA9IGRlcGVuZGFudCA9PiB7XG4gIEF0UnVsZSA9IGRlcGVuZGFudFxufVxuXG5Db250YWluZXIucmVnaXN0ZXJSb290ID0gZGVwZW5kYW50ID0+IHtcbiAgUm9vdCA9IGRlcGVuZGFudFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5lclxuQ29udGFpbmVyLmRlZmF1bHQgPSBDb250YWluZXJcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5Db250YWluZXIucmVidWlsZCA9IG5vZGUgPT4ge1xuICBpZiAobm9kZS50eXBlID09PSAnYXRydWxlJykge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlLCBBdFJ1bGUucHJvdG90eXBlKVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ3J1bGUnKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUsIFJ1bGUucHJvdG90eXBlKVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ2RlY2wnKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUsIERlY2xhcmF0aW9uLnByb3RvdHlwZSlcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdjb21tZW50Jykge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlLCBDb21tZW50LnByb3RvdHlwZSlcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdyb290Jykge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlLCBSb290LnByb3RvdHlwZSlcbiAgfVxuXG4gIG5vZGVbbXldID0gdHJ1ZVxuXG4gIGlmIChub2RlLm5vZGVzKSB7XG4gICAgbm9kZS5ub2Rlcy5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIENvbnRhaW5lci5yZWJ1aWxkKGNoaWxkKVxuICAgIH0pXG4gIH1cbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/container.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/css-syntax-error.js":
/*!******************************************************!*\
  !*** ./node_modules/postcss/lib/css-syntax-error.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet pico = __webpack_require__(/*! picocolors */ \"./node_modules/picocolors/picocolors.browser.js\")\n\nlet terminalHighlight = __webpack_require__(/*! ./terminal-highlight */ \"?fe98\")\n\nclass CssSyntaxError extends Error {\n  constructor(message, line, column, source, file, plugin) {\n    super(message)\n    this.name = 'CssSyntaxError'\n    this.reason = message\n\n    if (file) {\n      this.file = file\n    }\n    if (source) {\n      this.source = source\n    }\n    if (plugin) {\n      this.plugin = plugin\n    }\n    if (typeof line !== 'undefined' && typeof column !== 'undefined') {\n      if (typeof line === 'number') {\n        this.line = line\n        this.column = column\n      } else {\n        this.line = line.line\n        this.column = line.column\n        this.endLine = column.line\n        this.endColumn = column.column\n      }\n    }\n\n    this.setMessage()\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, CssSyntaxError)\n    }\n  }\n\n  setMessage() {\n    this.message = this.plugin ? this.plugin + ': ' : ''\n    this.message += this.file ? this.file : '<css input>'\n    if (typeof this.line !== 'undefined') {\n      this.message += ':' + this.line + ':' + this.column\n    }\n    this.message += ': ' + this.reason\n  }\n\n  showSourceCode(color) {\n    if (!this.source) return ''\n\n    let css = this.source\n    if (color == null) color = pico.isColorSupported\n\n    let aside = text => text\n    let mark = text => text\n    let highlight = text => text\n    if (color) {\n      let { bold, gray, red } = pico.createColors(true)\n      mark = text => bold(red(text))\n      aside = text => gray(text)\n      if (terminalHighlight) {\n        highlight = text => terminalHighlight(text)\n      }\n    }\n\n    let lines = css.split(/\\r?\\n/)\n    let start = Math.max(this.line - 3, 0)\n    let end = Math.min(this.line + 2, lines.length)\n    let maxWidth = String(end).length\n\n    return lines\n      .slice(start, end)\n      .map((line, index) => {\n        let number = start + 1 + index\n        let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | '\n        if (number === this.line) {\n          if (line.length > 160) {\n            let padding = 20\n            let subLineStart = Math.max(0, this.column - padding)\n            let subLineEnd = Math.max(\n              this.column + padding,\n              this.endColumn + padding\n            )\n            let subLine = line.slice(subLineStart, subLineEnd)\n\n            let spacing =\n              aside(gutter.replace(/\\d/g, ' ')) +\n              line\n                .slice(0, Math.min(this.column - 1, padding - 1))\n                .replace(/[^\\t]/g, ' ')\n\n            return (\n              mark('>') +\n              aside(gutter) +\n              highlight(subLine) +\n              '\\n ' +\n              spacing +\n              mark('^')\n            )\n          }\n\n          let spacing =\n            aside(gutter.replace(/\\d/g, ' ')) +\n            line.slice(0, this.column - 1).replace(/[^\\t]/g, ' ')\n\n          return (\n            mark('>') +\n            aside(gutter) +\n            highlight(line) +\n            '\\n ' +\n            spacing +\n            mark('^')\n          )\n        }\n\n        return ' ' + aside(gutter) + highlight(line)\n      })\n      .join('\\n')\n  }\n\n  toString() {\n    let code = this.showSourceCode()\n    if (code) {\n      code = '\\n\\n' + code + '\\n'\n    }\n    return this.name + ': ' + this.message + code\n  }\n}\n\nmodule.exports = CssSyntaxError\nCssSyntaxError.default = CssSyntaxError\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvY3NzLXN5bnRheC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsbUVBQVk7O0FBRS9CLHdCQUF3QixtQkFBTyxDQUFDLG1DQUFzQjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vamltaXB1bHNhckBnaXRodWIuY29tLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL2Nzcy1zeW50YXgtZXJyb3IuanM/MTE3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IHBpY28gPSByZXF1aXJlKCdwaWNvY29sb3JzJylcblxubGV0IHRlcm1pbmFsSGlnaGxpZ2h0ID0gcmVxdWlyZSgnLi90ZXJtaW5hbC1oaWdobGlnaHQnKVxuXG5jbGFzcyBDc3NTeW50YXhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgbGluZSwgY29sdW1uLCBzb3VyY2UsIGZpbGUsIHBsdWdpbikge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0Nzc1N5bnRheEVycm9yJ1xuICAgIHRoaXMucmVhc29uID0gbWVzc2FnZVxuXG4gICAgaWYgKGZpbGUpIHtcbiAgICAgIHRoaXMuZmlsZSA9IGZpbGVcbiAgICB9XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2VcbiAgICB9XG4gICAgaWYgKHBsdWdpbikge1xuICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW5cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsaW5lICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29sdW1uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHR5cGVvZiBsaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lXG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lLmxpbmVcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBsaW5lLmNvbHVtblxuICAgICAgICB0aGlzLmVuZExpbmUgPSBjb2x1bW4ubGluZVxuICAgICAgICB0aGlzLmVuZENvbHVtbiA9IGNvbHVtbi5jb2x1bW5cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldE1lc3NhZ2UoKVxuXG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDc3NTeW50YXhFcnJvcilcbiAgICB9XG4gIH1cblxuICBzZXRNZXNzYWdlKCkge1xuICAgIHRoaXMubWVzc2FnZSA9IHRoaXMucGx1Z2luID8gdGhpcy5wbHVnaW4gKyAnOiAnIDogJydcbiAgICB0aGlzLm1lc3NhZ2UgKz0gdGhpcy5maWxlID8gdGhpcy5maWxlIDogJzxjc3MgaW5wdXQ+J1xuICAgIGlmICh0eXBlb2YgdGhpcy5saW5lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5tZXNzYWdlICs9ICc6JyArIHRoaXMubGluZSArICc6JyArIHRoaXMuY29sdW1uXG4gICAgfVxuICAgIHRoaXMubWVzc2FnZSArPSAnOiAnICsgdGhpcy5yZWFzb25cbiAgfVxuXG4gIHNob3dTb3VyY2VDb2RlKGNvbG9yKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZSkgcmV0dXJuICcnXG5cbiAgICBsZXQgY3NzID0gdGhpcy5zb3VyY2VcbiAgICBpZiAoY29sb3IgPT0gbnVsbCkgY29sb3IgPSBwaWNvLmlzQ29sb3JTdXBwb3J0ZWRcblxuICAgIGxldCBhc2lkZSA9IHRleHQgPT4gdGV4dFxuICAgIGxldCBtYXJrID0gdGV4dCA9PiB0ZXh0XG4gICAgbGV0IGhpZ2hsaWdodCA9IHRleHQgPT4gdGV4dFxuICAgIGlmIChjb2xvcikge1xuICAgICAgbGV0IHsgYm9sZCwgZ3JheSwgcmVkIH0gPSBwaWNvLmNyZWF0ZUNvbG9ycyh0cnVlKVxuICAgICAgbWFyayA9IHRleHQgPT4gYm9sZChyZWQodGV4dCkpXG4gICAgICBhc2lkZSA9IHRleHQgPT4gZ3JheSh0ZXh0KVxuICAgICAgaWYgKHRlcm1pbmFsSGlnaGxpZ2h0KSB7XG4gICAgICAgIGhpZ2hsaWdodCA9IHRleHQgPT4gdGVybWluYWxIaWdobGlnaHQodGV4dClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgbGluZXMgPSBjc3Muc3BsaXQoL1xccj9cXG4vKVxuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHRoaXMubGluZSAtIDMsIDApXG4gICAgbGV0IGVuZCA9IE1hdGgubWluKHRoaXMubGluZSArIDIsIGxpbmVzLmxlbmd0aClcbiAgICBsZXQgbWF4V2lkdGggPSBTdHJpbmcoZW5kKS5sZW5ndGhcblxuICAgIHJldHVybiBsaW5lc1xuICAgICAgLnNsaWNlKHN0YXJ0LCBlbmQpXG4gICAgICAubWFwKChsaW5lLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgbnVtYmVyID0gc3RhcnQgKyAxICsgaW5kZXhcbiAgICAgICAgbGV0IGd1dHRlciA9ICcgJyArICgnICcgKyBudW1iZXIpLnNsaWNlKC1tYXhXaWR0aCkgKyAnIHwgJ1xuICAgICAgICBpZiAobnVtYmVyID09PSB0aGlzLmxpbmUpIHtcbiAgICAgICAgICBpZiAobGluZS5sZW5ndGggPiAxNjApIHtcbiAgICAgICAgICAgIGxldCBwYWRkaW5nID0gMjBcbiAgICAgICAgICAgIGxldCBzdWJMaW5lU3RhcnQgPSBNYXRoLm1heCgwLCB0aGlzLmNvbHVtbiAtIHBhZGRpbmcpXG4gICAgICAgICAgICBsZXQgc3ViTGluZUVuZCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICB0aGlzLmNvbHVtbiArIHBhZGRpbmcsXG4gICAgICAgICAgICAgIHRoaXMuZW5kQ29sdW1uICsgcGFkZGluZ1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgbGV0IHN1YkxpbmUgPSBsaW5lLnNsaWNlKHN1YkxpbmVTdGFydCwgc3ViTGluZUVuZClcblxuICAgICAgICAgICAgbGV0IHNwYWNpbmcgPVxuICAgICAgICAgICAgICBhc2lkZShndXR0ZXIucmVwbGFjZSgvXFxkL2csICcgJykpICtcbiAgICAgICAgICAgICAgbGluZVxuICAgICAgICAgICAgICAgIC5zbGljZSgwLCBNYXRoLm1pbih0aGlzLmNvbHVtbiAtIDEsIHBhZGRpbmcgLSAxKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvW15cXHRdL2csICcgJylcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgbWFyaygnPicpICtcbiAgICAgICAgICAgICAgYXNpZGUoZ3V0dGVyKSArXG4gICAgICAgICAgICAgIGhpZ2hsaWdodChzdWJMaW5lKSArXG4gICAgICAgICAgICAgICdcXG4gJyArXG4gICAgICAgICAgICAgIHNwYWNpbmcgK1xuICAgICAgICAgICAgICBtYXJrKCdeJylcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgc3BhY2luZyA9XG4gICAgICAgICAgICBhc2lkZShndXR0ZXIucmVwbGFjZSgvXFxkL2csICcgJykpICtcbiAgICAgICAgICAgIGxpbmUuc2xpY2UoMCwgdGhpcy5jb2x1bW4gLSAxKS5yZXBsYWNlKC9bXlxcdF0vZywgJyAnKVxuXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG1hcmsoJz4nKSArXG4gICAgICAgICAgICBhc2lkZShndXR0ZXIpICtcbiAgICAgICAgICAgIGhpZ2hsaWdodChsaW5lKSArXG4gICAgICAgICAgICAnXFxuICcgK1xuICAgICAgICAgICAgc3BhY2luZyArXG4gICAgICAgICAgICBtYXJrKCdeJylcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyAnICsgYXNpZGUoZ3V0dGVyKSArIGhpZ2hsaWdodChsaW5lKVxuICAgICAgfSlcbiAgICAgIC5qb2luKCdcXG4nKVxuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IGNvZGUgPSB0aGlzLnNob3dTb3VyY2VDb2RlKClcbiAgICBpZiAoY29kZSkge1xuICAgICAgY29kZSA9ICdcXG5cXG4nICsgY29kZSArICdcXG4nXG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5hbWUgKyAnOiAnICsgdGhpcy5tZXNzYWdlICsgY29kZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ3NzU3ludGF4RXJyb3JcbkNzc1N5bnRheEVycm9yLmRlZmF1bHQgPSBDc3NTeW50YXhFcnJvclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/css-syntax-error.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/declaration.js":
/*!*************************************************!*\
  !*** ./node_modules/postcss/lib/declaration.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Node = __webpack_require__(/*! ./node */ \"./node_modules/postcss/lib/node.js\")\n\nclass Declaration extends Node {\n  constructor(defaults) {\n    if (\n      defaults &&\n      typeof defaults.value !== 'undefined' &&\n      typeof defaults.value !== 'string'\n    ) {\n      defaults = { ...defaults, value: String(defaults.value) }\n    }\n    super(defaults)\n    this.type = 'decl'\n  }\n\n  get variable() {\n    return this.prop.startsWith('--') || this.prop[0] === '$'\n  }\n}\n\nmodule.exports = Declaration\nDeclaration.default = Declaration\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvZGVjbGFyYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosV0FBVyxtQkFBTyxDQUFDLGtEQUFROztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vamltaXB1bHNhckBnaXRodWIuY29tLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL2RlY2xhcmF0aW9uLmpzP2UxMjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmxldCBOb2RlID0gcmVxdWlyZSgnLi9ub2RlJylcblxuY2xhc3MgRGVjbGFyYXRpb24gZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBpZiAoXG4gICAgICBkZWZhdWx0cyAmJlxuICAgICAgdHlwZW9mIGRlZmF1bHRzLnZhbHVlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIGRlZmF1bHRzLnZhbHVlICE9PSAnc3RyaW5nJ1xuICAgICkge1xuICAgICAgZGVmYXVsdHMgPSB7IC4uLmRlZmF1bHRzLCB2YWx1ZTogU3RyaW5nKGRlZmF1bHRzLnZhbHVlKSB9XG4gICAgfVxuICAgIHN1cGVyKGRlZmF1bHRzKVxuICAgIHRoaXMudHlwZSA9ICdkZWNsJ1xuICB9XG5cbiAgZ2V0IHZhcmlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnByb3Auc3RhcnRzV2l0aCgnLS0nKSB8fCB0aGlzLnByb3BbMF0gPT09ICckJ1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGVjbGFyYXRpb25cbkRlY2xhcmF0aW9uLmRlZmF1bHQgPSBEZWNsYXJhdGlvblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/declaration.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/document.js":
/*!**********************************************!*\
  !*** ./node_modules/postcss/lib/document.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\n\nlet LazyResult, Processor\n\nclass Document extends Container {\n  constructor(defaults) {\n    // type needs to be passed to super, otherwise child roots won't be normalized correctly\n    super({ type: 'document', ...defaults })\n\n    if (!this.nodes) {\n      this.nodes = []\n    }\n  }\n\n  toResult(opts = {}) {\n    let lazy = new LazyResult(new Processor(), this, opts)\n\n    return lazy.stringify()\n  }\n}\n\nDocument.registerLazyResult = dependant => {\n  LazyResult = dependant\n}\n\nDocument.registerProcessor = dependant => {\n  Processor = dependant\n}\n\nmodule.exports = Document\nDocument.default = Document\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvZG9jdW1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZ0JBQWdCLG1CQUFPLENBQUMsNERBQWE7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0JBQStCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ppbWlwdWxzYXJAZ2l0aHViLmNvbS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9kb2N1bWVudC5qcz9iYzUxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5sZXQgQ29udGFpbmVyID0gcmVxdWlyZSgnLi9jb250YWluZXInKVxuXG5sZXQgTGF6eVJlc3VsdCwgUHJvY2Vzc29yXG5cbmNsYXNzIERvY3VtZW50IGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICAvLyB0eXBlIG5lZWRzIHRvIGJlIHBhc3NlZCB0byBzdXBlciwgb3RoZXJ3aXNlIGNoaWxkIHJvb3RzIHdvbid0IGJlIG5vcm1hbGl6ZWQgY29ycmVjdGx5XG4gICAgc3VwZXIoeyB0eXBlOiAnZG9jdW1lbnQnLCAuLi5kZWZhdWx0cyB9KVxuXG4gICAgaWYgKCF0aGlzLm5vZGVzKSB7XG4gICAgICB0aGlzLm5vZGVzID0gW11cbiAgICB9XG4gIH1cblxuICB0b1Jlc3VsdChvcHRzID0ge30pIHtcbiAgICBsZXQgbGF6eSA9IG5ldyBMYXp5UmVzdWx0KG5ldyBQcm9jZXNzb3IoKSwgdGhpcywgb3B0cylcblxuICAgIHJldHVybiBsYXp5LnN0cmluZ2lmeSgpXG4gIH1cbn1cblxuRG9jdW1lbnQucmVnaXN0ZXJMYXp5UmVzdWx0ID0gZGVwZW5kYW50ID0+IHtcbiAgTGF6eVJlc3VsdCA9IGRlcGVuZGFudFxufVxuXG5Eb2N1bWVudC5yZWdpc3RlclByb2Nlc3NvciA9IGRlcGVuZGFudCA9PiB7XG4gIFByb2Nlc3NvciA9IGRlcGVuZGFudFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERvY3VtZW50XG5Eb2N1bWVudC5kZWZhdWx0ID0gRG9jdW1lbnRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/document.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/fromJSON.js":
/*!**********************************************!*\
  !*** ./node_modules/postcss/lib/fromJSON.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet AtRule = __webpack_require__(/*! ./at-rule */ \"./node_modules/postcss/lib/at-rule.js\")\nlet Comment = __webpack_require__(/*! ./comment */ \"./node_modules/postcss/lib/comment.js\")\nlet Declaration = __webpack_require__(/*! ./declaration */ \"./node_modules/postcss/lib/declaration.js\")\nlet Input = __webpack_require__(/*! ./input */ \"./node_modules/postcss/lib/input.js\")\nlet PreviousMap = __webpack_require__(/*! ./previous-map */ \"./node_modules/postcss/lib/previous-map.js\")\nlet Root = __webpack_require__(/*! ./root */ \"./node_modules/postcss/lib/root.js\")\nlet Rule = __webpack_require__(/*! ./rule */ \"./node_modules/postcss/lib/rule.js\")\n\nfunction fromJSON(json, inputs) {\n  if (Array.isArray(json)) return json.map(n => fromJSON(n))\n\n  let { inputs: ownInputs, ...defaults } = json\n  if (ownInputs) {\n    inputs = []\n    for (let input of ownInputs) {\n      let inputHydrated = { ...input, __proto__: Input.prototype }\n      if (inputHydrated.map) {\n        inputHydrated.map = {\n          ...inputHydrated.map,\n          __proto__: PreviousMap.prototype\n        }\n      }\n      inputs.push(inputHydrated)\n    }\n  }\n  if (defaults.nodes) {\n    defaults.nodes = json.nodes.map(n => fromJSON(n, inputs))\n  }\n  if (defaults.source) {\n    let { inputId, ...source } = defaults.source\n    defaults.source = source\n    if (inputId != null) {\n      defaults.source.input = inputs[inputId]\n    }\n  }\n  if (defaults.type === 'root') {\n    return new Root(defaults)\n  } else if (defaults.type === 'decl') {\n    return new Declaration(defaults)\n  } else if (defaults.type === 'rule') {\n    return new Rule(defaults)\n  } else if (defaults.type === 'comment') {\n    return new Comment(defaults)\n  } else if (defaults.type === 'atrule') {\n    return new AtRule(defaults)\n  } else {\n    throw new Error('Unknown node type: ' + json.type)\n  }\n}\n\nmodule.exports = fromJSON\nfromJSON.default = fromJSON\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvZnJvbUpTT04uanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLHdEQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyx3REFBVztBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyxnRUFBZTtBQUN6QyxZQUFZLG1CQUFPLENBQUMsb0RBQVM7QUFDN0Isa0JBQWtCLG1CQUFPLENBQUMsa0VBQWdCO0FBQzFDLFdBQVcsbUJBQU8sQ0FBQyxrREFBUTtBQUMzQixXQUFXLG1CQUFPLENBQUMsa0RBQVE7O0FBRTNCO0FBQ0E7O0FBRUEsUUFBUSxpQ0FBaUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQkFBcUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qaW1pcHVsc2FyQGdpdGh1Yi5jb20vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvZnJvbUpTT04uanM/YTM3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IEF0UnVsZSA9IHJlcXVpcmUoJy4vYXQtcnVsZScpXG5sZXQgQ29tbWVudCA9IHJlcXVpcmUoJy4vY29tbWVudCcpXG5sZXQgRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL2RlY2xhcmF0aW9uJylcbmxldCBJbnB1dCA9IHJlcXVpcmUoJy4vaW5wdXQnKVxubGV0IFByZXZpb3VzTWFwID0gcmVxdWlyZSgnLi9wcmV2aW91cy1tYXAnKVxubGV0IFJvb3QgPSByZXF1aXJlKCcuL3Jvb3QnKVxubGV0IFJ1bGUgPSByZXF1aXJlKCcuL3J1bGUnKVxuXG5mdW5jdGlvbiBmcm9tSlNPTihqc29uLCBpbnB1dHMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHJldHVybiBqc29uLm1hcChuID0+IGZyb21KU09OKG4pKVxuXG4gIGxldCB7IGlucHV0czogb3duSW5wdXRzLCAuLi5kZWZhdWx0cyB9ID0ganNvblxuICBpZiAob3duSW5wdXRzKSB7XG4gICAgaW5wdXRzID0gW11cbiAgICBmb3IgKGxldCBpbnB1dCBvZiBvd25JbnB1dHMpIHtcbiAgICAgIGxldCBpbnB1dEh5ZHJhdGVkID0geyAuLi5pbnB1dCwgX19wcm90b19fOiBJbnB1dC5wcm90b3R5cGUgfVxuICAgICAgaWYgKGlucHV0SHlkcmF0ZWQubWFwKSB7XG4gICAgICAgIGlucHV0SHlkcmF0ZWQubWFwID0ge1xuICAgICAgICAgIC4uLmlucHV0SHlkcmF0ZWQubWFwLFxuICAgICAgICAgIF9fcHJvdG9fXzogUHJldmlvdXNNYXAucHJvdG90eXBlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlucHV0cy5wdXNoKGlucHV0SHlkcmF0ZWQpXG4gICAgfVxuICB9XG4gIGlmIChkZWZhdWx0cy5ub2Rlcykge1xuICAgIGRlZmF1bHRzLm5vZGVzID0ganNvbi5ub2Rlcy5tYXAobiA9PiBmcm9tSlNPTihuLCBpbnB1dHMpKVxuICB9XG4gIGlmIChkZWZhdWx0cy5zb3VyY2UpIHtcbiAgICBsZXQgeyBpbnB1dElkLCAuLi5zb3VyY2UgfSA9IGRlZmF1bHRzLnNvdXJjZVxuICAgIGRlZmF1bHRzLnNvdXJjZSA9IHNvdXJjZVxuICAgIGlmIChpbnB1dElkICE9IG51bGwpIHtcbiAgICAgIGRlZmF1bHRzLnNvdXJjZS5pbnB1dCA9IGlucHV0c1tpbnB1dElkXVxuICAgIH1cbiAgfVxuICBpZiAoZGVmYXVsdHMudHlwZSA9PT0gJ3Jvb3QnKSB7XG4gICAgcmV0dXJuIG5ldyBSb290KGRlZmF1bHRzKVxuICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09ICdkZWNsJykge1xuICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24oZGVmYXVsdHMpXG4gIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gJ3J1bGUnKSB7XG4gICAgcmV0dXJuIG5ldyBSdWxlKGRlZmF1bHRzKVxuICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09ICdjb21tZW50Jykge1xuICAgIHJldHVybiBuZXcgQ29tbWVudChkZWZhdWx0cylcbiAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSAnYXRydWxlJykge1xuICAgIHJldHVybiBuZXcgQXRSdWxlKGRlZmF1bHRzKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBub2RlIHR5cGU6ICcgKyBqc29uLnR5cGUpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmcm9tSlNPTlxuZnJvbUpTT04uZGVmYXVsdCA9IGZyb21KU09OXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/fromJSON.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/input.js":
/*!*******************************************!*\
  !*** ./node_modules/postcss/lib/input.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet { nanoid } = __webpack_require__(/*! nanoid/non-secure */ \"./node_modules/nanoid/non-secure/index.cjs\")\nlet { isAbsolute, resolve } = __webpack_require__(/*! path */ \"?25fb\")\nlet { SourceMapConsumer, SourceMapGenerator } = __webpack_require__(/*! source-map-js */ \"?6f78\")\nlet { fileURLToPath, pathToFileURL } = __webpack_require__(/*! url */ \"?9214\")\n\nlet CssSyntaxError = __webpack_require__(/*! ./css-syntax-error */ \"./node_modules/postcss/lib/css-syntax-error.js\")\nlet PreviousMap = __webpack_require__(/*! ./previous-map */ \"./node_modules/postcss/lib/previous-map.js\")\nlet terminalHighlight = __webpack_require__(/*! ./terminal-highlight */ \"?fe98\")\n\nlet fromOffsetCache = Symbol('fromOffsetCache')\n\nlet sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)\nlet pathAvailable = Boolean(resolve && isAbsolute)\n\nclass Input {\n  constructor(css, opts = {}) {\n    if (\n      css === null ||\n      typeof css === 'undefined' ||\n      (typeof css === 'object' && !css.toString)\n    ) {\n      throw new Error(`PostCSS received ${css} instead of CSS string`)\n    }\n\n    this.css = css.toString()\n\n    if (this.css[0] === '\\uFEFF' || this.css[0] === '\\uFFFE') {\n      this.hasBOM = true\n      this.css = this.css.slice(1)\n    } else {\n      this.hasBOM = false\n    }\n\n    if (opts.from) {\n      if (\n        !pathAvailable ||\n        /^\\w+:\\/\\//.test(opts.from) ||\n        isAbsolute(opts.from)\n      ) {\n        this.file = opts.from\n      } else {\n        this.file = resolve(opts.from)\n      }\n    }\n\n    if (pathAvailable && sourceMapAvailable) {\n      let map = new PreviousMap(this.css, opts)\n      if (map.text) {\n        this.map = map\n        let file = map.consumer().file\n        if (!this.file && file) this.file = this.mapResolve(file)\n      }\n    }\n\n    if (!this.file) {\n      this.id = '<input css ' + nanoid(6) + '>'\n    }\n    if (this.map) this.map.file = this.from\n  }\n\n  error(message, line, column, opts = {}) {\n    let endColumn, endLine, result\n\n    if (line && typeof line === 'object') {\n      let start = line\n      let end = column\n      if (typeof start.offset === 'number') {\n        let pos = this.fromOffset(start.offset)\n        line = pos.line\n        column = pos.col\n      } else {\n        line = start.line\n        column = start.column\n      }\n      if (typeof end.offset === 'number') {\n        let pos = this.fromOffset(end.offset)\n        endLine = pos.line\n        endColumn = pos.col\n      } else {\n        endLine = end.line\n        endColumn = end.column\n      }\n    } else if (!column) {\n      let pos = this.fromOffset(line)\n      line = pos.line\n      column = pos.col\n    }\n\n    let origin = this.origin(line, column, endLine, endColumn)\n    if (origin) {\n      result = new CssSyntaxError(\n        message,\n        origin.endLine === undefined\n          ? origin.line\n          : { column: origin.column, line: origin.line },\n        origin.endLine === undefined\n          ? origin.column\n          : { column: origin.endColumn, line: origin.endLine },\n        origin.source,\n        origin.file,\n        opts.plugin\n      )\n    } else {\n      result = new CssSyntaxError(\n        message,\n        endLine === undefined ? line : { column, line },\n        endLine === undefined ? column : { column: endColumn, line: endLine },\n        this.css,\n        this.file,\n        opts.plugin\n      )\n    }\n\n    result.input = { column, endColumn, endLine, line, source: this.css }\n    if (this.file) {\n      if (pathToFileURL) {\n        result.input.url = pathToFileURL(this.file).toString()\n      }\n      result.input.file = this.file\n    }\n\n    return result\n  }\n\n  fromOffset(offset) {\n    let lastLine, lineToIndex\n    if (!this[fromOffsetCache]) {\n      let lines = this.css.split('\\n')\n      lineToIndex = new Array(lines.length)\n      let prevIndex = 0\n\n      for (let i = 0, l = lines.length; i < l; i++) {\n        lineToIndex[i] = prevIndex\n        prevIndex += lines[i].length + 1\n      }\n\n      this[fromOffsetCache] = lineToIndex\n    } else {\n      lineToIndex = this[fromOffsetCache]\n    }\n    lastLine = lineToIndex[lineToIndex.length - 1]\n\n    let min = 0\n    if (offset >= lastLine) {\n      min = lineToIndex.length - 1\n    } else {\n      let max = lineToIndex.length - 2\n      let mid\n      while (min < max) {\n        mid = min + ((max - min) >> 1)\n        if (offset < lineToIndex[mid]) {\n          max = mid - 1\n        } else if (offset >= lineToIndex[mid + 1]) {\n          min = mid + 1\n        } else {\n          min = mid\n          break\n        }\n      }\n    }\n    return {\n      col: offset - lineToIndex[min] + 1,\n      line: min + 1\n    }\n  }\n\n  mapResolve(file) {\n    if (/^\\w+:\\/\\//.test(file)) {\n      return file\n    }\n    return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file)\n  }\n\n  origin(line, column, endLine, endColumn) {\n    if (!this.map) return false\n    let consumer = this.map.consumer()\n\n    let from = consumer.originalPositionFor({ column, line })\n    if (!from.source) return false\n\n    let to\n    if (typeof endLine === 'number') {\n      to = consumer.originalPositionFor({ column: endColumn, line: endLine })\n    }\n\n    let fromUrl\n\n    if (isAbsolute(from.source)) {\n      fromUrl = pathToFileURL(from.source)\n    } else {\n      fromUrl = new URL(\n        from.source,\n        this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)\n      )\n    }\n\n    let result = {\n      column: from.column,\n      endColumn: to && to.column,\n      endLine: to && to.line,\n      line: from.line,\n      url: fromUrl.toString()\n    }\n\n    if (fromUrl.protocol === 'file:') {\n      if (fileURLToPath) {\n        result.file = fileURLToPath(fromUrl)\n      } else {\n        /* c8 ignore next 2 */\n        throw new Error(`file: protocol is not available in this PostCSS build`)\n      }\n    }\n\n    let source = consumer.sourceContentFor(from.source)\n    if (source) result.source = source\n\n    return result\n  }\n\n  toJSON() {\n    let json = {}\n    for (let name of ['hasBOM', 'css', 'file', 'id']) {\n      if (this[name] != null) {\n        json[name] = this[name]\n      }\n    }\n    if (this.map) {\n      json.map = { ...this.map }\n      if (json.map.consumerCache) {\n        json.map.consumerCache = undefined\n      }\n    }\n    return json\n  }\n\n  get from() {\n    return this.file || this.id\n  }\n}\n\nmodule.exports = Input\nInput.default = Input\n\nif (terminalHighlight && terminalHighlight.registerInput) {\n  terminalHighlight.registerInput(Input)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvaW5wdXQuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosTUFBTSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxxRUFBbUI7QUFDNUMsTUFBTSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLG1CQUFNO0FBQzVDLE1BQU0sd0NBQXdDLEVBQUUsbUJBQU8sQ0FBQyw0QkFBZTtBQUN2RSxNQUFNLCtCQUErQixFQUFFLG1CQUFPLENBQUMsa0JBQUs7O0FBRXBELHFCQUFxQixtQkFBTyxDQUFDLDBFQUFvQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxrRUFBZ0I7QUFDMUMsd0JBQXdCLG1CQUFPLENBQUMsbUNBQXNCOztBQUV0RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQ0FBMEM7QUFDeEQ7QUFDQTtBQUNBLGNBQWMsZ0RBQWdEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RCwyQ0FBMkMsa0NBQWtDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLGtDQUFrQztBQUM1RTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ppbWlwdWxzYXJAZ2l0aHViLmNvbS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9pbnB1dC5qcz8xODdkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5sZXQgeyBuYW5vaWQgfSA9IHJlcXVpcmUoJ25hbm9pZC9ub24tc2VjdXJlJylcbmxldCB7IGlzQWJzb2x1dGUsIHJlc29sdmUgfSA9IHJlcXVpcmUoJ3BhdGgnKVxubGV0IHsgU291cmNlTWFwQ29uc3VtZXIsIFNvdXJjZU1hcEdlbmVyYXRvciB9ID0gcmVxdWlyZSgnc291cmNlLW1hcC1qcycpXG5sZXQgeyBmaWxlVVJMVG9QYXRoLCBwYXRoVG9GaWxlVVJMIH0gPSByZXF1aXJlKCd1cmwnKVxuXG5sZXQgQ3NzU3ludGF4RXJyb3IgPSByZXF1aXJlKCcuL2Nzcy1zeW50YXgtZXJyb3InKVxubGV0IFByZXZpb3VzTWFwID0gcmVxdWlyZSgnLi9wcmV2aW91cy1tYXAnKVxubGV0IHRlcm1pbmFsSGlnaGxpZ2h0ID0gcmVxdWlyZSgnLi90ZXJtaW5hbC1oaWdobGlnaHQnKVxuXG5sZXQgZnJvbU9mZnNldENhY2hlID0gU3ltYm9sKCdmcm9tT2Zmc2V0Q2FjaGUnKVxuXG5sZXQgc291cmNlTWFwQXZhaWxhYmxlID0gQm9vbGVhbihTb3VyY2VNYXBDb25zdW1lciAmJiBTb3VyY2VNYXBHZW5lcmF0b3IpXG5sZXQgcGF0aEF2YWlsYWJsZSA9IEJvb2xlYW4ocmVzb2x2ZSAmJiBpc0Fic29sdXRlKVxuXG5jbGFzcyBJbnB1dCB7XG4gIGNvbnN0cnVjdG9yKGNzcywgb3B0cyA9IHt9KSB7XG4gICAgaWYgKFxuICAgICAgY3NzID09PSBudWxsIHx8XG4gICAgICB0eXBlb2YgY3NzID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgKHR5cGVvZiBjc3MgPT09ICdvYmplY3QnICYmICFjc3MudG9TdHJpbmcpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc3RDU1MgcmVjZWl2ZWQgJHtjc3N9IGluc3RlYWQgb2YgQ1NTIHN0cmluZ2ApXG4gICAgfVxuXG4gICAgdGhpcy5jc3MgPSBjc3MudG9TdHJpbmcoKVxuXG4gICAgaWYgKHRoaXMuY3NzWzBdID09PSAnXFx1RkVGRicgfHwgdGhpcy5jc3NbMF0gPT09ICdcXHVGRkZFJykge1xuICAgICAgdGhpcy5oYXNCT00gPSB0cnVlXG4gICAgICB0aGlzLmNzcyA9IHRoaXMuY3NzLnNsaWNlKDEpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFzQk9NID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAob3B0cy5mcm9tKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFwYXRoQXZhaWxhYmxlIHx8XG4gICAgICAgIC9eXFx3KzpcXC9cXC8vLnRlc3Qob3B0cy5mcm9tKSB8fFxuICAgICAgICBpc0Fic29sdXRlKG9wdHMuZnJvbSlcbiAgICAgICkge1xuICAgICAgICB0aGlzLmZpbGUgPSBvcHRzLmZyb21cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmlsZSA9IHJlc29sdmUob3B0cy5mcm9tKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXRoQXZhaWxhYmxlICYmIHNvdXJjZU1hcEF2YWlsYWJsZSkge1xuICAgICAgbGV0IG1hcCA9IG5ldyBQcmV2aW91c01hcCh0aGlzLmNzcywgb3B0cylcbiAgICAgIGlmIChtYXAudGV4dCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcFxuICAgICAgICBsZXQgZmlsZSA9IG1hcC5jb25zdW1lcigpLmZpbGVcbiAgICAgICAgaWYgKCF0aGlzLmZpbGUgJiYgZmlsZSkgdGhpcy5maWxlID0gdGhpcy5tYXBSZXNvbHZlKGZpbGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmZpbGUpIHtcbiAgICAgIHRoaXMuaWQgPSAnPGlucHV0IGNzcyAnICsgbmFub2lkKDYpICsgJz4nXG4gICAgfVxuICAgIGlmICh0aGlzLm1hcCkgdGhpcy5tYXAuZmlsZSA9IHRoaXMuZnJvbVxuICB9XG5cbiAgZXJyb3IobWVzc2FnZSwgbGluZSwgY29sdW1uLCBvcHRzID0ge30pIHtcbiAgICBsZXQgZW5kQ29sdW1uLCBlbmRMaW5lLCByZXN1bHRcblxuICAgIGlmIChsaW5lICYmIHR5cGVvZiBsaW5lID09PSAnb2JqZWN0Jykge1xuICAgICAgbGV0IHN0YXJ0ID0gbGluZVxuICAgICAgbGV0IGVuZCA9IGNvbHVtblxuICAgICAgaWYgKHR5cGVvZiBzdGFydC5vZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmZyb21PZmZzZXQoc3RhcnQub2Zmc2V0KVxuICAgICAgICBsaW5lID0gcG9zLmxpbmVcbiAgICAgICAgY29sdW1uID0gcG9zLmNvbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZSA9IHN0YXJ0LmxpbmVcbiAgICAgICAgY29sdW1uID0gc3RhcnQuY29sdW1uXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVuZC5vZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmZyb21PZmZzZXQoZW5kLm9mZnNldClcbiAgICAgICAgZW5kTGluZSA9IHBvcy5saW5lXG4gICAgICAgIGVuZENvbHVtbiA9IHBvcy5jb2xcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZExpbmUgPSBlbmQubGluZVxuICAgICAgICBlbmRDb2x1bW4gPSBlbmQuY29sdW1uXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghY29sdW1uKSB7XG4gICAgICBsZXQgcG9zID0gdGhpcy5mcm9tT2Zmc2V0KGxpbmUpXG4gICAgICBsaW5lID0gcG9zLmxpbmVcbiAgICAgIGNvbHVtbiA9IHBvcy5jb2xcbiAgICB9XG5cbiAgICBsZXQgb3JpZ2luID0gdGhpcy5vcmlnaW4obGluZSwgY29sdW1uLCBlbmRMaW5lLCBlbmRDb2x1bW4pXG4gICAgaWYgKG9yaWdpbikge1xuICAgICAgcmVzdWx0ID0gbmV3IENzc1N5bnRheEVycm9yKFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBvcmlnaW4uZW5kTGluZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBvcmlnaW4ubGluZVxuICAgICAgICAgIDogeyBjb2x1bW46IG9yaWdpbi5jb2x1bW4sIGxpbmU6IG9yaWdpbi5saW5lIH0sXG4gICAgICAgIG9yaWdpbi5lbmRMaW5lID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IG9yaWdpbi5jb2x1bW5cbiAgICAgICAgICA6IHsgY29sdW1uOiBvcmlnaW4uZW5kQ29sdW1uLCBsaW5lOiBvcmlnaW4uZW5kTGluZSB9LFxuICAgICAgICBvcmlnaW4uc291cmNlLFxuICAgICAgICBvcmlnaW4uZmlsZSxcbiAgICAgICAgb3B0cy5wbHVnaW5cbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gbmV3IENzc1N5bnRheEVycm9yKFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBlbmRMaW5lID09PSB1bmRlZmluZWQgPyBsaW5lIDogeyBjb2x1bW4sIGxpbmUgfSxcbiAgICAgICAgZW5kTGluZSA9PT0gdW5kZWZpbmVkID8gY29sdW1uIDogeyBjb2x1bW46IGVuZENvbHVtbiwgbGluZTogZW5kTGluZSB9LFxuICAgICAgICB0aGlzLmNzcyxcbiAgICAgICAgdGhpcy5maWxlLFxuICAgICAgICBvcHRzLnBsdWdpblxuICAgICAgKVxuICAgIH1cblxuICAgIHJlc3VsdC5pbnB1dCA9IHsgY29sdW1uLCBlbmRDb2x1bW4sIGVuZExpbmUsIGxpbmUsIHNvdXJjZTogdGhpcy5jc3MgfVxuICAgIGlmICh0aGlzLmZpbGUpIHtcbiAgICAgIGlmIChwYXRoVG9GaWxlVVJMKSB7XG4gICAgICAgIHJlc3VsdC5pbnB1dC51cmwgPSBwYXRoVG9GaWxlVVJMKHRoaXMuZmlsZSkudG9TdHJpbmcoKVxuICAgICAgfVxuICAgICAgcmVzdWx0LmlucHV0LmZpbGUgPSB0aGlzLmZpbGVcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmcm9tT2Zmc2V0KG9mZnNldCkge1xuICAgIGxldCBsYXN0TGluZSwgbGluZVRvSW5kZXhcbiAgICBpZiAoIXRoaXNbZnJvbU9mZnNldENhY2hlXSkge1xuICAgICAgbGV0IGxpbmVzID0gdGhpcy5jc3Muc3BsaXQoJ1xcbicpXG4gICAgICBsaW5lVG9JbmRleCA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpXG4gICAgICBsZXQgcHJldkluZGV4ID0gMFxuXG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBsaW5lVG9JbmRleFtpXSA9IHByZXZJbmRleFxuICAgICAgICBwcmV2SW5kZXggKz0gbGluZXNbaV0ubGVuZ3RoICsgMVxuICAgICAgfVxuXG4gICAgICB0aGlzW2Zyb21PZmZzZXRDYWNoZV0gPSBsaW5lVG9JbmRleFxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lVG9JbmRleCA9IHRoaXNbZnJvbU9mZnNldENhY2hlXVxuICAgIH1cbiAgICBsYXN0TGluZSA9IGxpbmVUb0luZGV4W2xpbmVUb0luZGV4Lmxlbmd0aCAtIDFdXG5cbiAgICBsZXQgbWluID0gMFxuICAgIGlmIChvZmZzZXQgPj0gbGFzdExpbmUpIHtcbiAgICAgIG1pbiA9IGxpbmVUb0luZGV4Lmxlbmd0aCAtIDFcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1heCA9IGxpbmVUb0luZGV4Lmxlbmd0aCAtIDJcbiAgICAgIGxldCBtaWRcbiAgICAgIHdoaWxlIChtaW4gPCBtYXgpIHtcbiAgICAgICAgbWlkID0gbWluICsgKChtYXggLSBtaW4pID4+IDEpXG4gICAgICAgIGlmIChvZmZzZXQgPCBsaW5lVG9JbmRleFttaWRdKSB7XG4gICAgICAgICAgbWF4ID0gbWlkIC0gMVxuICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCA+PSBsaW5lVG9JbmRleFttaWQgKyAxXSkge1xuICAgICAgICAgIG1pbiA9IG1pZCArIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtaW4gPSBtaWRcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjb2w6IG9mZnNldCAtIGxpbmVUb0luZGV4W21pbl0gKyAxLFxuICAgICAgbGluZTogbWluICsgMVxuICAgIH1cbiAgfVxuXG4gIG1hcFJlc29sdmUoZmlsZSkge1xuICAgIGlmICgvXlxcdys6XFwvXFwvLy50ZXN0KGZpbGUpKSB7XG4gICAgICByZXR1cm4gZmlsZVxuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZSh0aGlzLm1hcC5jb25zdW1lcigpLnNvdXJjZVJvb3QgfHwgdGhpcy5tYXAucm9vdCB8fCAnLicsIGZpbGUpXG4gIH1cblxuICBvcmlnaW4obGluZSwgY29sdW1uLCBlbmRMaW5lLCBlbmRDb2x1bW4pIHtcbiAgICBpZiAoIXRoaXMubWFwKSByZXR1cm4gZmFsc2VcbiAgICBsZXQgY29uc3VtZXIgPSB0aGlzLm1hcC5jb25zdW1lcigpXG5cbiAgICBsZXQgZnJvbSA9IGNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3IoeyBjb2x1bW4sIGxpbmUgfSlcbiAgICBpZiAoIWZyb20uc291cmNlKSByZXR1cm4gZmFsc2VcblxuICAgIGxldCB0b1xuICAgIGlmICh0eXBlb2YgZW5kTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRvID0gY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7IGNvbHVtbjogZW5kQ29sdW1uLCBsaW5lOiBlbmRMaW5lIH0pXG4gICAgfVxuXG4gICAgbGV0IGZyb21VcmxcblxuICAgIGlmIChpc0Fic29sdXRlKGZyb20uc291cmNlKSkge1xuICAgICAgZnJvbVVybCA9IHBhdGhUb0ZpbGVVUkwoZnJvbS5zb3VyY2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb21VcmwgPSBuZXcgVVJMKFxuICAgICAgICBmcm9tLnNvdXJjZSxcbiAgICAgICAgdGhpcy5tYXAuY29uc3VtZXIoKS5zb3VyY2VSb290IHx8IHBhdGhUb0ZpbGVVUkwodGhpcy5tYXAubWFwRmlsZSlcbiAgICAgIClcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgY29sdW1uOiBmcm9tLmNvbHVtbixcbiAgICAgIGVuZENvbHVtbjogdG8gJiYgdG8uY29sdW1uLFxuICAgICAgZW5kTGluZTogdG8gJiYgdG8ubGluZSxcbiAgICAgIGxpbmU6IGZyb20ubGluZSxcbiAgICAgIHVybDogZnJvbVVybC50b1N0cmluZygpXG4gICAgfVxuXG4gICAgaWYgKGZyb21VcmwucHJvdG9jb2wgPT09ICdmaWxlOicpIHtcbiAgICAgIGlmIChmaWxlVVJMVG9QYXRoKSB7XG4gICAgICAgIHJlc3VsdC5maWxlID0gZmlsZVVSTFRvUGF0aChmcm9tVXJsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogYzggaWdub3JlIG5leHQgMiAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZpbGU6IHByb3RvY29sIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBQb3N0Q1NTIGJ1aWxkYClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgc291cmNlID0gY29uc3VtZXIuc291cmNlQ29udGVudEZvcihmcm9tLnNvdXJjZSlcbiAgICBpZiAoc291cmNlKSByZXN1bHQuc291cmNlID0gc291cmNlXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgbGV0IGpzb24gPSB7fVxuICAgIGZvciAobGV0IG5hbWUgb2YgWydoYXNCT00nLCAnY3NzJywgJ2ZpbGUnLCAnaWQnXSkge1xuICAgICAgaWYgKHRoaXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICBqc29uW25hbWVdID0gdGhpc1tuYW1lXVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgIGpzb24ubWFwID0geyAuLi50aGlzLm1hcCB9XG4gICAgICBpZiAoanNvbi5tYXAuY29uc3VtZXJDYWNoZSkge1xuICAgICAgICBqc29uLm1hcC5jb25zdW1lckNhY2hlID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqc29uXG4gIH1cblxuICBnZXQgZnJvbSgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxlIHx8IHRoaXMuaWRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0XG5JbnB1dC5kZWZhdWx0ID0gSW5wdXRcblxuaWYgKHRlcm1pbmFsSGlnaGxpZ2h0ICYmIHRlcm1pbmFsSGlnaGxpZ2h0LnJlZ2lzdGVySW5wdXQpIHtcbiAgdGVybWluYWxIaWdobGlnaHQucmVnaXN0ZXJJbnB1dChJbnB1dClcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/input.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/lazy-result.js":
/*!*************************************************!*\
  !*** ./node_modules/postcss/lib/lazy-result.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\nlet Document = __webpack_require__(/*! ./document */ \"./node_modules/postcss/lib/document.js\")\nlet MapGenerator = __webpack_require__(/*! ./map-generator */ \"./node_modules/postcss/lib/map-generator.js\")\nlet parse = __webpack_require__(/*! ./parse */ \"./node_modules/postcss/lib/parse.js\")\nlet Result = __webpack_require__(/*! ./result */ \"./node_modules/postcss/lib/result.js\")\nlet Root = __webpack_require__(/*! ./root */ \"./node_modules/postcss/lib/root.js\")\nlet stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/postcss/lib/stringify.js\")\nlet { isClean, my } = __webpack_require__(/*! ./symbols */ \"./node_modules/postcss/lib/symbols.js\")\nlet warnOnce = __webpack_require__(/*! ./warn-once */ \"./node_modules/postcss/lib/warn-once.js\")\n\nconst TYPE_TO_CLASS_NAME = {\n  atrule: 'AtRule',\n  comment: 'Comment',\n  decl: 'Declaration',\n  document: 'Document',\n  root: 'Root',\n  rule: 'Rule'\n}\n\nconst PLUGIN_PROPS = {\n  AtRule: true,\n  AtRuleExit: true,\n  Comment: true,\n  CommentExit: true,\n  Declaration: true,\n  DeclarationExit: true,\n  Document: true,\n  DocumentExit: true,\n  Once: true,\n  OnceExit: true,\n  postcssPlugin: true,\n  prepare: true,\n  Root: true,\n  RootExit: true,\n  Rule: true,\n  RuleExit: true\n}\n\nconst NOT_VISITORS = {\n  Once: true,\n  postcssPlugin: true,\n  prepare: true\n}\n\nconst CHILDREN = 0\n\nfunction isPromise(obj) {\n  return typeof obj === 'object' && typeof obj.then === 'function'\n}\n\nfunction getEvents(node) {\n  let key = false\n  let type = TYPE_TO_CLASS_NAME[node.type]\n  if (node.type === 'decl') {\n    key = node.prop.toLowerCase()\n  } else if (node.type === 'atrule') {\n    key = node.name.toLowerCase()\n  }\n\n  if (key && node.append) {\n    return [\n      type,\n      type + '-' + key,\n      CHILDREN,\n      type + 'Exit',\n      type + 'Exit-' + key\n    ]\n  } else if (key) {\n    return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key]\n  } else if (node.append) {\n    return [type, CHILDREN, type + 'Exit']\n  } else {\n    return [type, type + 'Exit']\n  }\n}\n\nfunction toStack(node) {\n  let events\n  if (node.type === 'document') {\n    events = ['Document', CHILDREN, 'DocumentExit']\n  } else if (node.type === 'root') {\n    events = ['Root', CHILDREN, 'RootExit']\n  } else {\n    events = getEvents(node)\n  }\n\n  return {\n    eventIndex: 0,\n    events,\n    iterator: 0,\n    node,\n    visitorIndex: 0,\n    visitors: []\n  }\n}\n\nfunction cleanMarks(node) {\n  node[isClean] = false\n  if (node.nodes) node.nodes.forEach(i => cleanMarks(i))\n  return node\n}\n\nlet postcss = {}\n\nclass LazyResult {\n  constructor(processor, css, opts) {\n    this.stringified = false\n    this.processed = false\n\n    let root\n    if (\n      typeof css === 'object' &&\n      css !== null &&\n      (css.type === 'root' || css.type === 'document')\n    ) {\n      root = cleanMarks(css)\n    } else if (css instanceof LazyResult || css instanceof Result) {\n      root = cleanMarks(css.root)\n      if (css.map) {\n        if (typeof opts.map === 'undefined') opts.map = {}\n        if (!opts.map.inline) opts.map.inline = false\n        opts.map.prev = css.map\n      }\n    } else {\n      let parser = parse\n      if (opts.syntax) parser = opts.syntax.parse\n      if (opts.parser) parser = opts.parser\n      if (parser.parse) parser = parser.parse\n\n      try {\n        root = parser(css, opts)\n      } catch (error) {\n        this.processed = true\n        this.error = error\n      }\n\n      if (root && !root[my]) {\n        /* c8 ignore next 2 */\n        Container.rebuild(root)\n      }\n    }\n\n    this.result = new Result(processor, root, opts)\n    this.helpers = { ...postcss, postcss, result: this.result }\n    this.plugins = this.processor.plugins.map(plugin => {\n      if (typeof plugin === 'object' && plugin.prepare) {\n        return { ...plugin, ...plugin.prepare(this.result) }\n      } else {\n        return plugin\n      }\n    })\n  }\n\n  async() {\n    if (this.error) return Promise.reject(this.error)\n    if (this.processed) return Promise.resolve(this.result)\n    if (!this.processing) {\n      this.processing = this.runAsync()\n    }\n    return this.processing\n  }\n\n  catch(onRejected) {\n    return this.async().catch(onRejected)\n  }\n\n  finally(onFinally) {\n    return this.async().then(onFinally, onFinally)\n  }\n\n  getAsyncError() {\n    throw new Error('Use process(css).then(cb) to work with async plugins')\n  }\n\n  handleError(error, node) {\n    let plugin = this.result.lastPlugin\n    try {\n      if (node) node.addToError(error)\n      this.error = error\n      if (error.name === 'CssSyntaxError' && !error.plugin) {\n        error.plugin = plugin.postcssPlugin\n        error.setMessage()\n      } else if (plugin.postcssVersion) {\n        if (true) {\n          let pluginName = plugin.postcssPlugin\n          let pluginVer = plugin.postcssVersion\n          let runtimeVer = this.result.processor.version\n          let a = pluginVer.split('.')\n          let b = runtimeVer.split('.')\n\n          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n            // eslint-disable-next-line no-console\n            console.error(\n              'Unknown error from PostCSS plugin. Your current PostCSS ' +\n                'version is ' +\n                runtimeVer +\n                ', but ' +\n                pluginName +\n                ' uses ' +\n                pluginVer +\n                '. Perhaps this is the source of the error below.'\n            )\n          }\n        }\n      }\n    } catch (err) {\n      /* c8 ignore next 3 */\n      // eslint-disable-next-line no-console\n      if (console && console.error) console.error(err)\n    }\n    return error\n  }\n\n  prepareVisitors() {\n    this.listeners = {}\n    let add = (plugin, type, cb) => {\n      if (!this.listeners[type]) this.listeners[type] = []\n      this.listeners[type].push([plugin, cb])\n    }\n    for (let plugin of this.plugins) {\n      if (typeof plugin === 'object') {\n        for (let event in plugin) {\n          if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {\n            throw new Error(\n              `Unknown event ${event} in ${plugin.postcssPlugin}. ` +\n                `Try to update PostCSS (${this.processor.version} now).`\n            )\n          }\n          if (!NOT_VISITORS[event]) {\n            if (typeof plugin[event] === 'object') {\n              for (let filter in plugin[event]) {\n                if (filter === '*') {\n                  add(plugin, event, plugin[event][filter])\n                } else {\n                  add(\n                    plugin,\n                    event + '-' + filter.toLowerCase(),\n                    plugin[event][filter]\n                  )\n                }\n              }\n            } else if (typeof plugin[event] === 'function') {\n              add(plugin, event, plugin[event])\n            }\n          }\n        }\n      }\n    }\n    this.hasListener = Object.keys(this.listeners).length > 0\n  }\n\n  async runAsync() {\n    this.plugin = 0\n    for (let i = 0; i < this.plugins.length; i++) {\n      let plugin = this.plugins[i]\n      let promise = this.runOnRoot(plugin)\n      if (isPromise(promise)) {\n        try {\n          await promise\n        } catch (error) {\n          throw this.handleError(error)\n        }\n      }\n    }\n\n    this.prepareVisitors()\n    if (this.hasListener) {\n      let root = this.result.root\n      while (!root[isClean]) {\n        root[isClean] = true\n        let stack = [toStack(root)]\n        while (stack.length > 0) {\n          let promise = this.visitTick(stack)\n          if (isPromise(promise)) {\n            try {\n              await promise\n            } catch (e) {\n              let node = stack[stack.length - 1].node\n              throw this.handleError(e, node)\n            }\n          }\n        }\n      }\n\n      if (this.listeners.OnceExit) {\n        for (let [plugin, visitor] of this.listeners.OnceExit) {\n          this.result.lastPlugin = plugin\n          try {\n            if (root.type === 'document') {\n              let roots = root.nodes.map(subRoot =>\n                visitor(subRoot, this.helpers)\n              )\n\n              await Promise.all(roots)\n            } else {\n              await visitor(root, this.helpers)\n            }\n          } catch (e) {\n            throw this.handleError(e)\n          }\n        }\n      }\n    }\n\n    this.processed = true\n    return this.stringify()\n  }\n\n  runOnRoot(plugin) {\n    this.result.lastPlugin = plugin\n    try {\n      if (typeof plugin === 'object' && plugin.Once) {\n        if (this.result.root.type === 'document') {\n          let roots = this.result.root.nodes.map(root =>\n            plugin.Once(root, this.helpers)\n          )\n\n          if (isPromise(roots[0])) {\n            return Promise.all(roots)\n          }\n\n          return roots\n        }\n\n        return plugin.Once(this.result.root, this.helpers)\n      } else if (typeof plugin === 'function') {\n        return plugin(this.result.root, this.result)\n      }\n    } catch (error) {\n      throw this.handleError(error)\n    }\n  }\n\n  stringify() {\n    if (this.error) throw this.error\n    if (this.stringified) return this.result\n    this.stringified = true\n\n    this.sync()\n\n    let opts = this.result.opts\n    let str = stringify\n    if (opts.syntax) str = opts.syntax.stringify\n    if (opts.stringifier) str = opts.stringifier\n    if (str.stringify) str = str.stringify\n\n    let map = new MapGenerator(str, this.result.root, this.result.opts)\n    let data = map.generate()\n    this.result.css = data[0]\n    this.result.map = data[1]\n\n    return this.result\n  }\n\n  sync() {\n    if (this.error) throw this.error\n    if (this.processed) return this.result\n    this.processed = true\n\n    if (this.processing) {\n      throw this.getAsyncError()\n    }\n\n    for (let plugin of this.plugins) {\n      let promise = this.runOnRoot(plugin)\n      if (isPromise(promise)) {\n        throw this.getAsyncError()\n      }\n    }\n\n    this.prepareVisitors()\n    if (this.hasListener) {\n      let root = this.result.root\n      while (!root[isClean]) {\n        root[isClean] = true\n        this.walkSync(root)\n      }\n      if (this.listeners.OnceExit) {\n        if (root.type === 'document') {\n          for (let subRoot of root.nodes) {\n            this.visitSync(this.listeners.OnceExit, subRoot)\n          }\n        } else {\n          this.visitSync(this.listeners.OnceExit, root)\n        }\n      }\n    }\n\n    return this.result\n  }\n\n  then(onFulfilled, onRejected) {\n    if (true) {\n      if (!('from' in this.opts)) {\n        warnOnce(\n          'Without `from` option PostCSS could generate wrong source map ' +\n            'and will not find Browserslist config. Set it to CSS file path ' +\n            'or to `undefined` to prevent this warning.'\n        )\n      }\n    }\n    return this.async().then(onFulfilled, onRejected)\n  }\n\n  toString() {\n    return this.css\n  }\n\n  visitSync(visitors, node) {\n    for (let [plugin, visitor] of visitors) {\n      this.result.lastPlugin = plugin\n      let promise\n      try {\n        promise = visitor(node, this.helpers)\n      } catch (e) {\n        throw this.handleError(e, node.proxyOf)\n      }\n      if (node.type !== 'root' && node.type !== 'document' && !node.parent) {\n        return true\n      }\n      if (isPromise(promise)) {\n        throw this.getAsyncError()\n      }\n    }\n  }\n\n  visitTick(stack) {\n    let visit = stack[stack.length - 1]\n    let { node, visitors } = visit\n\n    if (node.type !== 'root' && node.type !== 'document' && !node.parent) {\n      stack.pop()\n      return\n    }\n\n    if (visitors.length > 0 && visit.visitorIndex < visitors.length) {\n      let [plugin, visitor] = visitors[visit.visitorIndex]\n      visit.visitorIndex += 1\n      if (visit.visitorIndex === visitors.length) {\n        visit.visitors = []\n        visit.visitorIndex = 0\n      }\n      this.result.lastPlugin = plugin\n      try {\n        return visitor(node.toProxy(), this.helpers)\n      } catch (e) {\n        throw this.handleError(e, node)\n      }\n    }\n\n    if (visit.iterator !== 0) {\n      let iterator = visit.iterator\n      let child\n      while ((child = node.nodes[node.indexes[iterator]])) {\n        node.indexes[iterator] += 1\n        if (!child[isClean]) {\n          child[isClean] = true\n          stack.push(toStack(child))\n          return\n        }\n      }\n      visit.iterator = 0\n      delete node.indexes[iterator]\n    }\n\n    let events = visit.events\n    while (visit.eventIndex < events.length) {\n      let event = events[visit.eventIndex]\n      visit.eventIndex += 1\n      if (event === CHILDREN) {\n        if (node.nodes && node.nodes.length) {\n          node[isClean] = true\n          visit.iterator = node.getIterator()\n        }\n        return\n      } else if (this.listeners[event]) {\n        visit.visitors = this.listeners[event]\n        return\n      }\n    }\n    stack.pop()\n  }\n\n  walkSync(node) {\n    node[isClean] = true\n    let events = getEvents(node)\n    for (let event of events) {\n      if (event === CHILDREN) {\n        if (node.nodes) {\n          node.each(child => {\n            if (!child[isClean]) this.walkSync(child)\n          })\n        }\n      } else {\n        let visitors = this.listeners[event]\n        if (visitors) {\n          if (this.visitSync(visitors, node.toProxy())) return\n        }\n      }\n    }\n  }\n\n  warnings() {\n    return this.sync().warnings()\n  }\n\n  get content() {\n    return this.stringify().content\n  }\n\n  get css() {\n    return this.stringify().css\n  }\n\n  get map() {\n    return this.stringify().map\n  }\n\n  get messages() {\n    return this.sync().messages\n  }\n\n  get opts() {\n    return this.result.opts\n  }\n\n  get processor() {\n    return this.result.processor\n  }\n\n  get root() {\n    return this.sync().root\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'LazyResult'\n  }\n}\n\nLazyResult.registerPostcss = dependant => {\n  postcss = dependant\n}\n\nmodule.exports = LazyResult\nLazyResult.default = LazyResult\n\nRoot.registerLazyResult(LazyResult)\nDocument.registerLazyResult(LazyResult)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvbGF6eS1yZXN1bHQuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZ0JBQWdCLG1CQUFPLENBQUMsNERBQWE7QUFDckMsZUFBZSxtQkFBTyxDQUFDLDBEQUFZO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLG9FQUFpQjtBQUM1QyxZQUFZLG1CQUFPLENBQUMsb0RBQVM7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLHNEQUFVO0FBQy9CLFdBQVcsbUJBQU8sQ0FBQyxrREFBUTtBQUMzQixnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBYTtBQUNyQyxNQUFNLGNBQWMsRUFBRSxtQkFBTyxDQUFDLHdEQUFXO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyw0REFBYTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLEtBQUsscUJBQXFCO0FBQ2hFLDBDQUEwQyx3QkFBd0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vamltaXB1bHNhckBnaXRodWIuY29tLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL2xhenktcmVzdWx0LmpzP2U0YzEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmxldCBDb250YWluZXIgPSByZXF1aXJlKCcuL2NvbnRhaW5lcicpXG5sZXQgRG9jdW1lbnQgPSByZXF1aXJlKCcuL2RvY3VtZW50JylcbmxldCBNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL21hcC1nZW5lcmF0b3InKVxubGV0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5sZXQgUmVzdWx0ID0gcmVxdWlyZSgnLi9yZXN1bHQnKVxubGV0IFJvb3QgPSByZXF1aXJlKCcuL3Jvb3QnKVxubGV0IHN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5JylcbmxldCB7IGlzQ2xlYW4sIG15IH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxubGV0IHdhcm5PbmNlID0gcmVxdWlyZSgnLi93YXJuLW9uY2UnKVxuXG5jb25zdCBUWVBFX1RPX0NMQVNTX05BTUUgPSB7XG4gIGF0cnVsZTogJ0F0UnVsZScsXG4gIGNvbW1lbnQ6ICdDb21tZW50JyxcbiAgZGVjbDogJ0RlY2xhcmF0aW9uJyxcbiAgZG9jdW1lbnQ6ICdEb2N1bWVudCcsXG4gIHJvb3Q6ICdSb290JyxcbiAgcnVsZTogJ1J1bGUnXG59XG5cbmNvbnN0IFBMVUdJTl9QUk9QUyA9IHtcbiAgQXRSdWxlOiB0cnVlLFxuICBBdFJ1bGVFeGl0OiB0cnVlLFxuICBDb21tZW50OiB0cnVlLFxuICBDb21tZW50RXhpdDogdHJ1ZSxcbiAgRGVjbGFyYXRpb246IHRydWUsXG4gIERlY2xhcmF0aW9uRXhpdDogdHJ1ZSxcbiAgRG9jdW1lbnQ6IHRydWUsXG4gIERvY3VtZW50RXhpdDogdHJ1ZSxcbiAgT25jZTogdHJ1ZSxcbiAgT25jZUV4aXQ6IHRydWUsXG4gIHBvc3Rjc3NQbHVnaW46IHRydWUsXG4gIHByZXBhcmU6IHRydWUsXG4gIFJvb3Q6IHRydWUsXG4gIFJvb3RFeGl0OiB0cnVlLFxuICBSdWxlOiB0cnVlLFxuICBSdWxlRXhpdDogdHJ1ZVxufVxuXG5jb25zdCBOT1RfVklTSVRPUlMgPSB7XG4gIE9uY2U6IHRydWUsXG4gIHBvc3Rjc3NQbHVnaW46IHRydWUsXG4gIHByZXBhcmU6IHRydWVcbn1cblxuY29uc3QgQ0hJTERSRU4gPSAwXG5cbmZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudHMobm9kZSkge1xuICBsZXQga2V5ID0gZmFsc2VcbiAgbGV0IHR5cGUgPSBUWVBFX1RPX0NMQVNTX05BTUVbbm9kZS50eXBlXVxuICBpZiAobm9kZS50eXBlID09PSAnZGVjbCcpIHtcbiAgICBrZXkgPSBub2RlLnByb3AudG9Mb3dlckNhc2UoKVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ2F0cnVsZScpIHtcbiAgICBrZXkgPSBub2RlLm5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgaWYgKGtleSAmJiBub2RlLmFwcGVuZCkge1xuICAgIHJldHVybiBbXG4gICAgICB0eXBlLFxuICAgICAgdHlwZSArICctJyArIGtleSxcbiAgICAgIENISUxEUkVOLFxuICAgICAgdHlwZSArICdFeGl0JyxcbiAgICAgIHR5cGUgKyAnRXhpdC0nICsga2V5XG4gICAgXVxuICB9IGVsc2UgaWYgKGtleSkge1xuICAgIHJldHVybiBbdHlwZSwgdHlwZSArICctJyArIGtleSwgdHlwZSArICdFeGl0JywgdHlwZSArICdFeGl0LScgKyBrZXldXG4gIH0gZWxzZSBpZiAobm9kZS5hcHBlbmQpIHtcbiAgICByZXR1cm4gW3R5cGUsIENISUxEUkVOLCB0eXBlICsgJ0V4aXQnXVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBbdHlwZSwgdHlwZSArICdFeGl0J11cbiAgfVxufVxuXG5mdW5jdGlvbiB0b1N0YWNrKG5vZGUpIHtcbiAgbGV0IGV2ZW50c1xuICBpZiAobm9kZS50eXBlID09PSAnZG9jdW1lbnQnKSB7XG4gICAgZXZlbnRzID0gWydEb2N1bWVudCcsIENISUxEUkVOLCAnRG9jdW1lbnRFeGl0J11cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdyb290Jykge1xuICAgIGV2ZW50cyA9IFsnUm9vdCcsIENISUxEUkVOLCAnUm9vdEV4aXQnXVxuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGdldEV2ZW50cyhub2RlKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBldmVudEluZGV4OiAwLFxuICAgIGV2ZW50cyxcbiAgICBpdGVyYXRvcjogMCxcbiAgICBub2RlLFxuICAgIHZpc2l0b3JJbmRleDogMCxcbiAgICB2aXNpdG9yczogW11cbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhbk1hcmtzKG5vZGUpIHtcbiAgbm9kZVtpc0NsZWFuXSA9IGZhbHNlXG4gIGlmIChub2RlLm5vZGVzKSBub2RlLm5vZGVzLmZvckVhY2goaSA9PiBjbGVhbk1hcmtzKGkpKVxuICByZXR1cm4gbm9kZVxufVxuXG5sZXQgcG9zdGNzcyA9IHt9XG5cbmNsYXNzIExhenlSZXN1bHQge1xuICBjb25zdHJ1Y3Rvcihwcm9jZXNzb3IsIGNzcywgb3B0cykge1xuICAgIHRoaXMuc3RyaW5naWZpZWQgPSBmYWxzZVxuICAgIHRoaXMucHJvY2Vzc2VkID0gZmFsc2VcblxuICAgIGxldCByb290XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIGNzcyA9PT0gJ29iamVjdCcgJiZcbiAgICAgIGNzcyAhPT0gbnVsbCAmJlxuICAgICAgKGNzcy50eXBlID09PSAncm9vdCcgfHwgY3NzLnR5cGUgPT09ICdkb2N1bWVudCcpXG4gICAgKSB7XG4gICAgICByb290ID0gY2xlYW5NYXJrcyhjc3MpXG4gICAgfSBlbHNlIGlmIChjc3MgaW5zdGFuY2VvZiBMYXp5UmVzdWx0IHx8IGNzcyBpbnN0YW5jZW9mIFJlc3VsdCkge1xuICAgICAgcm9vdCA9IGNsZWFuTWFya3MoY3NzLnJvb3QpXG4gICAgICBpZiAoY3NzLm1hcCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdHMubWFwID09PSAndW5kZWZpbmVkJykgb3B0cy5tYXAgPSB7fVxuICAgICAgICBpZiAoIW9wdHMubWFwLmlubGluZSkgb3B0cy5tYXAuaW5saW5lID0gZmFsc2VcbiAgICAgICAgb3B0cy5tYXAucHJldiA9IGNzcy5tYXBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhcnNlciA9IHBhcnNlXG4gICAgICBpZiAob3B0cy5zeW50YXgpIHBhcnNlciA9IG9wdHMuc3ludGF4LnBhcnNlXG4gICAgICBpZiAob3B0cy5wYXJzZXIpIHBhcnNlciA9IG9wdHMucGFyc2VyXG4gICAgICBpZiAocGFyc2VyLnBhcnNlKSBwYXJzZXIgPSBwYXJzZXIucGFyc2VcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcm9vdCA9IHBhcnNlcihjc3MsIG9wdHMpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWVcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yXG4gICAgICB9XG5cbiAgICAgIGlmIChyb290ICYmICFyb290W215XSkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAyICovXG4gICAgICAgIENvbnRhaW5lci5yZWJ1aWxkKHJvb3QpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZXN1bHQgPSBuZXcgUmVzdWx0KHByb2Nlc3Nvciwgcm9vdCwgb3B0cylcbiAgICB0aGlzLmhlbHBlcnMgPSB7IC4uLnBvc3Rjc3MsIHBvc3Rjc3MsIHJlc3VsdDogdGhpcy5yZXN1bHQgfVxuICAgIHRoaXMucGx1Z2lucyA9IHRoaXMucHJvY2Vzc29yLnBsdWdpbnMubWFwKHBsdWdpbiA9PiB7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ29iamVjdCcgJiYgcGx1Z2luLnByZXBhcmUpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ucGx1Z2luLCAuLi5wbHVnaW4ucHJlcGFyZSh0aGlzLnJlc3VsdCkgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBsdWdpblxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBhc3luYygpIHtcbiAgICBpZiAodGhpcy5lcnJvcikgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuZXJyb3IpXG4gICAgaWYgKHRoaXMucHJvY2Vzc2VkKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMucmVzdWx0KVxuICAgIGlmICghdGhpcy5wcm9jZXNzaW5nKSB7XG4gICAgICB0aGlzLnByb2Nlc3NpbmcgPSB0aGlzLnJ1bkFzeW5jKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc2luZ1xuICB9XG5cbiAgY2F0Y2gob25SZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLmFzeW5jKCkuY2F0Y2gob25SZWplY3RlZClcbiAgfVxuXG4gIGZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRmluYWxseSwgb25GaW5hbGx5KVxuICB9XG5cbiAgZ2V0QXN5bmNFcnJvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZSBwcm9jZXNzKGNzcykudGhlbihjYikgdG8gd29yayB3aXRoIGFzeW5jIHBsdWdpbnMnKVxuICB9XG5cbiAgaGFuZGxlRXJyb3IoZXJyb3IsIG5vZGUpIHtcbiAgICBsZXQgcGx1Z2luID0gdGhpcy5yZXN1bHQubGFzdFBsdWdpblxuICAgIHRyeSB7XG4gICAgICBpZiAobm9kZSkgbm9kZS5hZGRUb0Vycm9yKGVycm9yKVxuICAgICAgdGhpcy5lcnJvciA9IGVycm9yXG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Nzc1N5bnRheEVycm9yJyAmJiAhZXJyb3IucGx1Z2luKSB7XG4gICAgICAgIGVycm9yLnBsdWdpbiA9IHBsdWdpbi5wb3N0Y3NzUGx1Z2luXG4gICAgICAgIGVycm9yLnNldE1lc3NhZ2UoKVxuICAgICAgfSBlbHNlIGlmIChwbHVnaW4ucG9zdGNzc1ZlcnNpb24pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBsZXQgcGx1Z2luTmFtZSA9IHBsdWdpbi5wb3N0Y3NzUGx1Z2luXG4gICAgICAgICAgbGV0IHBsdWdpblZlciA9IHBsdWdpbi5wb3N0Y3NzVmVyc2lvblxuICAgICAgICAgIGxldCBydW50aW1lVmVyID0gdGhpcy5yZXN1bHQucHJvY2Vzc29yLnZlcnNpb25cbiAgICAgICAgICBsZXQgYSA9IHBsdWdpblZlci5zcGxpdCgnLicpXG4gICAgICAgICAgbGV0IGIgPSBydW50aW1lVmVyLnNwbGl0KCcuJylcblxuICAgICAgICAgIGlmIChhWzBdICE9PSBiWzBdIHx8IHBhcnNlSW50KGFbMV0pID4gcGFyc2VJbnQoYlsxXSkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnVW5rbm93biBlcnJvciBmcm9tIFBvc3RDU1MgcGx1Z2luLiBZb3VyIGN1cnJlbnQgUG9zdENTUyAnICtcbiAgICAgICAgICAgICAgICAndmVyc2lvbiBpcyAnICtcbiAgICAgICAgICAgICAgICBydW50aW1lVmVyICtcbiAgICAgICAgICAgICAgICAnLCBidXQgJyArXG4gICAgICAgICAgICAgICAgcGx1Z2luTmFtZSArXG4gICAgICAgICAgICAgICAgJyB1c2VzICcgK1xuICAgICAgICAgICAgICAgIHBsdWdpblZlciArXG4gICAgICAgICAgICAgICAgJy4gUGVyaGFwcyB0aGlzIGlzIHRoZSBzb3VyY2Ugb2YgdGhlIGVycm9yIGJlbG93LidcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSBjb25zb2xlLmVycm9yKGVycilcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yXG4gIH1cblxuICBwcmVwYXJlVmlzaXRvcnMoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB7fVxuICAgIGxldCBhZGQgPSAocGx1Z2luLCB0eXBlLCBjYikgPT4ge1xuICAgICAgaWYgKCF0aGlzLmxpc3RlbmVyc1t0eXBlXSkgdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBbXVxuICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaChbcGx1Z2luLCBjYl0pXG4gICAgfVxuICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgIGlmICh0eXBlb2YgcGx1Z2luID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKGxldCBldmVudCBpbiBwbHVnaW4pIHtcbiAgICAgICAgICBpZiAoIVBMVUdJTl9QUk9QU1tldmVudF0gJiYgL15bQS1aXS8udGVzdChldmVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZXZlbnQgJHtldmVudH0gaW4gJHtwbHVnaW4ucG9zdGNzc1BsdWdpbn0uIGAgK1xuICAgICAgICAgICAgICAgIGBUcnkgdG8gdXBkYXRlIFBvc3RDU1MgKCR7dGhpcy5wcm9jZXNzb3IudmVyc2lvbn0gbm93KS5gXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghTk9UX1ZJU0lUT1JTW2V2ZW50XSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbHVnaW5bZXZlbnRdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBmb3IgKGxldCBmaWx0ZXIgaW4gcGx1Z2luW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgYWRkKHBsdWdpbiwgZXZlbnQsIHBsdWdpbltldmVudF1bZmlsdGVyXSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYWRkKFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4sXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50ICsgJy0nICsgZmlsdGVyLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbltldmVudF1bZmlsdGVyXVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luW2V2ZW50XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBhZGQocGx1Z2luLCBldmVudCwgcGx1Z2luW2V2ZW50XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5oYXNMaXN0ZW5lciA9IE9iamVjdC5rZXlzKHRoaXMubGlzdGVuZXJzKS5sZW5ndGggPiAwXG4gIH1cblxuICBhc3luYyBydW5Bc3luYygpIHtcbiAgICB0aGlzLnBsdWdpbiA9IDBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHBsdWdpbiA9IHRoaXMucGx1Z2luc1tpXVxuICAgICAgbGV0IHByb21pc2UgPSB0aGlzLnJ1bk9uUm9vdChwbHVnaW4pXG4gICAgICBpZiAoaXNQcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgcHJvbWlzZVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnByZXBhcmVWaXNpdG9ycygpXG4gICAgaWYgKHRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgICAgIGxldCByb290ID0gdGhpcy5yZXN1bHQucm9vdFxuICAgICAgd2hpbGUgKCFyb290W2lzQ2xlYW5dKSB7XG4gICAgICAgIHJvb3RbaXNDbGVhbl0gPSB0cnVlXG4gICAgICAgIGxldCBzdGFjayA9IFt0b1N0YWNrKHJvb3QpXVxuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCBwcm9taXNlID0gdGhpcy52aXNpdFRpY2soc3RhY2spXG4gICAgICAgICAgaWYgKGlzUHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgcHJvbWlzZVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBsZXQgbm9kZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLm5vZGVcbiAgICAgICAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlLCBub2RlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpIHtcbiAgICAgICAgZm9yIChsZXQgW3BsdWdpbiwgdmlzaXRvcl0gb2YgdGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpIHtcbiAgICAgICAgICB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyb290LnR5cGUgPT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgICAgICAgbGV0IHJvb3RzID0gcm9vdC5ub2Rlcy5tYXAoc3ViUm9vdCA9PlxuICAgICAgICAgICAgICAgIHZpc2l0b3Ioc3ViUm9vdCwgdGhpcy5oZWxwZXJzKVxuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocm9vdHMpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhd2FpdCB2aXNpdG9yKHJvb3QsIHRoaXMuaGVscGVycylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlXG4gICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KClcbiAgfVxuXG4gIHJ1bk9uUm9vdChwbHVnaW4pIHtcbiAgICB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgcGx1Z2luID09PSAnb2JqZWN0JyAmJiBwbHVnaW4uT25jZSkge1xuICAgICAgICBpZiAodGhpcy5yZXN1bHQucm9vdC50eXBlID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgbGV0IHJvb3RzID0gdGhpcy5yZXN1bHQucm9vdC5ub2Rlcy5tYXAocm9vdCA9PlxuICAgICAgICAgICAgcGx1Z2luLk9uY2Uocm9vdCwgdGhpcy5oZWxwZXJzKVxuICAgICAgICAgIClcblxuICAgICAgICAgIGlmIChpc1Byb21pc2Uocm9vdHNbMF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocm9vdHMpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJvb3RzXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGx1Z2luLk9uY2UodGhpcy5yZXN1bHQucm9vdCwgdGhpcy5oZWxwZXJzKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBwbHVnaW4odGhpcy5yZXN1bHQucm9vdCwgdGhpcy5yZXN1bHQpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgc3RyaW5naWZ5KCkge1xuICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yXG4gICAgaWYgKHRoaXMuc3RyaW5naWZpZWQpIHJldHVybiB0aGlzLnJlc3VsdFxuICAgIHRoaXMuc3RyaW5naWZpZWQgPSB0cnVlXG5cbiAgICB0aGlzLnN5bmMoKVxuXG4gICAgbGV0IG9wdHMgPSB0aGlzLnJlc3VsdC5vcHRzXG4gICAgbGV0IHN0ciA9IHN0cmluZ2lmeVxuICAgIGlmIChvcHRzLnN5bnRheCkgc3RyID0gb3B0cy5zeW50YXguc3RyaW5naWZ5XG4gICAgaWYgKG9wdHMuc3RyaW5naWZpZXIpIHN0ciA9IG9wdHMuc3RyaW5naWZpZXJcbiAgICBpZiAoc3RyLnN0cmluZ2lmeSkgc3RyID0gc3RyLnN0cmluZ2lmeVxuXG4gICAgbGV0IG1hcCA9IG5ldyBNYXBHZW5lcmF0b3Ioc3RyLCB0aGlzLnJlc3VsdC5yb290LCB0aGlzLnJlc3VsdC5vcHRzKVxuICAgIGxldCBkYXRhID0gbWFwLmdlbmVyYXRlKClcbiAgICB0aGlzLnJlc3VsdC5jc3MgPSBkYXRhWzBdXG4gICAgdGhpcy5yZXN1bHQubWFwID0gZGF0YVsxXVxuXG4gICAgcmV0dXJuIHRoaXMucmVzdWx0XG4gIH1cblxuICBzeW5jKCkge1xuICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yXG4gICAgaWYgKHRoaXMucHJvY2Vzc2VkKSByZXR1cm4gdGhpcy5yZXN1bHRcbiAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWVcblxuICAgIGlmICh0aGlzLnByb2Nlc3NpbmcpIHtcbiAgICAgIHRocm93IHRoaXMuZ2V0QXN5bmNFcnJvcigpXG4gICAgfVxuXG4gICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucykge1xuICAgICAgbGV0IHByb21pc2UgPSB0aGlzLnJ1bk9uUm9vdChwbHVnaW4pXG4gICAgICBpZiAoaXNQcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgIHRocm93IHRoaXMuZ2V0QXN5bmNFcnJvcigpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wcmVwYXJlVmlzaXRvcnMoKVxuICAgIGlmICh0aGlzLmhhc0xpc3RlbmVyKSB7XG4gICAgICBsZXQgcm9vdCA9IHRoaXMucmVzdWx0LnJvb3RcbiAgICAgIHdoaWxlICghcm9vdFtpc0NsZWFuXSkge1xuICAgICAgICByb290W2lzQ2xlYW5dID0gdHJ1ZVxuICAgICAgICB0aGlzLndhbGtTeW5jKHJvb3QpXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpIHtcbiAgICAgICAgaWYgKHJvb3QudHlwZSA9PT0gJ2RvY3VtZW50Jykge1xuICAgICAgICAgIGZvciAobGV0IHN1YlJvb3Qgb2Ygcm9vdC5ub2Rlcykge1xuICAgICAgICAgICAgdGhpcy52aXNpdFN5bmModGhpcy5saXN0ZW5lcnMuT25jZUV4aXQsIHN1YlJvb3QpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudmlzaXRTeW5jKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0LCByb290KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVzdWx0XG4gIH1cblxuICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghKCdmcm9tJyBpbiB0aGlzLm9wdHMpKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICdXaXRob3V0IGBmcm9tYCBvcHRpb24gUG9zdENTUyBjb3VsZCBnZW5lcmF0ZSB3cm9uZyBzb3VyY2UgbWFwICcgK1xuICAgICAgICAgICAgJ2FuZCB3aWxsIG5vdCBmaW5kIEJyb3dzZXJzbGlzdCBjb25maWcuIFNldCBpdCB0byBDU1MgZmlsZSBwYXRoICcgK1xuICAgICAgICAgICAgJ29yIHRvIGB1bmRlZmluZWRgIHRvIHByZXZlbnQgdGhpcyB3YXJuaW5nLidcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5jc3NcbiAgfVxuXG4gIHZpc2l0U3luYyh2aXNpdG9ycywgbm9kZSkge1xuICAgIGZvciAobGV0IFtwbHVnaW4sIHZpc2l0b3JdIG9mIHZpc2l0b3JzKSB7XG4gICAgICB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luXG4gICAgICBsZXQgcHJvbWlzZVxuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvbWlzZSA9IHZpc2l0b3Iobm9kZSwgdGhpcy5oZWxwZXJzKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGUsIG5vZGUucHJveHlPZilcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLnR5cGUgIT09ICdyb290JyAmJiBub2RlLnR5cGUgIT09ICdkb2N1bWVudCcgJiYgIW5vZGUucGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoaXNQcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgIHRocm93IHRoaXMuZ2V0QXN5bmNFcnJvcigpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmlzaXRUaWNrKHN0YWNrKSB7XG4gICAgbGV0IHZpc2l0ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1cbiAgICBsZXQgeyBub2RlLCB2aXNpdG9ycyB9ID0gdmlzaXRcblxuICAgIGlmIChub2RlLnR5cGUgIT09ICdyb290JyAmJiBub2RlLnR5cGUgIT09ICdkb2N1bWVudCcgJiYgIW5vZGUucGFyZW50KSB7XG4gICAgICBzdGFjay5wb3AoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHZpc2l0b3JzLmxlbmd0aCA+IDAgJiYgdmlzaXQudmlzaXRvckluZGV4IDwgdmlzaXRvcnMubGVuZ3RoKSB7XG4gICAgICBsZXQgW3BsdWdpbiwgdmlzaXRvcl0gPSB2aXNpdG9yc1t2aXNpdC52aXNpdG9ySW5kZXhdXG4gICAgICB2aXNpdC52aXNpdG9ySW5kZXggKz0gMVxuICAgICAgaWYgKHZpc2l0LnZpc2l0b3JJbmRleCA9PT0gdmlzaXRvcnMubGVuZ3RoKSB7XG4gICAgICAgIHZpc2l0LnZpc2l0b3JzID0gW11cbiAgICAgICAgdmlzaXQudmlzaXRvckluZGV4ID0gMFxuICAgICAgfVxuICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3Iobm9kZS50b1Byb3h5KCksIHRoaXMuaGVscGVycylcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5oYW5kbGVFcnJvcihlLCBub2RlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2aXNpdC5pdGVyYXRvciAhPT0gMCkge1xuICAgICAgbGV0IGl0ZXJhdG9yID0gdmlzaXQuaXRlcmF0b3JcbiAgICAgIGxldCBjaGlsZFxuICAgICAgd2hpbGUgKChjaGlsZCA9IG5vZGUubm9kZXNbbm9kZS5pbmRleGVzW2l0ZXJhdG9yXV0pKSB7XG4gICAgICAgIG5vZGUuaW5kZXhlc1tpdGVyYXRvcl0gKz0gMVxuICAgICAgICBpZiAoIWNoaWxkW2lzQ2xlYW5dKSB7XG4gICAgICAgICAgY2hpbGRbaXNDbGVhbl0gPSB0cnVlXG4gICAgICAgICAgc3RhY2sucHVzaCh0b1N0YWNrKGNoaWxkKSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmlzaXQuaXRlcmF0b3IgPSAwXG4gICAgICBkZWxldGUgbm9kZS5pbmRleGVzW2l0ZXJhdG9yXVxuICAgIH1cblxuICAgIGxldCBldmVudHMgPSB2aXNpdC5ldmVudHNcbiAgICB3aGlsZSAodmlzaXQuZXZlbnRJbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIGxldCBldmVudCA9IGV2ZW50c1t2aXNpdC5ldmVudEluZGV4XVxuICAgICAgdmlzaXQuZXZlbnRJbmRleCArPSAxXG4gICAgICBpZiAoZXZlbnQgPT09IENISUxEUkVOKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVzICYmIG5vZGUubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgbm9kZVtpc0NsZWFuXSA9IHRydWVcbiAgICAgICAgICB2aXNpdC5pdGVyYXRvciA9IG5vZGUuZ2V0SXRlcmF0b3IoKVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfSBlbHNlIGlmICh0aGlzLmxpc3RlbmVyc1tldmVudF0pIHtcbiAgICAgICAgdmlzaXQudmlzaXRvcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudF1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIHN0YWNrLnBvcCgpXG4gIH1cblxuICB3YWxrU3luYyhub2RlKSB7XG4gICAgbm9kZVtpc0NsZWFuXSA9IHRydWVcbiAgICBsZXQgZXZlbnRzID0gZ2V0RXZlbnRzKG5vZGUpXG4gICAgZm9yIChsZXQgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICBpZiAoZXZlbnQgPT09IENISUxEUkVOKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVzKSB7XG4gICAgICAgICAgbm9kZS5lYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGlmICghY2hpbGRbaXNDbGVhbl0pIHRoaXMud2Fsa1N5bmMoY2hpbGQpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHZpc2l0b3JzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnRdXG4gICAgICAgIGlmICh2aXNpdG9ycykge1xuICAgICAgICAgIGlmICh0aGlzLnZpc2l0U3luYyh2aXNpdG9ycywgbm9kZS50b1Byb3h5KCkpKSByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdhcm5pbmdzKCkge1xuICAgIHJldHVybiB0aGlzLnN5bmMoKS53YXJuaW5ncygpXG4gIH1cblxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5jb250ZW50XG4gIH1cblxuICBnZXQgY3NzKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeSgpLmNzc1xuICB9XG5cbiAgZ2V0IG1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5tYXBcbiAgfVxuXG4gIGdldCBtZXNzYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zeW5jKCkubWVzc2FnZXNcbiAgfVxuXG4gIGdldCBvcHRzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5vcHRzXG4gIH1cblxuICBnZXQgcHJvY2Vzc29yKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5wcm9jZXNzb3JcbiAgfVxuXG4gIGdldCByb290KCkge1xuICAgIHJldHVybiB0aGlzLnN5bmMoKS5yb290XG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdMYXp5UmVzdWx0J1xuICB9XG59XG5cbkxhenlSZXN1bHQucmVnaXN0ZXJQb3N0Y3NzID0gZGVwZW5kYW50ID0+IHtcbiAgcG9zdGNzcyA9IGRlcGVuZGFudFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExhenlSZXN1bHRcbkxhenlSZXN1bHQuZGVmYXVsdCA9IExhenlSZXN1bHRcblxuUm9vdC5yZWdpc3RlckxhenlSZXN1bHQoTGF6eVJlc3VsdClcbkRvY3VtZW50LnJlZ2lzdGVyTGF6eVJlc3VsdChMYXp5UmVzdWx0KVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/lazy-result.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/list.js":
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/list.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nlet list = {\n  comma(string) {\n    return list.split(string, [','], true)\n  },\n\n  space(string) {\n    let spaces = [' ', '\\n', '\\t']\n    return list.split(string, spaces)\n  },\n\n  split(string, separators, last) {\n    let array = []\n    let current = ''\n    let split = false\n\n    let func = 0\n    let inQuote = false\n    let prevQuote = ''\n    let escape = false\n\n    for (let letter of string) {\n      if (escape) {\n        escape = false\n      } else if (letter === '\\\\') {\n        escape = true\n      } else if (inQuote) {\n        if (letter === prevQuote) {\n          inQuote = false\n        }\n      } else if (letter === '\"' || letter === \"'\") {\n        inQuote = true\n        prevQuote = letter\n      } else if (letter === '(') {\n        func += 1\n      } else if (letter === ')') {\n        if (func > 0) func -= 1\n      } else if (func === 0) {\n        if (separators.includes(letter)) split = true\n      }\n\n      if (split) {\n        if (current !== '') array.push(current.trim())\n        current = ''\n        split = false\n      } else {\n        current += letter\n      }\n    }\n\n    if (last || current !== '') array.push(current.trim())\n    return array\n  }\n}\n\nmodule.exports = list\nlist.default = list\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvbGlzdC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qaW1pcHVsc2FyQGdpdGh1Yi5jb20vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvbGlzdC5qcz82ODUxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5sZXQgbGlzdCA9IHtcbiAgY29tbWEoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGxpc3Quc3BsaXQoc3RyaW5nLCBbJywnXSwgdHJ1ZSlcbiAgfSxcblxuICBzcGFjZShzdHJpbmcpIHtcbiAgICBsZXQgc3BhY2VzID0gWycgJywgJ1xcbicsICdcXHQnXVxuICAgIHJldHVybiBsaXN0LnNwbGl0KHN0cmluZywgc3BhY2VzKVxuICB9LFxuXG4gIHNwbGl0KHN0cmluZywgc2VwYXJhdG9ycywgbGFzdCkge1xuICAgIGxldCBhcnJheSA9IFtdXG4gICAgbGV0IGN1cnJlbnQgPSAnJ1xuICAgIGxldCBzcGxpdCA9IGZhbHNlXG5cbiAgICBsZXQgZnVuYyA9IDBcbiAgICBsZXQgaW5RdW90ZSA9IGZhbHNlXG4gICAgbGV0IHByZXZRdW90ZSA9ICcnXG4gICAgbGV0IGVzY2FwZSA9IGZhbHNlXG5cbiAgICBmb3IgKGxldCBsZXR0ZXIgb2Ygc3RyaW5nKSB7XG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIGVzY2FwZSA9IGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGVzY2FwZSA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAoaW5RdW90ZSkge1xuICAgICAgICBpZiAobGV0dGVyID09PSBwcmV2UXVvdGUpIHtcbiAgICAgICAgICBpblF1b3RlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09ICdcIicgfHwgbGV0dGVyID09PSBcIidcIikge1xuICAgICAgICBpblF1b3RlID0gdHJ1ZVxuICAgICAgICBwcmV2UXVvdGUgPSBsZXR0ZXJcbiAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSAnKCcpIHtcbiAgICAgICAgZnVuYyArPSAxXG4gICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gJyknKSB7XG4gICAgICAgIGlmIChmdW5jID4gMCkgZnVuYyAtPSAxXG4gICAgICB9IGVsc2UgaWYgKGZ1bmMgPT09IDApIHtcbiAgICAgICAgaWYgKHNlcGFyYXRvcnMuaW5jbHVkZXMobGV0dGVyKSkgc3BsaXQgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChzcGxpdCkge1xuICAgICAgICBpZiAoY3VycmVudCAhPT0gJycpIGFycmF5LnB1c2goY3VycmVudC50cmltKCkpXG4gICAgICAgIGN1cnJlbnQgPSAnJ1xuICAgICAgICBzcGxpdCA9IGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50ICs9IGxldHRlclxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsYXN0IHx8IGN1cnJlbnQgIT09ICcnKSBhcnJheS5wdXNoKGN1cnJlbnQudHJpbSgpKVxuICAgIHJldHVybiBhcnJheVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdFxubGlzdC5kZWZhdWx0ID0gbGlzdFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/list.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/map-generator.js":
/*!***************************************************!*\
  !*** ./node_modules/postcss/lib/map-generator.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\nlet { dirname, relative, resolve, sep } = __webpack_require__(/*! path */ \"?25fb\")\nlet { SourceMapConsumer, SourceMapGenerator } = __webpack_require__(/*! source-map-js */ \"?6f78\")\nlet { pathToFileURL } = __webpack_require__(/*! url */ \"?9214\")\n\nlet Input = __webpack_require__(/*! ./input */ \"./node_modules/postcss/lib/input.js\")\n\nlet sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)\nlet pathAvailable = Boolean(dirname && resolve && relative && sep)\n\nclass MapGenerator {\n  constructor(stringify, root, opts, cssString) {\n    this.stringify = stringify\n    this.mapOpts = opts.map || {}\n    this.root = root\n    this.opts = opts\n    this.css = cssString\n    this.originalCSS = cssString\n    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute\n\n    this.memoizedFileURLs = new Map()\n    this.memoizedPaths = new Map()\n    this.memoizedURLs = new Map()\n  }\n\n  addAnnotation() {\n    let content\n\n    if (this.isInline()) {\n      content =\n        'data:application/json;base64,' + this.toBase64(this.map.toString())\n    } else if (typeof this.mapOpts.annotation === 'string') {\n      content = this.mapOpts.annotation\n    } else if (typeof this.mapOpts.annotation === 'function') {\n      content = this.mapOpts.annotation(this.opts.to, this.root)\n    } else {\n      content = this.outputFile() + '.map'\n    }\n    let eol = '\\n'\n    if (this.css.includes('\\r\\n')) eol = '\\r\\n'\n\n    this.css += eol + '/*# sourceMappingURL=' + content + ' */'\n  }\n\n  applyPrevMaps() {\n    for (let prev of this.previous()) {\n      let from = this.toUrl(this.path(prev.file))\n      let root = prev.root || dirname(prev.file)\n      let map\n\n      if (this.mapOpts.sourcesContent === false) {\n        map = new SourceMapConsumer(prev.text)\n        if (map.sourcesContent) {\n          map.sourcesContent = null\n        }\n      } else {\n        map = prev.consumer()\n      }\n\n      this.map.applySourceMap(map, from, this.toUrl(this.path(root)))\n    }\n  }\n\n  clearAnnotation() {\n    if (this.mapOpts.annotation === false) return\n\n    if (this.root) {\n      let node\n      for (let i = this.root.nodes.length - 1; i >= 0; i--) {\n        node = this.root.nodes[i]\n        if (node.type !== 'comment') continue\n        if (node.text.startsWith('# sourceMappingURL=')) {\n          this.root.removeChild(i)\n        }\n      }\n    } else if (this.css) {\n      this.css = this.css.replace(/\\n*\\/\\*#[\\S\\s]*?\\*\\/$/gm, '')\n    }\n  }\n\n  generate() {\n    this.clearAnnotation()\n    if (pathAvailable && sourceMapAvailable && this.isMap()) {\n      return this.generateMap()\n    } else {\n      let result = ''\n      this.stringify(this.root, i => {\n        result += i\n      })\n      return [result]\n    }\n  }\n\n  generateMap() {\n    if (this.root) {\n      this.generateString()\n    } else if (this.previous().length === 1) {\n      let prev = this.previous()[0].consumer()\n      prev.file = this.outputFile()\n      this.map = SourceMapGenerator.fromSourceMap(prev, {\n        ignoreInvalidMapping: true\n      })\n    } else {\n      this.map = new SourceMapGenerator({\n        file: this.outputFile(),\n        ignoreInvalidMapping: true\n      })\n      this.map.addMapping({\n        generated: { column: 0, line: 1 },\n        original: { column: 0, line: 1 },\n        source: this.opts.from\n          ? this.toUrl(this.path(this.opts.from))\n          : '<no source>'\n      })\n    }\n\n    if (this.isSourcesContent()) this.setSourcesContent()\n    if (this.root && this.previous().length > 0) this.applyPrevMaps()\n    if (this.isAnnotation()) this.addAnnotation()\n\n    if (this.isInline()) {\n      return [this.css]\n    } else {\n      return [this.css, this.map]\n    }\n  }\n\n  generateString() {\n    this.css = ''\n    this.map = new SourceMapGenerator({\n      file: this.outputFile(),\n      ignoreInvalidMapping: true\n    })\n\n    let line = 1\n    let column = 1\n\n    let noSource = '<no source>'\n    let mapping = {\n      generated: { column: 0, line: 0 },\n      original: { column: 0, line: 0 },\n      source: ''\n    }\n\n    let last, lines\n    this.stringify(this.root, (str, node, type) => {\n      this.css += str\n\n      if (node && type !== 'end') {\n        mapping.generated.line = line\n        mapping.generated.column = column - 1\n        if (node.source && node.source.start) {\n          mapping.source = this.sourcePath(node)\n          mapping.original.line = node.source.start.line\n          mapping.original.column = node.source.start.column - 1\n          this.map.addMapping(mapping)\n        } else {\n          mapping.source = noSource\n          mapping.original.line = 1\n          mapping.original.column = 0\n          this.map.addMapping(mapping)\n        }\n      }\n\n      lines = str.match(/\\n/g)\n      if (lines) {\n        line += lines.length\n        last = str.lastIndexOf('\\n')\n        column = str.length - last\n      } else {\n        column += str.length\n      }\n\n      if (node && type !== 'start') {\n        let p = node.parent || { raws: {} }\n        let childless =\n          node.type === 'decl' || (node.type === 'atrule' && !node.nodes)\n        if (!childless || node !== p.last || p.raws.semicolon) {\n          if (node.source && node.source.end) {\n            mapping.source = this.sourcePath(node)\n            mapping.original.line = node.source.end.line\n            mapping.original.column = node.source.end.column - 1\n            mapping.generated.line = line\n            mapping.generated.column = column - 2\n            this.map.addMapping(mapping)\n          } else {\n            mapping.source = noSource\n            mapping.original.line = 1\n            mapping.original.column = 0\n            mapping.generated.line = line\n            mapping.generated.column = column - 1\n            this.map.addMapping(mapping)\n          }\n        }\n      }\n    })\n  }\n\n  isAnnotation() {\n    if (this.isInline()) {\n      return true\n    }\n    if (typeof this.mapOpts.annotation !== 'undefined') {\n      return this.mapOpts.annotation\n    }\n    if (this.previous().length) {\n      return this.previous().some(i => i.annotation)\n    }\n    return true\n  }\n\n  isInline() {\n    if (typeof this.mapOpts.inline !== 'undefined') {\n      return this.mapOpts.inline\n    }\n\n    let annotation = this.mapOpts.annotation\n    if (typeof annotation !== 'undefined' && annotation !== true) {\n      return false\n    }\n\n    if (this.previous().length) {\n      return this.previous().some(i => i.inline)\n    }\n    return true\n  }\n\n  isMap() {\n    if (typeof this.opts.map !== 'undefined') {\n      return !!this.opts.map\n    }\n    return this.previous().length > 0\n  }\n\n  isSourcesContent() {\n    if (typeof this.mapOpts.sourcesContent !== 'undefined') {\n      return this.mapOpts.sourcesContent\n    }\n    if (this.previous().length) {\n      return this.previous().some(i => i.withContent())\n    }\n    return true\n  }\n\n  outputFile() {\n    if (this.opts.to) {\n      return this.path(this.opts.to)\n    } else if (this.opts.from) {\n      return this.path(this.opts.from)\n    } else {\n      return 'to.css'\n    }\n  }\n\n  path(file) {\n    if (this.mapOpts.absolute) return file\n    if (file.charCodeAt(0) === 60 /* `<` */) return file\n    if (/^\\w+:\\/\\//.test(file)) return file\n    let cached = this.memoizedPaths.get(file)\n    if (cached) return cached\n\n    let from = this.opts.to ? dirname(this.opts.to) : '.'\n\n    if (typeof this.mapOpts.annotation === 'string') {\n      from = dirname(resolve(from, this.mapOpts.annotation))\n    }\n\n    let path = relative(from, file)\n    this.memoizedPaths.set(file, path)\n\n    return path\n  }\n\n  previous() {\n    if (!this.previousMaps) {\n      this.previousMaps = []\n      if (this.root) {\n        this.root.walk(node => {\n          if (node.source && node.source.input.map) {\n            let map = node.source.input.map\n            if (!this.previousMaps.includes(map)) {\n              this.previousMaps.push(map)\n            }\n          }\n        })\n      } else {\n        let input = new Input(this.originalCSS, this.opts)\n        if (input.map) this.previousMaps.push(input.map)\n      }\n    }\n\n    return this.previousMaps\n  }\n\n  setSourcesContent() {\n    let already = {}\n    if (this.root) {\n      this.root.walk(node => {\n        if (node.source) {\n          let from = node.source.input.from\n          if (from && !already[from]) {\n            already[from] = true\n            let fromUrl = this.usesFileUrls\n              ? this.toFileUrl(from)\n              : this.toUrl(this.path(from))\n            this.map.setSourceContent(fromUrl, node.source.input.css)\n          }\n        }\n      })\n    } else if (this.css) {\n      let from = this.opts.from\n        ? this.toUrl(this.path(this.opts.from))\n        : '<no source>'\n      this.map.setSourceContent(from, this.css)\n    }\n  }\n\n  sourcePath(node) {\n    if (this.mapOpts.from) {\n      return this.toUrl(this.mapOpts.from)\n    } else if (this.usesFileUrls) {\n      return this.toFileUrl(node.source.input.from)\n    } else {\n      return this.toUrl(this.path(node.source.input.from))\n    }\n  }\n\n  toBase64(str) {\n    if (Buffer) {\n      return Buffer.from(str).toString('base64')\n    } else {\n      return window.btoa(unescape(encodeURIComponent(str)))\n    }\n  }\n\n  toFileUrl(path) {\n    let cached = this.memoizedFileURLs.get(path)\n    if (cached) return cached\n\n    if (pathToFileURL) {\n      let fileURL = pathToFileURL(path).toString()\n      this.memoizedFileURLs.set(path, fileURL)\n\n      return fileURL\n    } else {\n      throw new Error(\n        '`map.absolute` option is not available in this PostCSS build'\n      )\n    }\n  }\n\n  toUrl(path) {\n    let cached = this.memoizedURLs.get(path)\n    if (cached) return cached\n\n    if (sep === '\\\\') {\n      path = path.replace(/\\\\/g, '/')\n    }\n\n    let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent)\n    this.memoizedURLs.set(path, url)\n\n    return url\n  }\n}\n\nmodule.exports = MapGenerator\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvbWFwLWdlbmVyYXRvci5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7O0FBRVosTUFBTSxrQ0FBa0MsRUFBRSxtQkFBTyxDQUFDLG1CQUFNO0FBQ3hELE1BQU0sd0NBQXdDLEVBQUUsbUJBQU8sQ0FBQyw0QkFBZTtBQUN2RSxNQUFNLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsa0JBQUs7O0FBRXJDLFlBQVksbUJBQU8sQ0FBQyxvREFBUzs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsTUFBTTtBQUNkLGFBQWEsTUFBTTtBQUNuQixNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vamltaXB1bHNhckBnaXRodWIuY29tLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL21hcC1nZW5lcmF0b3IuanM/N2E3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IHsgZGlybmFtZSwgcmVsYXRpdmUsIHJlc29sdmUsIHNlcCB9ID0gcmVxdWlyZSgncGF0aCcpXG5sZXQgeyBTb3VyY2VNYXBDb25zdW1lciwgU291cmNlTWFwR2VuZXJhdG9yIH0gPSByZXF1aXJlKCdzb3VyY2UtbWFwLWpzJylcbmxldCB7IHBhdGhUb0ZpbGVVUkwgfSA9IHJlcXVpcmUoJ3VybCcpXG5cbmxldCBJbnB1dCA9IHJlcXVpcmUoJy4vaW5wdXQnKVxuXG5sZXQgc291cmNlTWFwQXZhaWxhYmxlID0gQm9vbGVhbihTb3VyY2VNYXBDb25zdW1lciAmJiBTb3VyY2VNYXBHZW5lcmF0b3IpXG5sZXQgcGF0aEF2YWlsYWJsZSA9IEJvb2xlYW4oZGlybmFtZSAmJiByZXNvbHZlICYmIHJlbGF0aXZlICYmIHNlcClcblxuY2xhc3MgTWFwR2VuZXJhdG9yIHtcbiAgY29uc3RydWN0b3Ioc3RyaW5naWZ5LCByb290LCBvcHRzLCBjc3NTdHJpbmcpIHtcbiAgICB0aGlzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeVxuICAgIHRoaXMubWFwT3B0cyA9IG9wdHMubWFwIHx8IHt9XG4gICAgdGhpcy5yb290ID0gcm9vdFxuICAgIHRoaXMub3B0cyA9IG9wdHNcbiAgICB0aGlzLmNzcyA9IGNzc1N0cmluZ1xuICAgIHRoaXMub3JpZ2luYWxDU1MgPSBjc3NTdHJpbmdcbiAgICB0aGlzLnVzZXNGaWxlVXJscyA9ICF0aGlzLm1hcE9wdHMuZnJvbSAmJiB0aGlzLm1hcE9wdHMuYWJzb2x1dGVcblxuICAgIHRoaXMubWVtb2l6ZWRGaWxlVVJMcyA9IG5ldyBNYXAoKVxuICAgIHRoaXMubWVtb2l6ZWRQYXRocyA9IG5ldyBNYXAoKVxuICAgIHRoaXMubWVtb2l6ZWRVUkxzID0gbmV3IE1hcCgpXG4gIH1cblxuICBhZGRBbm5vdGF0aW9uKCkge1xuICAgIGxldCBjb250ZW50XG5cbiAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XG4gICAgICBjb250ZW50ID1cbiAgICAgICAgJ2RhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIHRoaXMudG9CYXNlNjQodGhpcy5tYXAudG9TdHJpbmcoKSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb250ZW50ID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb24odGhpcy5vcHRzLnRvLCB0aGlzLnJvb3QpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLm91dHB1dEZpbGUoKSArICcubWFwJ1xuICAgIH1cbiAgICBsZXQgZW9sID0gJ1xcbidcbiAgICBpZiAodGhpcy5jc3MuaW5jbHVkZXMoJ1xcclxcbicpKSBlb2wgPSAnXFxyXFxuJ1xuXG4gICAgdGhpcy5jc3MgKz0gZW9sICsgJy8qIyBzb3VyY2VNYXBwaW5nVVJMPScgKyBjb250ZW50ICsgJyAqLydcbiAgfVxuXG4gIGFwcGx5UHJldk1hcHMoKSB7XG4gICAgZm9yIChsZXQgcHJldiBvZiB0aGlzLnByZXZpb3VzKCkpIHtcbiAgICAgIGxldCBmcm9tID0gdGhpcy50b1VybCh0aGlzLnBhdGgocHJldi5maWxlKSlcbiAgICAgIGxldCByb290ID0gcHJldi5yb290IHx8IGRpcm5hbWUocHJldi5maWxlKVxuICAgICAgbGV0IG1hcFxuXG4gICAgICBpZiAodGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50ID09PSBmYWxzZSkge1xuICAgICAgICBtYXAgPSBuZXcgU291cmNlTWFwQ29uc3VtZXIocHJldi50ZXh0KVxuICAgICAgICBpZiAobWFwLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXAgPSBwcmV2LmNvbnN1bWVyKClcbiAgICAgIH1cblxuICAgICAgdGhpcy5tYXAuYXBwbHlTb3VyY2VNYXAobWFwLCBmcm9tLCB0aGlzLnRvVXJsKHRoaXMucGF0aChyb290KSkpXG4gICAgfVxuICB9XG5cbiAgY2xlYXJBbm5vdGF0aW9uKCkge1xuICAgIGlmICh0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gZmFsc2UpIHJldHVyblxuXG4gICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgbGV0IG5vZGVcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLnJvb3Qubm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbm9kZSA9IHRoaXMucm9vdC5ub2Rlc1tpXVxuICAgICAgICBpZiAobm9kZS50eXBlICE9PSAnY29tbWVudCcpIGNvbnRpbnVlXG4gICAgICAgIGlmIChub2RlLnRleHQuc3RhcnRzV2l0aCgnIyBzb3VyY2VNYXBwaW5nVVJMPScpKSB7XG4gICAgICAgICAgdGhpcy5yb290LnJlbW92ZUNoaWxkKGkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuY3NzKSB7XG4gICAgICB0aGlzLmNzcyA9IHRoaXMuY3NzLnJlcGxhY2UoL1xcbipcXC9cXCojW1xcU1xcc10qP1xcKlxcLyQvZ20sICcnKVxuICAgIH1cbiAgfVxuXG4gIGdlbmVyYXRlKCkge1xuICAgIHRoaXMuY2xlYXJBbm5vdGF0aW9uKClcbiAgICBpZiAocGF0aEF2YWlsYWJsZSAmJiBzb3VyY2VNYXBBdmFpbGFibGUgJiYgdGhpcy5pc01hcCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZU1hcCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZXN1bHQgPSAnJ1xuICAgICAgdGhpcy5zdHJpbmdpZnkodGhpcy5yb290LCBpID0+IHtcbiAgICAgICAgcmVzdWx0ICs9IGlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gW3Jlc3VsdF1cbiAgICB9XG4gIH1cblxuICBnZW5lcmF0ZU1hcCgpIHtcbiAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICB0aGlzLmdlbmVyYXRlU3RyaW5nKClcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxldCBwcmV2ID0gdGhpcy5wcmV2aW91cygpWzBdLmNvbnN1bWVyKClcbiAgICAgIHByZXYuZmlsZSA9IHRoaXMub3V0cHV0RmlsZSgpXG4gICAgICB0aGlzLm1hcCA9IFNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwKHByZXYsIHtcbiAgICAgICAgaWdub3JlSW52YWxpZE1hcHBpbmc6IHRydWVcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICAgIGZpbGU6IHRoaXMub3V0cHV0RmlsZSgpLFxuICAgICAgICBpZ25vcmVJbnZhbGlkTWFwcGluZzogdHJ1ZVxuICAgICAgfSlcbiAgICAgIHRoaXMubWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICBnZW5lcmF0ZWQ6IHsgY29sdW1uOiAwLCBsaW5lOiAxIH0sXG4gICAgICAgIG9yaWdpbmFsOiB7IGNvbHVtbjogMCwgbGluZTogMSB9LFxuICAgICAgICBzb3VyY2U6IHRoaXMub3B0cy5mcm9tXG4gICAgICAgICAgPyB0aGlzLnRvVXJsKHRoaXMucGF0aCh0aGlzLm9wdHMuZnJvbSkpXG4gICAgICAgICAgOiAnPG5vIHNvdXJjZT4nXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0aGlzLmlzU291cmNlc0NvbnRlbnQoKSkgdGhpcy5zZXRTb3VyY2VzQ29udGVudCgpXG4gICAgaWYgKHRoaXMucm9vdCAmJiB0aGlzLnByZXZpb3VzKCkubGVuZ3RoID4gMCkgdGhpcy5hcHBseVByZXZNYXBzKClcbiAgICBpZiAodGhpcy5pc0Fubm90YXRpb24oKSkgdGhpcy5hZGRBbm5vdGF0aW9uKClcblxuICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgIHJldHVybiBbdGhpcy5jc3NdXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbdGhpcy5jc3MsIHRoaXMubWFwXVxuICAgIH1cbiAgfVxuXG4gIGdlbmVyYXRlU3RyaW5nKCkge1xuICAgIHRoaXMuY3NzID0gJydcbiAgICB0aGlzLm1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgZmlsZTogdGhpcy5vdXRwdXRGaWxlKCksXG4gICAgICBpZ25vcmVJbnZhbGlkTWFwcGluZzogdHJ1ZVxuICAgIH0pXG5cbiAgICBsZXQgbGluZSA9IDFcbiAgICBsZXQgY29sdW1uID0gMVxuXG4gICAgbGV0IG5vU291cmNlID0gJzxubyBzb3VyY2U+J1xuICAgIGxldCBtYXBwaW5nID0ge1xuICAgICAgZ2VuZXJhdGVkOiB7IGNvbHVtbjogMCwgbGluZTogMCB9LFxuICAgICAgb3JpZ2luYWw6IHsgY29sdW1uOiAwLCBsaW5lOiAwIH0sXG4gICAgICBzb3VyY2U6ICcnXG4gICAgfVxuXG4gICAgbGV0IGxhc3QsIGxpbmVzXG4gICAgdGhpcy5zdHJpbmdpZnkodGhpcy5yb290LCAoc3RyLCBub2RlLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLmNzcyArPSBzdHJcblxuICAgICAgaWYgKG5vZGUgJiYgdHlwZSAhPT0gJ2VuZCcpIHtcbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmVcbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQuY29sdW1uID0gY29sdW1uIC0gMVxuICAgICAgICBpZiAobm9kZS5zb3VyY2UgJiYgbm9kZS5zb3VyY2Uuc3RhcnQpIHtcbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHRoaXMuc291cmNlUGF0aChub2RlKVxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IG5vZGUuc291cmNlLnN0YXJ0LmxpbmVcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IG5vZGUuc291cmNlLnN0YXJ0LmNvbHVtbiAtIDFcbiAgICAgICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBub1NvdXJjZVxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IDFcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IDBcbiAgICAgICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGluZXMgPSBzdHIubWF0Y2goL1xcbi9nKVxuICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgIGxpbmUgKz0gbGluZXMubGVuZ3RoXG4gICAgICAgIGxhc3QgPSBzdHIubGFzdEluZGV4T2YoJ1xcbicpXG4gICAgICAgIGNvbHVtbiA9IHN0ci5sZW5ndGggLSBsYXN0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2x1bW4gKz0gc3RyLmxlbmd0aFxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSAmJiB0eXBlICE9PSAnc3RhcnQnKSB7XG4gICAgICAgIGxldCBwID0gbm9kZS5wYXJlbnQgfHwgeyByYXdzOiB7fSB9XG4gICAgICAgIGxldCBjaGlsZGxlc3MgPVxuICAgICAgICAgIG5vZGUudHlwZSA9PT0gJ2RlY2wnIHx8IChub2RlLnR5cGUgPT09ICdhdHJ1bGUnICYmICFub2RlLm5vZGVzKVxuICAgICAgICBpZiAoIWNoaWxkbGVzcyB8fCBub2RlICE9PSBwLmxhc3QgfHwgcC5yYXdzLnNlbWljb2xvbikge1xuICAgICAgICAgIGlmIChub2RlLnNvdXJjZSAmJiBub2RlLnNvdXJjZS5lbmQpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdGhpcy5zb3VyY2VQYXRoKG5vZGUpXG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSBub2RlLnNvdXJjZS5lbmQubGluZVxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSBub2RlLnNvdXJjZS5lbmQuY29sdW1uIC0gMVxuICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmVcbiAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDJcbiAgICAgICAgICAgIHRoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBub1NvdXJjZVxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5saW5lID0gMVxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSAwXG4gICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5saW5lID0gbGluZVxuICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQuY29sdW1uID0gY29sdW1uIC0gMVxuICAgICAgICAgICAgdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBpc0Fubm90YXRpb24oKSB7XG4gICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvblxuICAgIH1cbiAgICBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5zb21lKGkgPT4gaS5hbm5vdGF0aW9uKVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaXNJbmxpbmUoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuaW5saW5lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXMubWFwT3B0cy5pbmxpbmVcbiAgICB9XG5cbiAgICBsZXQgYW5ub3RhdGlvbiA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uXG4gICAgaWYgKHR5cGVvZiBhbm5vdGF0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBhbm5vdGF0aW9uICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5zb21lKGkgPT4gaS5pbmxpbmUpXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpc01hcCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5tYXAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gISF0aGlzLm9wdHMubWFwXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkubGVuZ3RoID4gMFxuICB9XG5cbiAgaXNTb3VyY2VzQ29udGVudCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5zb3VyY2VzQ29udGVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnRcbiAgICB9XG4gICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZShpID0+IGkud2l0aENvbnRlbnQoKSlcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIG91dHB1dEZpbGUoKSB7XG4gICAgaWYgKHRoaXMub3B0cy50bykge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aCh0aGlzLm9wdHMudG8pXG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdHMuZnJvbSkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aCh0aGlzLm9wdHMuZnJvbSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICd0by5jc3MnXG4gICAgfVxuICB9XG5cbiAgcGF0aChmaWxlKSB7XG4gICAgaWYgKHRoaXMubWFwT3B0cy5hYnNvbHV0ZSkgcmV0dXJuIGZpbGVcbiAgICBpZiAoZmlsZS5jaGFyQ29kZUF0KDApID09PSA2MCAvKiBgPGAgKi8pIHJldHVybiBmaWxlXG4gICAgaWYgKC9eXFx3KzpcXC9cXC8vLnRlc3QoZmlsZSkpIHJldHVybiBmaWxlXG4gICAgbGV0IGNhY2hlZCA9IHRoaXMubWVtb2l6ZWRQYXRocy5nZXQoZmlsZSlcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkXG5cbiAgICBsZXQgZnJvbSA9IHRoaXMub3B0cy50byA/IGRpcm5hbWUodGhpcy5vcHRzLnRvKSA6ICcuJ1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZyb20gPSBkaXJuYW1lKHJlc29sdmUoZnJvbSwgdGhpcy5tYXBPcHRzLmFubm90YXRpb24pKVxuICAgIH1cblxuICAgIGxldCBwYXRoID0gcmVsYXRpdmUoZnJvbSwgZmlsZSlcbiAgICB0aGlzLm1lbW9pemVkUGF0aHMuc2V0KGZpbGUsIHBhdGgpXG5cbiAgICByZXR1cm4gcGF0aFxuICB9XG5cbiAgcHJldmlvdXMoKSB7XG4gICAgaWYgKCF0aGlzLnByZXZpb3VzTWFwcykge1xuICAgICAgdGhpcy5wcmV2aW91c01hcHMgPSBbXVxuICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICB0aGlzLnJvb3Qud2Fsayhub2RlID0+IHtcbiAgICAgICAgICBpZiAobm9kZS5zb3VyY2UgJiYgbm9kZS5zb3VyY2UuaW5wdXQubWFwKSB7XG4gICAgICAgICAgICBsZXQgbWFwID0gbm9kZS5zb3VyY2UuaW5wdXQubWFwXG4gICAgICAgICAgICBpZiAoIXRoaXMucHJldmlvdXNNYXBzLmluY2x1ZGVzKG1hcCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c01hcHMucHVzaChtYXApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGlucHV0ID0gbmV3IElucHV0KHRoaXMub3JpZ2luYWxDU1MsIHRoaXMub3B0cylcbiAgICAgICAgaWYgKGlucHV0Lm1hcCkgdGhpcy5wcmV2aW91c01hcHMucHVzaChpbnB1dC5tYXApXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHJldmlvdXNNYXBzXG4gIH1cblxuICBzZXRTb3VyY2VzQ29udGVudCgpIHtcbiAgICBsZXQgYWxyZWFkeSA9IHt9XG4gICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgdGhpcy5yb290LndhbGsobm9kZSA9PiB7XG4gICAgICAgIGlmIChub2RlLnNvdXJjZSkge1xuICAgICAgICAgIGxldCBmcm9tID0gbm9kZS5zb3VyY2UuaW5wdXQuZnJvbVxuICAgICAgICAgIGlmIChmcm9tICYmICFhbHJlYWR5W2Zyb21dKSB7XG4gICAgICAgICAgICBhbHJlYWR5W2Zyb21dID0gdHJ1ZVxuICAgICAgICAgICAgbGV0IGZyb21VcmwgPSB0aGlzLnVzZXNGaWxlVXJsc1xuICAgICAgICAgICAgICA/IHRoaXMudG9GaWxlVXJsKGZyb20pXG4gICAgICAgICAgICAgIDogdGhpcy50b1VybCh0aGlzLnBhdGgoZnJvbSkpXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXRTb3VyY2VDb250ZW50KGZyb21VcmwsIG5vZGUuc291cmNlLmlucHV0LmNzcylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmICh0aGlzLmNzcykge1xuICAgICAgbGV0IGZyb20gPSB0aGlzLm9wdHMuZnJvbVxuICAgICAgICA/IHRoaXMudG9VcmwodGhpcy5wYXRoKHRoaXMub3B0cy5mcm9tKSlcbiAgICAgICAgOiAnPG5vIHNvdXJjZT4nXG4gICAgICB0aGlzLm1hcC5zZXRTb3VyY2VDb250ZW50KGZyb20sIHRoaXMuY3NzKVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZVBhdGgobm9kZSkge1xuICAgIGlmICh0aGlzLm1hcE9wdHMuZnJvbSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9VcmwodGhpcy5tYXBPcHRzLmZyb20pXG4gICAgfSBlbHNlIGlmICh0aGlzLnVzZXNGaWxlVXJscykge1xuICAgICAgcmV0dXJuIHRoaXMudG9GaWxlVXJsKG5vZGUuc291cmNlLmlucHV0LmZyb20pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnRvVXJsKHRoaXMucGF0aChub2RlLnNvdXJjZS5pbnB1dC5mcm9tKSlcbiAgICB9XG4gIH1cblxuICB0b0Jhc2U2NChzdHIpIHtcbiAgICBpZiAoQnVmZmVyKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyKS50b1N0cmluZygnYmFzZTY0JylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHdpbmRvdy5idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSlcbiAgICB9XG4gIH1cblxuICB0b0ZpbGVVcmwocGF0aCkge1xuICAgIGxldCBjYWNoZWQgPSB0aGlzLm1lbW9pemVkRmlsZVVSTHMuZ2V0KHBhdGgpXG4gICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZFxuXG4gICAgaWYgKHBhdGhUb0ZpbGVVUkwpIHtcbiAgICAgIGxldCBmaWxlVVJMID0gcGF0aFRvRmlsZVVSTChwYXRoKS50b1N0cmluZygpXG4gICAgICB0aGlzLm1lbW9pemVkRmlsZVVSTHMuc2V0KHBhdGgsIGZpbGVVUkwpXG5cbiAgICAgIHJldHVybiBmaWxlVVJMXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2BtYXAuYWJzb2x1dGVgIG9wdGlvbiBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgUG9zdENTUyBidWlsZCdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICB0b1VybChwYXRoKSB7XG4gICAgbGV0IGNhY2hlZCA9IHRoaXMubWVtb2l6ZWRVUkxzLmdldChwYXRoKVxuICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWRcblxuICAgIGlmIChzZXAgPT09ICdcXFxcJykge1xuICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpXG4gICAgfVxuXG4gICAgbGV0IHVybCA9IGVuY29kZVVSSShwYXRoKS5yZXBsYWNlKC9bIz9dL2csIGVuY29kZVVSSUNvbXBvbmVudClcbiAgICB0aGlzLm1lbW9pemVkVVJMcy5zZXQocGF0aCwgdXJsKVxuXG4gICAgcmV0dXJuIHVybFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwR2VuZXJhdG9yXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/map-generator.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/no-work-result.js":
/*!****************************************************!*\
  !*** ./node_modules/postcss/lib/no-work-result.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet MapGenerator = __webpack_require__(/*! ./map-generator */ \"./node_modules/postcss/lib/map-generator.js\")\nlet parse = __webpack_require__(/*! ./parse */ \"./node_modules/postcss/lib/parse.js\")\nconst Result = __webpack_require__(/*! ./result */ \"./node_modules/postcss/lib/result.js\")\nlet stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/postcss/lib/stringify.js\")\nlet warnOnce = __webpack_require__(/*! ./warn-once */ \"./node_modules/postcss/lib/warn-once.js\")\n\nclass NoWorkResult {\n  constructor(processor, css, opts) {\n    css = css.toString()\n    this.stringified = false\n\n    this._processor = processor\n    this._css = css\n    this._opts = opts\n    this._map = undefined\n    let root\n\n    let str = stringify\n    this.result = new Result(this._processor, root, this._opts)\n    this.result.css = css\n\n    let self = this\n    Object.defineProperty(this.result, 'root', {\n      get() {\n        return self.root\n      }\n    })\n\n    let map = new MapGenerator(str, root, this._opts, css)\n    if (map.isMap()) {\n      let [generatedCSS, generatedMap] = map.generate()\n      if (generatedCSS) {\n        this.result.css = generatedCSS\n      }\n      if (generatedMap) {\n        this.result.map = generatedMap\n      }\n    } else {\n      map.clearAnnotation()\n      this.result.css = map.css\n    }\n  }\n\n  async() {\n    if (this.error) return Promise.reject(this.error)\n    return Promise.resolve(this.result)\n  }\n\n  catch(onRejected) {\n    return this.async().catch(onRejected)\n  }\n\n  finally(onFinally) {\n    return this.async().then(onFinally, onFinally)\n  }\n\n  sync() {\n    if (this.error) throw this.error\n    return this.result\n  }\n\n  then(onFulfilled, onRejected) {\n    if (true) {\n      if (!('from' in this._opts)) {\n        warnOnce(\n          'Without `from` option PostCSS could generate wrong source map ' +\n            'and will not find Browserslist config. Set it to CSS file path ' +\n            'or to `undefined` to prevent this warning.'\n        )\n      }\n    }\n\n    return this.async().then(onFulfilled, onRejected)\n  }\n\n  toString() {\n    return this._css\n  }\n\n  warnings() {\n    return []\n  }\n\n  get content() {\n    return this.result.css\n  }\n\n  get css() {\n    return this.result.css\n  }\n\n  get map() {\n    return this.result.map\n  }\n\n  get messages() {\n    return []\n  }\n\n  get opts() {\n    return this.result.opts\n  }\n\n  get processor() {\n    return this.result.processor\n  }\n\n  get root() {\n    if (this._root) {\n      return this._root\n    }\n\n    let root\n    let parser = parse\n\n    try {\n      root = parser(this._css, this._opts)\n    } catch (error) {\n      this.error = error\n    }\n\n    if (this.error) {\n      throw this.error\n    } else {\n      this._root = root\n      return root\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'NoWorkResult'\n  }\n}\n\nmodule.exports = NoWorkResult\nNoWorkResult.default = NoWorkResult\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvbm8td29yay1yZXN1bHQuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosbUJBQW1CLG1CQUFPLENBQUMsb0VBQWlCO0FBQzVDLFlBQVksbUJBQU8sQ0FBQyxvREFBUztBQUM3QixlQUFlLG1CQUFPLENBQUMsc0RBQVU7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsNERBQWE7QUFDckMsZUFBZSxtQkFBTyxDQUFDLDREQUFhOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vamltaXB1bHNhckBnaXRodWIuY29tLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL25vLXdvcmstcmVzdWx0LmpzP2Q4OWUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmxldCBNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL21hcC1nZW5lcmF0b3InKVxubGV0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBSZXN1bHQgPSByZXF1aXJlKCcuL3Jlc3VsdCcpXG5sZXQgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKVxubGV0IHdhcm5PbmNlID0gcmVxdWlyZSgnLi93YXJuLW9uY2UnKVxuXG5jbGFzcyBOb1dvcmtSZXN1bHQge1xuICBjb25zdHJ1Y3Rvcihwcm9jZXNzb3IsIGNzcywgb3B0cykge1xuICAgIGNzcyA9IGNzcy50b1N0cmluZygpXG4gICAgdGhpcy5zdHJpbmdpZmllZCA9IGZhbHNlXG5cbiAgICB0aGlzLl9wcm9jZXNzb3IgPSBwcm9jZXNzb3JcbiAgICB0aGlzLl9jc3MgPSBjc3NcbiAgICB0aGlzLl9vcHRzID0gb3B0c1xuICAgIHRoaXMuX21hcCA9IHVuZGVmaW5lZFxuICAgIGxldCByb290XG5cbiAgICBsZXQgc3RyID0gc3RyaW5naWZ5XG4gICAgdGhpcy5yZXN1bHQgPSBuZXcgUmVzdWx0KHRoaXMuX3Byb2Nlc3Nvciwgcm9vdCwgdGhpcy5fb3B0cylcbiAgICB0aGlzLnJlc3VsdC5jc3MgPSBjc3NcblxuICAgIGxldCBzZWxmID0gdGhpc1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnJlc3VsdCwgJ3Jvb3QnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnJvb3RcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgbGV0IG1hcCA9IG5ldyBNYXBHZW5lcmF0b3Ioc3RyLCByb290LCB0aGlzLl9vcHRzLCBjc3MpXG4gICAgaWYgKG1hcC5pc01hcCgpKSB7XG4gICAgICBsZXQgW2dlbmVyYXRlZENTUywgZ2VuZXJhdGVkTWFwXSA9IG1hcC5nZW5lcmF0ZSgpXG4gICAgICBpZiAoZ2VuZXJhdGVkQ1NTKSB7XG4gICAgICAgIHRoaXMucmVzdWx0LmNzcyA9IGdlbmVyYXRlZENTU1xuICAgICAgfVxuICAgICAgaWYgKGdlbmVyYXRlZE1hcCkge1xuICAgICAgICB0aGlzLnJlc3VsdC5tYXAgPSBnZW5lcmF0ZWRNYXBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFwLmNsZWFyQW5ub3RhdGlvbigpXG4gICAgICB0aGlzLnJlc3VsdC5jc3MgPSBtYXAuY3NzXG4gICAgfVxuICB9XG5cbiAgYXN5bmMoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5yZXN1bHQpXG4gIH1cblxuICBjYXRjaChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuYXN5bmMoKS5jYXRjaChvblJlamVjdGVkKVxuICB9XG5cbiAgZmluYWxseShvbkZpbmFsbHkpIHtcbiAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GaW5hbGx5LCBvbkZpbmFsbHkpXG4gIH1cblxuICBzeW5jKCkge1xuICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yXG4gICAgcmV0dXJuIHRoaXMucmVzdWx0XG4gIH1cblxuICB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghKCdmcm9tJyBpbiB0aGlzLl9vcHRzKSkge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAnV2l0aG91dCBgZnJvbWAgb3B0aW9uIFBvc3RDU1MgY291bGQgZ2VuZXJhdGUgd3Jvbmcgc291cmNlIG1hcCAnICtcbiAgICAgICAgICAgICdhbmQgd2lsbCBub3QgZmluZCBCcm93c2Vyc2xpc3QgY29uZmlnLiBTZXQgaXQgdG8gQ1NTIGZpbGUgcGF0aCAnICtcbiAgICAgICAgICAgICdvciB0byBgdW5kZWZpbmVkYCB0byBwcmV2ZW50IHRoaXMgd2FybmluZy4nXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fY3NzXG4gIH1cblxuICB3YXJuaW5ncygpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIGdldCBjb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLnJlc3VsdC5jc3NcbiAgfVxuXG4gIGdldCBjc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdWx0LmNzc1xuICB9XG5cbiAgZ2V0IG1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQubWFwXG4gIH1cblxuICBnZXQgbWVzc2FnZXMoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICBnZXQgb3B0cygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQub3B0c1xuICB9XG5cbiAgZ2V0IHByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQucHJvY2Vzc29yXG4gIH1cblxuICBnZXQgcm9vdCgpIHtcbiAgICBpZiAodGhpcy5fcm9vdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RcbiAgICB9XG5cbiAgICBsZXQgcm9vdFxuICAgIGxldCBwYXJzZXIgPSBwYXJzZVxuXG4gICAgdHJ5IHtcbiAgICAgIHJvb3QgPSBwYXJzZXIodGhpcy5fY3NzLCB0aGlzLl9vcHRzKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmVycm9yID0gZXJyb3JcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5lcnJvclxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yb290ID0gcm9vdFxuICAgICAgcmV0dXJuIHJvb3RcbiAgICB9XG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdOb1dvcmtSZXN1bHQnXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOb1dvcmtSZXN1bHRcbk5vV29ya1Jlc3VsdC5kZWZhdWx0ID0gTm9Xb3JrUmVzdWx0XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/no-work-result.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/node.js":
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/node.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet CssSyntaxError = __webpack_require__(/*! ./css-syntax-error */ \"./node_modules/postcss/lib/css-syntax-error.js\")\nlet Stringifier = __webpack_require__(/*! ./stringifier */ \"./node_modules/postcss/lib/stringifier.js\")\nlet stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/postcss/lib/stringify.js\")\nlet { isClean, my } = __webpack_require__(/*! ./symbols */ \"./node_modules/postcss/lib/symbols.js\")\n\nfunction cloneNode(obj, parent) {\n  let cloned = new obj.constructor()\n\n  for (let i in obj) {\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) {\n      /* c8 ignore next 2 */\n      continue\n    }\n    if (i === 'proxyCache') continue\n    let value = obj[i]\n    let type = typeof value\n\n    if (i === 'parent' && type === 'object') {\n      if (parent) cloned[i] = parent\n    } else if (i === 'source') {\n      cloned[i] = value\n    } else if (Array.isArray(value)) {\n      cloned[i] = value.map(j => cloneNode(j, cloned))\n    } else {\n      if (type === 'object' && value !== null) value = cloneNode(value)\n      cloned[i] = value\n    }\n  }\n\n  return cloned\n}\n\nclass Node {\n  constructor(defaults = {}) {\n    this.raws = {}\n    this[isClean] = false\n    this[my] = true\n\n    for (let name in defaults) {\n      if (name === 'nodes') {\n        this.nodes = []\n        for (let node of defaults[name]) {\n          if (typeof node.clone === 'function') {\n            this.append(node.clone())\n          } else {\n            this.append(node)\n          }\n        }\n      } else {\n        this[name] = defaults[name]\n      }\n    }\n  }\n\n  addToError(error) {\n    error.postcssNode = this\n    if (error.stack && this.source && /\\n\\s{4}at /.test(error.stack)) {\n      let s = this.source\n      error.stack = error.stack.replace(\n        /\\n\\s{4}at /,\n        `$&${s.input.from}:${s.start.line}:${s.start.column}$&`\n      )\n    }\n    return error\n  }\n\n  after(add) {\n    this.parent.insertAfter(this, add)\n    return this\n  }\n\n  assign(overrides = {}) {\n    for (let name in overrides) {\n      this[name] = overrides[name]\n    }\n    return this\n  }\n\n  before(add) {\n    this.parent.insertBefore(this, add)\n    return this\n  }\n\n  cleanRaws(keepBetween) {\n    delete this.raws.before\n    delete this.raws.after\n    if (!keepBetween) delete this.raws.between\n  }\n\n  clone(overrides = {}) {\n    let cloned = cloneNode(this)\n    for (let name in overrides) {\n      cloned[name] = overrides[name]\n    }\n    return cloned\n  }\n\n  cloneAfter(overrides = {}) {\n    let cloned = this.clone(overrides)\n    this.parent.insertAfter(this, cloned)\n    return cloned\n  }\n\n  cloneBefore(overrides = {}) {\n    let cloned = this.clone(overrides)\n    this.parent.insertBefore(this, cloned)\n    return cloned\n  }\n\n  error(message, opts = {}) {\n    if (this.source) {\n      let { end, start } = this.rangeBy(opts)\n      return this.source.input.error(\n        message,\n        { column: start.column, line: start.line },\n        { column: end.column, line: end.line },\n        opts\n      )\n    }\n    return new CssSyntaxError(message)\n  }\n\n  getProxyProcessor() {\n    return {\n      get(node, prop) {\n        if (prop === 'proxyOf') {\n          return node\n        } else if (prop === 'root') {\n          return () => node.root().toProxy()\n        } else {\n          return node[prop]\n        }\n      },\n\n      set(node, prop, value) {\n        if (node[prop] === value) return true\n        node[prop] = value\n        if (\n          prop === 'prop' ||\n          prop === 'value' ||\n          prop === 'name' ||\n          prop === 'params' ||\n          prop === 'important' ||\n          /* c8 ignore next */\n          prop === 'text'\n        ) {\n          node.markDirty()\n        }\n        return true\n      }\n    }\n  }\n\n  /* c8 ignore next 3 */\n  markClean() {\n    this[isClean] = true\n  }\n\n  markDirty() {\n    if (this[isClean]) {\n      this[isClean] = false\n      let next = this\n      while ((next = next.parent)) {\n        next[isClean] = false\n      }\n    }\n  }\n\n  next() {\n    if (!this.parent) return undefined\n    let index = this.parent.index(this)\n    return this.parent.nodes[index + 1]\n  }\n\n  positionBy(opts, stringRepresentation) {\n    let pos = this.source.start\n    if (opts.index) {\n      pos = this.positionInside(opts.index, stringRepresentation)\n    } else if (opts.word) {\n      stringRepresentation = this.toString()\n      let index = stringRepresentation.indexOf(opts.word)\n      if (index !== -1) pos = this.positionInside(index, stringRepresentation)\n    }\n    return pos\n  }\n\n  positionInside(index, stringRepresentation) {\n    let string = stringRepresentation || this.toString()\n    let column = this.source.start.column\n    let line = this.source.start.line\n\n    for (let i = 0; i < index; i++) {\n      if (string[i] === '\\n') {\n        column = 1\n        line += 1\n      } else {\n        column += 1\n      }\n    }\n\n    return { column, line }\n  }\n\n  prev() {\n    if (!this.parent) return undefined\n    let index = this.parent.index(this)\n    return this.parent.nodes[index - 1]\n  }\n\n  rangeBy(opts) {\n    let start = {\n      column: this.source.start.column,\n      line: this.source.start.line\n    }\n    let end = this.source.end\n      ? {\n          column: this.source.end.column + 1,\n          line: this.source.end.line\n        }\n      : {\n          column: start.column + 1,\n          line: start.line\n        }\n\n    if (opts.word) {\n      let stringRepresentation = this.toString()\n      let index = stringRepresentation.indexOf(opts.word)\n      if (index !== -1) {\n        start = this.positionInside(index, stringRepresentation)\n        end = this.positionInside(\n          index + opts.word.length,\n          stringRepresentation\n        )\n      }\n    } else {\n      if (opts.start) {\n        start = {\n          column: opts.start.column,\n          line: opts.start.line\n        }\n      } else if (opts.index) {\n        start = this.positionInside(opts.index)\n      }\n\n      if (opts.end) {\n        end = {\n          column: opts.end.column,\n          line: opts.end.line\n        }\n      } else if (typeof opts.endIndex === 'number') {\n        end = this.positionInside(opts.endIndex)\n      } else if (opts.index) {\n        end = this.positionInside(opts.index + 1)\n      }\n    }\n\n    if (\n      end.line < start.line ||\n      (end.line === start.line && end.column <= start.column)\n    ) {\n      end = { column: start.column + 1, line: start.line }\n    }\n\n    return { end, start }\n  }\n\n  raw(prop, defaultType) {\n    let str = new Stringifier()\n    return str.raw(this, prop, defaultType)\n  }\n\n  remove() {\n    if (this.parent) {\n      this.parent.removeChild(this)\n    }\n    this.parent = undefined\n    return this\n  }\n\n  replaceWith(...nodes) {\n    if (this.parent) {\n      let bookmark = this\n      let foundSelf = false\n      for (let node of nodes) {\n        if (node === this) {\n          foundSelf = true\n        } else if (foundSelf) {\n          this.parent.insertAfter(bookmark, node)\n          bookmark = node\n        } else {\n          this.parent.insertBefore(bookmark, node)\n        }\n      }\n\n      if (!foundSelf) {\n        this.remove()\n      }\n    }\n\n    return this\n  }\n\n  root() {\n    let result = this\n    while (result.parent && result.parent.type !== 'document') {\n      result = result.parent\n    }\n    return result\n  }\n\n  toJSON(_, inputs) {\n    let fixed = {}\n    let emitInputs = inputs == null\n    inputs = inputs || new Map()\n    let inputsNextIndex = 0\n\n    for (let name in this) {\n      if (!Object.prototype.hasOwnProperty.call(this, name)) {\n        /* c8 ignore next 2 */\n        continue\n      }\n      if (name === 'parent' || name === 'proxyCache') continue\n      let value = this[name]\n\n      if (Array.isArray(value)) {\n        fixed[name] = value.map(i => {\n          if (typeof i === 'object' && i.toJSON) {\n            return i.toJSON(null, inputs)\n          } else {\n            return i\n          }\n        })\n      } else if (typeof value === 'object' && value.toJSON) {\n        fixed[name] = value.toJSON(null, inputs)\n      } else if (name === 'source') {\n        let inputId = inputs.get(value.input)\n        if (inputId == null) {\n          inputId = inputsNextIndex\n          inputs.set(value.input, inputsNextIndex)\n          inputsNextIndex++\n        }\n        fixed[name] = {\n          end: value.end,\n          inputId,\n          start: value.start\n        }\n      } else {\n        fixed[name] = value\n      }\n    }\n\n    if (emitInputs) {\n      fixed.inputs = [...inputs.keys()].map(input => input.toJSON())\n    }\n\n    return fixed\n  }\n\n  toProxy() {\n    if (!this.proxyCache) {\n      this.proxyCache = new Proxy(this, this.getProxyProcessor())\n    }\n    return this.proxyCache\n  }\n\n  toString(stringifier = stringify) {\n    if (stringifier.stringify) stringifier = stringifier.stringify\n    let result = ''\n    stringifier(this, i => {\n      result += i\n    })\n    return result\n  }\n\n  warn(result, text, opts) {\n    let data = { node: this }\n    for (let i in opts) data[i] = opts[i]\n    return result.warn(text, data)\n  }\n\n  get proxyOf() {\n    return this\n  }\n}\n\nmodule.exports = Node\nNode.default = Node\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixxQkFBcUIsbUJBQU8sQ0FBQywwRUFBb0I7QUFDakQsa0JBQWtCLG1CQUFPLENBQUMsZ0VBQWU7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsNERBQWE7QUFDckMsTUFBTSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyx3REFBVzs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLEVBQUU7QUFDOUM7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQixhQUFhLGFBQWEsR0FBRyxhQUFhLEdBQUcsZUFBZTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xELFVBQVUsb0NBQW9DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vamltaXB1bHNhckBnaXRodWIuY29tLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL25vZGUuanM/YjJlOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IENzc1N5bnRheEVycm9yID0gcmVxdWlyZSgnLi9jc3Mtc3ludGF4LWVycm9yJylcbmxldCBTdHJpbmdpZmllciA9IHJlcXVpcmUoJy4vc3RyaW5naWZpZXInKVxubGV0IHN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5JylcbmxldCB7IGlzQ2xlYW4sIG15IH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuXG5mdW5jdGlvbiBjbG9uZU5vZGUob2JqLCBwYXJlbnQpIHtcbiAgbGV0IGNsb25lZCA9IG5ldyBvYmouY29uc3RydWN0b3IoKVxuXG4gIGZvciAobGV0IGkgaW4gb2JqKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkge1xuICAgICAgLyogYzggaWdub3JlIG5leHQgMiAqL1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGkgPT09ICdwcm94eUNhY2hlJykgY29udGludWVcbiAgICBsZXQgdmFsdWUgPSBvYmpbaV1cbiAgICBsZXQgdHlwZSA9IHR5cGVvZiB2YWx1ZVxuXG4gICAgaWYgKGkgPT09ICdwYXJlbnQnICYmIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocGFyZW50KSBjbG9uZWRbaV0gPSBwYXJlbnRcbiAgICB9IGVsc2UgaWYgKGkgPT09ICdzb3VyY2UnKSB7XG4gICAgICBjbG9uZWRbaV0gPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGNsb25lZFtpXSA9IHZhbHVlLm1hcChqID0+IGNsb25lTm9kZShqLCBjbG9uZWQpKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHZhbHVlID0gY2xvbmVOb2RlKHZhbHVlKVxuICAgICAgY2xvbmVkW2ldID0gdmFsdWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xvbmVkXG59XG5cbmNsYXNzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0cyA9IHt9KSB7XG4gICAgdGhpcy5yYXdzID0ge31cbiAgICB0aGlzW2lzQ2xlYW5dID0gZmFsc2VcbiAgICB0aGlzW215XSA9IHRydWVcblxuICAgIGZvciAobGV0IG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAgIGlmIChuYW1lID09PSAnbm9kZXMnKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXVxuICAgICAgICBmb3IgKGxldCBub2RlIG9mIGRlZmF1bHRzW25hbWVdKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBub2RlLmNsb25lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZChub2RlLmNsb25lKCkpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5vZGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW25hbWVdID0gZGVmYXVsdHNbbmFtZV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhZGRUb0Vycm9yKGVycm9yKSB7XG4gICAgZXJyb3IucG9zdGNzc05vZGUgPSB0aGlzXG4gICAgaWYgKGVycm9yLnN0YWNrICYmIHRoaXMuc291cmNlICYmIC9cXG5cXHN7NH1hdCAvLnRlc3QoZXJyb3Iuc3RhY2spKSB7XG4gICAgICBsZXQgcyA9IHRoaXMuc291cmNlXG4gICAgICBlcnJvci5zdGFjayA9IGVycm9yLnN0YWNrLnJlcGxhY2UoXG4gICAgICAgIC9cXG5cXHN7NH1hdCAvLFxuICAgICAgICBgJCYke3MuaW5wdXQuZnJvbX06JHtzLnN0YXJ0LmxpbmV9OiR7cy5zdGFydC5jb2x1bW59JCZgXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBlcnJvclxuICB9XG5cbiAgYWZ0ZXIoYWRkKSB7XG4gICAgdGhpcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIodGhpcywgYWRkKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBhc3NpZ24ob3ZlcnJpZGVzID0ge30pIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIG92ZXJyaWRlcykge1xuICAgICAgdGhpc1tuYW1lXSA9IG92ZXJyaWRlc1tuYW1lXVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYmVmb3JlKGFkZCkge1xuICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBhZGQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGNsZWFuUmF3cyhrZWVwQmV0d2Vlbikge1xuICAgIGRlbGV0ZSB0aGlzLnJhd3MuYmVmb3JlXG4gICAgZGVsZXRlIHRoaXMucmF3cy5hZnRlclxuICAgIGlmICgha2VlcEJldHdlZW4pIGRlbGV0ZSB0aGlzLnJhd3MuYmV0d2VlblxuICB9XG5cbiAgY2xvbmUob3ZlcnJpZGVzID0ge30pIHtcbiAgICBsZXQgY2xvbmVkID0gY2xvbmVOb2RlKHRoaXMpXG4gICAgZm9yIChsZXQgbmFtZSBpbiBvdmVycmlkZXMpIHtcbiAgICAgIGNsb25lZFtuYW1lXSA9IG92ZXJyaWRlc1tuYW1lXVxuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkXG4gIH1cblxuICBjbG9uZUFmdGVyKG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgbGV0IGNsb25lZCA9IHRoaXMuY2xvbmUob3ZlcnJpZGVzKVxuICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVyKHRoaXMsIGNsb25lZClcbiAgICByZXR1cm4gY2xvbmVkXG4gIH1cblxuICBjbG9uZUJlZm9yZShvdmVycmlkZXMgPSB7fSkge1xuICAgIGxldCBjbG9uZWQgPSB0aGlzLmNsb25lKG92ZXJyaWRlcylcbiAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgY2xvbmVkKVxuICAgIHJldHVybiBjbG9uZWRcbiAgfVxuXG4gIGVycm9yKG1lc3NhZ2UsIG9wdHMgPSB7fSkge1xuICAgIGlmICh0aGlzLnNvdXJjZSkge1xuICAgICAgbGV0IHsgZW5kLCBzdGFydCB9ID0gdGhpcy5yYW5nZUJ5KG9wdHMpXG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2UuaW5wdXQuZXJyb3IoXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHsgY29sdW1uOiBzdGFydC5jb2x1bW4sIGxpbmU6IHN0YXJ0LmxpbmUgfSxcbiAgICAgICAgeyBjb2x1bW46IGVuZC5jb2x1bW4sIGxpbmU6IGVuZC5saW5lIH0sXG4gICAgICAgIG9wdHNcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDc3NTeW50YXhFcnJvcihtZXNzYWdlKVxuICB9XG5cbiAgZ2V0UHJveHlQcm9jZXNzb3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldChub2RlLCBwcm9wKSB7XG4gICAgICAgIGlmIChwcm9wID09PSAncHJveHlPZicpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZVxuICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdyb290Jykge1xuICAgICAgICAgIHJldHVybiAoKSA9PiBub2RlLnJvb3QoKS50b1Byb3h5KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbm9kZVtwcm9wXVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBzZXQobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5vZGVbcHJvcF0gPT09IHZhbHVlKSByZXR1cm4gdHJ1ZVxuICAgICAgICBub2RlW3Byb3BdID0gdmFsdWVcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3AgPT09ICdwcm9wJyB8fFxuICAgICAgICAgIHByb3AgPT09ICd2YWx1ZScgfHxcbiAgICAgICAgICBwcm9wID09PSAnbmFtZScgfHxcbiAgICAgICAgICBwcm9wID09PSAncGFyYW1zJyB8fFxuICAgICAgICAgIHByb3AgPT09ICdpbXBvcnRhbnQnIHx8XG4gICAgICAgICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBwcm9wID09PSAndGV4dCdcbiAgICAgICAgKSB7XG4gICAgICAgICAgbm9kZS5tYXJrRGlydHkoKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICBtYXJrQ2xlYW4oKSB7XG4gICAgdGhpc1tpc0NsZWFuXSA9IHRydWVcbiAgfVxuXG4gIG1hcmtEaXJ0eSgpIHtcbiAgICBpZiAodGhpc1tpc0NsZWFuXSkge1xuICAgICAgdGhpc1tpc0NsZWFuXSA9IGZhbHNlXG4gICAgICBsZXQgbmV4dCA9IHRoaXNcbiAgICAgIHdoaWxlICgobmV4dCA9IG5leHQucGFyZW50KSkge1xuICAgICAgICBuZXh0W2lzQ2xlYW5dID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZXh0KCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHJldHVybiB1bmRlZmluZWRcbiAgICBsZXQgaW5kZXggPSB0aGlzLnBhcmVudC5pbmRleCh0aGlzKVxuICAgIHJldHVybiB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleCArIDFdXG4gIH1cblxuICBwb3NpdGlvbkJ5KG9wdHMsIHN0cmluZ1JlcHJlc2VudGF0aW9uKSB7XG4gICAgbGV0IHBvcyA9IHRoaXMuc291cmNlLnN0YXJ0XG4gICAgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgIHBvcyA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5pbmRleCwgc3RyaW5nUmVwcmVzZW50YXRpb24pXG4gICAgfSBlbHNlIGlmIChvcHRzLndvcmQpIHtcbiAgICAgIHN0cmluZ1JlcHJlc2VudGF0aW9uID0gdGhpcy50b1N0cmluZygpXG4gICAgICBsZXQgaW5kZXggPSBzdHJpbmdSZXByZXNlbnRhdGlvbi5pbmRleE9mKG9wdHMud29yZClcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHBvcyA9IHRoaXMucG9zaXRpb25JbnNpZGUoaW5kZXgsIHN0cmluZ1JlcHJlc2VudGF0aW9uKVxuICAgIH1cbiAgICByZXR1cm4gcG9zXG4gIH1cblxuICBwb3NpdGlvbkluc2lkZShpbmRleCwgc3RyaW5nUmVwcmVzZW50YXRpb24pIHtcbiAgICBsZXQgc3RyaW5nID0gc3RyaW5nUmVwcmVzZW50YXRpb24gfHwgdGhpcy50b1N0cmluZygpXG4gICAgbGV0IGNvbHVtbiA9IHRoaXMuc291cmNlLnN0YXJ0LmNvbHVtblxuICAgIGxldCBsaW5lID0gdGhpcy5zb3VyY2Uuc3RhcnQubGluZVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICBpZiAoc3RyaW5nW2ldID09PSAnXFxuJykge1xuICAgICAgICBjb2x1bW4gPSAxXG4gICAgICAgIGxpbmUgKz0gMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sdW1uICs9IDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBjb2x1bW4sIGxpbmUgfVxuICB9XG5cbiAgcHJldigpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSByZXR1cm4gdW5kZWZpbmVkXG4gICAgbGV0IGluZGV4ID0gdGhpcy5wYXJlbnQuaW5kZXgodGhpcylcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZXNbaW5kZXggLSAxXVxuICB9XG5cbiAgcmFuZ2VCeShvcHRzKSB7XG4gICAgbGV0IHN0YXJ0ID0ge1xuICAgICAgY29sdW1uOiB0aGlzLnNvdXJjZS5zdGFydC5jb2x1bW4sXG4gICAgICBsaW5lOiB0aGlzLnNvdXJjZS5zdGFydC5saW5lXG4gICAgfVxuICAgIGxldCBlbmQgPSB0aGlzLnNvdXJjZS5lbmRcbiAgICAgID8ge1xuICAgICAgICAgIGNvbHVtbjogdGhpcy5zb3VyY2UuZW5kLmNvbHVtbiArIDEsXG4gICAgICAgICAgbGluZTogdGhpcy5zb3VyY2UuZW5kLmxpbmVcbiAgICAgICAgfVxuICAgICAgOiB7XG4gICAgICAgICAgY29sdW1uOiBzdGFydC5jb2x1bW4gKyAxLFxuICAgICAgICAgIGxpbmU6IHN0YXJ0LmxpbmVcbiAgICAgICAgfVxuXG4gICAgaWYgKG9wdHMud29yZCkge1xuICAgICAgbGV0IHN0cmluZ1JlcHJlc2VudGF0aW9uID0gdGhpcy50b1N0cmluZygpXG4gICAgICBsZXQgaW5kZXggPSBzdHJpbmdSZXByZXNlbnRhdGlvbi5pbmRleE9mKG9wdHMud29yZClcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4LCBzdHJpbmdSZXByZXNlbnRhdGlvbilcbiAgICAgICAgZW5kID0gdGhpcy5wb3NpdGlvbkluc2lkZShcbiAgICAgICAgICBpbmRleCArIG9wdHMud29yZC5sZW5ndGgsXG4gICAgICAgICAgc3RyaW5nUmVwcmVzZW50YXRpb25cbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0cy5zdGFydCkge1xuICAgICAgICBzdGFydCA9IHtcbiAgICAgICAgICBjb2x1bW46IG9wdHMuc3RhcnQuY29sdW1uLFxuICAgICAgICAgIGxpbmU6IG9wdHMuc3RhcnQubGluZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuaW5kZXgpXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLmVuZCkge1xuICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgY29sdW1uOiBvcHRzLmVuZC5jb2x1bW4sXG4gICAgICAgICAgbGluZTogb3B0cy5lbmQubGluZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLmVuZEluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgICBlbmQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuZW5kSW5kZXgpXG4gICAgICB9IGVsc2UgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgZW5kID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4ICsgMSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBlbmQubGluZSA8IHN0YXJ0LmxpbmUgfHxcbiAgICAgIChlbmQubGluZSA9PT0gc3RhcnQubGluZSAmJiBlbmQuY29sdW1uIDw9IHN0YXJ0LmNvbHVtbilcbiAgICApIHtcbiAgICAgIGVuZCA9IHsgY29sdW1uOiBzdGFydC5jb2x1bW4gKyAxLCBsaW5lOiBzdGFydC5saW5lIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBlbmQsIHN0YXJ0IH1cbiAgfVxuXG4gIHJhdyhwcm9wLCBkZWZhdWx0VHlwZSkge1xuICAgIGxldCBzdHIgPSBuZXcgU3RyaW5naWZpZXIoKVxuICAgIHJldHVybiBzdHIucmF3KHRoaXMsIHByb3AsIGRlZmF1bHRUeXBlKVxuICB9XG5cbiAgcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcylcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmVwbGFjZVdpdGgoLi4ubm9kZXMpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIGxldCBib29rbWFyayA9IHRoaXNcbiAgICAgIGxldCBmb3VuZFNlbGYgPSBmYWxzZVxuICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcykge1xuICAgICAgICAgIGZvdW5kU2VsZiA9IHRydWVcbiAgICAgICAgfSBlbHNlIGlmIChmb3VuZFNlbGYpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRBZnRlcihib29rbWFyaywgbm9kZSlcbiAgICAgICAgICBib29rbWFyayA9IG5vZGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoYm9va21hcmssIG5vZGUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFmb3VuZFNlbGYpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByb290KCkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzXG4gICAgd2hpbGUgKHJlc3VsdC5wYXJlbnQgJiYgcmVzdWx0LnBhcmVudC50eXBlICE9PSAnZG9jdW1lbnQnKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQucGFyZW50XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHRvSlNPTihfLCBpbnB1dHMpIHtcbiAgICBsZXQgZml4ZWQgPSB7fVxuICAgIGxldCBlbWl0SW5wdXRzID0gaW5wdXRzID09IG51bGxcbiAgICBpbnB1dHMgPSBpbnB1dHMgfHwgbmV3IE1hcCgpXG4gICAgbGV0IGlucHV0c05leHRJbmRleCA9IDBcblxuICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcykge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgbmFtZSkpIHtcbiAgICAgICAgLyogYzggaWdub3JlIG5leHQgMiAqL1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKG5hbWUgPT09ICdwYXJlbnQnIHx8IG5hbWUgPT09ICdwcm94eUNhY2hlJykgY29udGludWVcbiAgICAgIGxldCB2YWx1ZSA9IHRoaXNbbmFtZV1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGZpeGVkW25hbWVdID0gdmFsdWUubWFwKGkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ29iamVjdCcgJiYgaS50b0pTT04pIHtcbiAgICAgICAgICAgIHJldHVybiBpLnRvSlNPTihudWxsLCBpbnB1dHMpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLnRvSlNPTikge1xuICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlLnRvSlNPTihudWxsLCBpbnB1dHMpXG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdzb3VyY2UnKSB7XG4gICAgICAgIGxldCBpbnB1dElkID0gaW5wdXRzLmdldCh2YWx1ZS5pbnB1dClcbiAgICAgICAgaWYgKGlucHV0SWQgPT0gbnVsbCkge1xuICAgICAgICAgIGlucHV0SWQgPSBpbnB1dHNOZXh0SW5kZXhcbiAgICAgICAgICBpbnB1dHMuc2V0KHZhbHVlLmlucHV0LCBpbnB1dHNOZXh0SW5kZXgpXG4gICAgICAgICAgaW5wdXRzTmV4dEluZGV4KytcbiAgICAgICAgfVxuICAgICAgICBmaXhlZFtuYW1lXSA9IHtcbiAgICAgICAgICBlbmQ6IHZhbHVlLmVuZCxcbiAgICAgICAgICBpbnB1dElkLFxuICAgICAgICAgIHN0YXJ0OiB2YWx1ZS5zdGFydFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXhlZFtuYW1lXSA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVtaXRJbnB1dHMpIHtcbiAgICAgIGZpeGVkLmlucHV0cyA9IFsuLi5pbnB1dHMua2V5cygpXS5tYXAoaW5wdXQgPT4gaW5wdXQudG9KU09OKCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZpeGVkXG4gIH1cblxuICB0b1Byb3h5KCkge1xuICAgIGlmICghdGhpcy5wcm94eUNhY2hlKSB7XG4gICAgICB0aGlzLnByb3h5Q2FjaGUgPSBuZXcgUHJveHkodGhpcywgdGhpcy5nZXRQcm94eVByb2Nlc3NvcigpKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm94eUNhY2hlXG4gIH1cblxuICB0b1N0cmluZyhzdHJpbmdpZmllciA9IHN0cmluZ2lmeSkge1xuICAgIGlmIChzdHJpbmdpZmllci5zdHJpbmdpZnkpIHN0cmluZ2lmaWVyID0gc3RyaW5naWZpZXIuc3RyaW5naWZ5XG4gICAgbGV0IHJlc3VsdCA9ICcnXG4gICAgc3RyaW5naWZpZXIodGhpcywgaSA9PiB7XG4gICAgICByZXN1bHQgKz0gaVxuICAgIH0pXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgd2FybihyZXN1bHQsIHRleHQsIG9wdHMpIHtcbiAgICBsZXQgZGF0YSA9IHsgbm9kZTogdGhpcyB9XG4gICAgZm9yIChsZXQgaSBpbiBvcHRzKSBkYXRhW2ldID0gb3B0c1tpXVxuICAgIHJldHVybiByZXN1bHQud2Fybih0ZXh0LCBkYXRhKVxuICB9XG5cbiAgZ2V0IHByb3h5T2YoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVcbk5vZGUuZGVmYXVsdCA9IE5vZGVcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/node.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/parse.js":
/*!*******************************************!*\
  !*** ./node_modules/postcss/lib/parse.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\nlet Input = __webpack_require__(/*! ./input */ \"./node_modules/postcss/lib/input.js\")\nlet Parser = __webpack_require__(/*! ./parser */ \"./node_modules/postcss/lib/parser.js\")\n\nfunction parse(css, opts) {\n  let input = new Input(css, opts)\n  let parser = new Parser(input)\n  try {\n    parser.parse()\n  } catch (e) {\n    if (true) {\n      if (e.name === 'CssSyntaxError' && opts && opts.from) {\n        if (/\\.scss$/i.test(opts.from)) {\n          e.message +=\n            '\\nYou tried to parse SCSS with ' +\n            'the standard CSS parser; ' +\n            'try again with the postcss-scss parser'\n        } else if (/\\.sass/i.test(opts.from)) {\n          e.message +=\n            '\\nYou tried to parse Sass with ' +\n            'the standard CSS parser; ' +\n            'try again with the postcss-sass parser'\n        } else if (/\\.less$/i.test(opts.from)) {\n          e.message +=\n            '\\nYou tried to parse Less with ' +\n            'the standard CSS parser; ' +\n            'try again with the postcss-less parser'\n        }\n      }\n    }\n    throw e\n  }\n\n  return parser.root\n}\n\nmodule.exports = parse\nparse.default = parse\n\nContainer.registerParse(parse)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcGFyc2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZ0JBQWdCLG1CQUFPLENBQUMsNERBQWE7QUFDckMsWUFBWSxtQkFBTyxDQUFDLG9EQUFTO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxzREFBVTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vamltaXB1bHNhckBnaXRodWIuY29tLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL3BhcnNlLmpzPzM2MzMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmxldCBDb250YWluZXIgPSByZXF1aXJlKCcuL2NvbnRhaW5lcicpXG5sZXQgSW5wdXQgPSByZXF1aXJlKCcuL2lucHV0JylcbmxldCBQYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpXG5cbmZ1bmN0aW9uIHBhcnNlKGNzcywgb3B0cykge1xuICBsZXQgaW5wdXQgPSBuZXcgSW5wdXQoY3NzLCBvcHRzKVxuICBsZXQgcGFyc2VyID0gbmV3IFBhcnNlcihpbnB1dClcbiAgdHJ5IHtcbiAgICBwYXJzZXIucGFyc2UoKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChlLm5hbWUgPT09ICdDc3NTeW50YXhFcnJvcicgJiYgb3B0cyAmJiBvcHRzLmZyb20pIHtcbiAgICAgICAgaWYgKC9cXC5zY3NzJC9pLnRlc3Qob3B0cy5mcm9tKSkge1xuICAgICAgICAgIGUubWVzc2FnZSArPVxuICAgICAgICAgICAgJ1xcbllvdSB0cmllZCB0byBwYXJzZSBTQ1NTIHdpdGggJyArXG4gICAgICAgICAgICAndGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7ICcgK1xuICAgICAgICAgICAgJ3RyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLXNjc3MgcGFyc2VyJ1xuICAgICAgICB9IGVsc2UgaWYgKC9cXC5zYXNzL2kudGVzdChvcHRzLmZyb20pKSB7XG4gICAgICAgICAgZS5tZXNzYWdlICs9XG4gICAgICAgICAgICAnXFxuWW91IHRyaWVkIHRvIHBhcnNlIFNhc3Mgd2l0aCAnICtcbiAgICAgICAgICAgICd0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgJyArXG4gICAgICAgICAgICAndHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3Mtc2FzcyBwYXJzZXInXG4gICAgICAgIH0gZWxzZSBpZiAoL1xcLmxlc3MkL2kudGVzdChvcHRzLmZyb20pKSB7XG4gICAgICAgICAgZS5tZXNzYWdlICs9XG4gICAgICAgICAgICAnXFxuWW91IHRyaWVkIHRvIHBhcnNlIExlc3Mgd2l0aCAnICtcbiAgICAgICAgICAgICd0aGUgc3RhbmRhcmQgQ1NTIHBhcnNlcjsgJyArXG4gICAgICAgICAgICAndHJ5IGFnYWluIHdpdGggdGhlIHBvc3Rjc3MtbGVzcyBwYXJzZXInXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZVxuICB9XG5cbiAgcmV0dXJuIHBhcnNlci5yb290XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcbnBhcnNlLmRlZmF1bHQgPSBwYXJzZVxuXG5Db250YWluZXIucmVnaXN0ZXJQYXJzZShwYXJzZSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/parse.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/parser.js":
/*!********************************************!*\
  !*** ./node_modules/postcss/lib/parser.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet AtRule = __webpack_require__(/*! ./at-rule */ \"./node_modules/postcss/lib/at-rule.js\")\nlet Comment = __webpack_require__(/*! ./comment */ \"./node_modules/postcss/lib/comment.js\")\nlet Declaration = __webpack_require__(/*! ./declaration */ \"./node_modules/postcss/lib/declaration.js\")\nlet Root = __webpack_require__(/*! ./root */ \"./node_modules/postcss/lib/root.js\")\nlet Rule = __webpack_require__(/*! ./rule */ \"./node_modules/postcss/lib/rule.js\")\nlet tokenizer = __webpack_require__(/*! ./tokenize */ \"./node_modules/postcss/lib/tokenize.js\")\n\nconst SAFE_COMMENT_NEIGHBOR = {\n  empty: true,\n  space: true\n}\n\nfunction findLastWithPosition(tokens) {\n  for (let i = tokens.length - 1; i >= 0; i--) {\n    let token = tokens[i]\n    let pos = token[3] || token[2]\n    if (pos) return pos\n  }\n}\n\nclass Parser {\n  constructor(input) {\n    this.input = input\n\n    this.root = new Root()\n    this.current = this.root\n    this.spaces = ''\n    this.semicolon = false\n\n    this.createTokenizer()\n    this.root.source = { input, start: { column: 1, line: 1, offset: 0 } }\n  }\n\n  atrule(token) {\n    let node = new AtRule()\n    node.name = token[1].slice(1)\n    if (node.name === '') {\n      this.unnamedAtrule(node, token)\n    }\n    this.init(node, token[2])\n\n    let type\n    let prev\n    let shift\n    let last = false\n    let open = false\n    let params = []\n    let brackets = []\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n      type = token[0]\n\n      if (type === '(' || type === '[') {\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (type === '{' && brackets.length > 0) {\n        brackets.push('}')\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n      }\n\n      if (brackets.length === 0) {\n        if (type === ';') {\n          node.source.end = this.getPosition(token[2])\n          node.source.end.offset++\n          this.semicolon = true\n          break\n        } else if (type === '{') {\n          open = true\n          break\n        } else if (type === '}') {\n          if (params.length > 0) {\n            shift = params.length - 1\n            prev = params[shift]\n            while (prev && prev[0] === 'space') {\n              prev = params[--shift]\n            }\n            if (prev) {\n              node.source.end = this.getPosition(prev[3] || prev[2])\n              node.source.end.offset++\n            }\n          }\n          this.end(token)\n          break\n        } else {\n          params.push(token)\n        }\n      } else {\n        params.push(token)\n      }\n\n      if (this.tokenizer.endOfFile()) {\n        last = true\n        break\n      }\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params)\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params)\n      this.raw(node, 'params', params)\n      if (last) {\n        token = params[params.length - 1]\n        node.source.end = this.getPosition(token[3] || token[2])\n        node.source.end.offset++\n        this.spaces = node.raws.between\n        node.raws.between = ''\n      }\n    } else {\n      node.raws.afterName = ''\n      node.params = ''\n    }\n\n    if (open) {\n      node.nodes = []\n      this.current = node\n    }\n  }\n\n  checkMissedSemicolon(tokens) {\n    let colon = this.colon(tokens)\n    if (colon === false) return\n\n    let founded = 0\n    let token\n    for (let j = colon - 1; j >= 0; j--) {\n      token = tokens[j]\n      if (token[0] !== 'space') {\n        founded += 1\n        if (founded === 2) break\n      }\n    }\n    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.\n    // Then we need to return the colon after that word token. [3] is the \"end\" colon of that word.\n    // And because we need it after that one we do +1 to get the next one.\n    throw this.input.error(\n      'Missed semicolon',\n      token[0] === 'word' ? token[3] + 1 : token[2]\n    )\n  }\n\n  colon(tokens) {\n    let brackets = 0\n    let prev, token, type\n    for (let [i, element] of tokens.entries()) {\n      token = element\n      type = token[0]\n\n      if (type === '(') {\n        brackets += 1\n      }\n      if (type === ')') {\n        brackets -= 1\n      }\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token)\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue\n        } else {\n          return i\n        }\n      }\n\n      prev = token\n    }\n    return false\n  }\n\n  comment(token) {\n    let node = new Comment()\n    this.init(node, token[2])\n    node.source.end = this.getPosition(token[3] || token[2])\n    node.source.end.offset++\n\n    let text = token[1].slice(2, -2)\n    if (/^\\s*$/.test(text)) {\n      node.text = ''\n      node.raws.left = text\n      node.raws.right = ''\n    } else {\n      let match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/)\n      node.text = match[2]\n      node.raws.left = match[1]\n      node.raws.right = match[3]\n    }\n  }\n\n  createTokenizer() {\n    this.tokenizer = tokenizer(this.input)\n  }\n\n  decl(tokens, customProperty) {\n    let node = new Declaration()\n    this.init(node, tokens[0][2])\n\n    let last = tokens[tokens.length - 1]\n    if (last[0] === ';') {\n      this.semicolon = true\n      tokens.pop()\n    }\n\n    node.source.end = this.getPosition(\n      last[3] || last[2] || findLastWithPosition(tokens)\n    )\n    node.source.end.offset++\n\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens)\n      node.raws.before += tokens.shift()[1]\n    }\n    node.source.start = this.getPosition(tokens[0][2])\n\n    node.prop = ''\n    while (tokens.length) {\n      let type = tokens[0][0]\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break\n      }\n      node.prop += tokens.shift()[1]\n    }\n\n    node.raws.between = ''\n\n    let token\n    while (tokens.length) {\n      token = tokens.shift()\n\n      if (token[0] === ':') {\n        node.raws.between += token[1]\n        break\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token])\n        }\n        node.raws.between += token[1]\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0]\n      node.prop = node.prop.slice(1)\n    }\n\n    let firstSpaces = []\n    let next\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      firstSpaces.push(tokens.shift())\n    }\n\n    this.precheckMissedSemicolon(tokens)\n\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i]\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true\n        let string = this.stringFrom(tokens, i)\n        string = this.spacesFromEnd(tokens) + string\n        if (string !== ' !important') node.raws.important = string\n        break\n      } else if (token[1].toLowerCase() === 'important') {\n        let cache = tokens.slice(0)\n        let str = ''\n        for (let j = i; j > 0; j--) {\n          let type = cache[j][0]\n          if (str.trim().startsWith('!') && type !== 'space') {\n            break\n          }\n          str = cache.pop()[1] + str\n        }\n        if (str.trim().startsWith('!')) {\n          node.important = true\n          node.raws.important = str\n          tokens = cache\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break\n      }\n    }\n\n    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment')\n\n    if (hasWord) {\n      node.raws.between += firstSpaces.map(i => i[1]).join('')\n      firstSpaces = []\n    }\n    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty)\n\n    if (node.value.includes(':') && !customProperty) {\n      this.checkMissedSemicolon(tokens)\n    }\n  }\n\n  doubleColon(token) {\n    throw this.input.error(\n      'Double colon',\n      { offset: token[2] },\n      { offset: token[2] + token[1].length }\n    )\n  }\n\n  emptyRule(token) {\n    let node = new Rule()\n    this.init(node, token[2])\n    node.selector = ''\n    node.raws.between = ''\n    this.current = node\n  }\n\n  end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.semicolon = false\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n    this.spaces = ''\n\n    if (this.current.parent) {\n      this.current.source.end = this.getPosition(token[2])\n      this.current.source.end.offset++\n      this.current = this.current.parent\n    } else {\n      this.unexpectedClose(token)\n    }\n  }\n\n  endFile() {\n    if (this.current.parent) this.unclosedBlock()\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n    this.root.source.end = this.getPosition(this.tokenizer.position())\n  }\n\n  freeSemicolon(token) {\n    this.spaces += token[1]\n    if (this.current.nodes) {\n      let prev = this.current.nodes[this.current.nodes.length - 1]\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces\n        this.spaces = ''\n      }\n    }\n  }\n\n  // Helpers\n\n  getPosition(offset) {\n    let pos = this.input.fromOffset(offset)\n    return {\n      column: pos.col,\n      line: pos.line,\n      offset\n    }\n  }\n\n  init(node, offset) {\n    this.current.push(node)\n    node.source = {\n      input: this.input,\n      start: this.getPosition(offset)\n    }\n    node.raws.before = this.spaces\n    this.spaces = ''\n    if (node.type !== 'comment') this.semicolon = false\n  }\n\n  other(start) {\n    let end = false\n    let type = null\n    let colon = false\n    let bracket = null\n    let brackets = []\n    let customProperty = start[1].startsWith('--')\n\n    let tokens = []\n    let token = start\n    while (token) {\n      type = token[0]\n      tokens.push(token)\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (customProperty && colon && type === '{') {\n        if (!bracket) bracket = token\n        brackets.push('}')\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens, customProperty)\n            return\n          } else {\n            break\n          }\n        } else if (type === '{') {\n          this.rule(tokens)\n          return\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop())\n          end = true\n          break\n        } else if (type === ':') {\n          colon = true\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n        if (brackets.length === 0) bracket = null\n      }\n\n      token = this.tokenizer.nextToken()\n    }\n\n    if (this.tokenizer.endOfFile()) end = true\n    if (brackets.length > 0) this.unclosedBracket(bracket)\n\n    if (end && colon) {\n      if (!customProperty) {\n        while (tokens.length) {\n          token = tokens[tokens.length - 1][0]\n          if (token !== 'space' && token !== 'comment') break\n          this.tokenizer.back(tokens.pop())\n        }\n      }\n      this.decl(tokens, customProperty)\n    } else {\n      this.unknownWord(tokens)\n    }\n  }\n\n  parse() {\n    let token\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1]\n          break\n\n        case ';':\n          this.freeSemicolon(token)\n          break\n\n        case '}':\n          this.end(token)\n          break\n\n        case 'comment':\n          this.comment(token)\n          break\n\n        case 'at-word':\n          this.atrule(token)\n          break\n\n        case '{':\n          this.emptyRule(token)\n          break\n\n        default:\n          this.other(token)\n          break\n      }\n    }\n    this.endFile()\n  }\n\n  precheckMissedSemicolon(/* tokens */) {\n    // Hook for Safe Parser\n  }\n\n  raw(node, prop, tokens, customProperty) {\n    let token, type\n    let length = tokens.length\n    let value = ''\n    let clean = true\n    let next, prev\n\n    for (let i = 0; i < length; i += 1) {\n      token = tokens[i]\n      type = token[0]\n      if (type === 'space' && i === length - 1 && !customProperty) {\n        clean = false\n      } else if (type === 'comment') {\n        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty'\n        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty'\n        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\n          if (value.slice(-1) === ',') {\n            clean = false\n          } else {\n            value += token[1]\n          }\n        } else {\n          clean = false\n        }\n      } else {\n        value += token[1]\n      }\n    }\n    if (!clean) {\n      let raw = tokens.reduce((all, i) => all + i[1], '')\n      node.raws[prop] = { raw, value }\n    }\n    node[prop] = value\n  }\n\n  rule(tokens) {\n    tokens.pop()\n\n    let node = new Rule()\n    this.init(node, tokens[0][2])\n\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens)\n    this.raw(node, 'selector', tokens)\n    this.current = node\n  }\n\n  spacesAndCommentsFromEnd(tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  // Errors\n\n  spacesAndCommentsFromStart(tokens) {\n    let next\n    let spaces = ''\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      spaces += tokens.shift()[1]\n    }\n    return spaces\n  }\n\n  spacesFromEnd(tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  stringFrom(tokens, from) {\n    let result = ''\n    for (let i = from; i < tokens.length; i++) {\n      result += tokens[i][1]\n    }\n    tokens.splice(from, tokens.length - from)\n    return result\n  }\n\n  unclosedBlock() {\n    let pos = this.current.source.start\n    throw this.input.error('Unclosed block', pos.line, pos.column)\n  }\n\n  unclosedBracket(bracket) {\n    throw this.input.error(\n      'Unclosed bracket',\n      { offset: bracket[2] },\n      { offset: bracket[2] + 1 }\n    )\n  }\n\n  unexpectedClose(token) {\n    throw this.input.error(\n      'Unexpected }',\n      { offset: token[2] },\n      { offset: token[2] + 1 }\n    )\n  }\n\n  unknownWord(tokens) {\n    throw this.input.error(\n      'Unknown word',\n      { offset: tokens[0][2] },\n      { offset: tokens[0][2] + tokens[0][1].length }\n    )\n  }\n\n  unnamedAtrule(node, token) {\n    throw this.input.error(\n      'At-rule without name',\n      { offset: token[2] },\n      { offset: token[2] + token[1].length }\n    )\n  }\n}\n\nmodule.exports = Parser\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyx3REFBVztBQUNoQyxjQUFjLG1CQUFPLENBQUMsd0RBQVc7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsZ0VBQWU7QUFDekMsV0FBVyxtQkFBTyxDQUFDLGtEQUFRO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxrREFBUTtBQUMzQixnQkFBZ0IsbUJBQU8sQ0FBQywwREFBWTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLG9CQUFvQjtBQUM1Qix3QkFBd0I7QUFDeEIsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBK0M7QUFDdkQ7QUFDQSx3QkFBd0I7QUFDeEIsUUFBUTtBQUNSLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQW9CO0FBQzVCLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsUUFBUSxrQkFBa0I7QUFDMUIsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzQkFBc0I7QUFDOUIsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ppbWlwdWxzYXJAZ2l0aHViLmNvbS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9wYXJzZXIuanM/ZTkzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IEF0UnVsZSA9IHJlcXVpcmUoJy4vYXQtcnVsZScpXG5sZXQgQ29tbWVudCA9IHJlcXVpcmUoJy4vY29tbWVudCcpXG5sZXQgRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL2RlY2xhcmF0aW9uJylcbmxldCBSb290ID0gcmVxdWlyZSgnLi9yb290JylcbmxldCBSdWxlID0gcmVxdWlyZSgnLi9ydWxlJylcbmxldCB0b2tlbml6ZXIgPSByZXF1aXJlKCcuL3Rva2VuaXplJylcblxuY29uc3QgU0FGRV9DT01NRU5UX05FSUdIQk9SID0ge1xuICBlbXB0eTogdHJ1ZSxcbiAgc3BhY2U6IHRydWVcbn1cblxuZnVuY3Rpb24gZmluZExhc3RXaXRoUG9zaXRpb24odG9rZW5zKSB7XG4gIGZvciAobGV0IGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV1cbiAgICBsZXQgcG9zID0gdG9rZW5bM10gfHwgdG9rZW5bMl1cbiAgICBpZiAocG9zKSByZXR1cm4gcG9zXG4gIH1cbn1cblxuY2xhc3MgUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXRcblxuICAgIHRoaXMucm9vdCA9IG5ldyBSb290KClcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnJvb3RcbiAgICB0aGlzLnNwYWNlcyA9ICcnXG4gICAgdGhpcy5zZW1pY29sb24gPSBmYWxzZVxuXG4gICAgdGhpcy5jcmVhdGVUb2tlbml6ZXIoKVxuICAgIHRoaXMucm9vdC5zb3VyY2UgPSB7IGlucHV0LCBzdGFydDogeyBjb2x1bW46IDEsIGxpbmU6IDEsIG9mZnNldDogMCB9IH1cbiAgfVxuXG4gIGF0cnVsZSh0b2tlbikge1xuICAgIGxldCBub2RlID0gbmV3IEF0UnVsZSgpXG4gICAgbm9kZS5uYW1lID0gdG9rZW5bMV0uc2xpY2UoMSlcbiAgICBpZiAobm9kZS5uYW1lID09PSAnJykge1xuICAgICAgdGhpcy51bm5hbWVkQXRydWxlKG5vZGUsIHRva2VuKVxuICAgIH1cbiAgICB0aGlzLmluaXQobm9kZSwgdG9rZW5bMl0pXG5cbiAgICBsZXQgdHlwZVxuICAgIGxldCBwcmV2XG4gICAgbGV0IHNoaWZ0XG4gICAgbGV0IGxhc3QgPSBmYWxzZVxuICAgIGxldCBvcGVuID0gZmFsc2VcbiAgICBsZXQgcGFyYW1zID0gW11cbiAgICBsZXQgYnJhY2tldHMgPSBbXVxuXG4gICAgd2hpbGUgKCF0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkge1xuICAgICAgdG9rZW4gPSB0aGlzLnRva2VuaXplci5uZXh0VG9rZW4oKVxuICAgICAgdHlwZSA9IHRva2VuWzBdXG5cbiAgICAgIGlmICh0eXBlID09PSAnKCcgfHwgdHlwZSA9PT0gJ1snKSB7XG4gICAgICAgIGJyYWNrZXRzLnB1c2godHlwZSA9PT0gJygnID8gJyknIDogJ10nKVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAneycgJiYgYnJhY2tldHMubGVuZ3RoID4gMCkge1xuICAgICAgICBicmFja2V0cy5wdXNoKCd9JylcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gYnJhY2tldHNbYnJhY2tldHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgYnJhY2tldHMucG9wKClcbiAgICAgIH1cblxuICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJzsnKSB7XG4gICAgICAgICAgbm9kZS5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblsyXSlcbiAgICAgICAgICBub2RlLnNvdXJjZS5lbmQub2Zmc2V0KytcbiAgICAgICAgICB0aGlzLnNlbWljb2xvbiA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd7Jykge1xuICAgICAgICAgIG9wZW4gPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnfScpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNoaWZ0ID0gcGFyYW1zLmxlbmd0aCAtIDFcbiAgICAgICAgICAgIHByZXYgPSBwYXJhbXNbc2hpZnRdXG4gICAgICAgICAgICB3aGlsZSAocHJldiAmJiBwcmV2WzBdID09PSAnc3BhY2UnKSB7XG4gICAgICAgICAgICAgIHByZXYgPSBwYXJhbXNbLS1zaGlmdF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgIG5vZGUuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24ocHJldlszXSB8fCBwcmV2WzJdKVxuICAgICAgICAgICAgICBub2RlLnNvdXJjZS5lbmQub2Zmc2V0KytcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbmQodG9rZW4pXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJhbXMucHVzaCh0b2tlbilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zLnB1c2godG9rZW4pXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkge1xuICAgICAgICBsYXN0ID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUucmF3cy5iZXR3ZWVuID0gdGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21FbmQocGFyYW1zKVxuICAgIGlmIChwYXJhbXMubGVuZ3RoKSB7XG4gICAgICBub2RlLnJhd3MuYWZ0ZXJOYW1lID0gdGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21TdGFydChwYXJhbXMpXG4gICAgICB0aGlzLnJhdyhub2RlLCAncGFyYW1zJywgcGFyYW1zKVxuICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgdG9rZW4gPSBwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdXG4gICAgICAgIG5vZGUuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bM10gfHwgdG9rZW5bMl0pXG4gICAgICAgIG5vZGUuc291cmNlLmVuZC5vZmZzZXQrK1xuICAgICAgICB0aGlzLnNwYWNlcyA9IG5vZGUucmF3cy5iZXR3ZWVuXG4gICAgICAgIG5vZGUucmF3cy5iZXR3ZWVuID0gJydcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5yYXdzLmFmdGVyTmFtZSA9ICcnXG4gICAgICBub2RlLnBhcmFtcyA9ICcnXG4gICAgfVxuXG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIG5vZGUubm9kZXMgPSBbXVxuICAgICAgdGhpcy5jdXJyZW50ID0gbm9kZVxuICAgIH1cbiAgfVxuXG4gIGNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucykge1xuICAgIGxldCBjb2xvbiA9IHRoaXMuY29sb24odG9rZW5zKVxuICAgIGlmIChjb2xvbiA9PT0gZmFsc2UpIHJldHVyblxuXG4gICAgbGV0IGZvdW5kZWQgPSAwXG4gICAgbGV0IHRva2VuXG4gICAgZm9yIChsZXQgaiA9IGNvbG9uIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2pdXG4gICAgICBpZiAodG9rZW5bMF0gIT09ICdzcGFjZScpIHtcbiAgICAgICAgZm91bmRlZCArPSAxXG4gICAgICAgIGlmIChmb3VuZGVkID09PSAyKSBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgdG9rZW4gaXMgYSB3b3JkLCBlLmcuIGAhaW1wb3J0YW50YCwgYHJlZGAgb3IgYW55IG90aGVyIHZhbGlkIHByb3BlcnR5J3MgdmFsdWUuXG4gICAgLy8gVGhlbiB3ZSBuZWVkIHRvIHJldHVybiB0aGUgY29sb24gYWZ0ZXIgdGhhdCB3b3JkIHRva2VuLiBbM10gaXMgdGhlIFwiZW5kXCIgY29sb24gb2YgdGhhdCB3b3JkLlxuICAgIC8vIEFuZCBiZWNhdXNlIHdlIG5lZWQgaXQgYWZ0ZXIgdGhhdCBvbmUgd2UgZG8gKzEgdG8gZ2V0IHRoZSBuZXh0IG9uZS5cbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgJ01pc3NlZCBzZW1pY29sb24nLFxuICAgICAgdG9rZW5bMF0gPT09ICd3b3JkJyA/IHRva2VuWzNdICsgMSA6IHRva2VuWzJdXG4gICAgKVxuICB9XG5cbiAgY29sb24odG9rZW5zKSB7XG4gICAgbGV0IGJyYWNrZXRzID0gMFxuICAgIGxldCBwcmV2LCB0b2tlbiwgdHlwZVxuICAgIGZvciAobGV0IFtpLCBlbGVtZW50XSBvZiB0b2tlbnMuZW50cmllcygpKSB7XG4gICAgICB0b2tlbiA9IGVsZW1lbnRcbiAgICAgIHR5cGUgPSB0b2tlblswXVxuXG4gICAgICBpZiAodHlwZSA9PT0gJygnKSB7XG4gICAgICAgIGJyYWNrZXRzICs9IDFcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnKScpIHtcbiAgICAgICAgYnJhY2tldHMgLT0gMVxuICAgICAgfVxuICAgICAgaWYgKGJyYWNrZXRzID09PSAwICYmIHR5cGUgPT09ICc6Jykge1xuICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICB0aGlzLmRvdWJsZUNvbG9uKHRva2VuKVxuICAgICAgICB9IGVsc2UgaWYgKHByZXZbMF0gPT09ICd3b3JkJyAmJiBwcmV2WzFdID09PSAncHJvZ2lkJykge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2ID0gdG9rZW5cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb21tZW50KHRva2VuKSB7XG4gICAgbGV0IG5vZGUgPSBuZXcgQ29tbWVudCgpXG4gICAgdGhpcy5pbml0KG5vZGUsIHRva2VuWzJdKVxuICAgIG5vZGUuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bM10gfHwgdG9rZW5bMl0pXG4gICAgbm9kZS5zb3VyY2UuZW5kLm9mZnNldCsrXG5cbiAgICBsZXQgdGV4dCA9IHRva2VuWzFdLnNsaWNlKDIsIC0yKVxuICAgIGlmICgvXlxccyokLy50ZXN0KHRleHQpKSB7XG4gICAgICBub2RlLnRleHQgPSAnJ1xuICAgICAgbm9kZS5yYXdzLmxlZnQgPSB0ZXh0XG4gICAgICBub2RlLnJhd3MucmlnaHQgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWF0Y2ggPSB0ZXh0Lm1hdGNoKC9eKFxccyopKFteXSpcXFMpKFxccyopJC8pXG4gICAgICBub2RlLnRleHQgPSBtYXRjaFsyXVxuICAgICAgbm9kZS5yYXdzLmxlZnQgPSBtYXRjaFsxXVxuICAgICAgbm9kZS5yYXdzLnJpZ2h0ID0gbWF0Y2hbM11cbiAgICB9XG4gIH1cblxuICBjcmVhdGVUb2tlbml6ZXIoKSB7XG4gICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXIodGhpcy5pbnB1dClcbiAgfVxuXG4gIGRlY2wodG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSkge1xuICAgIGxldCBub2RlID0gbmV3IERlY2xhcmF0aW9uKClcbiAgICB0aGlzLmluaXQobm9kZSwgdG9rZW5zWzBdWzJdKVxuXG4gICAgbGV0IGxhc3QgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdXG4gICAgaWYgKGxhc3RbMF0gPT09ICc7Jykge1xuICAgICAgdGhpcy5zZW1pY29sb24gPSB0cnVlXG4gICAgICB0b2tlbnMucG9wKClcbiAgICB9XG5cbiAgICBub2RlLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKFxuICAgICAgbGFzdFszXSB8fCBsYXN0WzJdIHx8IGZpbmRMYXN0V2l0aFBvc2l0aW9uKHRva2VucylcbiAgICApXG4gICAgbm9kZS5zb3VyY2UuZW5kLm9mZnNldCsrXG5cbiAgICB3aGlsZSAodG9rZW5zWzBdWzBdICE9PSAnd29yZCcpIHtcbiAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB0aGlzLnVua25vd25Xb3JkKHRva2VucylcbiAgICAgIG5vZGUucmF3cy5iZWZvcmUgKz0gdG9rZW5zLnNoaWZ0KClbMV1cbiAgICB9XG4gICAgbm9kZS5zb3VyY2Uuc3RhcnQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2Vuc1swXVsyXSlcblxuICAgIG5vZGUucHJvcCA9ICcnXG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGxldCB0eXBlID0gdG9rZW5zWzBdWzBdXG4gICAgICBpZiAodHlwZSA9PT0gJzonIHx8IHR5cGUgPT09ICdzcGFjZScgfHwgdHlwZSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBub2RlLnByb3AgKz0gdG9rZW5zLnNoaWZ0KClbMV1cbiAgICB9XG5cbiAgICBub2RlLnJhd3MuYmV0d2VlbiA9ICcnXG5cbiAgICBsZXQgdG9rZW5cbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgdG9rZW4gPSB0b2tlbnMuc2hpZnQoKVxuXG4gICAgICBpZiAodG9rZW5bMF0gPT09ICc6Jykge1xuICAgICAgICBub2RlLnJhd3MuYmV0d2VlbiArPSB0b2tlblsxXVxuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRva2VuWzBdID09PSAnd29yZCcgJiYgL1xcdy8udGVzdCh0b2tlblsxXSkpIHtcbiAgICAgICAgICB0aGlzLnVua25vd25Xb3JkKFt0b2tlbl0pXG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5yYXdzLmJldHdlZW4gKz0gdG9rZW5bMV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS5wcm9wWzBdID09PSAnXycgfHwgbm9kZS5wcm9wWzBdID09PSAnKicpIHtcbiAgICAgIG5vZGUucmF3cy5iZWZvcmUgKz0gbm9kZS5wcm9wWzBdXG4gICAgICBub2RlLnByb3AgPSBub2RlLnByb3Auc2xpY2UoMSlcbiAgICB9XG5cbiAgICBsZXQgZmlyc3RTcGFjZXMgPSBbXVxuICAgIGxldCBuZXh0XG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIG5leHQgPSB0b2tlbnNbMF1bMF1cbiAgICAgIGlmIChuZXh0ICE9PSAnc3BhY2UnICYmIG5leHQgIT09ICdjb21tZW50JykgYnJlYWtcbiAgICAgIGZpcnN0U3BhY2VzLnB1c2godG9rZW5zLnNoaWZ0KCkpXG4gICAgfVxuXG4gICAgdGhpcy5wcmVjaGVja01pc3NlZFNlbWljb2xvbih0b2tlbnMpXG5cbiAgICBmb3IgKGxldCBpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXVxuICAgICAgaWYgKHRva2VuWzFdLnRvTG93ZXJDYXNlKCkgPT09ICchaW1wb3J0YW50Jykge1xuICAgICAgICBub2RlLmltcG9ydGFudCA9IHRydWVcbiAgICAgICAgbGV0IHN0cmluZyA9IHRoaXMuc3RyaW5nRnJvbSh0b2tlbnMsIGkpXG4gICAgICAgIHN0cmluZyA9IHRoaXMuc3BhY2VzRnJvbUVuZCh0b2tlbnMpICsgc3RyaW5nXG4gICAgICAgIGlmIChzdHJpbmcgIT09ICcgIWltcG9ydGFudCcpIG5vZGUucmF3cy5pbXBvcnRhbnQgPSBzdHJpbmdcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAodG9rZW5bMV0udG9Mb3dlckNhc2UoKSA9PT0gJ2ltcG9ydGFudCcpIHtcbiAgICAgICAgbGV0IGNhY2hlID0gdG9rZW5zLnNsaWNlKDApXG4gICAgICAgIGxldCBzdHIgPSAnJ1xuICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA+IDA7IGotLSkge1xuICAgICAgICAgIGxldCB0eXBlID0gY2FjaGVbal1bMF1cbiAgICAgICAgICBpZiAoc3RyLnRyaW0oKS5zdGFydHNXaXRoKCchJykgJiYgdHlwZSAhPT0gJ3NwYWNlJykge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyID0gY2FjaGUucG9wKClbMV0gKyBzdHJcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLnRyaW0oKS5zdGFydHNXaXRoKCchJykpIHtcbiAgICAgICAgICBub2RlLmltcG9ydGFudCA9IHRydWVcbiAgICAgICAgICBub2RlLnJhd3MuaW1wb3J0YW50ID0gc3RyXG4gICAgICAgICAgdG9rZW5zID0gY2FjaGVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW5bMF0gIT09ICdzcGFjZScgJiYgdG9rZW5bMF0gIT09ICdjb21tZW50Jykge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBoYXNXb3JkID0gdG9rZW5zLnNvbWUoaSA9PiBpWzBdICE9PSAnc3BhY2UnICYmIGlbMF0gIT09ICdjb21tZW50JylcblxuICAgIGlmIChoYXNXb3JkKSB7XG4gICAgICBub2RlLnJhd3MuYmV0d2VlbiArPSBmaXJzdFNwYWNlcy5tYXAoaSA9PiBpWzFdKS5qb2luKCcnKVxuICAgICAgZmlyc3RTcGFjZXMgPSBbXVxuICAgIH1cbiAgICB0aGlzLnJhdyhub2RlLCAndmFsdWUnLCBmaXJzdFNwYWNlcy5jb25jYXQodG9rZW5zKSwgY3VzdG9tUHJvcGVydHkpXG5cbiAgICBpZiAobm9kZS52YWx1ZS5pbmNsdWRlcygnOicpICYmICFjdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgdGhpcy5jaGVja01pc3NlZFNlbWljb2xvbih0b2tlbnMpXG4gICAgfVxuICB9XG5cbiAgZG91YmxlQ29sb24odG9rZW4pIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgJ0RvdWJsZSBjb2xvbicsXG4gICAgICB7IG9mZnNldDogdG9rZW5bMl0gfSxcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSArIHRva2VuWzFdLmxlbmd0aCB9XG4gICAgKVxuICB9XG5cbiAgZW1wdHlSdWxlKHRva2VuKSB7XG4gICAgbGV0IG5vZGUgPSBuZXcgUnVsZSgpXG4gICAgdGhpcy5pbml0KG5vZGUsIHRva2VuWzJdKVxuICAgIG5vZGUuc2VsZWN0b3IgPSAnJ1xuICAgIG5vZGUucmF3cy5iZXR3ZWVuID0gJydcbiAgICB0aGlzLmN1cnJlbnQgPSBub2RlXG4gIH1cblxuICBlbmQodG9rZW4pIHtcbiAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzICYmIHRoaXMuY3VycmVudC5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY3VycmVudC5yYXdzLnNlbWljb2xvbiA9IHRoaXMuc2VtaWNvbG9uXG4gICAgfVxuICAgIHRoaXMuc2VtaWNvbG9uID0gZmFsc2VcblxuICAgIHRoaXMuY3VycmVudC5yYXdzLmFmdGVyID0gKHRoaXMuY3VycmVudC5yYXdzLmFmdGVyIHx8ICcnKSArIHRoaXMuc3BhY2VzXG4gICAgdGhpcy5zcGFjZXMgPSAnJ1xuXG4gICAgaWYgKHRoaXMuY3VycmVudC5wYXJlbnQpIHtcbiAgICAgIHRoaXMuY3VycmVudC5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblsyXSlcbiAgICAgIHRoaXMuY3VycmVudC5zb3VyY2UuZW5kLm9mZnNldCsrXG4gICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmN1cnJlbnQucGFyZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZENsb3NlKHRva2VuKVxuICAgIH1cbiAgfVxuXG4gIGVuZEZpbGUoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC5wYXJlbnQpIHRoaXMudW5jbG9zZWRCbG9jaygpXG4gICAgaWYgKHRoaXMuY3VycmVudC5ub2RlcyAmJiB0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmN1cnJlbnQucmF3cy5zZW1pY29sb24gPSB0aGlzLnNlbWljb2xvblxuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQucmF3cy5hZnRlciA9ICh0aGlzLmN1cnJlbnQucmF3cy5hZnRlciB8fCAnJykgKyB0aGlzLnNwYWNlc1xuICAgIHRoaXMucm9vdC5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0aGlzLnRva2VuaXplci5wb3NpdGlvbigpKVxuICB9XG5cbiAgZnJlZVNlbWljb2xvbih0b2tlbikge1xuICAgIHRoaXMuc3BhY2VzICs9IHRva2VuWzFdXG4gICAgaWYgKHRoaXMuY3VycmVudC5ub2Rlcykge1xuICAgICAgbGV0IHByZXYgPSB0aGlzLmN1cnJlbnQubm9kZXNbdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCAtIDFdXG4gICAgICBpZiAocHJldiAmJiBwcmV2LnR5cGUgPT09ICdydWxlJyAmJiAhcHJldi5yYXdzLm93blNlbWljb2xvbikge1xuICAgICAgICBwcmV2LnJhd3Mub3duU2VtaWNvbG9uID0gdGhpcy5zcGFjZXNcbiAgICAgICAgdGhpcy5zcGFjZXMgPSAnJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEhlbHBlcnNcblxuICBnZXRQb3NpdGlvbihvZmZzZXQpIHtcbiAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5mcm9tT2Zmc2V0KG9mZnNldClcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uOiBwb3MuY29sLFxuICAgICAgbGluZTogcG9zLmxpbmUsXG4gICAgICBvZmZzZXRcbiAgICB9XG4gIH1cblxuICBpbml0KG5vZGUsIG9mZnNldCkge1xuICAgIHRoaXMuY3VycmVudC5wdXNoKG5vZGUpXG4gICAgbm9kZS5zb3VyY2UgPSB7XG4gICAgICBpbnB1dDogdGhpcy5pbnB1dCxcbiAgICAgIHN0YXJ0OiB0aGlzLmdldFBvc2l0aW9uKG9mZnNldClcbiAgICB9XG4gICAgbm9kZS5yYXdzLmJlZm9yZSA9IHRoaXMuc3BhY2VzXG4gICAgdGhpcy5zcGFjZXMgPSAnJ1xuICAgIGlmIChub2RlLnR5cGUgIT09ICdjb21tZW50JykgdGhpcy5zZW1pY29sb24gPSBmYWxzZVxuICB9XG5cbiAgb3RoZXIoc3RhcnQpIHtcbiAgICBsZXQgZW5kID0gZmFsc2VcbiAgICBsZXQgdHlwZSA9IG51bGxcbiAgICBsZXQgY29sb24gPSBmYWxzZVxuICAgIGxldCBicmFja2V0ID0gbnVsbFxuICAgIGxldCBicmFja2V0cyA9IFtdXG4gICAgbGV0IGN1c3RvbVByb3BlcnR5ID0gc3RhcnRbMV0uc3RhcnRzV2l0aCgnLS0nKVxuXG4gICAgbGV0IHRva2VucyA9IFtdXG4gICAgbGV0IHRva2VuID0gc3RhcnRcbiAgICB3aGlsZSAodG9rZW4pIHtcbiAgICAgIHR5cGUgPSB0b2tlblswXVxuICAgICAgdG9rZW5zLnB1c2godG9rZW4pXG5cbiAgICAgIGlmICh0eXBlID09PSAnKCcgfHwgdHlwZSA9PT0gJ1snKSB7XG4gICAgICAgIGlmICghYnJhY2tldCkgYnJhY2tldCA9IHRva2VuXG4gICAgICAgIGJyYWNrZXRzLnB1c2godHlwZSA9PT0gJygnID8gJyknIDogJ10nKVxuICAgICAgfSBlbHNlIGlmIChjdXN0b21Qcm9wZXJ0eSAmJiBjb2xvbiAmJiB0eXBlID09PSAneycpIHtcbiAgICAgICAgaWYgKCFicmFja2V0KSBicmFja2V0ID0gdG9rZW5cbiAgICAgICAgYnJhY2tldHMucHVzaCgnfScpXG4gICAgICB9IGVsc2UgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJzsnKSB7XG4gICAgICAgICAgaWYgKGNvbG9uKSB7XG4gICAgICAgICAgICB0aGlzLmRlY2wodG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSlcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAneycpIHtcbiAgICAgICAgICB0aGlzLnJ1bGUodG9rZW5zKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd9Jykge1xuICAgICAgICAgIHRoaXMudG9rZW5pemVyLmJhY2sodG9rZW5zLnBvcCgpKVxuICAgICAgICAgIGVuZCA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICc6Jykge1xuICAgICAgICAgIGNvbG9uID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IGJyYWNrZXRzW2JyYWNrZXRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIGJyYWNrZXRzLnBvcCgpXG4gICAgICAgIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIGJyYWNrZXQgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKClcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpIGVuZCA9IHRydWVcbiAgICBpZiAoYnJhY2tldHMubGVuZ3RoID4gMCkgdGhpcy51bmNsb3NlZEJyYWNrZXQoYnJhY2tldClcblxuICAgIGlmIChlbmQgJiYgY29sb24pIHtcbiAgICAgIGlmICghY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICB0b2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1bMF1cbiAgICAgICAgICBpZiAodG9rZW4gIT09ICdzcGFjZScgJiYgdG9rZW4gIT09ICdjb21tZW50JykgYnJlYWtcbiAgICAgICAgICB0aGlzLnRva2VuaXplci5iYWNrKHRva2Vucy5wb3AoKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5kZWNsKHRva2VucywgY3VzdG9tUHJvcGVydHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5rbm93bldvcmQodG9rZW5zKVxuICAgIH1cbiAgfVxuXG4gIHBhcnNlKCkge1xuICAgIGxldCB0b2tlblxuICAgIHdoaWxlICghdGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpIHtcbiAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKClcblxuICAgICAgc3dpdGNoICh0b2tlblswXSkge1xuICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgdGhpcy5zcGFjZXMgKz0gdG9rZW5bMV1cbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJzsnOlxuICAgICAgICAgIHRoaXMuZnJlZVNlbWljb2xvbih0b2tlbilcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgIHRoaXMuZW5kKHRva2VuKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgdGhpcy5jb21tZW50KHRva2VuKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnYXQtd29yZCc6XG4gICAgICAgICAgdGhpcy5hdHJ1bGUodG9rZW4pXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICB0aGlzLmVtcHR5UnVsZSh0b2tlbilcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5vdGhlcih0b2tlbilcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVuZEZpbGUoKVxuICB9XG5cbiAgcHJlY2hlY2tNaXNzZWRTZW1pY29sb24oLyogdG9rZW5zICovKSB7XG4gICAgLy8gSG9vayBmb3IgU2FmZSBQYXJzZXJcbiAgfVxuXG4gIHJhdyhub2RlLCBwcm9wLCB0b2tlbnMsIGN1c3RvbVByb3BlcnR5KSB7XG4gICAgbGV0IHRva2VuLCB0eXBlXG4gICAgbGV0IGxlbmd0aCA9IHRva2Vucy5sZW5ndGhcbiAgICBsZXQgdmFsdWUgPSAnJ1xuICAgIGxldCBjbGVhbiA9IHRydWVcbiAgICBsZXQgbmV4dCwgcHJldlxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV1cbiAgICAgIHR5cGUgPSB0b2tlblswXVxuICAgICAgaWYgKHR5cGUgPT09ICdzcGFjZScgJiYgaSA9PT0gbGVuZ3RoIC0gMSAmJiAhY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgY2xlYW4gPSBmYWxzZVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnY29tbWVudCcpIHtcbiAgICAgICAgcHJldiA9IHRva2Vuc1tpIC0gMV0gPyB0b2tlbnNbaSAtIDFdWzBdIDogJ2VtcHR5J1xuICAgICAgICBuZXh0ID0gdG9rZW5zW2kgKyAxXSA/IHRva2Vuc1tpICsgMV1bMF0gOiAnZW1wdHknXG4gICAgICAgIGlmICghU0FGRV9DT01NRU5UX05FSUdIQk9SW3ByZXZdICYmICFTQUZFX0NPTU1FTlRfTkVJR0hCT1JbbmV4dF0pIHtcbiAgICAgICAgICBpZiAodmFsdWUuc2xpY2UoLTEpID09PSAnLCcpIHtcbiAgICAgICAgICAgIGNsZWFuID0gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgKz0gdG9rZW5bMV1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYW4gPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSArPSB0b2tlblsxXVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNsZWFuKSB7XG4gICAgICBsZXQgcmF3ID0gdG9rZW5zLnJlZHVjZSgoYWxsLCBpKSA9PiBhbGwgKyBpWzFdLCAnJylcbiAgICAgIG5vZGUucmF3c1twcm9wXSA9IHsgcmF3LCB2YWx1ZSB9XG4gICAgfVxuICAgIG5vZGVbcHJvcF0gPSB2YWx1ZVxuICB9XG5cbiAgcnVsZSh0b2tlbnMpIHtcbiAgICB0b2tlbnMucG9wKClcblxuICAgIGxldCBub2RlID0gbmV3IFJ1bGUoKVxuICAgIHRoaXMuaW5pdChub2RlLCB0b2tlbnNbMF1bMl0pXG5cbiAgICBub2RlLnJhd3MuYmV0d2VlbiA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHRva2VucylcbiAgICB0aGlzLnJhdyhub2RlLCAnc2VsZWN0b3InLCB0b2tlbnMpXG4gICAgdGhpcy5jdXJyZW50ID0gbm9kZVxuICB9XG5cbiAgc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHRva2Vucykge1xuICAgIGxldCBsYXN0VG9rZW5UeXBlXG4gICAgbGV0IHNwYWNlcyA9ICcnXG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGxhc3RUb2tlblR5cGUgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdWzBdXG4gICAgICBpZiAobGFzdFRva2VuVHlwZSAhPT0gJ3NwYWNlJyAmJiBsYXN0VG9rZW5UeXBlICE9PSAnY29tbWVudCcpIGJyZWFrXG4gICAgICBzcGFjZXMgPSB0b2tlbnMucG9wKClbMV0gKyBzcGFjZXNcbiAgICB9XG4gICAgcmV0dXJuIHNwYWNlc1xuICB9XG5cbiAgLy8gRXJyb3JzXG5cbiAgc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQodG9rZW5zKSB7XG4gICAgbGV0IG5leHRcbiAgICBsZXQgc3BhY2VzID0gJydcbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgbmV4dCA9IHRva2Vuc1swXVswXVxuICAgICAgaWYgKG5leHQgIT09ICdzcGFjZScgJiYgbmV4dCAhPT0gJ2NvbW1lbnQnKSBicmVha1xuICAgICAgc3BhY2VzICs9IHRva2Vucy5zaGlmdCgpWzFdXG4gICAgfVxuICAgIHJldHVybiBzcGFjZXNcbiAgfVxuXG4gIHNwYWNlc0Zyb21FbmQodG9rZW5zKSB7XG4gICAgbGV0IGxhc3RUb2tlblR5cGVcbiAgICBsZXQgc3BhY2VzID0gJydcbiAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgbGFzdFRva2VuVHlwZSA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1bMF1cbiAgICAgIGlmIChsYXN0VG9rZW5UeXBlICE9PSAnc3BhY2UnKSBicmVha1xuICAgICAgc3BhY2VzID0gdG9rZW5zLnBvcCgpWzFdICsgc3BhY2VzXG4gICAgfVxuICAgIHJldHVybiBzcGFjZXNcbiAgfVxuXG4gIHN0cmluZ0Zyb20odG9rZW5zLCBmcm9tKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnXG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdCArPSB0b2tlbnNbaV1bMV1cbiAgICB9XG4gICAgdG9rZW5zLnNwbGljZShmcm9tLCB0b2tlbnMubGVuZ3RoIC0gZnJvbSlcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICB1bmNsb3NlZEJsb2NrKCkge1xuICAgIGxldCBwb3MgPSB0aGlzLmN1cnJlbnQuc291cmNlLnN0YXJ0XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcignVW5jbG9zZWQgYmxvY2snLCBwb3MubGluZSwgcG9zLmNvbHVtbilcbiAgfVxuXG4gIHVuY2xvc2VkQnJhY2tldChicmFja2V0KSB7XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcbiAgICAgICdVbmNsb3NlZCBicmFja2V0JyxcbiAgICAgIHsgb2Zmc2V0OiBicmFja2V0WzJdIH0sXG4gICAgICB7IG9mZnNldDogYnJhY2tldFsyXSArIDEgfVxuICAgIClcbiAgfVxuXG4gIHVuZXhwZWN0ZWRDbG9zZSh0b2tlbikge1xuICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXG4gICAgICAnVW5leHBlY3RlZCB9JyxcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdICsgMSB9XG4gICAgKVxuICB9XG5cbiAgdW5rbm93bldvcmQodG9rZW5zKSB7XG4gICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcbiAgICAgICdVbmtub3duIHdvcmQnLFxuICAgICAgeyBvZmZzZXQ6IHRva2Vuc1swXVsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IHRva2Vuc1swXVsyXSArIHRva2Vuc1swXVsxXS5sZW5ndGggfVxuICAgIClcbiAgfVxuXG4gIHVubmFtZWRBdHJ1bGUobm9kZSwgdG9rZW4pIHtcbiAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFxuICAgICAgJ0F0LXJ1bGUgd2l0aG91dCBuYW1lJyxcbiAgICAgIHsgb2Zmc2V0OiB0b2tlblsyXSB9LFxuICAgICAgeyBvZmZzZXQ6IHRva2VuWzJdICsgdG9rZW5bMV0ubGVuZ3RoIH1cbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/parser.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/postcss.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/postcss.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n\n\nlet AtRule = __webpack_require__(/*! ./at-rule */ \"./node_modules/postcss/lib/at-rule.js\")\nlet Comment = __webpack_require__(/*! ./comment */ \"./node_modules/postcss/lib/comment.js\")\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\nlet CssSyntaxError = __webpack_require__(/*! ./css-syntax-error */ \"./node_modules/postcss/lib/css-syntax-error.js\")\nlet Declaration = __webpack_require__(/*! ./declaration */ \"./node_modules/postcss/lib/declaration.js\")\nlet Document = __webpack_require__(/*! ./document */ \"./node_modules/postcss/lib/document.js\")\nlet fromJSON = __webpack_require__(/*! ./fromJSON */ \"./node_modules/postcss/lib/fromJSON.js\")\nlet Input = __webpack_require__(/*! ./input */ \"./node_modules/postcss/lib/input.js\")\nlet LazyResult = __webpack_require__(/*! ./lazy-result */ \"./node_modules/postcss/lib/lazy-result.js\")\nlet list = __webpack_require__(/*! ./list */ \"./node_modules/postcss/lib/list.js\")\nlet Node = __webpack_require__(/*! ./node */ \"./node_modules/postcss/lib/node.js\")\nlet parse = __webpack_require__(/*! ./parse */ \"./node_modules/postcss/lib/parse.js\")\nlet Processor = __webpack_require__(/*! ./processor */ \"./node_modules/postcss/lib/processor.js\")\nlet Result = __webpack_require__(/*! ./result.js */ \"./node_modules/postcss/lib/result.js\")\nlet Root = __webpack_require__(/*! ./root */ \"./node_modules/postcss/lib/root.js\")\nlet Rule = __webpack_require__(/*! ./rule */ \"./node_modules/postcss/lib/rule.js\")\nlet stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/postcss/lib/stringify.js\")\nlet Warning = __webpack_require__(/*! ./warning */ \"./node_modules/postcss/lib/warning.js\")\n\nfunction postcss(...plugins) {\n  if (plugins.length === 1 && Array.isArray(plugins[0])) {\n    plugins = plugins[0]\n  }\n  return new Processor(plugins)\n}\n\npostcss.plugin = function plugin(name, initializer) {\n  let warningPrinted = false\n  function creator(...args) {\n    // eslint-disable-next-line no-console\n    if (console && console.warn && !warningPrinted) {\n      warningPrinted = true\n      // eslint-disable-next-line no-console\n      console.warn(\n        name +\n          ': postcss.plugin was deprecated. Migration guide:\\n' +\n          'https://evilmartians.com/chronicles/postcss-8-plugin-migration'\n      )\n      if (process.env.LANG && process.env.LANG.startsWith('cn')) {\n        /* c8 ignore next 7 */\n        // eslint-disable-next-line no-console\n        console.warn(\n          name +\n            ':  postcss.plugin . :\\n' +\n            'https://www.w3ctech.com/topic/2226'\n        )\n      }\n    }\n    let transformer = initializer(...args)\n    transformer.postcssPlugin = name\n    transformer.postcssVersion = new Processor().version\n    return transformer\n  }\n\n  let cache\n  Object.defineProperty(creator, 'postcss', {\n    get() {\n      if (!cache) cache = creator()\n      return cache\n    }\n  })\n\n  creator.process = function (css, processOpts, pluginOpts) {\n    return postcss([creator(pluginOpts)]).process(css, processOpts)\n  }\n\n  return creator\n}\n\npostcss.stringify = stringify\npostcss.parse = parse\npostcss.fromJSON = fromJSON\npostcss.list = list\n\npostcss.comment = defaults => new Comment(defaults)\npostcss.atRule = defaults => new AtRule(defaults)\npostcss.decl = defaults => new Declaration(defaults)\npostcss.rule = defaults => new Rule(defaults)\npostcss.root = defaults => new Root(defaults)\npostcss.document = defaults => new Document(defaults)\n\npostcss.CssSyntaxError = CssSyntaxError\npostcss.Declaration = Declaration\npostcss.Container = Container\npostcss.Processor = Processor\npostcss.Document = Document\npostcss.Comment = Comment\npostcss.Warning = Warning\npostcss.AtRule = AtRule\npostcss.Result = Result\npostcss.Input = Input\npostcss.Rule = Rule\npostcss.Root = Root\npostcss.Node = Node\n\nLazyResult.registerPostcss(postcss)\n\nmodule.exports = postcss\npostcss.default = postcss\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcG9zdGNzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLHdEQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyx3REFBVztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBYTtBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQywwRUFBb0I7QUFDakQsa0JBQWtCLG1CQUFPLENBQUMsZ0VBQWU7QUFDekMsZUFBZSxtQkFBTyxDQUFDLDBEQUFZO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQywwREFBWTtBQUNuQyxZQUFZLG1CQUFPLENBQUMsb0RBQVM7QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsZ0VBQWU7QUFDeEMsV0FBVyxtQkFBTyxDQUFDLGtEQUFRO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxrREFBUTtBQUMzQixZQUFZLG1CQUFPLENBQUMsb0RBQVM7QUFDN0IsZ0JBQWdCLG1CQUFPLENBQUMsNERBQWE7QUFDckMsYUFBYSxtQkFBTyxDQUFDLHlEQUFhO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQyxrREFBUTtBQUMzQixXQUFXLG1CQUFPLENBQUMsa0RBQVE7QUFDM0IsZ0JBQWdCLG1CQUFPLENBQUMsNERBQWE7QUFDckMsY0FBYyxtQkFBTyxDQUFDLHdEQUFXOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPLGFBQWEsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qaW1pcHVsc2FyQGdpdGh1Yi5jb20vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcG9zdGNzcy5qcz9hYWNiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5sZXQgQXRSdWxlID0gcmVxdWlyZSgnLi9hdC1ydWxlJylcbmxldCBDb21tZW50ID0gcmVxdWlyZSgnLi9jb21tZW50JylcbmxldCBDb250YWluZXIgPSByZXF1aXJlKCcuL2NvbnRhaW5lcicpXG5sZXQgQ3NzU3ludGF4RXJyb3IgPSByZXF1aXJlKCcuL2Nzcy1zeW50YXgtZXJyb3InKVxubGV0IERlY2xhcmF0aW9uID0gcmVxdWlyZSgnLi9kZWNsYXJhdGlvbicpXG5sZXQgRG9jdW1lbnQgPSByZXF1aXJlKCcuL2RvY3VtZW50JylcbmxldCBmcm9tSlNPTiA9IHJlcXVpcmUoJy4vZnJvbUpTT04nKVxubGV0IElucHV0ID0gcmVxdWlyZSgnLi9pbnB1dCcpXG5sZXQgTGF6eVJlc3VsdCA9IHJlcXVpcmUoJy4vbGF6eS1yZXN1bHQnKVxubGV0IGxpc3QgPSByZXF1aXJlKCcuL2xpc3QnKVxubGV0IE5vZGUgPSByZXF1aXJlKCcuL25vZGUnKVxubGV0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5sZXQgUHJvY2Vzc29yID0gcmVxdWlyZSgnLi9wcm9jZXNzb3InKVxubGV0IFJlc3VsdCA9IHJlcXVpcmUoJy4vcmVzdWx0LmpzJylcbmxldCBSb290ID0gcmVxdWlyZSgnLi9yb290JylcbmxldCBSdWxlID0gcmVxdWlyZSgnLi9ydWxlJylcbmxldCBzdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpXG5sZXQgV2FybmluZyA9IHJlcXVpcmUoJy4vd2FybmluZycpXG5cbmZ1bmN0aW9uIHBvc3Rjc3MoLi4ucGx1Z2lucykge1xuICBpZiAocGx1Z2lucy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShwbHVnaW5zWzBdKSkge1xuICAgIHBsdWdpbnMgPSBwbHVnaW5zWzBdXG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9jZXNzb3IocGx1Z2lucylcbn1cblxucG9zdGNzcy5wbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4obmFtZSwgaW5pdGlhbGl6ZXIpIHtcbiAgbGV0IHdhcm5pbmdQcmludGVkID0gZmFsc2VcbiAgZnVuY3Rpb24gY3JlYXRvciguLi5hcmdzKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4gJiYgIXdhcm5pbmdQcmludGVkKSB7XG4gICAgICB3YXJuaW5nUHJpbnRlZCA9IHRydWVcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIG5hbWUgK1xuICAgICAgICAgICc6IHBvc3Rjc3MucGx1Z2luIHdhcyBkZXByZWNhdGVkLiBNaWdyYXRpb24gZ3VpZGU6XFxuJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZXZpbG1hcnRpYW5zLmNvbS9jaHJvbmljbGVzL3Bvc3Rjc3MtOC1wbHVnaW4tbWlncmF0aW9uJ1xuICAgICAgKVxuICAgICAgaWYgKHByb2Nlc3MuZW52LkxBTkcgJiYgcHJvY2Vzcy5lbnYuTEFORy5zdGFydHNXaXRoKCdjbicpKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDcgKi9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIG5hbWUgK1xuICAgICAgICAgICAgJzog6YeM6Z2iIHBvc3Rjc3MucGx1Z2luIOiiq+W8g+eUqC4g6L+B56e75oyH5Y2XOlxcbicgK1xuICAgICAgICAgICAgJ2h0dHBzOi8vd3d3LnczY3RlY2guY29tL3RvcGljLzIyMjYnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRyYW5zZm9ybWVyID0gaW5pdGlhbGl6ZXIoLi4uYXJncylcbiAgICB0cmFuc2Zvcm1lci5wb3N0Y3NzUGx1Z2luID0gbmFtZVxuICAgIHRyYW5zZm9ybWVyLnBvc3Rjc3NWZXJzaW9uID0gbmV3IFByb2Nlc3NvcigpLnZlcnNpb25cbiAgICByZXR1cm4gdHJhbnNmb3JtZXJcbiAgfVxuXG4gIGxldCBjYWNoZVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRvciwgJ3Bvc3Rjc3MnLCB7XG4gICAgZ2V0KCkge1xuICAgICAgaWYgKCFjYWNoZSkgY2FjaGUgPSBjcmVhdG9yKClcbiAgICAgIHJldHVybiBjYWNoZVxuICAgIH1cbiAgfSlcblxuICBjcmVhdG9yLnByb2Nlc3MgPSBmdW5jdGlvbiAoY3NzLCBwcm9jZXNzT3B0cywgcGx1Z2luT3B0cykge1xuICAgIHJldHVybiBwb3N0Y3NzKFtjcmVhdG9yKHBsdWdpbk9wdHMpXSkucHJvY2Vzcyhjc3MsIHByb2Nlc3NPcHRzKVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0b3Jcbn1cblxucG9zdGNzcy5zdHJpbmdpZnkgPSBzdHJpbmdpZnlcbnBvc3Rjc3MucGFyc2UgPSBwYXJzZVxucG9zdGNzcy5mcm9tSlNPTiA9IGZyb21KU09OXG5wb3N0Y3NzLmxpc3QgPSBsaXN0XG5cbnBvc3Rjc3MuY29tbWVudCA9IGRlZmF1bHRzID0+IG5ldyBDb21tZW50KGRlZmF1bHRzKVxucG9zdGNzcy5hdFJ1bGUgPSBkZWZhdWx0cyA9PiBuZXcgQXRSdWxlKGRlZmF1bHRzKVxucG9zdGNzcy5kZWNsID0gZGVmYXVsdHMgPT4gbmV3IERlY2xhcmF0aW9uKGRlZmF1bHRzKVxucG9zdGNzcy5ydWxlID0gZGVmYXVsdHMgPT4gbmV3IFJ1bGUoZGVmYXVsdHMpXG5wb3N0Y3NzLnJvb3QgPSBkZWZhdWx0cyA9PiBuZXcgUm9vdChkZWZhdWx0cylcbnBvc3Rjc3MuZG9jdW1lbnQgPSBkZWZhdWx0cyA9PiBuZXcgRG9jdW1lbnQoZGVmYXVsdHMpXG5cbnBvc3Rjc3MuQ3NzU3ludGF4RXJyb3IgPSBDc3NTeW50YXhFcnJvclxucG9zdGNzcy5EZWNsYXJhdGlvbiA9IERlY2xhcmF0aW9uXG5wb3N0Y3NzLkNvbnRhaW5lciA9IENvbnRhaW5lclxucG9zdGNzcy5Qcm9jZXNzb3IgPSBQcm9jZXNzb3JcbnBvc3Rjc3MuRG9jdW1lbnQgPSBEb2N1bWVudFxucG9zdGNzcy5Db21tZW50ID0gQ29tbWVudFxucG9zdGNzcy5XYXJuaW5nID0gV2FybmluZ1xucG9zdGNzcy5BdFJ1bGUgPSBBdFJ1bGVcbnBvc3Rjc3MuUmVzdWx0ID0gUmVzdWx0XG5wb3N0Y3NzLklucHV0ID0gSW5wdXRcbnBvc3Rjc3MuUnVsZSA9IFJ1bGVcbnBvc3Rjc3MuUm9vdCA9IFJvb3RcbnBvc3Rjc3MuTm9kZSA9IE5vZGVcblxuTGF6eVJlc3VsdC5yZWdpc3RlclBvc3Rjc3MocG9zdGNzcylcblxubW9kdWxlLmV4cG9ydHMgPSBwb3N0Y3NzXG5wb3N0Y3NzLmRlZmF1bHQgPSBwb3N0Y3NzXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/postcss.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/previous-map.js":
/*!**************************************************!*\
  !*** ./node_modules/postcss/lib/previous-map.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\nlet { existsSync, readFileSync } = __webpack_require__(/*! fs */ \"?2f81\")\nlet { dirname, join } = __webpack_require__(/*! path */ \"?25fb\")\nlet { SourceMapConsumer, SourceMapGenerator } = __webpack_require__(/*! source-map-js */ \"?6f78\")\n\nfunction fromBase64(str) {\n  if (Buffer) {\n    return Buffer.from(str, 'base64').toString()\n  } else {\n    /* c8 ignore next 2 */\n    return window.atob(str)\n  }\n}\n\nclass PreviousMap {\n  constructor(css, opts) {\n    if (opts.map === false) return\n    this.loadAnnotation(css)\n    this.inline = this.startWith(this.annotation, 'data:')\n\n    let prev = opts.map ? opts.map.prev : undefined\n    let text = this.loadMap(opts.from, prev)\n    if (!this.mapFile && opts.from) {\n      this.mapFile = opts.from\n    }\n    if (this.mapFile) this.root = dirname(this.mapFile)\n    if (text) this.text = text\n  }\n\n  consumer() {\n    if (!this.consumerCache) {\n      this.consumerCache = new SourceMapConsumer(this.text)\n    }\n    return this.consumerCache\n  }\n\n  decodeInline(text) {\n    let baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/\n    let baseUri = /^data:application\\/json;base64,/\n    let charsetUri = /^data:application\\/json;charset=utf-?8,/\n    let uri = /^data:application\\/json,/\n\n    let uriMatch = text.match(charsetUri) || text.match(uri)\n    if (uriMatch) {\n      return decodeURIComponent(text.substr(uriMatch[0].length))\n    }\n\n    let baseUriMatch = text.match(baseCharsetUri) || text.match(baseUri)\n    if (baseUriMatch) {\n      return fromBase64(text.substr(baseUriMatch[0].length))\n    }\n\n    let encoding = text.match(/data:application\\/json;([^,]+),/)[1]\n    throw new Error('Unsupported source map encoding ' + encoding)\n  }\n\n  getAnnotationURL(sourceMapString) {\n    return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, '').trim()\n  }\n\n  isMap(map) {\n    if (typeof map !== 'object') return false\n    return (\n      typeof map.mappings === 'string' ||\n      typeof map._mappings === 'string' ||\n      Array.isArray(map.sections)\n    )\n  }\n\n  loadAnnotation(css) {\n    let comments = css.match(/\\/\\*\\s*# sourceMappingURL=/g)\n    if (!comments) return\n\n    // sourceMappingURLs from comments, strings, etc.\n    let start = css.lastIndexOf(comments.pop())\n    let end = css.indexOf('*/', start)\n\n    if (start > -1 && end > -1) {\n      // Locate the last sourceMappingURL to avoid pickin\n      this.annotation = this.getAnnotationURL(css.substring(start, end))\n    }\n  }\n\n  loadFile(path) {\n    this.root = dirname(path)\n    if (existsSync(path)) {\n      this.mapFile = path\n      return readFileSync(path, 'utf-8').toString().trim()\n    }\n  }\n\n  loadMap(file, prev) {\n    if (prev === false) return false\n\n    if (prev) {\n      if (typeof prev === 'string') {\n        return prev\n      } else if (typeof prev === 'function') {\n        let prevPath = prev(file)\n        if (prevPath) {\n          let map = this.loadFile(prevPath)\n          if (!map) {\n            throw new Error(\n              'Unable to load previous source map: ' + prevPath.toString()\n            )\n          }\n          return map\n        }\n      } else if (prev instanceof SourceMapConsumer) {\n        return SourceMapGenerator.fromSourceMap(prev).toString()\n      } else if (prev instanceof SourceMapGenerator) {\n        return prev.toString()\n      } else if (this.isMap(prev)) {\n        return JSON.stringify(prev)\n      } else {\n        throw new Error(\n          'Unsupported previous source map format: ' + prev.toString()\n        )\n      }\n    } else if (this.inline) {\n      return this.decodeInline(this.annotation)\n    } else if (this.annotation) {\n      let map = this.annotation\n      if (file) map = join(dirname(file), map)\n      return this.loadFile(map)\n    }\n  }\n\n  startWith(string, start) {\n    if (!string) return false\n    return string.substr(0, start.length) === start\n  }\n\n  withContent() {\n    return !!(\n      this.consumer().sourcesContent &&\n      this.consumer().sourcesContent.length > 0\n    )\n  }\n}\n\nmodule.exports = PreviousMap\nPreviousMap.default = PreviousMap\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcHJldmlvdXMtbWFwLmpzIiwibWFwcGluZ3MiOiI7QUFBWTs7QUFFWixNQUFNLDJCQUEyQixFQUFFLG1CQUFPLENBQUMsaUJBQUk7QUFDL0MsTUFBTSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLG1CQUFNO0FBQ3RDLE1BQU0sd0NBQXdDLEVBQUUsbUJBQU8sQ0FBQyw0QkFBZTs7QUFFdkU7QUFDQSxNQUFNLE1BQU07QUFDWixXQUFXLE1BQU07QUFDakIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QsZUFBZTtBQUNqRSwyQ0FBMkM7QUFDM0MsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qaW1pcHVsc2FyQGdpdGh1Yi5jb20vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcHJldmlvdXMtbWFwLmpzPzViM2MiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmxldCB7IGV4aXN0c1N5bmMsIHJlYWRGaWxlU3luYyB9ID0gcmVxdWlyZSgnZnMnKVxubGV0IHsgZGlybmFtZSwgam9pbiB9ID0gcmVxdWlyZSgncGF0aCcpXG5sZXQgeyBTb3VyY2VNYXBDb25zdW1lciwgU291cmNlTWFwR2VuZXJhdG9yIH0gPSByZXF1aXJlKCdzb3VyY2UtbWFwLWpzJylcblxuZnVuY3Rpb24gZnJvbUJhc2U2NChzdHIpIHtcbiAgaWYgKEJ1ZmZlcikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIsICdiYXNlNjQnKS50b1N0cmluZygpXG4gIH0gZWxzZSB7XG4gICAgLyogYzggaWdub3JlIG5leHQgMiAqL1xuICAgIHJldHVybiB3aW5kb3cuYXRvYihzdHIpXG4gIH1cbn1cblxuY2xhc3MgUHJldmlvdXNNYXAge1xuICBjb25zdHJ1Y3Rvcihjc3MsIG9wdHMpIHtcbiAgICBpZiAob3B0cy5tYXAgPT09IGZhbHNlKSByZXR1cm5cbiAgICB0aGlzLmxvYWRBbm5vdGF0aW9uKGNzcylcbiAgICB0aGlzLmlubGluZSA9IHRoaXMuc3RhcnRXaXRoKHRoaXMuYW5ub3RhdGlvbiwgJ2RhdGE6JylcblxuICAgIGxldCBwcmV2ID0gb3B0cy5tYXAgPyBvcHRzLm1hcC5wcmV2IDogdW5kZWZpbmVkXG4gICAgbGV0IHRleHQgPSB0aGlzLmxvYWRNYXAob3B0cy5mcm9tLCBwcmV2KVxuICAgIGlmICghdGhpcy5tYXBGaWxlICYmIG9wdHMuZnJvbSkge1xuICAgICAgdGhpcy5tYXBGaWxlID0gb3B0cy5mcm9tXG4gICAgfVxuICAgIGlmICh0aGlzLm1hcEZpbGUpIHRoaXMucm9vdCA9IGRpcm5hbWUodGhpcy5tYXBGaWxlKVxuICAgIGlmICh0ZXh0KSB0aGlzLnRleHQgPSB0ZXh0XG4gIH1cblxuICBjb25zdW1lcigpIHtcbiAgICBpZiAoIXRoaXMuY29uc3VtZXJDYWNoZSkge1xuICAgICAgdGhpcy5jb25zdW1lckNhY2hlID0gbmV3IFNvdXJjZU1hcENvbnN1bWVyKHRoaXMudGV4dClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29uc3VtZXJDYWNoZVxuICB9XG5cbiAgZGVjb2RlSW5saW5lKHRleHQpIHtcbiAgICBsZXQgYmFzZUNoYXJzZXRVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2NoYXJzZXQ9dXRmLT84O2Jhc2U2NCwvXG4gICAgbGV0IGJhc2VVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2Jhc2U2NCwvXG4gICAgbGV0IGNoYXJzZXRVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2NoYXJzZXQ9dXRmLT84LC9cbiAgICBsZXQgdXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbiwvXG5cbiAgICBsZXQgdXJpTWF0Y2ggPSB0ZXh0Lm1hdGNoKGNoYXJzZXRVcmkpIHx8IHRleHQubWF0Y2godXJpKVxuICAgIGlmICh1cmlNYXRjaCkge1xuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh0ZXh0LnN1YnN0cih1cmlNYXRjaFswXS5sZW5ndGgpKVxuICAgIH1cblxuICAgIGxldCBiYXNlVXJpTWF0Y2ggPSB0ZXh0Lm1hdGNoKGJhc2VDaGFyc2V0VXJpKSB8fCB0ZXh0Lm1hdGNoKGJhc2VVcmkpXG4gICAgaWYgKGJhc2VVcmlNYXRjaCkge1xuICAgICAgcmV0dXJuIGZyb21CYXNlNjQodGV4dC5zdWJzdHIoYmFzZVVyaU1hdGNoWzBdLmxlbmd0aCkpXG4gICAgfVxuXG4gICAgbGV0IGVuY29kaW5nID0gdGV4dC5tYXRjaCgvZGF0YTphcHBsaWNhdGlvblxcL2pzb247KFteLF0rKSwvKVsxXVxuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc291cmNlIG1hcCBlbmNvZGluZyAnICsgZW5jb2RpbmcpXG4gIH1cblxuICBnZXRBbm5vdGF0aW9uVVJMKHNvdXJjZU1hcFN0cmluZykge1xuICAgIHJldHVybiBzb3VyY2VNYXBTdHJpbmcucmVwbGFjZSgvXlxcL1xcKlxccyojIHNvdXJjZU1hcHBpbmdVUkw9LywgJycpLnRyaW0oKVxuICB9XG5cbiAgaXNNYXAobWFwKSB7XG4gICAgaWYgKHR5cGVvZiBtYXAgIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIG1hcC5tYXBwaW5ncyA9PT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiBtYXAuX21hcHBpbmdzID09PSAnc3RyaW5nJyB8fFxuICAgICAgQXJyYXkuaXNBcnJheShtYXAuc2VjdGlvbnMpXG4gICAgKVxuICB9XG5cbiAgbG9hZEFubm90YXRpb24oY3NzKSB7XG4gICAgbGV0IGNvbW1lbnRzID0gY3NzLm1hdGNoKC9cXC9cXCpcXHMqIyBzb3VyY2VNYXBwaW5nVVJMPS9nKVxuICAgIGlmICghY29tbWVudHMpIHJldHVyblxuXG4gICAgLy8gc291cmNlTWFwcGluZ1VSTHMgZnJvbSBjb21tZW50cywgc3RyaW5ncywgZXRjLlxuICAgIGxldCBzdGFydCA9IGNzcy5sYXN0SW5kZXhPZihjb21tZW50cy5wb3AoKSlcbiAgICBsZXQgZW5kID0gY3NzLmluZGV4T2YoJyovJywgc3RhcnQpXG5cbiAgICBpZiAoc3RhcnQgPiAtMSAmJiBlbmQgPiAtMSkge1xuICAgICAgLy8gTG9jYXRlIHRoZSBsYXN0IHNvdXJjZU1hcHBpbmdVUkwgdG8gYXZvaWQgcGlja2luXG4gICAgICB0aGlzLmFubm90YXRpb24gPSB0aGlzLmdldEFubm90YXRpb25VUkwoY3NzLnN1YnN0cmluZyhzdGFydCwgZW5kKSlcbiAgICB9XG4gIH1cblxuICBsb2FkRmlsZShwYXRoKSB7XG4gICAgdGhpcy5yb290ID0gZGlybmFtZShwYXRoKVxuICAgIGlmIChleGlzdHNTeW5jKHBhdGgpKSB7XG4gICAgICB0aGlzLm1hcEZpbGUgPSBwYXRoXG4gICAgICByZXR1cm4gcmVhZEZpbGVTeW5jKHBhdGgsICd1dGYtOCcpLnRvU3RyaW5nKCkudHJpbSgpXG4gICAgfVxuICB9XG5cbiAgbG9hZE1hcChmaWxlLCBwcmV2KSB7XG4gICAgaWYgKHByZXYgPT09IGZhbHNlKSByZXR1cm4gZmFsc2VcblxuICAgIGlmIChwcmV2KSB7XG4gICAgICBpZiAodHlwZW9mIHByZXYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBwcmV2XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcmV2ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxldCBwcmV2UGF0aCA9IHByZXYoZmlsZSlcbiAgICAgICAgaWYgKHByZXZQYXRoKSB7XG4gICAgICAgICAgbGV0IG1hcCA9IHRoaXMubG9hZEZpbGUocHJldlBhdGgpXG4gICAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ1VuYWJsZSB0byBsb2FkIHByZXZpb3VzIHNvdXJjZSBtYXA6ICcgKyBwcmV2UGF0aC50b1N0cmluZygpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcmV2IGluc3RhbmNlb2YgU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICAgICAgcmV0dXJuIFNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwKHByZXYpLnRvU3RyaW5nKClcbiAgICAgIH0gZWxzZSBpZiAocHJldiBpbnN0YW5jZW9mIFNvdXJjZU1hcEdlbmVyYXRvcikge1xuICAgICAgICByZXR1cm4gcHJldi50b1N0cmluZygpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNNYXAocHJldikpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByZXYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1Vuc3VwcG9ydGVkIHByZXZpb3VzIHNvdXJjZSBtYXAgZm9ybWF0OiAnICsgcHJldi50b1N0cmluZygpXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5saW5lKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGVJbmxpbmUodGhpcy5hbm5vdGF0aW9uKVxuICAgIH0gZWxzZSBpZiAodGhpcy5hbm5vdGF0aW9uKSB7XG4gICAgICBsZXQgbWFwID0gdGhpcy5hbm5vdGF0aW9uXG4gICAgICBpZiAoZmlsZSkgbWFwID0gam9pbihkaXJuYW1lKGZpbGUpLCBtYXApXG4gICAgICByZXR1cm4gdGhpcy5sb2FkRmlsZShtYXApXG4gICAgfVxuICB9XG5cbiAgc3RhcnRXaXRoKHN0cmluZywgc3RhcnQpIHtcbiAgICBpZiAoIXN0cmluZykgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIHN0cmluZy5zdWJzdHIoMCwgc3RhcnQubGVuZ3RoKSA9PT0gc3RhcnRcbiAgfVxuXG4gIHdpdGhDb250ZW50KCkge1xuICAgIHJldHVybiAhIShcbiAgICAgIHRoaXMuY29uc3VtZXIoKS5zb3VyY2VzQ29udGVudCAmJlxuICAgICAgdGhpcy5jb25zdW1lcigpLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+IDBcbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcmV2aW91c01hcFxuUHJldmlvdXNNYXAuZGVmYXVsdCA9IFByZXZpb3VzTWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/previous-map.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/processor.js":
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/processor.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Document = __webpack_require__(/*! ./document */ \"./node_modules/postcss/lib/document.js\")\nlet LazyResult = __webpack_require__(/*! ./lazy-result */ \"./node_modules/postcss/lib/lazy-result.js\")\nlet NoWorkResult = __webpack_require__(/*! ./no-work-result */ \"./node_modules/postcss/lib/no-work-result.js\")\nlet Root = __webpack_require__(/*! ./root */ \"./node_modules/postcss/lib/root.js\")\n\nclass Processor {\n  constructor(plugins = []) {\n    this.version = '8.4.47'\n    this.plugins = this.normalize(plugins)\n  }\n\n  normalize(plugins) {\n    let normalized = []\n    for (let i of plugins) {\n      if (i.postcss === true) {\n        i = i()\n      } else if (i.postcss) {\n        i = i.postcss\n      }\n\n      if (typeof i === 'object' && Array.isArray(i.plugins)) {\n        normalized = normalized.concat(i.plugins)\n      } else if (typeof i === 'object' && i.postcssPlugin) {\n        normalized.push(i)\n      } else if (typeof i === 'function') {\n        normalized.push(i)\n      } else if (typeof i === 'object' && (i.parse || i.stringify)) {\n        if (true) {\n          throw new Error(\n            'PostCSS syntaxes cannot be used as plugins. Instead, please use ' +\n              'one of the syntax/parser/stringifier options as outlined ' +\n              'in your PostCSS runner documentation.'\n          )\n        }\n      } else {\n        throw new Error(i + ' is not a PostCSS plugin')\n      }\n    }\n    return normalized\n  }\n\n  process(css, opts = {}) {\n    if (\n      !this.plugins.length &&\n      !opts.parser &&\n      !opts.stringifier &&\n      !opts.syntax\n    ) {\n      return new NoWorkResult(this, css, opts)\n    } else {\n      return new LazyResult(this, css, opts)\n    }\n  }\n\n  use(plugin) {\n    this.plugins = this.plugins.concat(this.normalize([plugin]))\n    return this\n  }\n}\n\nmodule.exports = Processor\nProcessor.default = Processor\n\nRoot.registerProcessor(Processor)\nDocument.registerProcessor(Processor)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcHJvY2Vzc29yLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQywwREFBWTtBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyxnRUFBZTtBQUN4QyxtQkFBbUIsbUJBQU8sQ0FBQyxzRUFBa0I7QUFDN0MsV0FBVyxtQkFBTyxDQUFDLGtEQUFROztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLFlBQVksSUFBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ppbWlwdWxzYXJAZ2l0aHViLmNvbS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9wcm9jZXNzb3IuanM/MjMzMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IERvY3VtZW50ID0gcmVxdWlyZSgnLi9kb2N1bWVudCcpXG5sZXQgTGF6eVJlc3VsdCA9IHJlcXVpcmUoJy4vbGF6eS1yZXN1bHQnKVxubGV0IE5vV29ya1Jlc3VsdCA9IHJlcXVpcmUoJy4vbm8td29yay1yZXN1bHQnKVxubGV0IFJvb3QgPSByZXF1aXJlKCcuL3Jvb3QnKVxuXG5jbGFzcyBQcm9jZXNzb3Ige1xuICBjb25zdHJ1Y3RvcihwbHVnaW5zID0gW10pIHtcbiAgICB0aGlzLnZlcnNpb24gPSAnOC40LjQ3J1xuICAgIHRoaXMucGx1Z2lucyA9IHRoaXMubm9ybWFsaXplKHBsdWdpbnMpXG4gIH1cblxuICBub3JtYWxpemUocGx1Z2lucykge1xuICAgIGxldCBub3JtYWxpemVkID0gW11cbiAgICBmb3IgKGxldCBpIG9mIHBsdWdpbnMpIHtcbiAgICAgIGlmIChpLnBvc3Rjc3MgPT09IHRydWUpIHtcbiAgICAgICAgaSA9IGkoKVxuICAgICAgfSBlbHNlIGlmIChpLnBvc3Rjc3MpIHtcbiAgICAgICAgaSA9IGkucG9zdGNzc1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGkgPT09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkoaS5wbHVnaW5zKSkge1xuICAgICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5jb25jYXQoaS5wbHVnaW5zKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaSA9PT0gJ29iamVjdCcgJiYgaS5wb3N0Y3NzUGx1Z2luKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQucHVzaChpKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBub3JtYWxpemVkLnB1c2goaSlcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGkgPT09ICdvYmplY3QnICYmIChpLnBhcnNlIHx8IGkuc3RyaW5naWZ5KSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdQb3N0Q1NTIHN5bnRheGVzIGNhbm5vdCBiZSB1c2VkIGFzIHBsdWdpbnMuIEluc3RlYWQsIHBsZWFzZSB1c2UgJyArXG4gICAgICAgICAgICAgICdvbmUgb2YgdGhlIHN5bnRheC9wYXJzZXIvc3RyaW5naWZpZXIgb3B0aW9ucyBhcyBvdXRsaW5lZCAnICtcbiAgICAgICAgICAgICAgJ2luIHlvdXIgUG9zdENTUyBydW5uZXIgZG9jdW1lbnRhdGlvbi4nXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaSArICcgaXMgbm90IGEgUG9zdENTUyBwbHVnaW4nKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZFxuICB9XG5cbiAgcHJvY2Vzcyhjc3MsIG9wdHMgPSB7fSkge1xuICAgIGlmIChcbiAgICAgICF0aGlzLnBsdWdpbnMubGVuZ3RoICYmXG4gICAgICAhb3B0cy5wYXJzZXIgJiZcbiAgICAgICFvcHRzLnN0cmluZ2lmaWVyICYmXG4gICAgICAhb3B0cy5zeW50YXhcbiAgICApIHtcbiAgICAgIHJldHVybiBuZXcgTm9Xb3JrUmVzdWx0KHRoaXMsIGNzcywgb3B0cylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBMYXp5UmVzdWx0KHRoaXMsIGNzcywgb3B0cylcbiAgICB9XG4gIH1cblxuICB1c2UocGx1Z2luKSB7XG4gICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wbHVnaW5zLmNvbmNhdCh0aGlzLm5vcm1hbGl6ZShbcGx1Z2luXSkpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2Nlc3NvclxuUHJvY2Vzc29yLmRlZmF1bHQgPSBQcm9jZXNzb3JcblxuUm9vdC5yZWdpc3RlclByb2Nlc3NvcihQcm9jZXNzb3IpXG5Eb2N1bWVudC5yZWdpc3RlclByb2Nlc3NvcihQcm9jZXNzb3IpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/processor.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/result.js":
/*!********************************************!*\
  !*** ./node_modules/postcss/lib/result.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Warning = __webpack_require__(/*! ./warning */ \"./node_modules/postcss/lib/warning.js\")\n\nclass Result {\n  constructor(processor, root, opts) {\n    this.processor = processor\n    this.messages = []\n    this.root = root\n    this.opts = opts\n    this.css = undefined\n    this.map = undefined\n  }\n\n  toString() {\n    return this.css\n  }\n\n  warn(text, opts = {}) {\n    if (!opts.plugin) {\n      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {\n        opts.plugin = this.lastPlugin.postcssPlugin\n      }\n    }\n\n    let warning = new Warning(text, opts)\n    this.messages.push(warning)\n\n    return warning\n  }\n\n  warnings() {\n    return this.messages.filter(i => i.type === 'warning')\n  }\n\n  get content() {\n    return this.css\n  }\n}\n\nmodule.exports = Result\nResult.default = Result\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcmVzdWx0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGNBQWMsbUJBQU8sQ0FBQyx3REFBVzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qaW1pcHVsc2FyQGdpdGh1Yi5jb20vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcmVzdWx0LmpzPzM2OGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmxldCBXYXJuaW5nID0gcmVxdWlyZSgnLi93YXJuaW5nJylcblxuY2xhc3MgUmVzdWx0IHtcbiAgY29uc3RydWN0b3IocHJvY2Vzc29yLCByb290LCBvcHRzKSB7XG4gICAgdGhpcy5wcm9jZXNzb3IgPSBwcm9jZXNzb3JcbiAgICB0aGlzLm1lc3NhZ2VzID0gW11cbiAgICB0aGlzLnJvb3QgPSByb290XG4gICAgdGhpcy5vcHRzID0gb3B0c1xuICAgIHRoaXMuY3NzID0gdW5kZWZpbmVkXG4gICAgdGhpcy5tYXAgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNzc1xuICB9XG5cbiAgd2Fybih0ZXh0LCBvcHRzID0ge30pIHtcbiAgICBpZiAoIW9wdHMucGx1Z2luKSB7XG4gICAgICBpZiAodGhpcy5sYXN0UGx1Z2luICYmIHRoaXMubGFzdFBsdWdpbi5wb3N0Y3NzUGx1Z2luKSB7XG4gICAgICAgIG9wdHMucGx1Z2luID0gdGhpcy5sYXN0UGx1Z2luLnBvc3Rjc3NQbHVnaW5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgd2FybmluZyA9IG5ldyBXYXJuaW5nKHRleHQsIG9wdHMpXG4gICAgdGhpcy5tZXNzYWdlcy5wdXNoKHdhcm5pbmcpXG5cbiAgICByZXR1cm4gd2FybmluZ1xuICB9XG5cbiAgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuZmlsdGVyKGkgPT4gaS50eXBlID09PSAnd2FybmluZycpXG4gIH1cblxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jc3NcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3VsdFxuUmVzdWx0LmRlZmF1bHQgPSBSZXN1bHRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/result.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/root.js":
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/root.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\n\nlet LazyResult, Processor\n\nclass Root extends Container {\n  constructor(defaults) {\n    super(defaults)\n    this.type = 'root'\n    if (!this.nodes) this.nodes = []\n  }\n\n  normalize(child, sample, type) {\n    let nodes = super.normalize(child)\n\n    if (sample) {\n      if (type === 'prepend') {\n        if (this.nodes.length > 1) {\n          sample.raws.before = this.nodes[1].raws.before\n        } else {\n          delete sample.raws.before\n        }\n      } else if (this.first !== sample) {\n        for (let node of nodes) {\n          node.raws.before = sample.raws.before\n        }\n      }\n    }\n\n    return nodes\n  }\n\n  removeChild(child, ignore) {\n    let index = this.index(child)\n\n    if (!ignore && index === 0 && this.nodes.length > 1) {\n      this.nodes[1].raws.before = this.nodes[index].raws.before\n    }\n\n    return super.removeChild(child)\n  }\n\n  toResult(opts = {}) {\n    let lazy = new LazyResult(new Processor(), this, opts)\n    return lazy.stringify()\n  }\n}\n\nRoot.registerLazyResult = dependant => {\n  LazyResult = dependant\n}\n\nRoot.registerProcessor = dependant => {\n  Processor = dependant\n}\n\nmodule.exports = Root\nRoot.default = Root\n\nContainer.registerRoot(Root)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcm9vdC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBYTs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vamltaXB1bHNhckBnaXRodWIuY29tLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL3Jvb3QuanM/NTlkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubGV0IENvbnRhaW5lciA9IHJlcXVpcmUoJy4vY29udGFpbmVyJylcblxubGV0IExhenlSZXN1bHQsIFByb2Nlc3NvclxuXG5jbGFzcyBSb290IGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBzdXBlcihkZWZhdWx0cylcbiAgICB0aGlzLnR5cGUgPSAncm9vdCdcbiAgICBpZiAoIXRoaXMubm9kZXMpIHRoaXMubm9kZXMgPSBbXVxuICB9XG5cbiAgbm9ybWFsaXplKGNoaWxkLCBzYW1wbGUsIHR5cGUpIHtcbiAgICBsZXQgbm9kZXMgPSBzdXBlci5ub3JtYWxpemUoY2hpbGQpXG5cbiAgICBpZiAoc2FtcGxlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ3ByZXBlbmQnKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBzYW1wbGUucmF3cy5iZWZvcmUgPSB0aGlzLm5vZGVzWzFdLnJhd3MuYmVmb3JlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHNhbXBsZS5yYXdzLmJlZm9yZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZmlyc3QgIT09IHNhbXBsZSkge1xuICAgICAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgICAgbm9kZS5yYXdzLmJlZm9yZSA9IHNhbXBsZS5yYXdzLmJlZm9yZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVzXG4gIH1cblxuICByZW1vdmVDaGlsZChjaGlsZCwgaWdub3JlKSB7XG4gICAgbGV0IGluZGV4ID0gdGhpcy5pbmRleChjaGlsZClcblxuICAgIGlmICghaWdub3JlICYmIGluZGV4ID09PSAwICYmIHRoaXMubm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5ub2Rlc1sxXS5yYXdzLmJlZm9yZSA9IHRoaXMubm9kZXNbaW5kZXhdLnJhd3MuYmVmb3JlXG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnJlbW92ZUNoaWxkKGNoaWxkKVxuICB9XG5cbiAgdG9SZXN1bHQob3B0cyA9IHt9KSB7XG4gICAgbGV0IGxhenkgPSBuZXcgTGF6eVJlc3VsdChuZXcgUHJvY2Vzc29yKCksIHRoaXMsIG9wdHMpXG4gICAgcmV0dXJuIGxhenkuc3RyaW5naWZ5KClcbiAgfVxufVxuXG5Sb290LnJlZ2lzdGVyTGF6eVJlc3VsdCA9IGRlcGVuZGFudCA9PiB7XG4gIExhenlSZXN1bHQgPSBkZXBlbmRhbnRcbn1cblxuUm9vdC5yZWdpc3RlclByb2Nlc3NvciA9IGRlcGVuZGFudCA9PiB7XG4gIFByb2Nlc3NvciA9IGRlcGVuZGFudFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJvb3RcblJvb3QuZGVmYXVsdCA9IFJvb3RcblxuQ29udGFpbmVyLnJlZ2lzdGVyUm9vdChSb290KVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/root.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/rule.js":
/*!******************************************!*\
  !*** ./node_modules/postcss/lib/rule.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Container = __webpack_require__(/*! ./container */ \"./node_modules/postcss/lib/container.js\")\nlet list = __webpack_require__(/*! ./list */ \"./node_modules/postcss/lib/list.js\")\n\nclass Rule extends Container {\n  constructor(defaults) {\n    super(defaults)\n    this.type = 'rule'\n    if (!this.nodes) this.nodes = []\n  }\n\n  get selectors() {\n    return list.comma(this.selector)\n  }\n\n  set selectors(values) {\n    let match = this.selector ? this.selector.match(/,\\s*/) : null\n    let sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen')\n    this.selector = values.join(sep)\n  }\n}\n\nmodule.exports = Rule\nRule.default = Rule\n\nContainer.registerRule(Rule)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcnVsZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBYTtBQUNyQyxXQUFXLG1CQUFPLENBQUMsa0RBQVE7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qaW1pcHVsc2FyQGdpdGh1Yi5jb20vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcnVsZS5qcz81M2JhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5sZXQgQ29udGFpbmVyID0gcmVxdWlyZSgnLi9jb250YWluZXInKVxubGV0IGxpc3QgPSByZXF1aXJlKCcuL2xpc3QnKVxuXG5jbGFzcyBSdWxlIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgY29uc3RydWN0b3IoZGVmYXVsdHMpIHtcbiAgICBzdXBlcihkZWZhdWx0cylcbiAgICB0aGlzLnR5cGUgPSAncnVsZSdcbiAgICBpZiAoIXRoaXMubm9kZXMpIHRoaXMubm9kZXMgPSBbXVxuICB9XG5cbiAgZ2V0IHNlbGVjdG9ycygpIHtcbiAgICByZXR1cm4gbGlzdC5jb21tYSh0aGlzLnNlbGVjdG9yKVxuICB9XG5cbiAgc2V0IHNlbGVjdG9ycyh2YWx1ZXMpIHtcbiAgICBsZXQgbWF0Y2ggPSB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3Rvci5tYXRjaCgvLFxccyovKSA6IG51bGxcbiAgICBsZXQgc2VwID0gbWF0Y2ggPyBtYXRjaFswXSA6ICcsJyArIHRoaXMucmF3KCdiZXR3ZWVuJywgJ2JlZm9yZU9wZW4nKVxuICAgIHRoaXMuc2VsZWN0b3IgPSB2YWx1ZXMuam9pbihzZXApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSdWxlXG5SdWxlLmRlZmF1bHQgPSBSdWxlXG5cbkNvbnRhaW5lci5yZWdpc3RlclJ1bGUoUnVsZSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/rule.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/stringifier.js":
/*!*************************************************!*\
  !*** ./node_modules/postcss/lib/stringifier.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst DEFAULT_RAW = {\n  after: '\\n',\n  beforeClose: '\\n',\n  beforeComment: '\\n',\n  beforeDecl: '\\n',\n  beforeOpen: ' ',\n  beforeRule: '\\n',\n  colon: ': ',\n  commentLeft: ' ',\n  commentRight: ' ',\n  emptyBody: '',\n  indent: '    ',\n  semicolon: false\n}\n\nfunction capitalize(str) {\n  return str[0].toUpperCase() + str.slice(1)\n}\n\nclass Stringifier {\n  constructor(builder) {\n    this.builder = builder\n  }\n\n  atrule(node, semicolon) {\n    let name = '@' + node.name\n    let params = node.params ? this.rawValue(node, 'params') : ''\n\n    if (typeof node.raws.afterName !== 'undefined') {\n      name += node.raws.afterName\n    } else if (params) {\n      name += ' '\n    }\n\n    if (node.nodes) {\n      this.block(node, name + params)\n    } else {\n      let end = (node.raws.between || '') + (semicolon ? ';' : '')\n      this.builder(name + params + end, node)\n    }\n  }\n\n  beforeAfter(node, detect) {\n    let value\n    if (node.type === 'decl') {\n      value = this.raw(node, null, 'beforeDecl')\n    } else if (node.type === 'comment') {\n      value = this.raw(node, null, 'beforeComment')\n    } else if (detect === 'before') {\n      value = this.raw(node, null, 'beforeRule')\n    } else {\n      value = this.raw(node, null, 'beforeClose')\n    }\n\n    let buf = node.parent\n    let depth = 0\n    while (buf && buf.type !== 'root') {\n      depth += 1\n      buf = buf.parent\n    }\n\n    if (value.includes('\\n')) {\n      let indent = this.raw(node, null, 'indent')\n      if (indent.length) {\n        for (let step = 0; step < depth; step++) value += indent\n      }\n    }\n\n    return value\n  }\n\n  block(node, start) {\n    let between = this.raw(node, 'between', 'beforeOpen')\n    this.builder(start + between + '{', node, 'start')\n\n    let after\n    if (node.nodes && node.nodes.length) {\n      this.body(node)\n      after = this.raw(node, 'after')\n    } else {\n      after = this.raw(node, 'after', 'emptyBody')\n    }\n\n    if (after) this.builder(after)\n    this.builder('}', node, 'end')\n  }\n\n  body(node) {\n    let last = node.nodes.length - 1\n    while (last > 0) {\n      if (node.nodes[last].type !== 'comment') break\n      last -= 1\n    }\n\n    let semicolon = this.raw(node, 'semicolon')\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i]\n      let before = this.raw(child, 'before')\n      if (before) this.builder(before)\n      this.stringify(child, last !== i || semicolon)\n    }\n  }\n\n  comment(node) {\n    let left = this.raw(node, 'left', 'commentLeft')\n    let right = this.raw(node, 'right', 'commentRight')\n    this.builder('/*' + left + node.text + right + '*/', node)\n  }\n\n  decl(node, semicolon) {\n    let between = this.raw(node, 'between', 'colon')\n    let string = node.prop + between + this.rawValue(node, 'value')\n\n    if (node.important) {\n      string += node.raws.important || ' !important'\n    }\n\n    if (semicolon) string += ';'\n    this.builder(string, node)\n  }\n\n  document(node) {\n    this.body(node)\n  }\n\n  raw(node, own, detect) {\n    let value\n    if (!detect) detect = own\n\n    // Already had\n    if (own) {\n      value = node.raws[own]\n      if (typeof value !== 'undefined') return value\n    }\n\n    let parent = node.parent\n\n    if (detect === 'before') {\n      // Hack for first rule in CSS\n      if (!parent || (parent.type === 'root' && parent.first === node)) {\n        return ''\n      }\n\n      // `root` nodes in `document` should use only their own raws\n      if (parent && parent.type === 'document') {\n        return ''\n      }\n    }\n\n    // Floating child without parent\n    if (!parent) return DEFAULT_RAW[detect]\n\n    // Detect style by other nodes\n    let root = node.root()\n    if (!root.rawCache) root.rawCache = {}\n    if (typeof root.rawCache[detect] !== 'undefined') {\n      return root.rawCache[detect]\n    }\n\n    if (detect === 'before' || detect === 'after') {\n      return this.beforeAfter(node, detect)\n    } else {\n      let method = 'raw' + capitalize(detect)\n      if (this[method]) {\n        value = this[method](root, node)\n      } else {\n        root.walk(i => {\n          value = i.raws[own]\n          if (typeof value !== 'undefined') return false\n        })\n      }\n    }\n\n    if (typeof value === 'undefined') value = DEFAULT_RAW[detect]\n\n    root.rawCache[detect] = value\n    return value\n  }\n\n  rawBeforeClose(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && i.nodes.length > 0) {\n        if (typeof i.raws.after !== 'undefined') {\n          value = i.raws.after\n          if (value.includes('\\n')) {\n            value = value.replace(/[^\\n]+$/, '')\n          }\n          return false\n        }\n      }\n    })\n    if (value) value = value.replace(/\\S/g, '')\n    return value\n  }\n\n  rawBeforeComment(root, node) {\n    let value\n    root.walkComments(i => {\n      if (typeof i.raws.before !== 'undefined') {\n        value = i.raws.before\n        if (value.includes('\\n')) {\n          value = value.replace(/[^\\n]+$/, '')\n        }\n        return false\n      }\n    })\n    if (typeof value === 'undefined') {\n      value = this.raw(node, null, 'beforeDecl')\n    } else if (value) {\n      value = value.replace(/\\S/g, '')\n    }\n    return value\n  }\n\n  rawBeforeDecl(root, node) {\n    let value\n    root.walkDecls(i => {\n      if (typeof i.raws.before !== 'undefined') {\n        value = i.raws.before\n        if (value.includes('\\n')) {\n          value = value.replace(/[^\\n]+$/, '')\n        }\n        return false\n      }\n    })\n    if (typeof value === 'undefined') {\n      value = this.raw(node, null, 'beforeRule')\n    } else if (value) {\n      value = value.replace(/\\S/g, '')\n    }\n    return value\n  }\n\n  rawBeforeOpen(root) {\n    let value\n    root.walk(i => {\n      if (i.type !== 'decl') {\n        value = i.raws.between\n        if (typeof value !== 'undefined') return false\n      }\n    })\n    return value\n  }\n\n  rawBeforeRule(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && (i.parent !== root || root.first !== i)) {\n        if (typeof i.raws.before !== 'undefined') {\n          value = i.raws.before\n          if (value.includes('\\n')) {\n            value = value.replace(/[^\\n]+$/, '')\n          }\n          return false\n        }\n      }\n    })\n    if (value) value = value.replace(/\\S/g, '')\n    return value\n  }\n\n  rawColon(root) {\n    let value\n    root.walkDecls(i => {\n      if (typeof i.raws.between !== 'undefined') {\n        value = i.raws.between.replace(/[^\\s:]/g, '')\n        return false\n      }\n    })\n    return value\n  }\n\n  rawEmptyBody(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && i.nodes.length === 0) {\n        value = i.raws.after\n        if (typeof value !== 'undefined') return false\n      }\n    })\n    return value\n  }\n\n  rawIndent(root) {\n    if (root.raws.indent) return root.raws.indent\n    let value\n    root.walk(i => {\n      let p = i.parent\n      if (p && p !== root && p.parent && p.parent === root) {\n        if (typeof i.raws.before !== 'undefined') {\n          let parts = i.raws.before.split('\\n')\n          value = parts[parts.length - 1]\n          value = value.replace(/\\S/g, '')\n          return false\n        }\n      }\n    })\n    return value\n  }\n\n  rawSemicolon(root) {\n    let value\n    root.walk(i => {\n      if (i.nodes && i.nodes.length && i.last.type === 'decl') {\n        value = i.raws.semicolon\n        if (typeof value !== 'undefined') return false\n      }\n    })\n    return value\n  }\n\n  rawValue(node, prop) {\n    let value = node[prop]\n    let raw = node.raws[prop]\n    if (raw && raw.value === value) {\n      return raw.raw\n    }\n\n    return value\n  }\n\n  root(node) {\n    this.body(node)\n    if (node.raws.after) this.builder(node.raws.after)\n  }\n\n  rule(node) {\n    this.block(node, this.rawValue(node, 'selector'))\n    if (node.raws.ownSemicolon) {\n      this.builder(node.raws.ownSemicolon, node, 'end')\n    }\n  }\n\n  stringify(node, semicolon) {\n    /* c8 ignore start */\n    if (!this[node.type]) {\n      throw new Error(\n        'Unknown AST node type ' +\n          node.type +\n          '. ' +\n          'Maybe you need to change PostCSS stringifier.'\n      )\n    }\n    /* c8 ignore stop */\n    this[node.type](node, semicolon)\n  }\n}\n\nmodule.exports = Stringifier\nStringifier.default = Stringifier\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvc3RyaW5naWZpZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qaW1pcHVsc2FyQGdpdGh1Yi5jb20vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvc3RyaW5naWZpZXIuanM/ODM1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgREVGQVVMVF9SQVcgPSB7XG4gIGFmdGVyOiAnXFxuJyxcbiAgYmVmb3JlQ2xvc2U6ICdcXG4nLFxuICBiZWZvcmVDb21tZW50OiAnXFxuJyxcbiAgYmVmb3JlRGVjbDogJ1xcbicsXG4gIGJlZm9yZU9wZW46ICcgJyxcbiAgYmVmb3JlUnVsZTogJ1xcbicsXG4gIGNvbG9uOiAnOiAnLFxuICBjb21tZW50TGVmdDogJyAnLFxuICBjb21tZW50UmlnaHQ6ICcgJyxcbiAgZW1wdHlCb2R5OiAnJyxcbiAgaW5kZW50OiAnICAgICcsXG4gIHNlbWljb2xvbjogZmFsc2Vcbn1cblxuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59XG5cbmNsYXNzIFN0cmluZ2lmaWVyIHtcbiAgY29uc3RydWN0b3IoYnVpbGRlcikge1xuICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXJcbiAgfVxuXG4gIGF0cnVsZShub2RlLCBzZW1pY29sb24pIHtcbiAgICBsZXQgbmFtZSA9ICdAJyArIG5vZGUubmFtZVxuICAgIGxldCBwYXJhbXMgPSBub2RlLnBhcmFtcyA/IHRoaXMucmF3VmFsdWUobm9kZSwgJ3BhcmFtcycpIDogJydcblxuICAgIGlmICh0eXBlb2Ygbm9kZS5yYXdzLmFmdGVyTmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG5hbWUgKz0gbm9kZS5yYXdzLmFmdGVyTmFtZVxuICAgIH0gZWxzZSBpZiAocGFyYW1zKSB7XG4gICAgICBuYW1lICs9ICcgJ1xuICAgIH1cblxuICAgIGlmIChub2RlLm5vZGVzKSB7XG4gICAgICB0aGlzLmJsb2NrKG5vZGUsIG5hbWUgKyBwYXJhbXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBlbmQgPSAobm9kZS5yYXdzLmJldHdlZW4gfHwgJycpICsgKHNlbWljb2xvbiA/ICc7JyA6ICcnKVxuICAgICAgdGhpcy5idWlsZGVyKG5hbWUgKyBwYXJhbXMgKyBlbmQsIG5vZGUpXG4gICAgfVxuICB9XG5cbiAgYmVmb3JlQWZ0ZXIobm9kZSwgZGV0ZWN0KSB7XG4gICAgbGV0IHZhbHVlXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2RlY2wnKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUsIG51bGwsICdiZWZvcmVEZWNsJylcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUsIG51bGwsICdiZWZvcmVDb21tZW50JylcbiAgICB9IGVsc2UgaWYgKGRldGVjdCA9PT0gJ2JlZm9yZScpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZSwgbnVsbCwgJ2JlZm9yZVJ1bGUnKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUsIG51bGwsICdiZWZvcmVDbG9zZScpXG4gICAgfVxuXG4gICAgbGV0IGJ1ZiA9IG5vZGUucGFyZW50XG4gICAgbGV0IGRlcHRoID0gMFxuICAgIHdoaWxlIChidWYgJiYgYnVmLnR5cGUgIT09ICdyb290Jykge1xuICAgICAgZGVwdGggKz0gMVxuICAgICAgYnVmID0gYnVmLnBhcmVudFxuICAgIH1cblxuICAgIGlmICh2YWx1ZS5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgIGxldCBpbmRlbnQgPSB0aGlzLnJhdyhub2RlLCBudWxsLCAnaW5kZW50JylcbiAgICAgIGlmIChpbmRlbnQubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IHN0ZXAgPSAwOyBzdGVwIDwgZGVwdGg7IHN0ZXArKykgdmFsdWUgKz0gaW5kZW50XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBibG9jayhub2RlLCBzdGFydCkge1xuICAgIGxldCBiZXR3ZWVuID0gdGhpcy5yYXcobm9kZSwgJ2JldHdlZW4nLCAnYmVmb3JlT3BlbicpXG4gICAgdGhpcy5idWlsZGVyKHN0YXJ0ICsgYmV0d2VlbiArICd7Jywgbm9kZSwgJ3N0YXJ0JylcblxuICAgIGxldCBhZnRlclxuICAgIGlmIChub2RlLm5vZGVzICYmIG5vZGUubm9kZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmJvZHkobm9kZSlcbiAgICAgIGFmdGVyID0gdGhpcy5yYXcobm9kZSwgJ2FmdGVyJylcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXIgPSB0aGlzLnJhdyhub2RlLCAnYWZ0ZXInLCAnZW1wdHlCb2R5JylcbiAgICB9XG5cbiAgICBpZiAoYWZ0ZXIpIHRoaXMuYnVpbGRlcihhZnRlcilcbiAgICB0aGlzLmJ1aWxkZXIoJ30nLCBub2RlLCAnZW5kJylcbiAgfVxuXG4gIGJvZHkobm9kZSkge1xuICAgIGxldCBsYXN0ID0gbm9kZS5ub2Rlcy5sZW5ndGggLSAxXG4gICAgd2hpbGUgKGxhc3QgPiAwKSB7XG4gICAgICBpZiAobm9kZS5ub2Rlc1tsYXN0XS50eXBlICE9PSAnY29tbWVudCcpIGJyZWFrXG4gICAgICBsYXN0IC09IDFcbiAgICB9XG5cbiAgICBsZXQgc2VtaWNvbG9uID0gdGhpcy5yYXcobm9kZSwgJ3NlbWljb2xvbicpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgY2hpbGQgPSBub2RlLm5vZGVzW2ldXG4gICAgICBsZXQgYmVmb3JlID0gdGhpcy5yYXcoY2hpbGQsICdiZWZvcmUnKVxuICAgICAgaWYgKGJlZm9yZSkgdGhpcy5idWlsZGVyKGJlZm9yZSlcbiAgICAgIHRoaXMuc3RyaW5naWZ5KGNoaWxkLCBsYXN0ICE9PSBpIHx8IHNlbWljb2xvbilcbiAgICB9XG4gIH1cblxuICBjb21tZW50KG5vZGUpIHtcbiAgICBsZXQgbGVmdCA9IHRoaXMucmF3KG5vZGUsICdsZWZ0JywgJ2NvbW1lbnRMZWZ0JylcbiAgICBsZXQgcmlnaHQgPSB0aGlzLnJhdyhub2RlLCAncmlnaHQnLCAnY29tbWVudFJpZ2h0JylcbiAgICB0aGlzLmJ1aWxkZXIoJy8qJyArIGxlZnQgKyBub2RlLnRleHQgKyByaWdodCArICcqLycsIG5vZGUpXG4gIH1cblxuICBkZWNsKG5vZGUsIHNlbWljb2xvbikge1xuICAgIGxldCBiZXR3ZWVuID0gdGhpcy5yYXcobm9kZSwgJ2JldHdlZW4nLCAnY29sb24nKVxuICAgIGxldCBzdHJpbmcgPSBub2RlLnByb3AgKyBiZXR3ZWVuICsgdGhpcy5yYXdWYWx1ZShub2RlLCAndmFsdWUnKVxuXG4gICAgaWYgKG5vZGUuaW1wb3J0YW50KSB7XG4gICAgICBzdHJpbmcgKz0gbm9kZS5yYXdzLmltcG9ydGFudCB8fCAnICFpbXBvcnRhbnQnXG4gICAgfVxuXG4gICAgaWYgKHNlbWljb2xvbikgc3RyaW5nICs9ICc7J1xuICAgIHRoaXMuYnVpbGRlcihzdHJpbmcsIG5vZGUpXG4gIH1cblxuICBkb2N1bWVudChub2RlKSB7XG4gICAgdGhpcy5ib2R5KG5vZGUpXG4gIH1cblxuICByYXcobm9kZSwgb3duLCBkZXRlY3QpIHtcbiAgICBsZXQgdmFsdWVcbiAgICBpZiAoIWRldGVjdCkgZGV0ZWN0ID0gb3duXG5cbiAgICAvLyBBbHJlYWR5IGhhZFxuICAgIGlmIChvd24pIHtcbiAgICAgIHZhbHVlID0gbm9kZS5yYXdzW293bl1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnRcblxuICAgIGlmIChkZXRlY3QgPT09ICdiZWZvcmUnKSB7XG4gICAgICAvLyBIYWNrIGZvciBmaXJzdCBydWxlIGluIENTU1xuICAgICAgaWYgKCFwYXJlbnQgfHwgKHBhcmVudC50eXBlID09PSAncm9vdCcgJiYgcGFyZW50LmZpcnN0ID09PSBub2RlKSkge1xuICAgICAgICByZXR1cm4gJydcbiAgICAgIH1cblxuICAgICAgLy8gYHJvb3RgIG5vZGVzIGluIGBkb2N1bWVudGAgc2hvdWxkIHVzZSBvbmx5IHRoZWlyIG93biByYXdzXG4gICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZsb2F0aW5nIGNoaWxkIHdpdGhvdXQgcGFyZW50XG4gICAgaWYgKCFwYXJlbnQpIHJldHVybiBERUZBVUxUX1JBV1tkZXRlY3RdXG5cbiAgICAvLyBEZXRlY3Qgc3R5bGUgYnkgb3RoZXIgbm9kZXNcbiAgICBsZXQgcm9vdCA9IG5vZGUucm9vdCgpXG4gICAgaWYgKCFyb290LnJhd0NhY2hlKSByb290LnJhd0NhY2hlID0ge31cbiAgICBpZiAodHlwZW9mIHJvb3QucmF3Q2FjaGVbZGV0ZWN0XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiByb290LnJhd0NhY2hlW2RldGVjdF1cbiAgICB9XG5cbiAgICBpZiAoZGV0ZWN0ID09PSAnYmVmb3JlJyB8fCBkZXRlY3QgPT09ICdhZnRlcicpIHtcbiAgICAgIHJldHVybiB0aGlzLmJlZm9yZUFmdGVyKG5vZGUsIGRldGVjdClcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG1ldGhvZCA9ICdyYXcnICsgY2FwaXRhbGl6ZShkZXRlY3QpXG4gICAgICBpZiAodGhpc1ttZXRob2RdKSB7XG4gICAgICAgIHZhbHVlID0gdGhpc1ttZXRob2RdKHJvb3QsIG5vZGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LndhbGsoaSA9PiB7XG4gICAgICAgICAgdmFsdWUgPSBpLnJhd3Nbb3duXVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2VcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykgdmFsdWUgPSBERUZBVUxUX1JBV1tkZXRlY3RdXG5cbiAgICByb290LnJhd0NhY2hlW2RldGVjdF0gPSB2YWx1ZVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgcmF3QmVmb3JlQ2xvc2Uocm9vdCkge1xuICAgIGxldCB2YWx1ZVxuICAgIHJvb3Qud2FsayhpID0+IHtcbiAgICAgIGlmIChpLm5vZGVzICYmIGkubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAodHlwZW9mIGkucmF3cy5hZnRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YWx1ZSA9IGkucmF3cy5hZnRlclxuICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCAnJylcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICAgIGlmICh2YWx1ZSkgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgJycpXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICByYXdCZWZvcmVDb21tZW50KHJvb3QsIG5vZGUpIHtcbiAgICBsZXQgdmFsdWVcbiAgICByb290LndhbGtDb21tZW50cyhpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaS5yYXdzLmJlZm9yZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFsdWUgPSBpLnJhd3MuYmVmb3JlXG4gICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgJycpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlLCBudWxsLCAnYmVmb3JlRGVjbCcpXG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgJycpXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgcmF3QmVmb3JlRGVjbChyb290LCBub2RlKSB7XG4gICAgbGV0IHZhbHVlXG4gICAgcm9vdC53YWxrRGVjbHMoaSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGkucmF3cy5iZWZvcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhbHVlID0gaS5yYXdzLmJlZm9yZVxuICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sICcnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZSwgbnVsbCwgJ2JlZm9yZVJ1bGUnKVxuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csICcnKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJhd0JlZm9yZU9wZW4ocm9vdCkge1xuICAgIGxldCB2YWx1ZVxuICAgIHJvb3Qud2FsayhpID0+IHtcbiAgICAgIGlmIChpLnR5cGUgIT09ICdkZWNsJykge1xuICAgICAgICB2YWx1ZSA9IGkucmF3cy5iZXR3ZWVuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgcmF3QmVmb3JlUnVsZShyb290KSB7XG4gICAgbGV0IHZhbHVlXG4gICAgcm9vdC53YWxrKGkgPT4ge1xuICAgICAgaWYgKGkubm9kZXMgJiYgKGkucGFyZW50ICE9PSByb290IHx8IHJvb3QuZmlyc3QgIT09IGkpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaS5yYXdzLmJlZm9yZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YWx1ZSA9IGkucmF3cy5iZWZvcmVcbiAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgJycpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAodmFsdWUpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csICcnKVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgcmF3Q29sb24ocm9vdCkge1xuICAgIGxldCB2YWx1ZVxuICAgIHJvb3Qud2Fsa0RlY2xzKGkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBpLnJhd3MuYmV0d2VlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFsdWUgPSBpLnJhd3MuYmV0d2Vlbi5yZXBsYWNlKC9bXlxcczpdL2csICcnKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgcmF3RW1wdHlCb2R5KHJvb3QpIHtcbiAgICBsZXQgdmFsdWVcbiAgICByb290LndhbGsoaSA9PiB7XG4gICAgICBpZiAoaS5ub2RlcyAmJiBpLm5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YWx1ZSA9IGkucmF3cy5hZnRlclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJhd0luZGVudChyb290KSB7XG4gICAgaWYgKHJvb3QucmF3cy5pbmRlbnQpIHJldHVybiByb290LnJhd3MuaW5kZW50XG4gICAgbGV0IHZhbHVlXG4gICAgcm9vdC53YWxrKGkgPT4ge1xuICAgICAgbGV0IHAgPSBpLnBhcmVudFxuICAgICAgaWYgKHAgJiYgcCAhPT0gcm9vdCAmJiBwLnBhcmVudCAmJiBwLnBhcmVudCA9PT0gcm9vdCkge1xuICAgICAgICBpZiAodHlwZW9mIGkucmF3cy5iZWZvcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgbGV0IHBhcnRzID0gaS5yYXdzLmJlZm9yZS5zcGxpdCgnXFxuJylcbiAgICAgICAgICB2YWx1ZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgJycpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgcmF3U2VtaWNvbG9uKHJvb3QpIHtcbiAgICBsZXQgdmFsdWVcbiAgICByb290LndhbGsoaSA9PiB7XG4gICAgICBpZiAoaS5ub2RlcyAmJiBpLm5vZGVzLmxlbmd0aCAmJiBpLmxhc3QudHlwZSA9PT0gJ2RlY2wnKSB7XG4gICAgICAgIHZhbHVlID0gaS5yYXdzLnNlbWljb2xvblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJhd1ZhbHVlKG5vZGUsIHByb3ApIHtcbiAgICBsZXQgdmFsdWUgPSBub2RlW3Byb3BdXG4gICAgbGV0IHJhdyA9IG5vZGUucmF3c1twcm9wXVxuICAgIGlmIChyYXcgJiYgcmF3LnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHJhdy5yYXdcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIHJvb3Qobm9kZSkge1xuICAgIHRoaXMuYm9keShub2RlKVxuICAgIGlmIChub2RlLnJhd3MuYWZ0ZXIpIHRoaXMuYnVpbGRlcihub2RlLnJhd3MuYWZ0ZXIpXG4gIH1cblxuICBydWxlKG5vZGUpIHtcbiAgICB0aGlzLmJsb2NrKG5vZGUsIHRoaXMucmF3VmFsdWUobm9kZSwgJ3NlbGVjdG9yJykpXG4gICAgaWYgKG5vZGUucmF3cy5vd25TZW1pY29sb24pIHtcbiAgICAgIHRoaXMuYnVpbGRlcihub2RlLnJhd3Mub3duU2VtaWNvbG9uLCBub2RlLCAnZW5kJylcbiAgICB9XG4gIH1cblxuICBzdHJpbmdpZnkobm9kZSwgc2VtaWNvbG9uKSB7XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKCF0aGlzW25vZGUudHlwZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1Vua25vd24gQVNUIG5vZGUgdHlwZSAnICtcbiAgICAgICAgICBub2RlLnR5cGUgK1xuICAgICAgICAgICcuICcgK1xuICAgICAgICAgICdNYXliZSB5b3UgbmVlZCB0byBjaGFuZ2UgUG9zdENTUyBzdHJpbmdpZmllci4nXG4gICAgICApXG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgdGhpc1tub2RlLnR5cGVdKG5vZGUsIHNlbWljb2xvbilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZ2lmaWVyXG5TdHJpbmdpZmllci5kZWZhdWx0ID0gU3RyaW5naWZpZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/stringifier.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/stringify.js":
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/stringify.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nlet Stringifier = __webpack_require__(/*! ./stringifier */ \"./node_modules/postcss/lib/stringifier.js\")\n\nfunction stringify(node, builder) {\n  let str = new Stringifier(builder)\n  str.stringify(node)\n}\n\nmodule.exports = stringify\nstringify.default = stringify\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGtCQUFrQixtQkFBTyxDQUFDLGdFQUFlOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vamltaXB1bHNhckBnaXRodWIuY29tLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL3N0cmluZ2lmeS5qcz9kN2MzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5sZXQgU3RyaW5naWZpZXIgPSByZXF1aXJlKCcuL3N0cmluZ2lmaWVyJylcblxuZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUsIGJ1aWxkZXIpIHtcbiAgbGV0IHN0ciA9IG5ldyBTdHJpbmdpZmllcihidWlsZGVyKVxuICBzdHIuc3RyaW5naWZ5KG5vZGUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5naWZ5XG5zdHJpbmdpZnkuZGVmYXVsdCA9IHN0cmluZ2lmeVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/stringify.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/symbols.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/symbols.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports.isClean = Symbol('isClean')\n\nmodule.exports.my = Symbol('my')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixzQkFBc0I7O0FBRXRCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL2ppbWlwdWxzYXJAZ2l0aHViLmNvbS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi9zeW1ib2xzLmpzP2IwY2IiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzLmlzQ2xlYW4gPSBTeW1ib2woJ2lzQ2xlYW4nKVxuXG5tb2R1bGUuZXhwb3J0cy5teSA9IFN5bWJvbCgnbXknKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/symbols.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/tokenize.js":
/*!**********************************************!*\
  !*** ./node_modules/postcss/lib/tokenize.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst SINGLE_QUOTE = \"'\".charCodeAt(0)\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0)\nconst BACKSLASH = '\\\\'.charCodeAt(0)\nconst SLASH = '/'.charCodeAt(0)\nconst NEWLINE = '\\n'.charCodeAt(0)\nconst SPACE = ' '.charCodeAt(0)\nconst FEED = '\\f'.charCodeAt(0)\nconst TAB = '\\t'.charCodeAt(0)\nconst CR = '\\r'.charCodeAt(0)\nconst OPEN_SQUARE = '['.charCodeAt(0)\nconst CLOSE_SQUARE = ']'.charCodeAt(0)\nconst OPEN_PARENTHESES = '('.charCodeAt(0)\nconst CLOSE_PARENTHESES = ')'.charCodeAt(0)\nconst OPEN_CURLY = '{'.charCodeAt(0)\nconst CLOSE_CURLY = '}'.charCodeAt(0)\nconst SEMICOLON = ';'.charCodeAt(0)\nconst ASTERISK = '*'.charCodeAt(0)\nconst COLON = ':'.charCodeAt(0)\nconst AT = '@'.charCodeAt(0)\n\nconst RE_AT_END = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g\nconst RE_WORD_END = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g\nconst RE_BAD_BRACKET = /.[\\r\\n\"'(/\\\\]/\nconst RE_HEX_ESCAPE = /[\\da-f]/i\n\nmodule.exports = function tokenizer(input, options = {}) {\n  let css = input.css.valueOf()\n  let ignore = options.ignoreErrors\n\n  let code, content, escape, next, quote\n  let currentToken, escaped, escapePos, n, prev\n\n  let length = css.length\n  let pos = 0\n  let buffer = []\n  let returned = []\n\n  function position() {\n    return pos\n  }\n\n  function unclosed(what) {\n    throw input.error('Unclosed ' + what, pos)\n  }\n\n  function endOfFile() {\n    return returned.length === 0 && pos >= length\n  }\n\n  function nextToken(opts) {\n    if (returned.length) return returned.pop()\n    if (pos >= length) return\n\n    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false\n\n    code = css.charCodeAt(pos)\n\n    switch (code) {\n      case NEWLINE:\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED: {\n        next = pos\n        do {\n          next += 1\n          code = css.charCodeAt(next)\n        } while (\n          code === SPACE ||\n          code === NEWLINE ||\n          code === TAB ||\n          code === CR ||\n          code === FEED\n        )\n\n        currentToken = ['space', css.slice(pos, next)]\n        pos = next - 1\n        break\n      }\n\n      case OPEN_SQUARE:\n      case CLOSE_SQUARE:\n      case OPEN_CURLY:\n      case CLOSE_CURLY:\n      case COLON:\n      case SEMICOLON:\n      case CLOSE_PARENTHESES: {\n        let controlChar = String.fromCharCode(code)\n        currentToken = [controlChar, controlChar, pos]\n        break\n      }\n\n      case OPEN_PARENTHESES: {\n        prev = buffer.length ? buffer.pop()[1] : ''\n        n = css.charCodeAt(pos + 1)\n        if (\n          prev === 'url' &&\n          n !== SINGLE_QUOTE &&\n          n !== DOUBLE_QUOTE &&\n          n !== SPACE &&\n          n !== NEWLINE &&\n          n !== TAB &&\n          n !== FEED &&\n          n !== CR\n        ) {\n          next = pos\n          do {\n            escaped = false\n            next = css.indexOf(')', next + 1)\n            if (next === -1) {\n              if (ignore || ignoreUnclosed) {\n                next = pos\n                break\n              } else {\n                unclosed('bracket')\n              }\n            }\n            escapePos = next\n            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n              escapePos -= 1\n              escaped = !escaped\n            }\n          } while (escaped)\n\n          currentToken = ['brackets', css.slice(pos, next + 1), pos, next]\n\n          pos = next\n        } else {\n          next = css.indexOf(')', pos + 1)\n          content = css.slice(pos, next + 1)\n\n          if (next === -1 || RE_BAD_BRACKET.test(content)) {\n            currentToken = ['(', '(', pos]\n          } else {\n            currentToken = ['brackets', content, pos, next]\n            pos = next\n          }\n        }\n\n        break\n      }\n\n      case SINGLE_QUOTE:\n      case DOUBLE_QUOTE: {\n        quote = code === SINGLE_QUOTE ? \"'\" : '\"'\n        next = pos\n        do {\n          escaped = false\n          next = css.indexOf(quote, next + 1)\n          if (next === -1) {\n            if (ignore || ignoreUnclosed) {\n              next = pos + 1\n              break\n            } else {\n              unclosed('string')\n            }\n          }\n          escapePos = next\n          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n            escapePos -= 1\n            escaped = !escaped\n          }\n        } while (escaped)\n\n        currentToken = ['string', css.slice(pos, next + 1), pos, next]\n        pos = next\n        break\n      }\n\n      case AT: {\n        RE_AT_END.lastIndex = pos + 1\n        RE_AT_END.test(css)\n        if (RE_AT_END.lastIndex === 0) {\n          next = css.length - 1\n        } else {\n          next = RE_AT_END.lastIndex - 2\n        }\n\n        currentToken = ['at-word', css.slice(pos, next + 1), pos, next]\n\n        pos = next\n        break\n      }\n\n      case BACKSLASH: {\n        next = pos\n        escape = true\n        while (css.charCodeAt(next + 1) === BACKSLASH) {\n          next += 1\n          escape = !escape\n        }\n        code = css.charCodeAt(next + 1)\n        if (\n          escape &&\n          code !== SLASH &&\n          code !== SPACE &&\n          code !== NEWLINE &&\n          code !== TAB &&\n          code !== CR &&\n          code !== FEED\n        ) {\n          next += 1\n          if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {\n              next += 1\n            }\n            if (css.charCodeAt(next + 1) === SPACE) {\n              next += 1\n            }\n          }\n        }\n\n        currentToken = ['word', css.slice(pos, next + 1), pos, next]\n\n        pos = next\n        break\n      }\n\n      default: {\n        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n          next = css.indexOf('*/', pos + 2) + 1\n          if (next === 0) {\n            if (ignore || ignoreUnclosed) {\n              next = css.length\n            } else {\n              unclosed('comment')\n            }\n          }\n\n          currentToken = ['comment', css.slice(pos, next + 1), pos, next]\n          pos = next\n        } else {\n          RE_WORD_END.lastIndex = pos + 1\n          RE_WORD_END.test(css)\n          if (RE_WORD_END.lastIndex === 0) {\n            next = css.length - 1\n          } else {\n            next = RE_WORD_END.lastIndex - 2\n          }\n\n          currentToken = ['word', css.slice(pos, next + 1), pos, next]\n          buffer.push(currentToken)\n          pos = next\n        }\n\n        break\n      }\n    }\n\n    pos++\n    return currentToken\n  }\n\n  function back(token) {\n    returned.push(token)\n  }\n\n  return {\n    back,\n    endOfFile,\n    nextToken,\n    position\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvdG9rZW5pemUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLE9BQU87QUFDM0MsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTs7QUFFQSx1REFBdUQ7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qaW1pcHVsc2FyQGdpdGh1Yi5jb20vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvdG9rZW5pemUuanM/NDM3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgU0lOR0xFX1FVT1RFID0gXCInXCIuY2hhckNvZGVBdCgwKVxuY29uc3QgRE9VQkxFX1FVT1RFID0gJ1wiJy5jaGFyQ29kZUF0KDApXG5jb25zdCBCQUNLU0xBU0ggPSAnXFxcXCcuY2hhckNvZGVBdCgwKVxuY29uc3QgU0xBU0ggPSAnLycuY2hhckNvZGVBdCgwKVxuY29uc3QgTkVXTElORSA9ICdcXG4nLmNoYXJDb2RlQXQoMClcbmNvbnN0IFNQQUNFID0gJyAnLmNoYXJDb2RlQXQoMClcbmNvbnN0IEZFRUQgPSAnXFxmJy5jaGFyQ29kZUF0KDApXG5jb25zdCBUQUIgPSAnXFx0Jy5jaGFyQ29kZUF0KDApXG5jb25zdCBDUiA9ICdcXHInLmNoYXJDb2RlQXQoMClcbmNvbnN0IE9QRU5fU1FVQVJFID0gJ1snLmNoYXJDb2RlQXQoMClcbmNvbnN0IENMT1NFX1NRVUFSRSA9ICddJy5jaGFyQ29kZUF0KDApXG5jb25zdCBPUEVOX1BBUkVOVEhFU0VTID0gJygnLmNoYXJDb2RlQXQoMClcbmNvbnN0IENMT1NFX1BBUkVOVEhFU0VTID0gJyknLmNoYXJDb2RlQXQoMClcbmNvbnN0IE9QRU5fQ1VSTFkgPSAneycuY2hhckNvZGVBdCgwKVxuY29uc3QgQ0xPU0VfQ1VSTFkgPSAnfScuY2hhckNvZGVBdCgwKVxuY29uc3QgU0VNSUNPTE9OID0gJzsnLmNoYXJDb2RlQXQoMClcbmNvbnN0IEFTVEVSSVNLID0gJyonLmNoYXJDb2RlQXQoMClcbmNvbnN0IENPTE9OID0gJzonLmNoYXJDb2RlQXQoMClcbmNvbnN0IEFUID0gJ0AnLmNoYXJDb2RlQXQoMClcblxuY29uc3QgUkVfQVRfRU5EID0gL1tcXHRcXG5cXGZcXHIgXCIjJygpLztbXFxcXFxcXXt9XS9nXG5jb25zdCBSRV9XT1JEX0VORCA9IC9bXFx0XFxuXFxmXFxyICFcIiMnKCk6O0BbXFxcXFxcXXt9XXxcXC8oPz1cXCopL2dcbmNvbnN0IFJFX0JBRF9CUkFDS0VUID0gLy5bXFxyXFxuXCInKC9cXFxcXS9cbmNvbnN0IFJFX0hFWF9FU0NBUEUgPSAvW1xcZGEtZl0vaVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRva2VuaXplcihpbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCBjc3MgPSBpbnB1dC5jc3MudmFsdWVPZigpXG4gIGxldCBpZ25vcmUgPSBvcHRpb25zLmlnbm9yZUVycm9yc1xuXG4gIGxldCBjb2RlLCBjb250ZW50LCBlc2NhcGUsIG5leHQsIHF1b3RlXG4gIGxldCBjdXJyZW50VG9rZW4sIGVzY2FwZWQsIGVzY2FwZVBvcywgbiwgcHJldlxuXG4gIGxldCBsZW5ndGggPSBjc3MubGVuZ3RoXG4gIGxldCBwb3MgPSAwXG4gIGxldCBidWZmZXIgPSBbXVxuICBsZXQgcmV0dXJuZWQgPSBbXVxuXG4gIGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICAgIHJldHVybiBwb3NcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuY2xvc2VkKHdoYXQpIHtcbiAgICB0aHJvdyBpbnB1dC5lcnJvcignVW5jbG9zZWQgJyArIHdoYXQsIHBvcylcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZE9mRmlsZSgpIHtcbiAgICByZXR1cm4gcmV0dXJuZWQubGVuZ3RoID09PSAwICYmIHBvcyA+PSBsZW5ndGhcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHRUb2tlbihvcHRzKSB7XG4gICAgaWYgKHJldHVybmVkLmxlbmd0aCkgcmV0dXJuIHJldHVybmVkLnBvcCgpXG4gICAgaWYgKHBvcyA+PSBsZW5ndGgpIHJldHVyblxuXG4gICAgbGV0IGlnbm9yZVVuY2xvc2VkID0gb3B0cyA/IG9wdHMuaWdub3JlVW5jbG9zZWQgOiBmYWxzZVxuXG4gICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KHBvcylcblxuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSBORVdMSU5FOlxuICAgICAgY2FzZSBTUEFDRTpcbiAgICAgIGNhc2UgVEFCOlxuICAgICAgY2FzZSBDUjpcbiAgICAgIGNhc2UgRkVFRDoge1xuICAgICAgICBuZXh0ID0gcG9zXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBuZXh0ICs9IDFcbiAgICAgICAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQobmV4dClcbiAgICAgICAgfSB3aGlsZSAoXG4gICAgICAgICAgY29kZSA9PT0gU1BBQ0UgfHxcbiAgICAgICAgICBjb2RlID09PSBORVdMSU5FIHx8XG4gICAgICAgICAgY29kZSA9PT0gVEFCIHx8XG4gICAgICAgICAgY29kZSA9PT0gQ1IgfHxcbiAgICAgICAgICBjb2RlID09PSBGRUVEXG4gICAgICAgIClcblxuICAgICAgICBjdXJyZW50VG9rZW4gPSBbJ3NwYWNlJywgY3NzLnNsaWNlKHBvcywgbmV4dCldXG4gICAgICAgIHBvcyA9IG5leHQgLSAxXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNhc2UgT1BFTl9TUVVBUkU6XG4gICAgICBjYXNlIENMT1NFX1NRVUFSRTpcbiAgICAgIGNhc2UgT1BFTl9DVVJMWTpcbiAgICAgIGNhc2UgQ0xPU0VfQ1VSTFk6XG4gICAgICBjYXNlIENPTE9OOlxuICAgICAgY2FzZSBTRU1JQ09MT046XG4gICAgICBjYXNlIENMT1NFX1BBUkVOVEhFU0VTOiB7XG4gICAgICAgIGxldCBjb250cm9sQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSlcbiAgICAgICAgY3VycmVudFRva2VuID0gW2NvbnRyb2xDaGFyLCBjb250cm9sQ2hhciwgcG9zXVxuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBjYXNlIE9QRU5fUEFSRU5USEVTRVM6IHtcbiAgICAgICAgcHJldiA9IGJ1ZmZlci5sZW5ndGggPyBidWZmZXIucG9wKClbMV0gOiAnJ1xuICAgICAgICBuID0gY3NzLmNoYXJDb2RlQXQocG9zICsgMSlcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByZXYgPT09ICd1cmwnICYmXG4gICAgICAgICAgbiAhPT0gU0lOR0xFX1FVT1RFICYmXG4gICAgICAgICAgbiAhPT0gRE9VQkxFX1FVT1RFICYmXG4gICAgICAgICAgbiAhPT0gU1BBQ0UgJiZcbiAgICAgICAgICBuICE9PSBORVdMSU5FICYmXG4gICAgICAgICAgbiAhPT0gVEFCICYmXG4gICAgICAgICAgbiAhPT0gRkVFRCAmJlxuICAgICAgICAgIG4gIT09IENSXG4gICAgICAgICkge1xuICAgICAgICAgIG5leHQgPSBwb3NcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBlc2NhcGVkID0gZmFsc2VcbiAgICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZignKScsIG5leHQgKyAxKVxuICAgICAgICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gcG9zXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bmNsb3NlZCgnYnJhY2tldCcpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVzY2FwZVBvcyA9IG5leHRcbiAgICAgICAgICAgIHdoaWxlIChjc3MuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gQkFDS1NMQVNIKSB7XG4gICAgICAgICAgICAgIGVzY2FwZVBvcyAtPSAxXG4gICAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGVzY2FwZWQpXG5cbiAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbJ2JyYWNrZXRzJywgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdXG5cbiAgICAgICAgICBwb3MgPSBuZXh0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKCcpJywgcG9zICsgMSlcbiAgICAgICAgICBjb250ZW50ID0gY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpXG5cbiAgICAgICAgICBpZiAobmV4dCA9PT0gLTEgfHwgUkVfQkFEX0JSQUNLRVQudGVzdChjb250ZW50KSkge1xuICAgICAgICAgICAgY3VycmVudFRva2VuID0gWycoJywgJygnLCBwb3NdXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFsnYnJhY2tldHMnLCBjb250ZW50LCBwb3MsIG5leHRdXG4gICAgICAgICAgICBwb3MgPSBuZXh0XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgY2FzZSBTSU5HTEVfUVVPVEU6XG4gICAgICBjYXNlIERPVUJMRV9RVU9URToge1xuICAgICAgICBxdW90ZSA9IGNvZGUgPT09IFNJTkdMRV9RVU9URSA/IFwiJ1wiIDogJ1wiJ1xuICAgICAgICBuZXh0ID0gcG9zXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBlc2NhcGVkID0gZmFsc2VcbiAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YocXVvdGUsIG5leHQgKyAxKVxuICAgICAgICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKGlnbm9yZSB8fCBpZ25vcmVVbmNsb3NlZCkge1xuICAgICAgICAgICAgICBuZXh0ID0gcG9zICsgMVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdW5jbG9zZWQoJ3N0cmluZycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVzY2FwZVBvcyA9IG5leHRcbiAgICAgICAgICB3aGlsZSAoY3NzLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IEJBQ0tTTEFTSCkge1xuICAgICAgICAgICAgZXNjYXBlUG9zIC09IDFcbiAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZFxuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZXNjYXBlZClcblxuICAgICAgICBjdXJyZW50VG9rZW4gPSBbJ3N0cmluZycsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSwgcG9zLCBuZXh0XVxuICAgICAgICBwb3MgPSBuZXh0XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNhc2UgQVQ6IHtcbiAgICAgICAgUkVfQVRfRU5ELmxhc3RJbmRleCA9IHBvcyArIDFcbiAgICAgICAgUkVfQVRfRU5ELnRlc3QoY3NzKVxuICAgICAgICBpZiAoUkVfQVRfRU5ELmxhc3RJbmRleCA9PT0gMCkge1xuICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoIC0gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSBSRV9BVF9FTkQubGFzdEluZGV4IC0gMlxuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFRva2VuID0gWydhdC13b3JkJywgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdXG5cbiAgICAgICAgcG9zID0gbmV4dFxuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBjYXNlIEJBQ0tTTEFTSDoge1xuICAgICAgICBuZXh0ID0gcG9zXG4gICAgICAgIGVzY2FwZSA9IHRydWVcbiAgICAgICAgd2hpbGUgKGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKSA9PT0gQkFDS1NMQVNIKSB7XG4gICAgICAgICAgbmV4dCArPSAxXG4gICAgICAgICAgZXNjYXBlID0gIWVzY2FwZVxuICAgICAgICB9XG4gICAgICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0ICsgMSlcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGVzY2FwZSAmJlxuICAgICAgICAgIGNvZGUgIT09IFNMQVNIICYmXG4gICAgICAgICAgY29kZSAhPT0gU1BBQ0UgJiZcbiAgICAgICAgICBjb2RlICE9PSBORVdMSU5FICYmXG4gICAgICAgICAgY29kZSAhPT0gVEFCICYmXG4gICAgICAgICAgY29kZSAhPT0gQ1IgJiZcbiAgICAgICAgICBjb2RlICE9PSBGRUVEXG4gICAgICAgICkge1xuICAgICAgICAgIG5leHQgKz0gMVxuICAgICAgICAgIGlmIChSRV9IRVhfRVNDQVBFLnRlc3QoY3NzLmNoYXJBdChuZXh0KSkpIHtcbiAgICAgICAgICAgIHdoaWxlIChSRV9IRVhfRVNDQVBFLnRlc3QoY3NzLmNoYXJBdChuZXh0ICsgMSkpKSB7XG4gICAgICAgICAgICAgIG5leHQgKz0gMVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNzcy5jaGFyQ29kZUF0KG5leHQgKyAxKSA9PT0gU1BBQ0UpIHtcbiAgICAgICAgICAgICAgbmV4dCArPSAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFRva2VuID0gWyd3b3JkJywgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLCBwb3MsIG5leHRdXG5cbiAgICAgICAgcG9zID0gbmV4dFxuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGlmIChjb2RlID09PSBTTEFTSCAmJiBjc3MuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gQVNURVJJU0spIHtcbiAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoJyovJywgcG9zICsgMikgKyAxXG4gICAgICAgICAgaWYgKG5leHQgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChpZ25vcmUgfHwgaWdub3JlVW5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGhcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVuY2xvc2VkKCdjb21tZW50JylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbJ2NvbW1lbnQnLCBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksIHBvcywgbmV4dF1cbiAgICAgICAgICBwb3MgPSBuZXh0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUkVfV09SRF9FTkQubGFzdEluZGV4ID0gcG9zICsgMVxuICAgICAgICAgIFJFX1dPUkRfRU5ELnRlc3QoY3NzKVxuICAgICAgICAgIGlmIChSRV9XT1JEX0VORC5sYXN0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoIC0gMVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0ID0gUkVfV09SRF9FTkQubGFzdEluZGV4IC0gMlxuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFsnd29yZCcsIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSwgcG9zLCBuZXh0XVxuICAgICAgICAgIGJ1ZmZlci5wdXNoKGN1cnJlbnRUb2tlbilcbiAgICAgICAgICBwb3MgPSBuZXh0XG4gICAgICAgIH1cblxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIHBvcysrXG4gICAgcmV0dXJuIGN1cnJlbnRUb2tlblxuICB9XG5cbiAgZnVuY3Rpb24gYmFjayh0b2tlbikge1xuICAgIHJldHVybmVkLnB1c2godG9rZW4pXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhY2ssXG4gICAgZW5kT2ZGaWxlLFxuICAgIG5leHRUb2tlbixcbiAgICBwb3NpdGlvblxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/tokenize.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/warn-once.js":
/*!***********************************************!*\
  !*** ./node_modules/postcss/lib/warn-once.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("/* eslint-disable no-console */\n\n\nlet printed = {}\n\nmodule.exports = function warnOnce(message) {\n  if (printed[message]) return\n  printed[message] = true\n\n  if (typeof console !== 'undefined' && console.warn) {\n    console.warn(message)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvd2Fybi1vbmNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ1k7O0FBRVo7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vamltaXB1bHNhckBnaXRodWIuY29tLy4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MvbGliL3dhcm4tb25jZS5qcz8zOTcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbid1c2Ugc3RyaWN0J1xuXG5sZXQgcHJpbnRlZCA9IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2Fybk9uY2UobWVzc2FnZSkge1xuICBpZiAocHJpbnRlZFttZXNzYWdlXSkgcmV0dXJuXG4gIHByaW50ZWRbbWVzc2FnZV0gPSB0cnVlXG5cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICBjb25zb2xlLndhcm4obWVzc2FnZSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/warn-once.js\n");

/***/ }),

/***/ "./node_modules/postcss/lib/warning.js":
/*!*********************************************!*\
  !*** ./node_modules/postcss/lib/warning.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nclass Warning {\n  constructor(text, opts = {}) {\n    this.type = 'warning'\n    this.text = text\n\n    if (opts.node && opts.node.source) {\n      let range = opts.node.rangeBy(opts)\n      this.line = range.start.line\n      this.column = range.start.column\n      this.endLine = range.end.line\n      this.endColumn = range.end.column\n    }\n\n    for (let opt in opts) this[opt] = opts[opt]\n  }\n\n  toString() {\n    if (this.node) {\n      return this.node.error(this.text, {\n        index: this.index,\n        plugin: this.plugin,\n        word: this.word\n      }).message\n    }\n\n    if (this.plugin) {\n      return this.plugin + ': ' + this.text\n    }\n\n    return this.text\n  }\n}\n\nmodule.exports = Warning\nWarning.default = Warning\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvd2FybmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2ppbWlwdWxzYXJAZ2l0aHViLmNvbS8uL25vZGVfbW9kdWxlcy9wb3N0Y3NzL2xpYi93YXJuaW5nLmpzP2E0YjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIFdhcm5pbmcge1xuICBjb25zdHJ1Y3Rvcih0ZXh0LCBvcHRzID0ge30pIHtcbiAgICB0aGlzLnR5cGUgPSAnd2FybmluZydcbiAgICB0aGlzLnRleHQgPSB0ZXh0XG5cbiAgICBpZiAob3B0cy5ub2RlICYmIG9wdHMubm9kZS5zb3VyY2UpIHtcbiAgICAgIGxldCByYW5nZSA9IG9wdHMubm9kZS5yYW5nZUJ5KG9wdHMpXG4gICAgICB0aGlzLmxpbmUgPSByYW5nZS5zdGFydC5saW5lXG4gICAgICB0aGlzLmNvbHVtbiA9IHJhbmdlLnN0YXJ0LmNvbHVtblxuICAgICAgdGhpcy5lbmRMaW5lID0gcmFuZ2UuZW5kLmxpbmVcbiAgICAgIHRoaXMuZW5kQ29sdW1uID0gcmFuZ2UuZW5kLmNvbHVtblxuICAgIH1cblxuICAgIGZvciAobGV0IG9wdCBpbiBvcHRzKSB0aGlzW29wdF0gPSBvcHRzW29wdF1cbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGlmICh0aGlzLm5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUuZXJyb3IodGhpcy50ZXh0LCB7XG4gICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICBwbHVnaW46IHRoaXMucGx1Z2luLFxuICAgICAgICB3b3JkOiB0aGlzLndvcmRcbiAgICAgIH0pLm1lc3NhZ2VcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wbHVnaW4pIHtcbiAgICAgIHJldHVybiB0aGlzLnBsdWdpbiArICc6ICcgKyB0aGlzLnRleHRcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50ZXh0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXYXJuaW5nXG5XYXJuaW5nLmRlZmF1bHQgPSBXYXJuaW5nXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/warning.js\n");

/***/ }),

/***/ "?fe98":
/*!**************************************!*\
  !*** ./terminal-highlight (ignored) ***!
  \**************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?2f81":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?25fb":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?6f78":
/*!*******************************!*\
  !*** source-map-js (ignored) ***!
  \*******************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?9214":
/*!*********************!*\
  !*** url (ignored) ***!
  \*********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./node_modules/nanoid/non-secure/index.cjs":
/*!**************************************************!*\
  !*** ./node_modules/nanoid/non-secure/index.cjs ***!
  \**************************************************/
/***/ ((module) => {

eval("let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\nmodule.exports = { nanoid, customAlphabet }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmFub2lkL25vbi1zZWN1cmUvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qaW1pcHVsc2FyQGdpdGh1Yi5jb20vLi9ub2RlX21vZHVsZXMvbmFub2lkL25vbi1zZWN1cmUvaW5kZXguY2pzP2JkODEiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHVybEFscGhhYmV0ID1cbiAgJ3VzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3QnXG5sZXQgY3VzdG9tQWxwaGFiZXQgPSAoYWxwaGFiZXQsIGRlZmF1bHRTaXplID0gMjEpID0+IHtcbiAgcmV0dXJuIChzaXplID0gZGVmYXVsdFNpemUpID0+IHtcbiAgICBsZXQgaWQgPSAnJ1xuICAgIGxldCBpID0gc2l6ZVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlkICs9IGFscGhhYmV0WyhNYXRoLnJhbmRvbSgpICogYWxwaGFiZXQubGVuZ3RoKSB8IDBdXG4gICAgfVxuICAgIHJldHVybiBpZFxuICB9XG59XG5sZXQgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBsZXQgaWQgPSAnJ1xuICBsZXQgaSA9IHNpemVcbiAgd2hpbGUgKGktLSkge1xuICAgIGlkICs9IHVybEFscGhhYmV0WyhNYXRoLnJhbmRvbSgpICogNjQpIHwgMF1cbiAgfVxuICByZXR1cm4gaWRcbn1cbm1vZHVsZS5leHBvcnRzID0geyBuYW5vaWQsIGN1c3RvbUFscGhhYmV0IH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/nanoid/non-secure/index.cjs\n");

/***/ }),

/***/ "./node_modules/postcss/lib/postcss.mjs":
/*!**********************************************!*\
  !*** ./node_modules/postcss/lib/postcss.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AtRule: () => (/* binding */ AtRule),\n/* harmony export */   Comment: () => (/* binding */ Comment),\n/* harmony export */   Container: () => (/* binding */ Container),\n/* harmony export */   CssSyntaxError: () => (/* binding */ CssSyntaxError),\n/* harmony export */   Declaration: () => (/* binding */ Declaration),\n/* harmony export */   Document: () => (/* binding */ Document),\n/* harmony export */   Input: () => (/* binding */ Input),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   Processor: () => (/* binding */ Processor),\n/* harmony export */   Result: () => (/* binding */ Result),\n/* harmony export */   Root: () => (/* binding */ Root),\n/* harmony export */   Rule: () => (/* binding */ Rule),\n/* harmony export */   Warning: () => (/* binding */ Warning),\n/* harmony export */   atRule: () => (/* binding */ atRule),\n/* harmony export */   comment: () => (/* binding */ comment),\n/* harmony export */   decl: () => (/* binding */ decl),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   document: () => (/* binding */ document),\n/* harmony export */   fromJSON: () => (/* binding */ fromJSON),\n/* harmony export */   list: () => (/* binding */ list),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   plugin: () => (/* binding */ plugin),\n/* harmony export */   root: () => (/* binding */ root),\n/* harmony export */   rule: () => (/* binding */ rule),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\n/* harmony import */ var _postcss_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./postcss.js */ \"./node_modules/postcss/lib/postcss.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_postcss_js__WEBPACK_IMPORTED_MODULE_0__);\n\nconst stringify = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.stringify\nconst fromJSON = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.fromJSON\nconst plugin = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.plugin\nconst parse = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.parse\nconst list = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.list\n\nconst document = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.document\nconst comment = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.comment\nconst atRule = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.atRule\nconst rule = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.rule\nconst decl = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.decl\nconst root = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.root\n\nconst CssSyntaxError = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.CssSyntaxError\nconst Declaration = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Declaration\nconst Container = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Container\nconst Processor = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Processor\nconst Document = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Document\nconst Comment = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Comment\nconst Warning = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Warning\nconst AtRule = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.AtRule\nconst Result = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Result\nconst Input = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Input\nconst Rule = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Rule\nconst Root = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Root\nconst Node = _postcss_js__WEBPACK_IMPORTED_MODULE_0__.Node\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcG9zdGNzcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0M7O0FBRWxDLGlFQUFlLHdDQUFPOztBQUVmLGtCQUFrQixrREFBaUI7QUFDbkMsaUJBQWlCLGlEQUFnQjtBQUNqQyxlQUFlLCtDQUFjO0FBQzdCLGNBQWMsOENBQWE7QUFDM0IsYUFBYSw2Q0FBWTs7QUFFekIsaUJBQWlCLGlEQUFnQjtBQUNqQyxnQkFBZ0IsZ0RBQWU7QUFDL0IsZUFBZSwrQ0FBYztBQUM3QixhQUFhLDZDQUFZO0FBQ3pCLGFBQWEsNkNBQVk7QUFDekIsYUFBYSw2Q0FBWTs7QUFFekIsdUJBQXVCLHVEQUFzQjtBQUM3QyxvQkFBb0Isb0RBQW1CO0FBQ3ZDLGtCQUFrQixrREFBaUI7QUFDbkMsa0JBQWtCLGtEQUFpQjtBQUNuQyxpQkFBaUIsaURBQWdCO0FBQ2pDLGdCQUFnQixnREFBZTtBQUMvQixnQkFBZ0IsZ0RBQWU7QUFDL0IsZUFBZSwrQ0FBYztBQUM3QixlQUFlLCtDQUFjO0FBQzdCLGNBQWMsOENBQWE7QUFDM0IsYUFBYSw2Q0FBWTtBQUN6QixhQUFhLDZDQUFZO0FBQ3pCLGFBQWEsNkNBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qaW1pcHVsc2FyQGdpdGh1Yi5jb20vLi9ub2RlX21vZHVsZXMvcG9zdGNzcy9saWIvcG9zdGNzcy5tanM/NzY1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcG9zdGNzcyBmcm9tICcuL3Bvc3Rjc3MuanMnXG5cbmV4cG9ydCBkZWZhdWx0IHBvc3Rjc3NcblxuZXhwb3J0IGNvbnN0IHN0cmluZ2lmeSA9IHBvc3Rjc3Muc3RyaW5naWZ5XG5leHBvcnQgY29uc3QgZnJvbUpTT04gPSBwb3N0Y3NzLmZyb21KU09OXG5leHBvcnQgY29uc3QgcGx1Z2luID0gcG9zdGNzcy5wbHVnaW5cbmV4cG9ydCBjb25zdCBwYXJzZSA9IHBvc3Rjc3MucGFyc2VcbmV4cG9ydCBjb25zdCBsaXN0ID0gcG9zdGNzcy5saXN0XG5cbmV4cG9ydCBjb25zdCBkb2N1bWVudCA9IHBvc3Rjc3MuZG9jdW1lbnRcbmV4cG9ydCBjb25zdCBjb21tZW50ID0gcG9zdGNzcy5jb21tZW50XG5leHBvcnQgY29uc3QgYXRSdWxlID0gcG9zdGNzcy5hdFJ1bGVcbmV4cG9ydCBjb25zdCBydWxlID0gcG9zdGNzcy5ydWxlXG5leHBvcnQgY29uc3QgZGVjbCA9IHBvc3Rjc3MuZGVjbFxuZXhwb3J0IGNvbnN0IHJvb3QgPSBwb3N0Y3NzLnJvb3RcblxuZXhwb3J0IGNvbnN0IENzc1N5bnRheEVycm9yID0gcG9zdGNzcy5Dc3NTeW50YXhFcnJvclxuZXhwb3J0IGNvbnN0IERlY2xhcmF0aW9uID0gcG9zdGNzcy5EZWNsYXJhdGlvblxuZXhwb3J0IGNvbnN0IENvbnRhaW5lciA9IHBvc3Rjc3MuQ29udGFpbmVyXG5leHBvcnQgY29uc3QgUHJvY2Vzc29yID0gcG9zdGNzcy5Qcm9jZXNzb3JcbmV4cG9ydCBjb25zdCBEb2N1bWVudCA9IHBvc3Rjc3MuRG9jdW1lbnRcbmV4cG9ydCBjb25zdCBDb21tZW50ID0gcG9zdGNzcy5Db21tZW50XG5leHBvcnQgY29uc3QgV2FybmluZyA9IHBvc3Rjc3MuV2FybmluZ1xuZXhwb3J0IGNvbnN0IEF0UnVsZSA9IHBvc3Rjc3MuQXRSdWxlXG5leHBvcnQgY29uc3QgUmVzdWx0ID0gcG9zdGNzcy5SZXN1bHRcbmV4cG9ydCBjb25zdCBJbnB1dCA9IHBvc3Rjc3MuSW5wdXRcbmV4cG9ydCBjb25zdCBSdWxlID0gcG9zdGNzcy5SdWxlXG5leHBvcnQgY29uc3QgUm9vdCA9IHBvc3Rjc3MuUm9vdFxuZXhwb3J0IGNvbnN0IE5vZGUgPSBwb3N0Y3NzLk5vZGVcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/postcss/lib/postcss.mjs\n");

/***/ }),

/***/ "./node_modules/vite/dist/node/chunks/dep-Ba1kN6Mp.js":
/*!************************************************************!*\
  !*** ./node_modules/vite/dist/node/chunks/dep-Ba1kN6Mp.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   i: () => (/* binding */ index$1)\n/* harmony export */ });\n/* harmony import */ var _dep_CB_7IfJ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dep-CB_7IfJ-.js */ \"./node_modules/vite/dist/node/chunks/dep-CB_7IfJ-.js\");\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var postcss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! postcss */ \"./node_modules/postcss/lib/postcss.mjs\");\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'crypto'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\n/* harmony import */ var _dep_IQS_Za7F_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dep-IQS-Za7F.js */ \"./node_modules/vite/dist/node/chunks/dep-IQS-Za7F.js\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_module__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! node:module */ \"node:module\");\n/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\n\n\n\n\n\n\n\n\n\nconst __filename = (0,node_url__WEBPACK_IMPORTED_MODULE_5__.fileURLToPath)(\"file:///var/www/html/livewire-tall/node_modules/vite/dist/node/chunks/dep-Ba1kN6Mp.js\");\nconst __dirname = (0,node_path__WEBPACK_IMPORTED_MODULE_6__.dirname)(__filename);\nconst require = (0,node_module__WEBPACK_IMPORTED_MODULE_7__.createRequire)(\"file:///var/www/html/livewire-tall/node_modules/vite/dist/node/chunks/dep-Ba1kN6Mp.js\");\nconst __require = require;\nfunction _mergeNamespaces(n, m) {\n  for (var i = 0; i < m.length; i++) {\n    var e = m[i];\n    if (typeof e !== 'string' && !Array.isArray(e)) { for (var k in e) {\n      if (k !== 'default' && !(k in n)) {\n        n[k] = e[k];\n      }\n    } }\n  }\n  return n;\n}\n\nvar build = {exports: {}};\n\nvar fs = {};\n\nObject.defineProperty(fs, \"__esModule\", {\n  value: true\n});\nfs.getFileSystem = getFileSystem;\nfs.setFileSystem = setFileSystem;\nlet fileSystem = {\n  readFile: () => {\n    throw Error(\"readFile not implemented\");\n  },\n  writeFile: () => {\n    throw Error(\"writeFile not implemented\");\n  }\n};\n\nfunction setFileSystem(fs) {\n  fileSystem.readFile = fs.readFile;\n  fileSystem.writeFile = fs.writeFile;\n}\n\nfunction getFileSystem() {\n  return fileSystem;\n}\n\nvar pluginFactory = {};\n\nvar unquote$1 = {};\n\nObject.defineProperty(unquote$1, \"__esModule\", {\n  value: true\n});\nunquote$1.default = unquote;\n// copied from https://github.com/lakenen/node-unquote\nconst reg = /['\"]/;\n\nfunction unquote(str) {\n  if (!str) {\n    return \"\";\n  }\n\n  if (reg.test(str.charAt(0))) {\n    str = str.substr(1);\n  }\n\n  if (reg.test(str.charAt(str.length - 1))) {\n    str = str.substr(0, str.length - 1);\n  }\n\n  return str;\n}\n\nvar Parser$1 = {};\n\nconst matchValueName = /[$]?[\\w-]+/g;\n\nconst replaceValueSymbols$2 = (value, replacements) => {\n  let matches;\n\n  while ((matches = matchValueName.exec(value))) {\n    const replacement = replacements[matches[0]];\n\n    if (replacement) {\n      value =\n        value.slice(0, matches.index) +\n        replacement +\n        value.slice(matchValueName.lastIndex);\n\n      matchValueName.lastIndex -= matches[0].length - replacement.length;\n    }\n  }\n\n  return value;\n};\n\nvar replaceValueSymbols_1 = replaceValueSymbols$2;\n\nconst replaceValueSymbols$1 = replaceValueSymbols_1;\n\nconst replaceSymbols$1 = (css, replacements) => {\n  css.walk((node) => {\n    if (node.type === \"decl\" && node.value) {\n      node.value = replaceValueSymbols$1(node.value.toString(), replacements);\n    } else if (node.type === \"rule\" && node.selector) {\n      node.selector = replaceValueSymbols$1(\n        node.selector.toString(),\n        replacements\n      );\n    } else if (node.type === \"atrule\" && node.params) {\n      node.params = replaceValueSymbols$1(node.params.toString(), replacements);\n    }\n  });\n};\n\nvar replaceSymbols_1 = replaceSymbols$1;\n\nconst importPattern = /^:import\\((\"[^\"]*\"|'[^']*'|[^\"']+)\\)$/;\nconst balancedQuotes = /^(\"[^\"]*\"|'[^']*'|[^\"']+)$/;\n\nconst getDeclsObject = (rule) => {\n  const object = {};\n\n  rule.walkDecls((decl) => {\n    const before = decl.raws.before ? decl.raws.before.trim() : \"\";\n\n    object[before + decl.prop] = decl.value;\n  });\n\n  return object;\n};\n/**\n *\n * @param {string} css\n * @param {boolean} removeRules\n * @param {'auto' | 'rule' | 'at-rule'} mode\n */\nconst extractICSS$2 = (css, removeRules = true, mode = \"auto\") => {\n  const icssImports = {};\n  const icssExports = {};\n\n  function addImports(node, path) {\n    const unquoted = path.replace(/'|\"/g, \"\");\n    icssImports[unquoted] = Object.assign(\n      icssImports[unquoted] || {},\n      getDeclsObject(node)\n    );\n\n    if (removeRules) {\n      node.remove();\n    }\n  }\n\n  function addExports(node) {\n    Object.assign(icssExports, getDeclsObject(node));\n    if (removeRules) {\n      node.remove();\n    }\n  }\n\n  css.each((node) => {\n    if (node.type === \"rule\" && mode !== \"at-rule\") {\n      if (node.selector.slice(0, 7) === \":import\") {\n        const matches = importPattern.exec(node.selector);\n\n        if (matches) {\n          addImports(node, matches[1]);\n        }\n      }\n\n      if (node.selector === \":export\") {\n        addExports(node);\n      }\n    }\n\n    if (node.type === \"atrule\" && mode !== \"rule\") {\n      if (node.name === \"icss-import\") {\n        const matches = balancedQuotes.exec(node.params);\n\n        if (matches) {\n          addImports(node, matches[1]);\n        }\n      }\n      if (node.name === \"icss-export\") {\n        addExports(node);\n      }\n    }\n  });\n\n  return { icssImports, icssExports };\n};\n\nvar extractICSS_1 = extractICSS$2;\n\nconst createImports = (imports, postcss, mode = \"rule\") => {\n  return Object.keys(imports).map((path) => {\n    const aliases = imports[path];\n    const declarations = Object.keys(aliases).map((key) =>\n      postcss.decl({\n        prop: key,\n        value: aliases[key],\n        raws: { before: \"\\n  \" },\n      })\n    );\n\n    const hasDeclarations = declarations.length > 0;\n\n    const rule =\n      mode === \"rule\"\n        ? postcss.rule({\n            selector: `:import('${path}')`,\n            raws: { after: hasDeclarations ? \"\\n\" : \"\" },\n          })\n        : postcss.atRule({\n            name: \"icss-import\",\n            params: `'${path}'`,\n            raws: { after: hasDeclarations ? \"\\n\" : \"\" },\n          });\n\n    if (hasDeclarations) {\n      rule.append(declarations);\n    }\n\n    return rule;\n  });\n};\n\nconst createExports = (exports, postcss, mode = \"rule\") => {\n  const declarations = Object.keys(exports).map((key) =>\n    postcss.decl({\n      prop: key,\n      value: exports[key],\n      raws: { before: \"\\n  \" },\n    })\n  );\n\n  if (declarations.length === 0) {\n    return [];\n  }\n  const rule =\n    mode === \"rule\"\n      ? postcss.rule({\n          selector: `:export`,\n          raws: { after: \"\\n\" },\n        })\n      : postcss.atRule({\n          name: \"icss-export\",\n          raws: { after: \"\\n\" },\n        });\n\n  rule.append(declarations);\n\n  return [rule];\n};\n\nconst createICSSRules$1 = (imports, exports, postcss, mode) => [\n  ...createImports(imports, postcss, mode),\n  ...createExports(exports, postcss, mode),\n];\n\nvar createICSSRules_1 = createICSSRules$1;\n\nconst replaceValueSymbols = replaceValueSymbols_1;\nconst replaceSymbols = replaceSymbols_1;\nconst extractICSS$1 = extractICSS_1;\nconst createICSSRules = createICSSRules_1;\n\nvar src$4 = {\n  replaceValueSymbols,\n  replaceSymbols,\n  extractICSS: extractICSS$1,\n  createICSSRules,\n};\n\nObject.defineProperty(Parser$1, \"__esModule\", {\n  value: true\n});\nParser$1.default = void 0;\n\nvar _icssUtils = src$4;\n\n// Initially copied from https://github.com/css-modules/css-modules-loader-core\nconst importRegexp = /^:import\\((.+)\\)$/;\n\nclass Parser {\n  constructor(pathFetcher, trace) {\n    this.pathFetcher = pathFetcher;\n    this.plugin = this.plugin.bind(this);\n    this.exportTokens = {};\n    this.translations = {};\n    this.trace = trace;\n  }\n\n  plugin() {\n    const parser = this;\n    return {\n      postcssPlugin: \"css-modules-parser\",\n\n      async OnceExit(css) {\n        await Promise.all(parser.fetchAllImports(css));\n        parser.linkImportedSymbols(css);\n        return parser.extractExports(css);\n      }\n\n    };\n  }\n\n  fetchAllImports(css) {\n    let imports = [];\n    css.each(node => {\n      if (node.type == \"rule\" && node.selector.match(importRegexp)) {\n        imports.push(this.fetchImport(node, css.source.input.from, imports.length));\n      }\n    });\n    return imports;\n  }\n\n  linkImportedSymbols(css) {\n    (0, _icssUtils.replaceSymbols)(css, this.translations);\n  }\n\n  extractExports(css) {\n    css.each(node => {\n      if (node.type == \"rule\" && node.selector == \":export\") this.handleExport(node);\n    });\n  }\n\n  handleExport(exportNode) {\n    exportNode.each(decl => {\n      if (decl.type == \"decl\") {\n        Object.keys(this.translations).forEach(translation => {\n          decl.value = decl.value.replace(translation, this.translations[translation]);\n        });\n        this.exportTokens[decl.prop] = decl.value;\n      }\n    });\n    exportNode.remove();\n  }\n\n  async fetchImport(importNode, relativeTo, depNr) {\n    const file = importNode.selector.match(importRegexp)[1];\n    const depTrace = this.trace + String.fromCharCode(depNr);\n    const exports = await this.pathFetcher(file, relativeTo, depTrace);\n\n    try {\n      importNode.each(decl => {\n        if (decl.type == \"decl\") {\n          this.translations[decl.prop] = exports[decl.value];\n        }\n      });\n      importNode.remove();\n    } catch (err) {\n      console.log(err);\n    }\n  }\n\n}\n\nParser$1.default = Parser;\n\nvar saveJSON$1 = {};\n\nObject.defineProperty(saveJSON$1, \"__esModule\", {\n  value: true\n});\nsaveJSON$1.default = saveJSON;\n\nvar _fs$2 = fs;\n\nfunction saveJSON(cssFile, json) {\n  return new Promise((resolve, reject) => {\n    const {\n      writeFile\n    } = (0, _fs$2.getFileSystem)();\n    writeFile(`${cssFile}.json`, JSON.stringify(json), e => e ? reject(e) : resolve(json));\n  });\n}\n\nvar localsConvention = {};\n\n/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match words composed of alphanumeric characters. */\nvar reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n/** Used to match Latin Unicode letters (excluding mathematical operators). */\nvar reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20f0',\n    rsDingbatRange = '\\\\u2700-\\\\u27bf',\n    rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n    rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n    rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n    rsPunctuationRange = '\\\\u2000-\\\\u206f',\n    rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n    rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n    rsVarRange = '\\\\ufe0e\\\\ufe0f',\n    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n/** Used to compose unicode capture groups. */\nvar rsApos = \"['\\u2019]\",\n    rsAstral = '[' + rsAstralRange + ']',\n    rsBreak = '[' + rsBreakRange + ']',\n    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',\n    rsDigits = '\\\\d+',\n    rsDingbat = '[' + rsDingbatRange + ']',\n    rsLower = '[' + rsLowerRange + ']',\n    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n    rsNonAstral = '[^' + rsAstralRange + ']',\n    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n    rsUpper = '[' + rsUpperRange + ']',\n    rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',\n    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',\n    rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n    rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n    reOptMod = rsModifier + '?',\n    rsOptVar = '[' + rsVarRange + ']?',\n    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n    rsSeq = rsOptVar + reOptMod + rsOptJoin,\n    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match apostrophes. */\nvar reApos = RegExp(rsApos, 'g');\n\n/**\n * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n */\nvar reComboMark = RegExp(rsCombo, 'g');\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/** Used to match complex or compound words. */\nvar reUnicodeWord = RegExp([\n  rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n  rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',\n  rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,\n  rsUpper + '+' + rsOptUpperContr,\n  rsDigits,\n  rsEmoji\n].join('|'), 'g');\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');\n\n/** Used to detect strings that need a more robust regexp to match words. */\nvar reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n/** Used to map Latin Unicode letters to basic Latin letters. */\nvar deburredLetters = {\n  // Latin-1 Supplement block.\n  '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n  '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n  '\\xc7': 'C',  '\\xe7': 'c',\n  '\\xd0': 'D',  '\\xf0': 'd',\n  '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n  '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n  '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n  '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n  '\\xd1': 'N',  '\\xf1': 'n',\n  '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n  '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n  '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n  '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n  '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n  '\\xc6': 'Ae', '\\xe6': 'ae',\n  '\\xde': 'Th', '\\xfe': 'th',\n  '\\xdf': 'ss',\n  // Latin Extended-A block.\n  '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n  '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n  '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n  '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n  '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n  '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n  '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n  '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n  '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n  '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n  '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n  '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n  '\\u0134': 'J',  '\\u0135': 'j',\n  '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n  '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n  '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n  '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n  '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n  '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n  '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n  '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n  '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n  '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n  '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n  '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n  '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n  '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n  '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n  '\\u0174': 'W',  '\\u0175': 'w',\n  '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n  '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n  '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n  '\\u0132': 'IJ', '\\u0133': 'ij',\n  '\\u0152': 'Oe', '\\u0153': 'oe',\n  '\\u0149': \"'n\", '\\u017f': 'ss'\n};\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof _dep_CB_7IfJ_js__WEBPACK_IMPORTED_MODULE_0__.C == 'object' && _dep_CB_7IfJ_js__WEBPACK_IMPORTED_MODULE_0__.C && _dep_CB_7IfJ_js__WEBPACK_IMPORTED_MODULE_0__.C.Object === Object && _dep_CB_7IfJ_js__WEBPACK_IMPORTED_MODULE_0__.C;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root$2 = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction asciiToArray(string) {\n  return string.split('');\n}\n\n/**\n * Splits an ASCII `string` into an array of its words.\n *\n * @private\n * @param {string} The string to inspect.\n * @returns {Array} Returns the words of `string`.\n */\nfunction asciiWords(string) {\n  return string.match(reAsciiWord) || [];\n}\n\n/**\n * The base implementation of `_.propertyOf` without support for deep paths.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyOf(object) {\n  return function(key) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n * letters to basic Latin letters.\n *\n * @private\n * @param {string} letter The matched letter to deburr.\n * @returns {string} Returns the deburred letter.\n */\nvar deburrLetter = basePropertyOf(deburredLetters);\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\n/**\n * Checks if `string` contains a word composed of Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a word is found, else `false`.\n */\nfunction hasUnicodeWord(string) {\n  return reHasUnicodeWord.test(string);\n}\n\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction stringToArray(string) {\n  return hasUnicode(string)\n    ? unicodeToArray(string)\n    : asciiToArray(string);\n}\n\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n\n/**\n * Splits a Unicode `string` into an array of its words.\n *\n * @private\n * @param {string} The string to inspect.\n * @returns {Array} Returns the words of `string`.\n */\nfunction unicodeWords(string) {\n  return string.match(reUnicodeWord) || [];\n}\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar Symbol$1 = root$2.Symbol;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `array` to a slice if it's needed.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {number} start The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the cast slice.\n */\nfunction castSlice(array, start, end) {\n  var length = array.length;\n  end = end === undefined ? length : end;\n  return (!start && end >= length) ? array : baseSlice(array, start, end);\n}\n\n/**\n * Creates a function like `_.lowerFirst`.\n *\n * @private\n * @param {string} methodName The name of the `String` case method to use.\n * @returns {Function} Returns the new case function.\n */\nfunction createCaseFirst(methodName) {\n  return function(string) {\n    string = toString(string);\n\n    var strSymbols = hasUnicode(string)\n      ? stringToArray(string)\n      : undefined;\n\n    var chr = strSymbols\n      ? strSymbols[0]\n      : string.charAt(0);\n\n    var trailing = strSymbols\n      ? castSlice(strSymbols, 1).join('')\n      : string.slice(1);\n\n    return chr[methodName]() + trailing;\n  };\n}\n\n/**\n * Creates a function like `_.camelCase`.\n *\n * @private\n * @param {Function} callback The function to combine each word.\n * @returns {Function} Returns the new compounder function.\n */\nfunction createCompounder(callback) {\n  return function(string) {\n    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n  };\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the camel cased string.\n * @example\n *\n * _.camelCase('Foo Bar');\n * // => 'fooBar'\n *\n * _.camelCase('--foo-bar--');\n * // => 'fooBar'\n *\n * _.camelCase('__FOO_BAR__');\n * // => 'fooBar'\n */\nvar camelCase = createCompounder(function(result, word, index) {\n  word = word.toLowerCase();\n  return result + (index ? capitalize(word) : word);\n});\n\n/**\n * Converts the first character of `string` to upper case and the remaining\n * to lower case.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to capitalize.\n * @returns {string} Returns the capitalized string.\n * @example\n *\n * _.capitalize('FRED');\n * // => 'Fred'\n */\nfunction capitalize(string) {\n  return upperFirst(toString(string).toLowerCase());\n}\n\n/**\n * Deburrs `string` by converting\n * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n * letters to basic Latin letters and removing\n * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to deburr.\n * @returns {string} Returns the deburred string.\n * @example\n *\n * _.deburr('dj vu');\n * // => 'deja vu'\n */\nfunction deburr(string) {\n  string = toString(string);\n  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n}\n\n/**\n * Converts the first character of `string` to upper case.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.upperFirst('fred');\n * // => 'Fred'\n *\n * _.upperFirst('FRED');\n * // => 'FRED'\n */\nvar upperFirst = createCaseFirst('toUpperCase');\n\n/**\n * Splits `string` into an array of its words.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to inspect.\n * @param {RegExp|string} [pattern] The pattern to match words.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the words of `string`.\n * @example\n *\n * _.words('fred, barney, & pebbles');\n * // => ['fred', 'barney', 'pebbles']\n *\n * _.words('fred, barney, & pebbles', /[^, ]+/g);\n * // => ['fred', 'barney', '&', 'pebbles']\n */\nfunction words(string, pattern, guard) {\n  string = toString(string);\n  pattern = pattern;\n\n  if (pattern === undefined) {\n    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n  }\n  return string.match(pattern) || [];\n}\n\nvar lodash_camelcase = camelCase;\n\nObject.defineProperty(localsConvention, \"__esModule\", {\n  value: true\n});\nlocalsConvention.makeLocalsConventionReducer = makeLocalsConventionReducer;\n\nvar _lodash = _interopRequireDefault$5(lodash_camelcase);\n\nfunction _interopRequireDefault$5(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction dashesCamelCase(string) {\n  return string.replace(/-+(\\w)/g, (_, firstLetter) => firstLetter.toUpperCase());\n}\n\nfunction makeLocalsConventionReducer(localsConvention, inputFile) {\n  const isFunc = typeof localsConvention === \"function\";\n  return (tokens, [className, value]) => {\n    if (isFunc) {\n      const convention = localsConvention(className, value, inputFile);\n      tokens[convention] = value;\n      return tokens;\n    }\n\n    switch (localsConvention) {\n      case \"camelCase\":\n        tokens[className] = value;\n        tokens[(0, _lodash.default)(className)] = value;\n        break;\n\n      case \"camelCaseOnly\":\n        tokens[(0, _lodash.default)(className)] = value;\n        break;\n\n      case \"dashes\":\n        tokens[className] = value;\n        tokens[dashesCamelCase(className)] = value;\n        break;\n\n      case \"dashesOnly\":\n        tokens[dashesCamelCase(className)] = value;\n        break;\n    }\n\n    return tokens;\n  };\n}\n\nvar FileSystemLoader$1 = {};\n\nObject.defineProperty(FileSystemLoader$1, \"__esModule\", {\n  value: true\n});\nFileSystemLoader$1.default = void 0;\n\nvar _postcss$1 = _interopRequireDefault$4(postcss__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n\nvar _path = _interopRequireDefault$4(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nvar _Parser$1 = _interopRequireDefault$4(Parser$1);\n\nvar _fs$1 = fs;\n\nfunction _interopRequireDefault$4(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Initially copied from https://github.com/css-modules/css-modules-loader-core\nclass Core {\n  constructor(plugins) {\n    this.plugins = plugins || Core.defaultPlugins;\n  }\n\n  async load(sourceString, sourcePath, trace, pathFetcher) {\n    const parser = new _Parser$1.default(pathFetcher, trace);\n    const plugins = this.plugins.concat([parser.plugin()]);\n    const result = await (0, _postcss$1.default)(plugins).process(sourceString, {\n      from: sourcePath\n    });\n    return {\n      injectableSource: result.css,\n      exportTokens: parser.exportTokens\n    };\n  }\n\n} // Sorts dependencies in the following way:\n// AAA comes before AA and A\n// AB comes after AA and before A\n// All Bs come after all As\n// This ensures that the files are always returned in the following order:\n// - In the order they were required, except\n// - After all their dependencies\n\n\nconst traceKeySorter = (a, b) => {\n  if (a.length < b.length) {\n    return a < b.substring(0, a.length) ? -1 : 1;\n  }\n\n  if (a.length > b.length) {\n    return a.substring(0, b.length) <= b ? -1 : 1;\n  }\n\n  return a < b ? -1 : 1;\n};\n\nclass FileSystemLoader {\n  constructor(root, plugins, fileResolve) {\n    if (root === \"/\" && process.platform === \"win32\") {\n      const cwdDrive = process.cwd().slice(0, 3);\n\n      if (!/^[A-Za-z]:\\\\$/.test(cwdDrive)) {\n        throw new Error(`Failed to obtain root from \"${process.cwd()}\".`);\n      }\n\n      root = cwdDrive;\n    }\n\n    this.root = root;\n    this.fileResolve = fileResolve;\n    this.sources = {};\n    this.traces = {};\n    this.importNr = 0;\n    this.core = new Core(plugins);\n    this.tokensByFile = {};\n    this.fs = (0, _fs$1.getFileSystem)();\n  }\n\n  async fetch(_newPath, relativeTo, _trace) {\n    const newPath = _newPath.replace(/^[\"']|[\"']$/g, \"\");\n\n    const trace = _trace || String.fromCharCode(this.importNr++);\n\n    const useFileResolve = typeof this.fileResolve === \"function\";\n    const fileResolvedPath = useFileResolve ? await this.fileResolve(newPath, relativeTo) : await Promise.resolve();\n\n    if (fileResolvedPath && !_path.default.isAbsolute(fileResolvedPath)) {\n      throw new Error('The returned path from the \"fileResolve\" option must be absolute.');\n    }\n\n    const relativeDir = _path.default.dirname(relativeTo);\n\n    const rootRelativePath = fileResolvedPath || _path.default.resolve(relativeDir, newPath);\n\n    let fileRelativePath = fileResolvedPath || _path.default.resolve(_path.default.resolve(this.root, relativeDir), newPath); // if the path is not relative or absolute, try to resolve it in node_modules\n\n\n    if (!useFileResolve && newPath[0] !== \".\" && !_path.default.isAbsolute(newPath)) {\n      try {\n        fileRelativePath = require.resolve(newPath);\n      } catch (e) {// noop\n      }\n    }\n\n    const tokens = this.tokensByFile[fileRelativePath];\n    if (tokens) return tokens;\n    return new Promise((resolve, reject) => {\n      this.fs.readFile(fileRelativePath, \"utf-8\", async (err, source) => {\n        if (err) reject(err);\n        const {\n          injectableSource,\n          exportTokens\n        } = await this.core.load(source, rootRelativePath, trace, this.fetch.bind(this));\n        this.sources[fileRelativePath] = injectableSource;\n        this.traces[trace] = fileRelativePath;\n        this.tokensByFile[fileRelativePath] = exportTokens;\n        resolve(exportTokens);\n      });\n    });\n  }\n\n  get finalSource() {\n    const traces = this.traces;\n    const sources = this.sources;\n    let written = new Set();\n    return Object.keys(traces).sort(traceKeySorter).map(key => {\n      const filename = traces[key];\n\n      if (written.has(filename)) {\n        return null;\n      }\n\n      written.add(filename);\n      return sources[filename];\n    }).join(\"\");\n  }\n\n}\n\nFileSystemLoader$1.default = FileSystemLoader;\n\nvar scoping = {};\n\nvar src$3 = {exports: {}};\n\nconst PERMANENT_MARKER = 2;\nconst TEMPORARY_MARKER = 1;\n\nfunction createError(node, graph) {\n  const er = new Error(\"Nondeterministic import's order\");\n\n  const related = graph[node];\n  const relatedNode = related.find(\n    (relatedNode) => graph[relatedNode].indexOf(node) > -1\n  );\n\n  er.nodes = [node, relatedNode];\n\n  return er;\n}\n\nfunction walkGraph(node, graph, state, result, strict) {\n  if (state[node] === PERMANENT_MARKER) {\n    return;\n  }\n\n  if (state[node] === TEMPORARY_MARKER) {\n    if (strict) {\n      return createError(node, graph);\n    }\n\n    return;\n  }\n\n  state[node] = TEMPORARY_MARKER;\n\n  const children = graph[node];\n  const length = children.length;\n\n  for (let i = 0; i < length; ++i) {\n    const error = walkGraph(children[i], graph, state, result, strict);\n\n    if (error instanceof Error) {\n      return error;\n    }\n  }\n\n  state[node] = PERMANENT_MARKER;\n\n  result.push(node);\n}\n\nfunction topologicalSort$1(graph, strict) {\n  const result = [];\n  const state = {};\n\n  const nodes = Object.keys(graph);\n  const length = nodes.length;\n\n  for (let i = 0; i < length; ++i) {\n    const er = walkGraph(nodes[i], graph, state, result, strict);\n\n    if (er instanceof Error) {\n      return er;\n    }\n  }\n\n  return result;\n}\n\nvar topologicalSort_1 = topologicalSort$1;\n\nconst topologicalSort = topologicalSort_1;\n\nconst matchImports$1 = /^(.+?)\\s+from\\s+(?:\"([^\"]+)\"|'([^']+)'|(global))$/;\nconst icssImport = /^:import\\((?:\"([^\"]+)\"|'([^']+)')\\)/;\n\nconst VISITED_MARKER = 1;\n\n/**\n * :import('G') {}\n *\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'B'\n\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'A'\n *   composes: ... from 'C'\n *\n * Results in:\n *\n * graph: {\n *   G: [],\n *   A: [],\n *   B: ['A'],\n *   C: ['A'],\n * }\n */\nfunction addImportToGraph(importId, parentId, graph, visited) {\n  const siblingsId = parentId + \"_\" + \"siblings\";\n  const visitedId = parentId + \"_\" + importId;\n\n  if (visited[visitedId] !== VISITED_MARKER) {\n    if (!Array.isArray(visited[siblingsId])) {\n      visited[siblingsId] = [];\n    }\n\n    const siblings = visited[siblingsId];\n\n    if (Array.isArray(graph[importId])) {\n      graph[importId] = graph[importId].concat(siblings);\n    } else {\n      graph[importId] = siblings.slice();\n    }\n\n    visited[visitedId] = VISITED_MARKER;\n\n    siblings.push(importId);\n  }\n}\n\nsrc$3.exports = (options = {}) => {\n  let importIndex = 0;\n  const createImportedName =\n    typeof options.createImportedName !== \"function\"\n      ? (importName /*, path*/) =>\n          `i__imported_${importName.replace(/\\W/g, \"_\")}_${importIndex++}`\n      : options.createImportedName;\n  const failOnWrongOrder = options.failOnWrongOrder;\n\n  return {\n    postcssPlugin: \"postcss-modules-extract-imports\",\n    prepare() {\n      const graph = {};\n      const visited = {};\n      const existingImports = {};\n      const importDecls = {};\n      const imports = {};\n\n      return {\n        Once(root, postcss) {\n          // Check the existing imports order and save refs\n          root.walkRules((rule) => {\n            const matches = icssImport.exec(rule.selector);\n\n            if (matches) {\n              const [, /*match*/ doubleQuotePath, singleQuotePath] = matches;\n              const importPath = doubleQuotePath || singleQuotePath;\n\n              addImportToGraph(importPath, \"root\", graph, visited);\n\n              existingImports[importPath] = rule;\n            }\n          });\n\n          root.walkDecls(/^composes$/, (declaration) => {\n            const multiple = declaration.value.split(\",\");\n            const values = [];\n\n            multiple.forEach((value) => {\n              const matches = value.trim().match(matchImports$1);\n\n              if (!matches) {\n                values.push(value);\n\n                return;\n              }\n\n              let tmpSymbols;\n              let [\n                ,\n                /*match*/ symbols,\n                doubleQuotePath,\n                singleQuotePath,\n                global,\n              ] = matches;\n\n              if (global) {\n                // Composing globals simply means changing these classes to wrap them in global(name)\n                tmpSymbols = symbols.split(/\\s+/).map((s) => `global(${s})`);\n              } else {\n                const importPath = doubleQuotePath || singleQuotePath;\n\n                let parent = declaration.parent;\n                let parentIndexes = \"\";\n\n                while (parent.type !== \"root\") {\n                  parentIndexes =\n                    parent.parent.index(parent) + \"_\" + parentIndexes;\n                  parent = parent.parent;\n                }\n\n                const { selector } = declaration.parent;\n                const parentRule = `_${parentIndexes}${selector}`;\n\n                addImportToGraph(importPath, parentRule, graph, visited);\n\n                importDecls[importPath] = declaration;\n                imports[importPath] = imports[importPath] || {};\n\n                tmpSymbols = symbols.split(/\\s+/).map((s) => {\n                  if (!imports[importPath][s]) {\n                    imports[importPath][s] = createImportedName(s, importPath);\n                  }\n\n                  return imports[importPath][s];\n                });\n              }\n\n              values.push(tmpSymbols.join(\" \"));\n            });\n\n            declaration.value = values.join(\", \");\n          });\n\n          const importsOrder = topologicalSort(graph, failOnWrongOrder);\n\n          if (importsOrder instanceof Error) {\n            const importPath = importsOrder.nodes.find((importPath) =>\n              // eslint-disable-next-line no-prototype-builtins\n              importDecls.hasOwnProperty(importPath)\n            );\n            const decl = importDecls[importPath];\n\n            throw decl.error(\n              \"Failed to resolve order of composed modules \" +\n                importsOrder.nodes\n                  .map((importPath) => \"`\" + importPath + \"`\")\n                  .join(\", \") +\n                \".\",\n              {\n                plugin: \"postcss-modules-extract-imports\",\n                word: \"composes\",\n              }\n            );\n          }\n\n          let lastImportRule;\n\n          importsOrder.forEach((path) => {\n            const importedSymbols = imports[path];\n            let rule = existingImports[path];\n\n            if (!rule && importedSymbols) {\n              rule = postcss.rule({\n                selector: `:import(\"${path}\")`,\n                raws: { after: \"\\n\" },\n              });\n\n              if (lastImportRule) {\n                root.insertAfter(lastImportRule, rule);\n              } else {\n                root.prepend(rule);\n              }\n            }\n\n            lastImportRule = rule;\n\n            if (!importedSymbols) {\n              return;\n            }\n\n            Object.keys(importedSymbols).forEach((importedSymbol) => {\n              rule.append(\n                postcss.decl({\n                  value: importedSymbol,\n                  prop: importedSymbols[importedSymbol],\n                  raws: { before: \"\\n  \" },\n                })\n              );\n            });\n          });\n        },\n      };\n    },\n  };\n};\n\nsrc$3.exports.postcss = true;\n\nvar srcExports$2 = src$3.exports;\n\nvar wasmHash = {exports: {}};\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar hasRequiredWasmHash;\n\nfunction requireWasmHash () {\n\tif (hasRequiredWasmHash) return wasmHash.exports;\n\thasRequiredWasmHash = 1;\n\n\t// 65536 is the size of a wasm memory page\n\t// 64 is the maximum chunk size for every possible wasm hash implementation\n\t// 4 is the maximum number of bytes per char for string encoding (max is utf-8)\n\t// ~3 makes sure that it's always a block of 4 chars, so avoid partially encoded bytes for base64\n\tconst MAX_SHORT_STRING = Math.floor((65536 - 64) / 4) & ~3;\n\n\tclass WasmHash {\n\t  /**\n\t   * @param {WebAssembly.Instance} instance wasm instance\n\t   * @param {WebAssembly.Instance[]} instancesPool pool of instances\n\t   * @param {number} chunkSize size of data chunks passed to wasm\n\t   * @param {number} digestSize size of digest returned by wasm\n\t   */\n\t  constructor(instance, instancesPool, chunkSize, digestSize) {\n\t    const exports = /** @type {any} */ (instance.exports);\n\n\t    exports.init();\n\n\t    this.exports = exports;\n\t    this.mem = Buffer.from(exports.memory.buffer, 0, 65536);\n\t    this.buffered = 0;\n\t    this.instancesPool = instancesPool;\n\t    this.chunkSize = chunkSize;\n\t    this.digestSize = digestSize;\n\t  }\n\n\t  reset() {\n\t    this.buffered = 0;\n\t    this.exports.init();\n\t  }\n\n\t  /**\n\t   * @param {Buffer | string} data data\n\t   * @param {BufferEncoding=} encoding encoding\n\t   * @returns {this} itself\n\t   */\n\t  update(data, encoding) {\n\t    if (typeof data === \"string\") {\n\t      while (data.length > MAX_SHORT_STRING) {\n\t        this._updateWithShortString(data.slice(0, MAX_SHORT_STRING), encoding);\n\t        data = data.slice(MAX_SHORT_STRING);\n\t      }\n\n\t      this._updateWithShortString(data, encoding);\n\n\t      return this;\n\t    }\n\n\t    this._updateWithBuffer(data);\n\n\t    return this;\n\t  }\n\n\t  /**\n\t   * @param {string} data data\n\t   * @param {BufferEncoding=} encoding encoding\n\t   * @returns {void}\n\t   */\n\t  _updateWithShortString(data, encoding) {\n\t    const { exports, buffered, mem, chunkSize } = this;\n\n\t    let endPos;\n\n\t    if (data.length < 70) {\n\t      if (!encoding || encoding === \"utf-8\" || encoding === \"utf8\") {\n\t        endPos = buffered;\n\t        for (let i = 0; i < data.length; i++) {\n\t          const cc = data.charCodeAt(i);\n\n\t          if (cc < 0x80) {\n\t            mem[endPos++] = cc;\n\t          } else if (cc < 0x800) {\n\t            mem[endPos] = (cc >> 6) | 0xc0;\n\t            mem[endPos + 1] = (cc & 0x3f) | 0x80;\n\t            endPos += 2;\n\t          } else {\n\t            // bail-out for weird chars\n\t            endPos += mem.write(data.slice(i), endPos, encoding);\n\t            break;\n\t          }\n\t        }\n\t      } else if (encoding === \"latin1\") {\n\t        endPos = buffered;\n\n\t        for (let i = 0; i < data.length; i++) {\n\t          const cc = data.charCodeAt(i);\n\n\t          mem[endPos++] = cc;\n\t        }\n\t      } else {\n\t        endPos = buffered + mem.write(data, buffered, encoding);\n\t      }\n\t    } else {\n\t      endPos = buffered + mem.write(data, buffered, encoding);\n\t    }\n\n\t    if (endPos < chunkSize) {\n\t      this.buffered = endPos;\n\t    } else {\n\t      const l = endPos & ~(this.chunkSize - 1);\n\n\t      exports.update(l);\n\n\t      const newBuffered = endPos - l;\n\n\t      this.buffered = newBuffered;\n\n\t      if (newBuffered > 0) {\n\t        mem.copyWithin(0, l, endPos);\n\t      }\n\t    }\n\t  }\n\n\t  /**\n\t   * @param {Buffer} data data\n\t   * @returns {void}\n\t   */\n\t  _updateWithBuffer(data) {\n\t    const { exports, buffered, mem } = this;\n\t    const length = data.length;\n\n\t    if (buffered + length < this.chunkSize) {\n\t      data.copy(mem, buffered, 0, length);\n\n\t      this.buffered += length;\n\t    } else {\n\t      const l = (buffered + length) & ~(this.chunkSize - 1);\n\n\t      if (l > 65536) {\n\t        let i = 65536 - buffered;\n\n\t        data.copy(mem, buffered, 0, i);\n\t        exports.update(65536);\n\n\t        const stop = l - buffered - 65536;\n\n\t        while (i < stop) {\n\t          data.copy(mem, 0, i, i + 65536);\n\t          exports.update(65536);\n\t          i += 65536;\n\t        }\n\n\t        data.copy(mem, 0, i, l - buffered);\n\n\t        exports.update(l - buffered - i);\n\t      } else {\n\t        data.copy(mem, buffered, 0, l - buffered);\n\n\t        exports.update(l);\n\t      }\n\n\t      const newBuffered = length + buffered - l;\n\n\t      this.buffered = newBuffered;\n\n\t      if (newBuffered > 0) {\n\t        data.copy(mem, 0, length - newBuffered, length);\n\t      }\n\t    }\n\t  }\n\n\t  digest(type) {\n\t    const { exports, buffered, mem, digestSize } = this;\n\n\t    exports.final(buffered);\n\n\t    this.instancesPool.push(this);\n\n\t    const hex = mem.toString(\"latin1\", 0, digestSize);\n\n\t    if (type === \"hex\") {\n\t      return hex;\n\t    }\n\n\t    if (type === \"binary\" || !type) {\n\t      return Buffer.from(hex, \"hex\");\n\t    }\n\n\t    return Buffer.from(hex, \"hex\").toString(type);\n\t  }\n\t}\n\n\tconst create = (wasmModule, instancesPool, chunkSize, digestSize) => {\n\t  if (instancesPool.length > 0) {\n\t    const old = instancesPool.pop();\n\n\t    old.reset();\n\n\t    return old;\n\t  } else {\n\t    return new WasmHash(\n\t      new WebAssembly.Instance(wasmModule),\n\t      instancesPool,\n\t      chunkSize,\n\t      digestSize\n\t    );\n\t  }\n\t};\n\n\twasmHash.exports = create;\n\twasmHash.exports.MAX_SHORT_STRING = MAX_SHORT_STRING;\n\treturn wasmHash.exports;\n}\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar xxhash64_1;\nvar hasRequiredXxhash64;\n\nfunction requireXxhash64 () {\n\tif (hasRequiredXxhash64) return xxhash64_1;\n\thasRequiredXxhash64 = 1;\n\n\tconst create = requireWasmHash();\n\n\t//#region wasm code: xxhash64 (../../../assembly/hash/xxhash64.asm.ts) --initialMemory 1\n\tconst xxhash64 = new WebAssembly.Module(\n\t  Buffer.from(\n\t    // 1173 bytes\n\t    \"AGFzbQEAAAABCAJgAX8AYAAAAwQDAQAABQMBAAEGGgV+AUIAC34BQgALfgFCAAt+AUIAC34BQgALByIEBGluaXQAAAZ1cGRhdGUAAQVmaW5hbAACBm1lbW9yeQIACrUIAzAAQtbrgu7q/Yn14AAkAELP1tO+0ser2UIkAUIAJAJC+erQ0OfJoeThACQDQgAkBAvUAQIBfwR+IABFBEAPCyMEIACtfCQEIwAhAiMBIQMjAiEEIwMhBQNAIAIgASkDAELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiECIAMgASkDCELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEDIAQgASkDEELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEEIAUgASkDGELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEFIAAgAUEgaiIBSw0ACyACJAAgAyQBIAQkAiAFJAMLqwYCAX8EfiMEQgBSBH4jACICQgGJIwEiA0IHiXwjAiIEQgyJfCMDIgVCEol8IAJCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0gA0LP1tO+0ser2UJ+Qh+JQoeVr6+Ytt6bnn9+hUKHla+vmLbem55/fkKdo7Xqg7GNivoAfSAEQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IAVCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0FQsXP2bLx5brqJwsjBCAArXx8IQIDQCABQQhqIABNBEAgAiABKQMAQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQhuJQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IQIgAUEIaiEBDAELCyABQQRqIABNBEACfyACIAE1AgBCh5Wvr5i23puef36FQheJQs/W077Sx6vZQn5C+fPd8Zn2masWfCECIAFBBGoLIQELA0AgACABRwRAIAIgATEAAELFz9my8eW66id+hUILiUKHla+vmLbem55/fiECIAFBAWohAQwBCwtBACACIAJCIYiFQs/W077Sx6vZQn4iAiACQh2IhUL5893xmfaZqxZ+IgIgAkIgiIUiAkIgiCIDQv//A4NCIIYgA0KAgPz/D4NCEIiEIgNC/4GAgPAfg0IQhiADQoD+g4CA4D+DQgiIhCIDQo+AvIDwgcAHg0IIhiADQvCBwIeAnoD4AINCBIiEIgNChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IANCsODAgYOGjJgwhHw3AwBBCCACQv////8PgyICQv//A4NCIIYgAkKAgPz/D4NCEIiEIgJC/4GAgPAfg0IQhiACQoD+g4CA4D+DQgiIhCICQo+AvIDwgcAHg0IIhiACQvCBwIeAnoD4AINCBIiEIgJChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IAJCsODAgYOGjJgwhHw3AwAL\",\n\t    \"base64\"\n\t  )\n\t);\n\t//#endregion\n\n\txxhash64_1 = create.bind(null, xxhash64, [], 32, 16);\n\treturn xxhash64_1;\n}\n\nvar BatchedHash_1;\nvar hasRequiredBatchedHash;\n\nfunction requireBatchedHash () {\n\tif (hasRequiredBatchedHash) return BatchedHash_1;\n\thasRequiredBatchedHash = 1;\n\tconst MAX_SHORT_STRING = requireWasmHash().MAX_SHORT_STRING;\n\n\tclass BatchedHash {\n\t  constructor(hash) {\n\t    this.string = undefined;\n\t    this.encoding = undefined;\n\t    this.hash = hash;\n\t  }\n\n\t  /**\n\t   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n\t   * @param {string|Buffer} data data\n\t   * @param {string=} inputEncoding data encoding\n\t   * @returns {this} updated hash\n\t   */\n\t  update(data, inputEncoding) {\n\t    if (this.string !== undefined) {\n\t      if (\n\t        typeof data === \"string\" &&\n\t        inputEncoding === this.encoding &&\n\t        this.string.length + data.length < MAX_SHORT_STRING\n\t      ) {\n\t        this.string += data;\n\n\t        return this;\n\t      }\n\n\t      this.hash.update(this.string, this.encoding);\n\t      this.string = undefined;\n\t    }\n\n\t    if (typeof data === \"string\") {\n\t      if (\n\t        data.length < MAX_SHORT_STRING &&\n\t        // base64 encoding is not valid since it may contain padding chars\n\t        (!inputEncoding || !inputEncoding.startsWith(\"ba\"))\n\t      ) {\n\t        this.string = data;\n\t        this.encoding = inputEncoding;\n\t      } else {\n\t        this.hash.update(data, inputEncoding);\n\t      }\n\t    } else {\n\t      this.hash.update(data);\n\t    }\n\n\t    return this;\n\t  }\n\n\t  /**\n\t   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n\t   * @param {string=} encoding encoding of the return value\n\t   * @returns {string|Buffer} digest\n\t   */\n\t  digest(encoding) {\n\t    if (this.string !== undefined) {\n\t      this.hash.update(this.string, this.encoding);\n\t    }\n\n\t    return this.hash.digest(encoding);\n\t  }\n\t}\n\n\tBatchedHash_1 = BatchedHash;\n\treturn BatchedHash_1;\n}\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar md4_1;\nvar hasRequiredMd4;\n\nfunction requireMd4 () {\n\tif (hasRequiredMd4) return md4_1;\n\thasRequiredMd4 = 1;\n\n\tconst create = requireWasmHash();\n\n\t//#region wasm code: md4 (../../../assembly/hash/md4.asm.ts) --initialMemory 1\n\tconst md4 = new WebAssembly.Module(\n\t  Buffer.from(\n\t    // 2150 bytes\n\t    \"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\",\n\t    \"base64\"\n\t  )\n\t);\n\t//#endregion\n\n\tmd4_1 = create.bind(null, md4, [], 64, 32);\n\treturn md4_1;\n}\n\nvar BulkUpdateDecorator_1;\nvar hasRequiredBulkUpdateDecorator;\n\nfunction requireBulkUpdateDecorator () {\n\tif (hasRequiredBulkUpdateDecorator) return BulkUpdateDecorator_1;\n\thasRequiredBulkUpdateDecorator = 1;\n\tconst BULK_SIZE = 2000;\n\n\t// We are using an object instead of a Map as this will stay static during the runtime\n\t// so access to it can be optimized by v8\n\tconst digestCaches = {};\n\n\tclass BulkUpdateDecorator {\n\t  /**\n\t   * @param {Hash | function(): Hash} hashOrFactory function to create a hash\n\t   * @param {string=} hashKey key for caching\n\t   */\n\t  constructor(hashOrFactory, hashKey) {\n\t    this.hashKey = hashKey;\n\n\t    if (typeof hashOrFactory === \"function\") {\n\t      this.hashFactory = hashOrFactory;\n\t      this.hash = undefined;\n\t    } else {\n\t      this.hashFactory = undefined;\n\t      this.hash = hashOrFactory;\n\t    }\n\n\t    this.buffer = \"\";\n\t  }\n\n\t  /**\n\t   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n\t   * @param {string|Buffer} data data\n\t   * @param {string=} inputEncoding data encoding\n\t   * @returns {this} updated hash\n\t   */\n\t  update(data, inputEncoding) {\n\t    if (\n\t      inputEncoding !== undefined ||\n\t      typeof data !== \"string\" ||\n\t      data.length > BULK_SIZE\n\t    ) {\n\t      if (this.hash === undefined) {\n\t        this.hash = this.hashFactory();\n\t      }\n\n\t      if (this.buffer.length > 0) {\n\t        this.hash.update(this.buffer);\n\t        this.buffer = \"\";\n\t      }\n\n\t      this.hash.update(data, inputEncoding);\n\t    } else {\n\t      this.buffer += data;\n\n\t      if (this.buffer.length > BULK_SIZE) {\n\t        if (this.hash === undefined) {\n\t          this.hash = this.hashFactory();\n\t        }\n\n\t        this.hash.update(this.buffer);\n\t        this.buffer = \"\";\n\t      }\n\t    }\n\n\t    return this;\n\t  }\n\n\t  /**\n\t   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n\t   * @param {string=} encoding encoding of the return value\n\t   * @returns {string|Buffer} digest\n\t   */\n\t  digest(encoding) {\n\t    let digestCache;\n\n\t    const buffer = this.buffer;\n\n\t    if (this.hash === undefined) {\n\t      // short data for hash, we can use caching\n\t      const cacheKey = `${this.hashKey}-${encoding}`;\n\n\t      digestCache = digestCaches[cacheKey];\n\n\t      if (digestCache === undefined) {\n\t        digestCache = digestCaches[cacheKey] = new Map();\n\t      }\n\n\t      const cacheEntry = digestCache.get(buffer);\n\n\t      if (cacheEntry !== undefined) {\n\t        return cacheEntry;\n\t      }\n\n\t      this.hash = this.hashFactory();\n\t    }\n\n\t    if (buffer.length > 0) {\n\t      this.hash.update(buffer);\n\t    }\n\n\t    const digestResult = this.hash.digest(encoding);\n\n\t    if (digestCache !== undefined) {\n\t      digestCache.set(buffer, digestResult);\n\t    }\n\n\t    return digestResult;\n\t  }\n\t}\n\n\tBulkUpdateDecorator_1 = BulkUpdateDecorator;\n\treturn BulkUpdateDecorator_1;\n}\n\nconst baseEncodeTables = {\n  26: \"abcdefghijklmnopqrstuvwxyz\",\n  32: \"123456789abcdefghjkmnpqrstuvwxyz\", // no 0lio\n  36: \"0123456789abcdefghijklmnopqrstuvwxyz\",\n  49: \"abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\", // no lIO\n  52: \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n  58: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\", // no 0lIO\n  62: \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n  64: \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_\",\n};\n\n/**\n * @param {Uint32Array} uint32Array Treated as a long base-0x100000000 number, little endian\n * @param {number} divisor The divisor\n * @return {number} Modulo (remainder) of the division\n */\nfunction divmod32(uint32Array, divisor) {\n  let carry = 0;\n  for (let i = uint32Array.length - 1; i >= 0; i--) {\n    const value = carry * 0x100000000 + uint32Array[i];\n    carry = value % divisor;\n    uint32Array[i] = Math.floor(value / divisor);\n  }\n  return carry;\n}\n\nfunction encodeBufferToBase(buffer, base, length) {\n  const encodeTable = baseEncodeTables[base];\n\n  if (!encodeTable) {\n    throw new Error(\"Unknown encoding base\" + base);\n  }\n\n  // Input bits are only enough to generate this many characters\n  const limit = Math.ceil((buffer.length * 8) / Math.log2(base));\n  length = Math.min(length, limit);\n\n  // Most of the crypto digests (if not all) has length a multiple of 4 bytes.\n  // Fewer numbers in the array means faster math.\n  const uint32Array = new Uint32Array(Math.ceil(buffer.length / 4));\n\n  // Make sure the input buffer data is copied and is not mutated by reference.\n  // divmod32() would corrupt the BulkUpdateDecorator cache otherwise.\n  buffer.copy(Buffer.from(uint32Array.buffer));\n\n  let output = \"\";\n\n  for (let i = 0; i < length; i++) {\n    output = encodeTable[divmod32(uint32Array, base)] + output;\n  }\n\n  return output;\n}\n\nlet crypto = undefined;\nlet createXXHash64 = undefined;\nlet createMd4 = undefined;\nlet BatchedHash = undefined;\nlet BulkUpdateDecorator = undefined;\n\nfunction getHashDigest$1(buffer, algorithm, digestType, maxLength) {\n  algorithm = algorithm || \"xxhash64\";\n  maxLength = maxLength || 9999;\n\n  let hash;\n\n  if (algorithm === \"xxhash64\") {\n    if (createXXHash64 === undefined) {\n      createXXHash64 = requireXxhash64();\n\n      if (BatchedHash === undefined) {\n        BatchedHash = requireBatchedHash();\n      }\n    }\n\n    hash = new BatchedHash(createXXHash64());\n  } else if (algorithm === \"md4\") {\n    if (createMd4 === undefined) {\n      createMd4 = requireMd4();\n\n      if (BatchedHash === undefined) {\n        BatchedHash = requireBatchedHash();\n      }\n    }\n\n    hash = new BatchedHash(createMd4());\n  } else if (algorithm === \"native-md4\") {\n    if (typeof crypto === \"undefined\") {\n      crypto = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'crypto'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\n      if (BulkUpdateDecorator === undefined) {\n        BulkUpdateDecorator = requireBulkUpdateDecorator();\n      }\n    }\n\n    hash = new BulkUpdateDecorator(() => crypto.createHash(\"md4\"), \"md4\");\n  } else {\n    if (typeof crypto === \"undefined\") {\n      crypto = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'crypto'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\n      if (BulkUpdateDecorator === undefined) {\n        BulkUpdateDecorator = requireBulkUpdateDecorator();\n      }\n    }\n\n    hash = new BulkUpdateDecorator(\n      () => crypto.createHash(algorithm),\n      algorithm\n    );\n  }\n\n  hash.update(buffer);\n\n  if (\n    digestType === \"base26\" ||\n    digestType === \"base32\" ||\n    digestType === \"base36\" ||\n    digestType === \"base49\" ||\n    digestType === \"base52\" ||\n    digestType === \"base58\" ||\n    digestType === \"base62\"\n  ) {\n    return encodeBufferToBase(hash.digest(), digestType.substr(4), maxLength);\n  } else {\n    return hash.digest(digestType || \"hex\").substr(0, maxLength);\n  }\n}\n\nvar getHashDigest_1 = getHashDigest$1;\n\nconst path$1 = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\nconst getHashDigest = getHashDigest_1;\n\nfunction interpolateName$1(loaderContext, name, options = {}) {\n  let filename;\n\n  const hasQuery =\n    loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;\n\n  if (typeof name === \"function\") {\n    filename = name(\n      loaderContext.resourcePath,\n      hasQuery ? loaderContext.resourceQuery : undefined\n    );\n  } else {\n    filename = name || \"[hash].[ext]\";\n  }\n\n  const context = options.context;\n  const content = options.content;\n  const regExp = options.regExp;\n\n  let ext = \"bin\";\n  let basename = \"file\";\n  let directory = \"\";\n  let folder = \"\";\n  let query = \"\";\n\n  if (loaderContext.resourcePath) {\n    const parsed = path$1.parse(loaderContext.resourcePath);\n    let resourcePath = loaderContext.resourcePath;\n\n    if (parsed.ext) {\n      ext = parsed.ext.substr(1);\n    }\n\n    if (parsed.dir) {\n      basename = parsed.name;\n      resourcePath = parsed.dir + path$1.sep;\n    }\n\n    if (typeof context !== \"undefined\") {\n      directory = path$1\n        .relative(context, resourcePath + \"_\")\n        .replace(/\\\\/g, \"/\")\n        .replace(/\\.\\.(\\/)?/g, \"_$1\");\n      directory = directory.substr(0, directory.length - 1);\n    } else {\n      directory = resourcePath.replace(/\\\\/g, \"/\").replace(/\\.\\.(\\/)?/g, \"_$1\");\n    }\n\n    if (directory.length === 1) {\n      directory = \"\";\n    } else if (directory.length > 1) {\n      folder = path$1.basename(directory);\n    }\n  }\n\n  if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {\n    query = loaderContext.resourceQuery;\n\n    const hashIdx = query.indexOf(\"#\");\n\n    if (hashIdx >= 0) {\n      query = query.substr(0, hashIdx);\n    }\n  }\n\n  let url = filename;\n\n  if (content) {\n    // Match hash template\n    url = url\n      // `hash` and `contenthash` are same in `loader-utils` context\n      // let's keep `hash` for backward compatibility\n      .replace(\n        /\\[(?:([^[:\\]]+):)?(?:hash|contenthash)(?::([a-z]+\\d*))?(?::(\\d+))?\\]/gi,\n        (all, hashType, digestType, maxLength) =>\n          getHashDigest(content, hashType, digestType, parseInt(maxLength, 10))\n      );\n  }\n\n  url = url\n    .replace(/\\[ext\\]/gi, () => ext)\n    .replace(/\\[name\\]/gi, () => basename)\n    .replace(/\\[path\\]/gi, () => directory)\n    .replace(/\\[folder\\]/gi, () => folder)\n    .replace(/\\[query\\]/gi, () => query);\n\n  if (regExp && loaderContext.resourcePath) {\n    const match = loaderContext.resourcePath.match(new RegExp(regExp));\n\n    match &&\n      match.forEach((matched, i) => {\n        url = url.replace(new RegExp(\"\\\\[\" + i + \"\\\\]\", \"ig\"), matched);\n      });\n  }\n\n  if (\n    typeof loaderContext.options === \"object\" &&\n    typeof loaderContext.options.customInterpolateName === \"function\"\n  ) {\n    url = loaderContext.options.customInterpolateName.call(\n      loaderContext,\n      url,\n      name,\n      options\n    );\n  }\n\n  return url;\n}\n\nvar interpolateName_1 = interpolateName$1;\n\nvar interpolateName = interpolateName_1;\nvar path = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\n/**\n * @param  {string} pattern\n * @param  {object} options\n * @param  {string} options.context\n * @param  {string} options.hashPrefix\n * @return {function}\n */\nvar genericNames = function createGenerator(pattern, options) {\n  options = options || {};\n  var context =\n    options && typeof options.context === \"string\"\n      ? options.context\n      : process.cwd();\n  var hashPrefix =\n    options && typeof options.hashPrefix === \"string\" ? options.hashPrefix : \"\";\n\n  /**\n   * @param  {string} localName Usually a class name\n   * @param  {string} filepath  Absolute path\n   * @return {string}\n   */\n  return function generate(localName, filepath) {\n    var name = pattern.replace(/\\[local\\]/gi, localName);\n    var loaderContext = {\n      resourcePath: filepath,\n    };\n\n    var loaderOptions = {\n      content:\n        hashPrefix +\n        path.relative(context, filepath).replace(/\\\\/g, \"/\") +\n        \"\\x00\" +\n        localName,\n      context: context,\n    };\n\n    var genericName = interpolateName(loaderContext, name, loaderOptions);\n    return genericName\n      .replace(new RegExp(\"[^a-zA-Z0-9\\\\-_\\u00A0-\\uFFFF]\", \"g\"), \"-\")\n      .replace(/^((-?[0-9])|--)/, \"_$1\");\n  };\n};\n\nvar src$2 = {exports: {}};\n\nvar dist = {exports: {}};\n\nvar processor = {exports: {}};\n\nvar parser = {exports: {}};\n\nvar root$1 = {exports: {}};\n\nvar container = {exports: {}};\n\nvar node$1 = {exports: {}};\n\nvar util = {};\n\nvar unesc = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = unesc;\n\t// Many thanks for this post which made this migration much easier.\n\t// https://mathiasbynens.be/notes/css-escapes\n\n\t/**\n\t * \n\t * @param {string} str \n\t * @returns {[string, number]|undefined}\n\t */\n\tfunction gobbleHex(str) {\n\t  var lower = str.toLowerCase();\n\t  var hex = '';\n\t  var spaceTerminated = false;\n\t  for (var i = 0; i < 6 && lower[i] !== undefined; i++) {\n\t    var code = lower.charCodeAt(i);\n\t    // check to see if we are dealing with a valid hex char [a-f|0-9]\n\t    var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57;\n\t    // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point\n\t    spaceTerminated = code === 32;\n\t    if (!valid) {\n\t      break;\n\t    }\n\t    hex += lower[i];\n\t  }\n\t  if (hex.length === 0) {\n\t    return undefined;\n\t  }\n\t  var codePoint = parseInt(hex, 16);\n\t  var isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF;\n\t  // Add special case for\n\t  // \"If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point\"\n\t  // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point\n\t  if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {\n\t    return [\"\\uFFFD\", hex.length + (spaceTerminated ? 1 : 0)];\n\t  }\n\t  return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];\n\t}\n\tvar CONTAINS_ESCAPE = /\\\\/;\n\tfunction unesc(str) {\n\t  var needToProcess = CONTAINS_ESCAPE.test(str);\n\t  if (!needToProcess) {\n\t    return str;\n\t  }\n\t  var ret = \"\";\n\t  for (var i = 0; i < str.length; i++) {\n\t    if (str[i] === \"\\\\\") {\n\t      var gobbled = gobbleHex(str.slice(i + 1, i + 7));\n\t      if (gobbled !== undefined) {\n\t        ret += gobbled[0];\n\t        i += gobbled[1];\n\t        continue;\n\t      }\n\n\t      // Retain a pair of \\\\ if double escaped `\\\\\\\\`\n\t      // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e\n\t      if (str[i + 1] === \"\\\\\") {\n\t        ret += \"\\\\\";\n\t        i++;\n\t        continue;\n\t      }\n\n\t      // if \\\\ is at the end of the string retain it\n\t      // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb\n\t      if (str.length === i + 1) {\n\t        ret += str[i];\n\t      }\n\t      continue;\n\t    }\n\t    ret += str[i];\n\t  }\n\t  return ret;\n\t}\n\tmodule.exports = exports.default; \n} (unesc, unesc.exports));\n\nvar unescExports = unesc.exports;\n\nvar getProp = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = getProp;\n\tfunction getProp(obj) {\n\t  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t    props[_key - 1] = arguments[_key];\n\t  }\n\t  while (props.length > 0) {\n\t    var prop = props.shift();\n\t    if (!obj[prop]) {\n\t      return undefined;\n\t    }\n\t    obj = obj[prop];\n\t  }\n\t  return obj;\n\t}\n\tmodule.exports = exports.default; \n} (getProp, getProp.exports));\n\nvar getPropExports = getProp.exports;\n\nvar ensureObject = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = ensureObject;\n\tfunction ensureObject(obj) {\n\t  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t    props[_key - 1] = arguments[_key];\n\t  }\n\t  while (props.length > 0) {\n\t    var prop = props.shift();\n\t    if (!obj[prop]) {\n\t      obj[prop] = {};\n\t    }\n\t    obj = obj[prop];\n\t  }\n\t}\n\tmodule.exports = exports.default; \n} (ensureObject, ensureObject.exports));\n\nvar ensureObjectExports = ensureObject.exports;\n\nvar stripComments = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = stripComments;\n\tfunction stripComments(str) {\n\t  var s = \"\";\n\t  var commentStart = str.indexOf(\"/*\");\n\t  var lastEnd = 0;\n\t  while (commentStart >= 0) {\n\t    s = s + str.slice(lastEnd, commentStart);\n\t    var commentEnd = str.indexOf(\"*/\", commentStart + 2);\n\t    if (commentEnd < 0) {\n\t      return s;\n\t    }\n\t    lastEnd = commentEnd + 2;\n\t    commentStart = str.indexOf(\"/*\", lastEnd);\n\t  }\n\t  s = s + str.slice(lastEnd);\n\t  return s;\n\t}\n\tmodule.exports = exports.default; \n} (stripComments, stripComments.exports));\n\nvar stripCommentsExports = stripComments.exports;\n\nutil.__esModule = true;\nutil.unesc = util.stripComments = util.getProp = util.ensureObject = void 0;\nvar _unesc = _interopRequireDefault$3(unescExports);\nutil.unesc = _unesc[\"default\"];\nvar _getProp = _interopRequireDefault$3(getPropExports);\nutil.getProp = _getProp[\"default\"];\nvar _ensureObject = _interopRequireDefault$3(ensureObjectExports);\nutil.ensureObject = _ensureObject[\"default\"];\nvar _stripComments = _interopRequireDefault$3(stripCommentsExports);\nutil.stripComments = _stripComments[\"default\"];\nfunction _interopRequireDefault$3(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\tvar _util = util;\n\tfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\tfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\tvar cloneNode = function cloneNode(obj, parent) {\n\t  if (typeof obj !== 'object' || obj === null) {\n\t    return obj;\n\t  }\n\t  var cloned = new obj.constructor();\n\t  for (var i in obj) {\n\t    if (!obj.hasOwnProperty(i)) {\n\t      continue;\n\t    }\n\t    var value = obj[i];\n\t    var type = typeof value;\n\t    if (i === 'parent' && type === 'object') {\n\t      if (parent) {\n\t        cloned[i] = parent;\n\t      }\n\t    } else if (value instanceof Array) {\n\t      cloned[i] = value.map(function (j) {\n\t        return cloneNode(j, cloned);\n\t      });\n\t    } else {\n\t      cloned[i] = cloneNode(value, cloned);\n\t    }\n\t  }\n\t  return cloned;\n\t};\n\tvar Node = /*#__PURE__*/function () {\n\t  function Node(opts) {\n\t    if (opts === void 0) {\n\t      opts = {};\n\t    }\n\t    Object.assign(this, opts);\n\t    this.spaces = this.spaces || {};\n\t    this.spaces.before = this.spaces.before || '';\n\t    this.spaces.after = this.spaces.after || '';\n\t  }\n\t  var _proto = Node.prototype;\n\t  _proto.remove = function remove() {\n\t    if (this.parent) {\n\t      this.parent.removeChild(this);\n\t    }\n\t    this.parent = undefined;\n\t    return this;\n\t  };\n\t  _proto.replaceWith = function replaceWith() {\n\t    if (this.parent) {\n\t      for (var index in arguments) {\n\t        this.parent.insertBefore(this, arguments[index]);\n\t      }\n\t      this.remove();\n\t    }\n\t    return this;\n\t  };\n\t  _proto.next = function next() {\n\t    return this.parent.at(this.parent.index(this) + 1);\n\t  };\n\t  _proto.prev = function prev() {\n\t    return this.parent.at(this.parent.index(this) - 1);\n\t  };\n\t  _proto.clone = function clone(overrides) {\n\t    if (overrides === void 0) {\n\t      overrides = {};\n\t    }\n\t    var cloned = cloneNode(this);\n\t    for (var name in overrides) {\n\t      cloned[name] = overrides[name];\n\t    }\n\t    return cloned;\n\t  }\n\n\t  /**\n\t   * Some non-standard syntax doesn't follow normal escaping rules for css.\n\t   * This allows non standard syntax to be appended to an existing property\n\t   * by specifying the escaped value. By specifying the escaped value,\n\t   * illegal characters are allowed to be directly inserted into css output.\n\t   * @param {string} name the property to set\n\t   * @param {any} value the unescaped value of the property\n\t   * @param {string} valueEscaped optional. the escaped value of the property.\n\t   */;\n\t  _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {\n\t    if (!this.raws) {\n\t      this.raws = {};\n\t    }\n\t    var originalValue = this[name];\n\t    var originalEscaped = this.raws[name];\n\t    this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.\n\t    if (originalEscaped || valueEscaped !== value) {\n\t      this.raws[name] = (originalEscaped || originalValue) + valueEscaped;\n\t    } else {\n\t      delete this.raws[name]; // delete any escaped value that was created by the setter.\n\t    }\n\t  }\n\n\t  /**\n\t   * Some non-standard syntax doesn't follow normal escaping rules for css.\n\t   * This allows the escaped value to be specified directly, allowing illegal\n\t   * characters to be directly inserted into css output.\n\t   * @param {string} name the property to set\n\t   * @param {any} value the unescaped value of the property\n\t   * @param {string} valueEscaped the escaped value of the property.\n\t   */;\n\t  _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {\n\t    if (!this.raws) {\n\t      this.raws = {};\n\t    }\n\t    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\n\t    this.raws[name] = valueEscaped;\n\t  }\n\n\t  /**\n\t   * When you want a value to passed through to CSS directly. This method\n\t   * deletes the corresponding raw value causing the stringifier to fallback\n\t   * to the unescaped value.\n\t   * @param {string} name the property to set.\n\t   * @param {any} value The value that is both escaped and unescaped.\n\t   */;\n\t  _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {\n\t    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.\n\t    if (this.raws) {\n\t      delete this.raws[name];\n\t    }\n\t  }\n\n\t  /**\n\t   *\n\t   * @param {number} line The number (starting with 1)\n\t   * @param {number} column The column number (starting with 1)\n\t   */;\n\t  _proto.isAtPosition = function isAtPosition(line, column) {\n\t    if (this.source && this.source.start && this.source.end) {\n\t      if (this.source.start.line > line) {\n\t        return false;\n\t      }\n\t      if (this.source.end.line < line) {\n\t        return false;\n\t      }\n\t      if (this.source.start.line === line && this.source.start.column > column) {\n\t        return false;\n\t      }\n\t      if (this.source.end.line === line && this.source.end.column < column) {\n\t        return false;\n\t      }\n\t      return true;\n\t    }\n\t    return undefined;\n\t  };\n\t  _proto.stringifyProperty = function stringifyProperty(name) {\n\t    return this.raws && this.raws[name] || this[name];\n\t  };\n\t  _proto.valueToString = function valueToString() {\n\t    return String(this.stringifyProperty(\"value\"));\n\t  };\n\t  _proto.toString = function toString() {\n\t    return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join('');\n\t  };\n\t  _createClass(Node, [{\n\t    key: \"rawSpaceBefore\",\n\t    get: function get() {\n\t      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;\n\t      if (rawSpace === undefined) {\n\t        rawSpace = this.spaces && this.spaces.before;\n\t      }\n\t      return rawSpace || \"\";\n\t    },\n\t    set: function set(raw) {\n\t      (0, _util.ensureObject)(this, \"raws\", \"spaces\");\n\t      this.raws.spaces.before = raw;\n\t    }\n\t  }, {\n\t    key: \"rawSpaceAfter\",\n\t    get: function get() {\n\t      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;\n\t      if (rawSpace === undefined) {\n\t        rawSpace = this.spaces.after;\n\t      }\n\t      return rawSpace || \"\";\n\t    },\n\t    set: function set(raw) {\n\t      (0, _util.ensureObject)(this, \"raws\", \"spaces\");\n\t      this.raws.spaces.after = raw;\n\t    }\n\t  }]);\n\t  return Node;\n\t}();\n\texports[\"default\"] = Node;\n\tmodule.exports = exports.default; \n} (node$1, node$1.exports));\n\nvar nodeExports = node$1.exports;\n\nvar types = {};\n\ntypes.__esModule = true;\ntypes.UNIVERSAL = types.TAG = types.STRING = types.SELECTOR = types.ROOT = types.PSEUDO = types.NESTING = types.ID = types.COMMENT = types.COMBINATOR = types.CLASS = types.ATTRIBUTE = void 0;\nvar TAG = 'tag';\ntypes.TAG = TAG;\nvar STRING = 'string';\ntypes.STRING = STRING;\nvar SELECTOR = 'selector';\ntypes.SELECTOR = SELECTOR;\nvar ROOT = 'root';\ntypes.ROOT = ROOT;\nvar PSEUDO = 'pseudo';\ntypes.PSEUDO = PSEUDO;\nvar NESTING = 'nesting';\ntypes.NESTING = NESTING;\nvar ID = 'id';\ntypes.ID = ID;\nvar COMMENT = 'comment';\ntypes.COMMENT = COMMENT;\nvar COMBINATOR = 'combinator';\ntypes.COMBINATOR = COMBINATOR;\nvar CLASS = 'class';\ntypes.CLASS = CLASS;\nvar ATTRIBUTE = 'attribute';\ntypes.ATTRIBUTE = ATTRIBUTE;\nvar UNIVERSAL = 'universal';\ntypes.UNIVERSAL = UNIVERSAL;\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\tvar _node = _interopRequireDefault(nodeExports);\n\tvar types$1 = _interopRequireWildcard(types);\n\tfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\tfunction _interopRequireWildcard(obj, nodeInterop) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\tfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\tfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\tfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\tfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\tfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\tvar Container = /*#__PURE__*/function (_Node) {\n\t  _inheritsLoose(Container, _Node);\n\t  function Container(opts) {\n\t    var _this;\n\t    _this = _Node.call(this, opts) || this;\n\t    if (!_this.nodes) {\n\t      _this.nodes = [];\n\t    }\n\t    return _this;\n\t  }\n\t  var _proto = Container.prototype;\n\t  _proto.append = function append(selector) {\n\t    selector.parent = this;\n\t    this.nodes.push(selector);\n\t    return this;\n\t  };\n\t  _proto.prepend = function prepend(selector) {\n\t    selector.parent = this;\n\t    this.nodes.unshift(selector);\n\t    return this;\n\t  };\n\t  _proto.at = function at(index) {\n\t    return this.nodes[index];\n\t  };\n\t  _proto.index = function index(child) {\n\t    if (typeof child === 'number') {\n\t      return child;\n\t    }\n\t    return this.nodes.indexOf(child);\n\t  };\n\t  _proto.removeChild = function removeChild(child) {\n\t    child = this.index(child);\n\t    this.at(child).parent = undefined;\n\t    this.nodes.splice(child, 1);\n\t    var index;\n\t    for (var id in this.indexes) {\n\t      index = this.indexes[id];\n\t      if (index >= child) {\n\t        this.indexes[id] = index - 1;\n\t      }\n\t    }\n\t    return this;\n\t  };\n\t  _proto.removeAll = function removeAll() {\n\t    for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done;) {\n\t      var node = _step.value;\n\t      node.parent = undefined;\n\t    }\n\t    this.nodes = [];\n\t    return this;\n\t  };\n\t  _proto.empty = function empty() {\n\t    return this.removeAll();\n\t  };\n\t  _proto.insertAfter = function insertAfter(oldNode, newNode) {\n\t    newNode.parent = this;\n\t    var oldIndex = this.index(oldNode);\n\t    this.nodes.splice(oldIndex + 1, 0, newNode);\n\t    newNode.parent = this;\n\t    var index;\n\t    for (var id in this.indexes) {\n\t      index = this.indexes[id];\n\t      if (oldIndex <= index) {\n\t        this.indexes[id] = index + 1;\n\t      }\n\t    }\n\t    return this;\n\t  };\n\t  _proto.insertBefore = function insertBefore(oldNode, newNode) {\n\t    newNode.parent = this;\n\t    var oldIndex = this.index(oldNode);\n\t    this.nodes.splice(oldIndex, 0, newNode);\n\t    newNode.parent = this;\n\t    var index;\n\t    for (var id in this.indexes) {\n\t      index = this.indexes[id];\n\t      if (index <= oldIndex) {\n\t        this.indexes[id] = index + 1;\n\t      }\n\t    }\n\t    return this;\n\t  };\n\t  _proto._findChildAtPosition = function _findChildAtPosition(line, col) {\n\t    var found = undefined;\n\t    this.each(function (node) {\n\t      if (node.atPosition) {\n\t        var foundChild = node.atPosition(line, col);\n\t        if (foundChild) {\n\t          found = foundChild;\n\t          return false;\n\t        }\n\t      } else if (node.isAtPosition(line, col)) {\n\t        found = node;\n\t        return false;\n\t      }\n\t    });\n\t    return found;\n\t  }\n\n\t  /**\n\t   * Return the most specific node at the line and column number given.\n\t   * The source location is based on the original parsed location, locations aren't\n\t   * updated as selector nodes are mutated.\n\t   * \n\t   * Note that this location is relative to the location of the first character\n\t   * of the selector, and not the location of the selector in the overall document\n\t   * when used in conjunction with postcss.\n\t   *\n\t   * If not found, returns undefined.\n\t   * @param {number} line The line number of the node to find. (1-based index)\n\t   * @param {number} col  The column number of the node to find. (1-based index)\n\t   */;\n\t  _proto.atPosition = function atPosition(line, col) {\n\t    if (this.isAtPosition(line, col)) {\n\t      return this._findChildAtPosition(line, col) || this;\n\t    } else {\n\t      return undefined;\n\t    }\n\t  };\n\t  _proto._inferEndPosition = function _inferEndPosition() {\n\t    if (this.last && this.last.source && this.last.source.end) {\n\t      this.source = this.source || {};\n\t      this.source.end = this.source.end || {};\n\t      Object.assign(this.source.end, this.last.source.end);\n\t    }\n\t  };\n\t  _proto.each = function each(callback) {\n\t    if (!this.lastEach) {\n\t      this.lastEach = 0;\n\t    }\n\t    if (!this.indexes) {\n\t      this.indexes = {};\n\t    }\n\t    this.lastEach++;\n\t    var id = this.lastEach;\n\t    this.indexes[id] = 0;\n\t    if (!this.length) {\n\t      return undefined;\n\t    }\n\t    var index, result;\n\t    while (this.indexes[id] < this.length) {\n\t      index = this.indexes[id];\n\t      result = callback(this.at(index), index);\n\t      if (result === false) {\n\t        break;\n\t      }\n\t      this.indexes[id] += 1;\n\t    }\n\t    delete this.indexes[id];\n\t    if (result === false) {\n\t      return false;\n\t    }\n\t  };\n\t  _proto.walk = function walk(callback) {\n\t    return this.each(function (node, i) {\n\t      var result = callback(node, i);\n\t      if (result !== false && node.length) {\n\t        result = node.walk(callback);\n\t      }\n\t      if (result === false) {\n\t        return false;\n\t      }\n\t    });\n\t  };\n\t  _proto.walkAttributes = function walkAttributes(callback) {\n\t    var _this2 = this;\n\t    return this.walk(function (selector) {\n\t      if (selector.type === types$1.ATTRIBUTE) {\n\t        return callback.call(_this2, selector);\n\t      }\n\t    });\n\t  };\n\t  _proto.walkClasses = function walkClasses(callback) {\n\t    var _this3 = this;\n\t    return this.walk(function (selector) {\n\t      if (selector.type === types$1.CLASS) {\n\t        return callback.call(_this3, selector);\n\t      }\n\t    });\n\t  };\n\t  _proto.walkCombinators = function walkCombinators(callback) {\n\t    var _this4 = this;\n\t    return this.walk(function (selector) {\n\t      if (selector.type === types$1.COMBINATOR) {\n\t        return callback.call(_this4, selector);\n\t      }\n\t    });\n\t  };\n\t  _proto.walkComments = function walkComments(callback) {\n\t    var _this5 = this;\n\t    return this.walk(function (selector) {\n\t      if (selector.type === types$1.COMMENT) {\n\t        return callback.call(_this5, selector);\n\t      }\n\t    });\n\t  };\n\t  _proto.walkIds = function walkIds(callback) {\n\t    var _this6 = this;\n\t    return this.walk(function (selector) {\n\t      if (selector.type === types$1.ID) {\n\t        return callback.call(_this6, selector);\n\t      }\n\t    });\n\t  };\n\t  _proto.walkNesting = function walkNesting(callback) {\n\t    var _this7 = this;\n\t    return this.walk(function (selector) {\n\t      if (selector.type === types$1.NESTING) {\n\t        return callback.call(_this7, selector);\n\t      }\n\t    });\n\t  };\n\t  _proto.walkPseudos = function walkPseudos(callback) {\n\t    var _this8 = this;\n\t    return this.walk(function (selector) {\n\t      if (selector.type === types$1.PSEUDO) {\n\t        return callback.call(_this8, selector);\n\t      }\n\t    });\n\t  };\n\t  _proto.walkTags = function walkTags(callback) {\n\t    var _this9 = this;\n\t    return this.walk(function (selector) {\n\t      if (selector.type === types$1.TAG) {\n\t        return callback.call(_this9, selector);\n\t      }\n\t    });\n\t  };\n\t  _proto.walkUniversals = function walkUniversals(callback) {\n\t    var _this10 = this;\n\t    return this.walk(function (selector) {\n\t      if (selector.type === types$1.UNIVERSAL) {\n\t        return callback.call(_this10, selector);\n\t      }\n\t    });\n\t  };\n\t  _proto.split = function split(callback) {\n\t    var _this11 = this;\n\t    var current = [];\n\t    return this.reduce(function (memo, node, index) {\n\t      var split = callback.call(_this11, node);\n\t      current.push(node);\n\t      if (split) {\n\t        memo.push(current);\n\t        current = [];\n\t      } else if (index === _this11.length - 1) {\n\t        memo.push(current);\n\t      }\n\t      return memo;\n\t    }, []);\n\t  };\n\t  _proto.map = function map(callback) {\n\t    return this.nodes.map(callback);\n\t  };\n\t  _proto.reduce = function reduce(callback, memo) {\n\t    return this.nodes.reduce(callback, memo);\n\t  };\n\t  _proto.every = function every(callback) {\n\t    return this.nodes.every(callback);\n\t  };\n\t  _proto.some = function some(callback) {\n\t    return this.nodes.some(callback);\n\t  };\n\t  _proto.filter = function filter(callback) {\n\t    return this.nodes.filter(callback);\n\t  };\n\t  _proto.sort = function sort(callback) {\n\t    return this.nodes.sort(callback);\n\t  };\n\t  _proto.toString = function toString() {\n\t    return this.map(String).join('');\n\t  };\n\t  _createClass(Container, [{\n\t    key: \"first\",\n\t    get: function get() {\n\t      return this.at(0);\n\t    }\n\t  }, {\n\t    key: \"last\",\n\t    get: function get() {\n\t      return this.at(this.length - 1);\n\t    }\n\t  }, {\n\t    key: \"length\",\n\t    get: function get() {\n\t      return this.nodes.length;\n\t    }\n\t  }]);\n\t  return Container;\n\t}(_node[\"default\"]);\n\texports[\"default\"] = Container;\n\tmodule.exports = exports.default; \n} (container, container.exports));\n\nvar containerExports = container.exports;\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\tvar _container = _interopRequireDefault(containerExports);\n\tvar _types = types;\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\tfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\tfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\tvar Root = /*#__PURE__*/function (_Container) {\n\t  _inheritsLoose(Root, _Container);\n\t  function Root(opts) {\n\t    var _this;\n\t    _this = _Container.call(this, opts) || this;\n\t    _this.type = _types.ROOT;\n\t    return _this;\n\t  }\n\t  var _proto = Root.prototype;\n\t  _proto.toString = function toString() {\n\t    var str = this.reduce(function (memo, selector) {\n\t      memo.push(String(selector));\n\t      return memo;\n\t    }, []).join(',');\n\t    return this.trailingComma ? str + ',' : str;\n\t  };\n\t  _proto.error = function error(message, options) {\n\t    if (this._error) {\n\t      return this._error(message, options);\n\t    } else {\n\t      return new Error(message);\n\t    }\n\t  };\n\t  _createClass(Root, [{\n\t    key: \"errorGenerator\",\n\t    set: function set(handler) {\n\t      this._error = handler;\n\t    }\n\t  }]);\n\t  return Root;\n\t}(_container[\"default\"]);\n\texports[\"default\"] = Root;\n\tmodule.exports = exports.default; \n} (root$1, root$1.exports));\n\nvar rootExports = root$1.exports;\n\nvar selector$1 = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\tvar _container = _interopRequireDefault(containerExports);\n\tvar _types = types;\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\tvar Selector = /*#__PURE__*/function (_Container) {\n\t  _inheritsLoose(Selector, _Container);\n\t  function Selector(opts) {\n\t    var _this;\n\t    _this = _Container.call(this, opts) || this;\n\t    _this.type = _types.SELECTOR;\n\t    return _this;\n\t  }\n\t  return Selector;\n\t}(_container[\"default\"]);\n\texports[\"default\"] = Selector;\n\tmodule.exports = exports.default; \n} (selector$1, selector$1.exports));\n\nvar selectorExports = selector$1.exports;\n\nvar className$1 = {exports: {}};\n\n/*! https://mths.be/cssesc v3.0.0 by @mathias */\n\nvar object = {};\nvar hasOwnProperty$1 = object.hasOwnProperty;\nvar merge = function merge(options, defaults) {\n\tif (!options) {\n\t\treturn defaults;\n\t}\n\tvar result = {};\n\tfor (var key in defaults) {\n\t\t// `if (defaults.hasOwnProperty(key) {  }` is not needed here, since\n\t\t// only recognized option names are used.\n\t\tresult[key] = hasOwnProperty$1.call(options, key) ? options[key] : defaults[key];\n\t}\n\treturn result;\n};\n\nvar regexAnySingleEscape = /[ -,\\.\\/:-@\\[-\\^`\\{-~]/;\nvar regexSingleEscape = /[ -,\\.\\/:-@\\[\\]\\^`\\{-~]/;\nvar regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\n\n// https://mathiasbynens.be/notes/css-escapes#css\nvar cssesc = function cssesc(string, options) {\n\toptions = merge(options, cssesc.options);\n\tif (options.quotes != 'single' && options.quotes != 'double') {\n\t\toptions.quotes = 'single';\n\t}\n\tvar quote = options.quotes == 'double' ? '\"' : '\\'';\n\tvar isIdentifier = options.isIdentifier;\n\n\tvar firstChar = string.charAt(0);\n\tvar output = '';\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar character = string.charAt(counter++);\n\t\tvar codePoint = character.charCodeAt();\n\t\tvar value = void 0;\n\t\t// If its not a printable ASCII character\n\t\tif (codePoint < 0x20 || codePoint > 0x7E) {\n\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\n\t\t\t\t// Its a high surrogate, and there is a next character.\n\t\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t\t// next character is low surrogate\n\t\t\t\t\tcodePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\n\t\t\t\t} else {\n\t\t\t\t\t// Its an unmatched surrogate; only append this code unit, in case\n\t\t\t\t\t// the next code unit is the high surrogate of a surrogate pair.\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t} else {\n\t\t\tif (options.escapeEverything) {\n\t\t\t\tif (regexAnySingleEscape.test(character)) {\n\t\t\t\t\tvalue = '\\\\' + character;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t}\n\t\t\t} else if (/[\\t\\n\\f\\r\\x0B]/.test(character)) {\n\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t} else if (character == '\\\\' || !isIdentifier && (character == '\"' && quote == character || character == '\\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {\n\t\t\t\tvalue = '\\\\' + character;\n\t\t\t} else {\n\t\t\t\tvalue = character;\n\t\t\t}\n\t\t}\n\t\toutput += value;\n\t}\n\n\tif (isIdentifier) {\n\t\tif (/^-[-\\d]/.test(output)) {\n\t\t\toutput = '\\\\-' + output.slice(1);\n\t\t} else if (/\\d/.test(firstChar)) {\n\t\t\toutput = '\\\\3' + firstChar + ' ' + output.slice(1);\n\t\t}\n\t}\n\n\t// Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n\t// since theyre redundant. Note that this is only possible if the escape\n\t// sequence isnt preceded by an odd number of backslashes.\n\toutput = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {\n\t\tif ($1 && $1.length % 2) {\n\t\t\t// Its not safe to remove the space, so dont.\n\t\t\treturn $0;\n\t\t}\n\t\t// Strip the space.\n\t\treturn ($1 || '') + $2;\n\t});\n\n\tif (!isIdentifier && options.wrap) {\n\t\treturn quote + output + quote;\n\t}\n\treturn output;\n};\n\n// Expose default options (so they can be overridden globally).\ncssesc.options = {\n\t'escapeEverything': false,\n\t'isIdentifier': false,\n\t'quotes': 'single',\n\t'wrap': false\n};\n\ncssesc.version = '3.0.0';\n\nvar cssesc_1 = cssesc;\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\tvar _cssesc = _interopRequireDefault(cssesc_1);\n\tvar _util = util;\n\tvar _node = _interopRequireDefault(nodeExports);\n\tvar _types = types;\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\tfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\tfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\tvar ClassName = /*#__PURE__*/function (_Node) {\n\t  _inheritsLoose(ClassName, _Node);\n\t  function ClassName(opts) {\n\t    var _this;\n\t    _this = _Node.call(this, opts) || this;\n\t    _this.type = _types.CLASS;\n\t    _this._constructed = true;\n\t    return _this;\n\t  }\n\t  var _proto = ClassName.prototype;\n\t  _proto.valueToString = function valueToString() {\n\t    return '.' + _Node.prototype.valueToString.call(this);\n\t  };\n\t  _createClass(ClassName, [{\n\t    key: \"value\",\n\t    get: function get() {\n\t      return this._value;\n\t    },\n\t    set: function set(v) {\n\t      if (this._constructed) {\n\t        var escaped = (0, _cssesc[\"default\"])(v, {\n\t          isIdentifier: true\n\t        });\n\t        if (escaped !== v) {\n\t          (0, _util.ensureObject)(this, \"raws\");\n\t          this.raws.value = escaped;\n\t        } else if (this.raws) {\n\t          delete this.raws.value;\n\t        }\n\t      }\n\t      this._value = v;\n\t    }\n\t  }]);\n\t  return ClassName;\n\t}(_node[\"default\"]);\n\texports[\"default\"] = ClassName;\n\tmodule.exports = exports.default; \n} (className$1, className$1.exports));\n\nvar classNameExports = className$1.exports;\n\nvar comment$2 = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\tvar _node = _interopRequireDefault(nodeExports);\n\tvar _types = types;\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\tvar Comment = /*#__PURE__*/function (_Node) {\n\t  _inheritsLoose(Comment, _Node);\n\t  function Comment(opts) {\n\t    var _this;\n\t    _this = _Node.call(this, opts) || this;\n\t    _this.type = _types.COMMENT;\n\t    return _this;\n\t  }\n\t  return Comment;\n\t}(_node[\"default\"]);\n\texports[\"default\"] = Comment;\n\tmodule.exports = exports.default; \n} (comment$2, comment$2.exports));\n\nvar commentExports = comment$2.exports;\n\nvar id$1 = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\tvar _node = _interopRequireDefault(nodeExports);\n\tvar _types = types;\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\tvar ID = /*#__PURE__*/function (_Node) {\n\t  _inheritsLoose(ID, _Node);\n\t  function ID(opts) {\n\t    var _this;\n\t    _this = _Node.call(this, opts) || this;\n\t    _this.type = _types.ID;\n\t    return _this;\n\t  }\n\t  var _proto = ID.prototype;\n\t  _proto.valueToString = function valueToString() {\n\t    return '#' + _Node.prototype.valueToString.call(this);\n\t  };\n\t  return ID;\n\t}(_node[\"default\"]);\n\texports[\"default\"] = ID;\n\tmodule.exports = exports.default; \n} (id$1, id$1.exports));\n\nvar idExports = id$1.exports;\n\nvar tag$1 = {exports: {}};\n\nvar namespace = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\tvar _cssesc = _interopRequireDefault(cssesc_1);\n\tvar _util = util;\n\tvar _node = _interopRequireDefault(nodeExports);\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\tfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\tfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\tvar Namespace = /*#__PURE__*/function (_Node) {\n\t  _inheritsLoose(Namespace, _Node);\n\t  function Namespace() {\n\t    return _Node.apply(this, arguments) || this;\n\t  }\n\t  var _proto = Namespace.prototype;\n\t  _proto.qualifiedName = function qualifiedName(value) {\n\t    if (this.namespace) {\n\t      return this.namespaceString + \"|\" + value;\n\t    } else {\n\t      return value;\n\t    }\n\t  };\n\t  _proto.valueToString = function valueToString() {\n\t    return this.qualifiedName(_Node.prototype.valueToString.call(this));\n\t  };\n\t  _createClass(Namespace, [{\n\t    key: \"namespace\",\n\t    get: function get() {\n\t      return this._namespace;\n\t    },\n\t    set: function set(namespace) {\n\t      if (namespace === true || namespace === \"*\" || namespace === \"&\") {\n\t        this._namespace = namespace;\n\t        if (this.raws) {\n\t          delete this.raws.namespace;\n\t        }\n\t        return;\n\t      }\n\t      var escaped = (0, _cssesc[\"default\"])(namespace, {\n\t        isIdentifier: true\n\t      });\n\t      this._namespace = namespace;\n\t      if (escaped !== namespace) {\n\t        (0, _util.ensureObject)(this, \"raws\");\n\t        this.raws.namespace = escaped;\n\t      } else if (this.raws) {\n\t        delete this.raws.namespace;\n\t      }\n\t    }\n\t  }, {\n\t    key: \"ns\",\n\t    get: function get() {\n\t      return this._namespace;\n\t    },\n\t    set: function set(namespace) {\n\t      this.namespace = namespace;\n\t    }\n\t  }, {\n\t    key: \"namespaceString\",\n\t    get: function get() {\n\t      if (this.namespace) {\n\t        var ns = this.stringifyProperty(\"namespace\");\n\t        if (ns === true) {\n\t          return '';\n\t        } else {\n\t          return ns;\n\t        }\n\t      } else {\n\t        return '';\n\t      }\n\t    }\n\t  }]);\n\t  return Namespace;\n\t}(_node[\"default\"]);\n\texports[\"default\"] = Namespace;\n\tmodule.exports = exports.default; \n} (namespace, namespace.exports));\n\nvar namespaceExports = namespace.exports;\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\tvar _namespace = _interopRequireDefault(namespaceExports);\n\tvar _types = types;\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\tvar Tag = /*#__PURE__*/function (_Namespace) {\n\t  _inheritsLoose(Tag, _Namespace);\n\t  function Tag(opts) {\n\t    var _this;\n\t    _this = _Namespace.call(this, opts) || this;\n\t    _this.type = _types.TAG;\n\t    return _this;\n\t  }\n\t  return Tag;\n\t}(_namespace[\"default\"]);\n\texports[\"default\"] = Tag;\n\tmodule.exports = exports.default; \n} (tag$1, tag$1.exports));\n\nvar tagExports = tag$1.exports;\n\nvar string$1 = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\tvar _node = _interopRequireDefault(nodeExports);\n\tvar _types = types;\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\tvar String = /*#__PURE__*/function (_Node) {\n\t  _inheritsLoose(String, _Node);\n\t  function String(opts) {\n\t    var _this;\n\t    _this = _Node.call(this, opts) || this;\n\t    _this.type = _types.STRING;\n\t    return _this;\n\t  }\n\t  return String;\n\t}(_node[\"default\"]);\n\texports[\"default\"] = String;\n\tmodule.exports = exports.default; \n} (string$1, string$1.exports));\n\nvar stringExports = string$1.exports;\n\nvar pseudo$1 = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\tvar _container = _interopRequireDefault(containerExports);\n\tvar _types = types;\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\tvar Pseudo = /*#__PURE__*/function (_Container) {\n\t  _inheritsLoose(Pseudo, _Container);\n\t  function Pseudo(opts) {\n\t    var _this;\n\t    _this = _Container.call(this, opts) || this;\n\t    _this.type = _types.PSEUDO;\n\t    return _this;\n\t  }\n\t  var _proto = Pseudo.prototype;\n\t  _proto.toString = function toString() {\n\t    var params = this.length ? '(' + this.map(String).join(',') + ')' : '';\n\t    return [this.rawSpaceBefore, this.stringifyProperty(\"value\"), params, this.rawSpaceAfter].join('');\n\t  };\n\t  return Pseudo;\n\t}(_container[\"default\"]);\n\texports[\"default\"] = Pseudo;\n\tmodule.exports = exports.default; \n} (pseudo$1, pseudo$1.exports));\n\nvar pseudoExports = pseudo$1.exports;\n\nvar attribute$1 = {};\n\n/**\n * For Node.js, simply re-export the core `util.deprecate` function.\n */\n\nvar node = util__WEBPACK_IMPORTED_MODULE_3__.deprecate;\n\n(function (exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\texports.unescapeValue = unescapeValue;\n\tvar _cssesc = _interopRequireDefault(cssesc_1);\n\tvar _unesc = _interopRequireDefault(unescExports);\n\tvar _namespace = _interopRequireDefault(namespaceExports);\n\tvar _types = types;\n\tvar _CSSESC_QUOTE_OPTIONS;\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\tfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\tfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\tvar deprecate = node;\n\tvar WRAPPED_IN_QUOTES = /^('|\")([^]*)\\1$/;\n\tvar warnOfDeprecatedValueAssignment = deprecate(function () {}, \"Assigning an attribute a value containing characters that might need to be escaped is deprecated. \" + \"Call attribute.setValue() instead.\");\n\tvar warnOfDeprecatedQuotedAssignment = deprecate(function () {}, \"Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.\");\n\tvar warnOfDeprecatedConstructor = deprecate(function () {}, \"Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.\");\n\tfunction unescapeValue(value) {\n\t  var deprecatedUsage = false;\n\t  var quoteMark = null;\n\t  var unescaped = value;\n\t  var m = unescaped.match(WRAPPED_IN_QUOTES);\n\t  if (m) {\n\t    quoteMark = m[1];\n\t    unescaped = m[2];\n\t  }\n\t  unescaped = (0, _unesc[\"default\"])(unescaped);\n\t  if (unescaped !== value) {\n\t    deprecatedUsage = true;\n\t  }\n\t  return {\n\t    deprecatedUsage: deprecatedUsage,\n\t    unescaped: unescaped,\n\t    quoteMark: quoteMark\n\t  };\n\t}\n\tfunction handleDeprecatedContructorOpts(opts) {\n\t  if (opts.quoteMark !== undefined) {\n\t    return opts;\n\t  }\n\t  if (opts.value === undefined) {\n\t    return opts;\n\t  }\n\t  warnOfDeprecatedConstructor();\n\t  var _unescapeValue = unescapeValue(opts.value),\n\t    quoteMark = _unescapeValue.quoteMark,\n\t    unescaped = _unescapeValue.unescaped;\n\t  if (!opts.raws) {\n\t    opts.raws = {};\n\t  }\n\t  if (opts.raws.value === undefined) {\n\t    opts.raws.value = opts.value;\n\t  }\n\t  opts.value = unescaped;\n\t  opts.quoteMark = quoteMark;\n\t  return opts;\n\t}\n\tvar Attribute = /*#__PURE__*/function (_Namespace) {\n\t  _inheritsLoose(Attribute, _Namespace);\n\t  function Attribute(opts) {\n\t    var _this;\n\t    if (opts === void 0) {\n\t      opts = {};\n\t    }\n\t    _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;\n\t    _this.type = _types.ATTRIBUTE;\n\t    _this.raws = _this.raws || {};\n\t    Object.defineProperty(_this.raws, 'unquoted', {\n\t      get: deprecate(function () {\n\t        return _this.value;\n\t      }, \"attr.raws.unquoted is deprecated. Call attr.value instead.\"),\n\t      set: deprecate(function () {\n\t        return _this.value;\n\t      }, \"Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.\")\n\t    });\n\t    _this._constructed = true;\n\t    return _this;\n\t  }\n\n\t  /**\n\t   * Returns the Attribute's value quoted such that it would be legal to use\n\t   * in the value of a css file. The original value's quotation setting\n\t   * used for stringification is left unchanged. See `setValue(value, options)`\n\t   * if you want to control the quote settings of a new value for the attribute.\n\t   *\n\t   * You can also change the quotation used for the current value by setting quoteMark.\n\t   *\n\t   * Options:\n\t   *   * quoteMark {'\"' | \"'\" | null} - Use this value to quote the value. If this\n\t   *     option is not set, the original value for quoteMark will be used. If\n\t   *     indeterminate, a double quote is used. The legal values are:\n\t   *     * `null` - the value will be unquoted and characters will be escaped as necessary.\n\t   *     * `'` - the value will be quoted with a single quote and single quotes are escaped.\n\t   *     * `\"` - the value will be quoted with a double quote and double quotes are escaped.\n\t   *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark\n\t   *     over the quoteMark option value.\n\t   *   * smart {boolean} - if true, will select a quote mark based on the value\n\t   *     and the other options specified here. See the `smartQuoteMark()`\n\t   *     method.\n\t   **/\n\t  var _proto = Attribute.prototype;\n\t  _proto.getQuotedValue = function getQuotedValue(options) {\n\t    if (options === void 0) {\n\t      options = {};\n\t    }\n\t    var quoteMark = this._determineQuoteMark(options);\n\t    var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];\n\t    var escaped = (0, _cssesc[\"default\"])(this._value, cssescopts);\n\t    return escaped;\n\t  };\n\t  _proto._determineQuoteMark = function _determineQuoteMark(options) {\n\t    return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);\n\t  }\n\n\t  /**\n\t   * Set the unescaped value with the specified quotation options. The value\n\t   * provided must not include any wrapping quote marks -- those quotes will\n\t   * be interpreted as part of the value and escaped accordingly.\n\t   */;\n\t  _proto.setValue = function setValue(value, options) {\n\t    if (options === void 0) {\n\t      options = {};\n\t    }\n\t    this._value = value;\n\t    this._quoteMark = this._determineQuoteMark(options);\n\t    this._syncRawValue();\n\t  }\n\n\t  /**\n\t   * Intelligently select a quoteMark value based on the value's contents. If\n\t   * the value is a legal CSS ident, it will not be quoted. Otherwise a quote\n\t   * mark will be picked that minimizes the number of escapes.\n\t   *\n\t   * If there's no clear winner, the quote mark from these options is used,\n\t   * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is\n\t   * true). If the quoteMark is unspecified, a double quote is used.\n\t   *\n\t   * @param options This takes the quoteMark and preferCurrentQuoteMark options\n\t   * from the quoteValue method.\n\t   */;\n\t  _proto.smartQuoteMark = function smartQuoteMark(options) {\n\t    var v = this.value;\n\t    var numSingleQuotes = v.replace(/[^']/g, '').length;\n\t    var numDoubleQuotes = v.replace(/[^\"]/g, '').length;\n\t    if (numSingleQuotes + numDoubleQuotes === 0) {\n\t      var escaped = (0, _cssesc[\"default\"])(v, {\n\t        isIdentifier: true\n\t      });\n\t      if (escaped === v) {\n\t        return Attribute.NO_QUOTE;\n\t      } else {\n\t        var pref = this.preferredQuoteMark(options);\n\t        if (pref === Attribute.NO_QUOTE) {\n\t          // pick a quote mark that isn't none and see if it's smaller\n\t          var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;\n\t          var opts = CSSESC_QUOTE_OPTIONS[quote];\n\t          var quoteValue = (0, _cssesc[\"default\"])(v, opts);\n\t          if (quoteValue.length < escaped.length) {\n\t            return quote;\n\t          }\n\t        }\n\t        return pref;\n\t      }\n\t    } else if (numDoubleQuotes === numSingleQuotes) {\n\t      return this.preferredQuoteMark(options);\n\t    } else if (numDoubleQuotes < numSingleQuotes) {\n\t      return Attribute.DOUBLE_QUOTE;\n\t    } else {\n\t      return Attribute.SINGLE_QUOTE;\n\t    }\n\t  }\n\n\t  /**\n\t   * Selects the preferred quote mark based on the options and the current quote mark value.\n\t   * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`\n\t   * instead.\n\t   */;\n\t  _proto.preferredQuoteMark = function preferredQuoteMark(options) {\n\t    var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;\n\t    if (quoteMark === undefined) {\n\t      quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;\n\t    }\n\t    if (quoteMark === undefined) {\n\t      quoteMark = Attribute.DOUBLE_QUOTE;\n\t    }\n\t    return quoteMark;\n\t  };\n\t  _proto._syncRawValue = function _syncRawValue() {\n\t    var rawValue = (0, _cssesc[\"default\"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);\n\t    if (rawValue === this._value) {\n\t      if (this.raws) {\n\t        delete this.raws.value;\n\t      }\n\t    } else {\n\t      this.raws.value = rawValue;\n\t    }\n\t  };\n\t  _proto._handleEscapes = function _handleEscapes(prop, value) {\n\t    if (this._constructed) {\n\t      var escaped = (0, _cssesc[\"default\"])(value, {\n\t        isIdentifier: true\n\t      });\n\t      if (escaped !== value) {\n\t        this.raws[prop] = escaped;\n\t      } else {\n\t        delete this.raws[prop];\n\t      }\n\t    }\n\t  };\n\t  _proto._spacesFor = function _spacesFor(name) {\n\t    var attrSpaces = {\n\t      before: '',\n\t      after: ''\n\t    };\n\t    var spaces = this.spaces[name] || {};\n\t    var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};\n\t    return Object.assign(attrSpaces, spaces, rawSpaces);\n\t  };\n\t  _proto._stringFor = function _stringFor(name, spaceName, concat) {\n\t    if (spaceName === void 0) {\n\t      spaceName = name;\n\t    }\n\t    if (concat === void 0) {\n\t      concat = defaultAttrConcat;\n\t    }\n\t    var attrSpaces = this._spacesFor(spaceName);\n\t    return concat(this.stringifyProperty(name), attrSpaces);\n\t  }\n\n\t  /**\n\t   * returns the offset of the attribute part specified relative to the\n\t   * start of the node of the output string.\n\t   *\n\t   * * \"ns\" - alias for \"namespace\"\n\t   * * \"namespace\" - the namespace if it exists.\n\t   * * \"attribute\" - the attribute name\n\t   * * \"attributeNS\" - the start of the attribute or its namespace\n\t   * * \"operator\" - the match operator of the attribute\n\t   * * \"value\" - The value (string or identifier)\n\t   * * \"insensitive\" - the case insensitivity flag;\n\t   * @param part One of the possible values inside an attribute.\n\t   * @returns -1 if the name is invalid or the value doesn't exist in this attribute.\n\t   */;\n\t  _proto.offsetOf = function offsetOf(name) {\n\t    var count = 1;\n\t    var attributeSpaces = this._spacesFor(\"attribute\");\n\t    count += attributeSpaces.before.length;\n\t    if (name === \"namespace\" || name === \"ns\") {\n\t      return this.namespace ? count : -1;\n\t    }\n\t    if (name === \"attributeNS\") {\n\t      return count;\n\t    }\n\t    count += this.namespaceString.length;\n\t    if (this.namespace) {\n\t      count += 1;\n\t    }\n\t    if (name === \"attribute\") {\n\t      return count;\n\t    }\n\t    count += this.stringifyProperty(\"attribute\").length;\n\t    count += attributeSpaces.after.length;\n\t    var operatorSpaces = this._spacesFor(\"operator\");\n\t    count += operatorSpaces.before.length;\n\t    var operator = this.stringifyProperty(\"operator\");\n\t    if (name === \"operator\") {\n\t      return operator ? count : -1;\n\t    }\n\t    count += operator.length;\n\t    count += operatorSpaces.after.length;\n\t    var valueSpaces = this._spacesFor(\"value\");\n\t    count += valueSpaces.before.length;\n\t    var value = this.stringifyProperty(\"value\");\n\t    if (name === \"value\") {\n\t      return value ? count : -1;\n\t    }\n\t    count += value.length;\n\t    count += valueSpaces.after.length;\n\t    var insensitiveSpaces = this._spacesFor(\"insensitive\");\n\t    count += insensitiveSpaces.before.length;\n\t    if (name === \"insensitive\") {\n\t      return this.insensitive ? count : -1;\n\t    }\n\t    return -1;\n\t  };\n\t  _proto.toString = function toString() {\n\t    var _this2 = this;\n\t    var selector = [this.rawSpaceBefore, '['];\n\t    selector.push(this._stringFor('qualifiedAttribute', 'attribute'));\n\t    if (this.operator && (this.value || this.value === '')) {\n\t      selector.push(this._stringFor('operator'));\n\t      selector.push(this._stringFor('value'));\n\t      selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {\n\t        if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {\n\t          attrSpaces.before = \" \";\n\t        }\n\t        return defaultAttrConcat(attrValue, attrSpaces);\n\t      }));\n\t    }\n\t    selector.push(']');\n\t    selector.push(this.rawSpaceAfter);\n\t    return selector.join('');\n\t  };\n\t  _createClass(Attribute, [{\n\t    key: \"quoted\",\n\t    get: function get() {\n\t      var qm = this.quoteMark;\n\t      return qm === \"'\" || qm === '\"';\n\t    },\n\t    set: function set(value) {\n\t      warnOfDeprecatedQuotedAssignment();\n\t    }\n\n\t    /**\n\t     * returns a single (`'`) or double (`\"`) quote character if the value is quoted.\n\t     * returns `null` if the value is not quoted.\n\t     * returns `undefined` if the quotation state is unknown (this can happen when\n\t     * the attribute is constructed without specifying a quote mark.)\n\t     */\n\t  }, {\n\t    key: \"quoteMark\",\n\t    get: function get() {\n\t      return this._quoteMark;\n\t    }\n\n\t    /**\n\t     * Set the quote mark to be used by this attribute's value.\n\t     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute\n\t     * value is updated accordingly.\n\t     *\n\t     * @param {\"'\" | '\"' | null} quoteMark The quote mark or `null` if the value should be unquoted.\n\t     */,\n\t    set: function set(quoteMark) {\n\t      if (!this._constructed) {\n\t        this._quoteMark = quoteMark;\n\t        return;\n\t      }\n\t      if (this._quoteMark !== quoteMark) {\n\t        this._quoteMark = quoteMark;\n\t        this._syncRawValue();\n\t      }\n\t    }\n\t  }, {\n\t    key: \"qualifiedAttribute\",\n\t    get: function get() {\n\t      return this.qualifiedName(this.raws.attribute || this.attribute);\n\t    }\n\t  }, {\n\t    key: \"insensitiveFlag\",\n\t    get: function get() {\n\t      return this.insensitive ? 'i' : '';\n\t    }\n\t  }, {\n\t    key: \"value\",\n\t    get: function get() {\n\t      return this._value;\n\t    },\n\t    set:\n\t    /**\n\t     * Before 3.0, the value had to be set to an escaped value including any wrapped\n\t     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value\n\t     * is unescaped during parsing and any quote marks are removed.\n\t     *\n\t     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,\n\t     * a deprecation warning is raised when the new value contains any characters that would\n\t     * require escaping (including if it contains wrapped quotes).\n\t     *\n\t     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe\n\t     * how the new value is quoted.\n\t     */\n\t    function set(v) {\n\t      if (this._constructed) {\n\t        var _unescapeValue2 = unescapeValue(v),\n\t          deprecatedUsage = _unescapeValue2.deprecatedUsage,\n\t          unescaped = _unescapeValue2.unescaped,\n\t          quoteMark = _unescapeValue2.quoteMark;\n\t        if (deprecatedUsage) {\n\t          warnOfDeprecatedValueAssignment();\n\t        }\n\t        if (unescaped === this._value && quoteMark === this._quoteMark) {\n\t          return;\n\t        }\n\t        this._value = unescaped;\n\t        this._quoteMark = quoteMark;\n\t        this._syncRawValue();\n\t      } else {\n\t        this._value = v;\n\t      }\n\t    }\n\t  }, {\n\t    key: \"insensitive\",\n\t    get: function get() {\n\t      return this._insensitive;\n\t    }\n\n\t    /**\n\t     * Set the case insensitive flag.\n\t     * If the case insensitive flag changes, the raw (escaped) value at `attr.raws.insensitiveFlag`\n\t     * of the attribute is updated accordingly.\n\t     *\n\t     * @param {true | false} insensitive true if the attribute should match case-insensitively.\n\t     */,\n\t    set: function set(insensitive) {\n\t      if (!insensitive) {\n\t        this._insensitive = false;\n\n\t        // \"i\" and \"I\" can be used in \"this.raws.insensitiveFlag\" to store the original notation.\n\t        // When setting `attr.insensitive = false` both should be erased to ensure correct serialization.\n\t        if (this.raws && (this.raws.insensitiveFlag === 'I' || this.raws.insensitiveFlag === 'i')) {\n\t          this.raws.insensitiveFlag = undefined;\n\t        }\n\t      }\n\t      this._insensitive = insensitive;\n\t    }\n\t  }, {\n\t    key: \"attribute\",\n\t    get: function get() {\n\t      return this._attribute;\n\t    },\n\t    set: function set(name) {\n\t      this._handleEscapes(\"attribute\", name);\n\t      this._attribute = name;\n\t    }\n\t  }]);\n\t  return Attribute;\n\t}(_namespace[\"default\"]);\n\texports[\"default\"] = Attribute;\n\tAttribute.NO_QUOTE = null;\n\tAttribute.SINGLE_QUOTE = \"'\";\n\tAttribute.DOUBLE_QUOTE = '\"';\n\tvar CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {\n\t  \"'\": {\n\t    quotes: 'single',\n\t    wrap: true\n\t  },\n\t  '\"': {\n\t    quotes: 'double',\n\t    wrap: true\n\t  }\n\t}, _CSSESC_QUOTE_OPTIONS[null] = {\n\t  isIdentifier: true\n\t}, _CSSESC_QUOTE_OPTIONS);\n\tfunction defaultAttrConcat(attrValue, attrSpaces) {\n\t  return \"\" + attrSpaces.before + attrValue + attrSpaces.after;\n\t} \n} (attribute$1));\n\nvar universal$1 = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\tvar _namespace = _interopRequireDefault(namespaceExports);\n\tvar _types = types;\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\tvar Universal = /*#__PURE__*/function (_Namespace) {\n\t  _inheritsLoose(Universal, _Namespace);\n\t  function Universal(opts) {\n\t    var _this;\n\t    _this = _Namespace.call(this, opts) || this;\n\t    _this.type = _types.UNIVERSAL;\n\t    _this.value = '*';\n\t    return _this;\n\t  }\n\t  return Universal;\n\t}(_namespace[\"default\"]);\n\texports[\"default\"] = Universal;\n\tmodule.exports = exports.default; \n} (universal$1, universal$1.exports));\n\nvar universalExports = universal$1.exports;\n\nvar combinator$2 = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\tvar _node = _interopRequireDefault(nodeExports);\n\tvar _types = types;\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\tvar Combinator = /*#__PURE__*/function (_Node) {\n\t  _inheritsLoose(Combinator, _Node);\n\t  function Combinator(opts) {\n\t    var _this;\n\t    _this = _Node.call(this, opts) || this;\n\t    _this.type = _types.COMBINATOR;\n\t    return _this;\n\t  }\n\t  return Combinator;\n\t}(_node[\"default\"]);\n\texports[\"default\"] = Combinator;\n\tmodule.exports = exports.default; \n} (combinator$2, combinator$2.exports));\n\nvar combinatorExports = combinator$2.exports;\n\nvar nesting$1 = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\tvar _node = _interopRequireDefault(nodeExports);\n\tvar _types = types;\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\tfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\tfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\tvar Nesting = /*#__PURE__*/function (_Node) {\n\t  _inheritsLoose(Nesting, _Node);\n\t  function Nesting(opts) {\n\t    var _this;\n\t    _this = _Node.call(this, opts) || this;\n\t    _this.type = _types.NESTING;\n\t    _this.value = '&';\n\t    return _this;\n\t  }\n\t  return Nesting;\n\t}(_node[\"default\"]);\n\texports[\"default\"] = Nesting;\n\tmodule.exports = exports.default; \n} (nesting$1, nesting$1.exports));\n\nvar nestingExports = nesting$1.exports;\n\nvar sortAscending = {exports: {}};\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = sortAscending;\n\tfunction sortAscending(list) {\n\t  return list.sort(function (a, b) {\n\t    return a - b;\n\t  });\n\t}\n\tmodule.exports = exports.default; \n} (sortAscending, sortAscending.exports));\n\nvar sortAscendingExports = sortAscending.exports;\n\nvar tokenize = {};\n\nvar tokenTypes = {};\n\ntokenTypes.__esModule = true;\ntokenTypes.word = tokenTypes.tilde = tokenTypes.tab = tokenTypes.str = tokenTypes.space = tokenTypes.slash = tokenTypes.singleQuote = tokenTypes.semicolon = tokenTypes.plus = tokenTypes.pipe = tokenTypes.openSquare = tokenTypes.openParenthesis = tokenTypes.newline = tokenTypes.greaterThan = tokenTypes.feed = tokenTypes.equals = tokenTypes.doubleQuote = tokenTypes.dollar = tokenTypes.cr = tokenTypes.comment = tokenTypes.comma = tokenTypes.combinator = tokenTypes.colon = tokenTypes.closeSquare = tokenTypes.closeParenthesis = tokenTypes.caret = tokenTypes.bang = tokenTypes.backslash = tokenTypes.at = tokenTypes.asterisk = tokenTypes.ampersand = void 0;\nvar ampersand = 38; // `&`.charCodeAt(0);\ntokenTypes.ampersand = ampersand;\nvar asterisk = 42; // `*`.charCodeAt(0);\ntokenTypes.asterisk = asterisk;\nvar at = 64; // `@`.charCodeAt(0);\ntokenTypes.at = at;\nvar comma = 44; // `,`.charCodeAt(0);\ntokenTypes.comma = comma;\nvar colon = 58; // `:`.charCodeAt(0);\ntokenTypes.colon = colon;\nvar semicolon = 59; // `;`.charCodeAt(0);\ntokenTypes.semicolon = semicolon;\nvar openParenthesis = 40; // `(`.charCodeAt(0);\ntokenTypes.openParenthesis = openParenthesis;\nvar closeParenthesis = 41; // `)`.charCodeAt(0);\ntokenTypes.closeParenthesis = closeParenthesis;\nvar openSquare = 91; // `[`.charCodeAt(0);\ntokenTypes.openSquare = openSquare;\nvar closeSquare = 93; // `]`.charCodeAt(0);\ntokenTypes.closeSquare = closeSquare;\nvar dollar = 36; // `$`.charCodeAt(0);\ntokenTypes.dollar = dollar;\nvar tilde = 126; // `~`.charCodeAt(0);\ntokenTypes.tilde = tilde;\nvar caret = 94; // `^`.charCodeAt(0);\ntokenTypes.caret = caret;\nvar plus = 43; // `+`.charCodeAt(0);\ntokenTypes.plus = plus;\nvar equals = 61; // `=`.charCodeAt(0);\ntokenTypes.equals = equals;\nvar pipe = 124; // `|`.charCodeAt(0);\ntokenTypes.pipe = pipe;\nvar greaterThan = 62; // `>`.charCodeAt(0);\ntokenTypes.greaterThan = greaterThan;\nvar space = 32; // ` `.charCodeAt(0);\ntokenTypes.space = space;\nvar singleQuote = 39; // `'`.charCodeAt(0);\ntokenTypes.singleQuote = singleQuote;\nvar doubleQuote = 34; // `\"`.charCodeAt(0);\ntokenTypes.doubleQuote = doubleQuote;\nvar slash = 47; // `/`.charCodeAt(0);\ntokenTypes.slash = slash;\nvar bang = 33; // `!`.charCodeAt(0);\ntokenTypes.bang = bang;\nvar backslash = 92; // '\\\\'.charCodeAt(0);\ntokenTypes.backslash = backslash;\nvar cr = 13; // '\\r'.charCodeAt(0);\ntokenTypes.cr = cr;\nvar feed = 12; // '\\f'.charCodeAt(0);\ntokenTypes.feed = feed;\nvar newline = 10; // '\\n'.charCodeAt(0);\ntokenTypes.newline = newline;\nvar tab = 9; // '\\t'.charCodeAt(0);\n\n// Expose aliases primarily for readability.\ntokenTypes.tab = tab;\nvar str = singleQuote;\n\n// No good single character representation!\ntokenTypes.str = str;\nvar comment$1 = -1;\ntokenTypes.comment = comment$1;\nvar word = -2;\ntokenTypes.word = word;\nvar combinator$1 = -3;\ntokenTypes.combinator = combinator$1;\n\n(function (exports) {\n\n\texports.__esModule = true;\n\texports.FIELDS = void 0;\n\texports[\"default\"] = tokenize;\n\tvar t = _interopRequireWildcard(tokenTypes);\n\tvar _unescapable, _wordDelimiters;\n\tfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\tfunction _interopRequireWildcard(obj, nodeInterop) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\tvar unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);\n\tvar wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);\n\tvar hex = {};\n\tvar hexChars = \"0123456789abcdefABCDEF\";\n\tfor (var i = 0; i < hexChars.length; i++) {\n\t  hex[hexChars.charCodeAt(i)] = true;\n\t}\n\n\t/**\n\t *  Returns the last index of the bar css word\n\t * @param {string} css The string in which the word begins\n\t * @param {number} start The index into the string where word's first letter occurs\n\t */\n\tfunction consumeWord(css, start) {\n\t  var next = start;\n\t  var code;\n\t  do {\n\t    code = css.charCodeAt(next);\n\t    if (wordDelimiters[code]) {\n\t      return next - 1;\n\t    } else if (code === t.backslash) {\n\t      next = consumeEscape(css, next) + 1;\n\t    } else {\n\t      // All other characters are part of the word\n\t      next++;\n\t    }\n\t  } while (next < css.length);\n\t  return next - 1;\n\t}\n\n\t/**\n\t *  Returns the last index of the escape sequence\n\t * @param {string} css The string in which the sequence begins\n\t * @param {number} start The index into the string where escape character (`\\`) occurs.\n\t */\n\tfunction consumeEscape(css, start) {\n\t  var next = start;\n\t  var code = css.charCodeAt(next + 1);\n\t  if (unescapable[code]) ; else if (hex[code]) {\n\t    var hexDigits = 0;\n\t    // consume up to 6 hex chars\n\t    do {\n\t      next++;\n\t      hexDigits++;\n\t      code = css.charCodeAt(next + 1);\n\t    } while (hex[code] && hexDigits < 6);\n\t    // if fewer than 6 hex chars, a trailing space ends the escape\n\t    if (hexDigits < 6 && code === t.space) {\n\t      next++;\n\t    }\n\t  } else {\n\t    // the next char is part of the current word\n\t    next++;\n\t  }\n\t  return next;\n\t}\n\tvar FIELDS = {\n\t  TYPE: 0,\n\t  START_LINE: 1,\n\t  START_COL: 2,\n\t  END_LINE: 3,\n\t  END_COL: 4,\n\t  START_POS: 5,\n\t  END_POS: 6\n\t};\n\texports.FIELDS = FIELDS;\n\tfunction tokenize(input) {\n\t  var tokens = [];\n\t  var css = input.css.valueOf();\n\t  var _css = css,\n\t    length = _css.length;\n\t  var offset = -1;\n\t  var line = 1;\n\t  var start = 0;\n\t  var end = 0;\n\t  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;\n\t  function unclosed(what, fix) {\n\t    if (input.safe) {\n\t      // fyi: this is never set to true.\n\t      css += fix;\n\t      next = css.length - 1;\n\t    } else {\n\t      throw input.error('Unclosed ' + what, line, start - offset, start);\n\t    }\n\t  }\n\t  while (start < length) {\n\t    code = css.charCodeAt(start);\n\t    if (code === t.newline) {\n\t      offset = start;\n\t      line += 1;\n\t    }\n\t    switch (code) {\n\t      case t.space:\n\t      case t.tab:\n\t      case t.newline:\n\t      case t.cr:\n\t      case t.feed:\n\t        next = start;\n\t        do {\n\t          next += 1;\n\t          code = css.charCodeAt(next);\n\t          if (code === t.newline) {\n\t            offset = next;\n\t            line += 1;\n\t          }\n\t        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);\n\t        tokenType = t.space;\n\t        endLine = line;\n\t        endColumn = next - offset - 1;\n\t        end = next;\n\t        break;\n\t      case t.plus:\n\t      case t.greaterThan:\n\t      case t.tilde:\n\t      case t.pipe:\n\t        next = start;\n\t        do {\n\t          next += 1;\n\t          code = css.charCodeAt(next);\n\t        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);\n\t        tokenType = t.combinator;\n\t        endLine = line;\n\t        endColumn = start - offset;\n\t        end = next;\n\t        break;\n\n\t      // Consume these characters as single tokens.\n\t      case t.asterisk:\n\t      case t.ampersand:\n\t      case t.bang:\n\t      case t.comma:\n\t      case t.equals:\n\t      case t.dollar:\n\t      case t.caret:\n\t      case t.openSquare:\n\t      case t.closeSquare:\n\t      case t.colon:\n\t      case t.semicolon:\n\t      case t.openParenthesis:\n\t      case t.closeParenthesis:\n\t        next = start;\n\t        tokenType = code;\n\t        endLine = line;\n\t        endColumn = start - offset;\n\t        end = next + 1;\n\t        break;\n\t      case t.singleQuote:\n\t      case t.doubleQuote:\n\t        quote = code === t.singleQuote ? \"'\" : '\"';\n\t        next = start;\n\t        do {\n\t          escaped = false;\n\t          next = css.indexOf(quote, next + 1);\n\t          if (next === -1) {\n\t            unclosed('quote', quote);\n\t          }\n\t          escapePos = next;\n\t          while (css.charCodeAt(escapePos - 1) === t.backslash) {\n\t            escapePos -= 1;\n\t            escaped = !escaped;\n\t          }\n\t        } while (escaped);\n\t        tokenType = t.str;\n\t        endLine = line;\n\t        endColumn = start - offset;\n\t        end = next + 1;\n\t        break;\n\t      default:\n\t        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\n\t          next = css.indexOf('*/', start + 2) + 1;\n\t          if (next === 0) {\n\t            unclosed('comment', '*/');\n\t          }\n\t          content = css.slice(start, next + 1);\n\t          lines = content.split('\\n');\n\t          last = lines.length - 1;\n\t          if (last > 0) {\n\t            nextLine = line + last;\n\t            nextOffset = next - lines[last].length;\n\t          } else {\n\t            nextLine = line;\n\t            nextOffset = offset;\n\t          }\n\t          tokenType = t.comment;\n\t          line = nextLine;\n\t          endLine = nextLine;\n\t          endColumn = next - nextOffset;\n\t        } else if (code === t.slash) {\n\t          next = start;\n\t          tokenType = code;\n\t          endLine = line;\n\t          endColumn = start - offset;\n\t          end = next + 1;\n\t        } else {\n\t          next = consumeWord(css, start);\n\t          tokenType = t.word;\n\t          endLine = line;\n\t          endColumn = next - offset;\n\t        }\n\t        end = next + 1;\n\t        break;\n\t    }\n\n\t    // Ensure that the token structure remains consistent\n\t    tokens.push([tokenType,\n\t    // [0] Token type\n\t    line,\n\t    // [1] Starting line\n\t    start - offset,\n\t    // [2] Starting column\n\t    endLine,\n\t    // [3] Ending line\n\t    endColumn,\n\t    // [4] Ending column\n\t    start,\n\t    // [5] Start position / Source index\n\t    end // [6] End position\n\t    ]);\n\n\t    // Reset offset for the next token\n\t    if (nextOffset) {\n\t      offset = nextOffset;\n\t      nextOffset = null;\n\t    }\n\t    start = end;\n\t  }\n\t  return tokens;\n\t} \n} (tokenize));\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\tvar _root = _interopRequireDefault(rootExports);\n\tvar _selector = _interopRequireDefault(selectorExports);\n\tvar _className = _interopRequireDefault(classNameExports);\n\tvar _comment = _interopRequireDefault(commentExports);\n\tvar _id = _interopRequireDefault(idExports);\n\tvar _tag = _interopRequireDefault(tagExports);\n\tvar _string = _interopRequireDefault(stringExports);\n\tvar _pseudo = _interopRequireDefault(pseudoExports);\n\tvar _attribute = _interopRequireWildcard(attribute$1);\n\tvar _universal = _interopRequireDefault(universalExports);\n\tvar _combinator = _interopRequireDefault(combinatorExports);\n\tvar _nesting = _interopRequireDefault(nestingExports);\n\tvar _sortAscending = _interopRequireDefault(sortAscendingExports);\n\tvar _tokenize = _interopRequireWildcard(tokenize);\n\tvar tokens = _interopRequireWildcard(tokenTypes);\n\tvar types$1 = _interopRequireWildcard(types);\n\tvar _util = util;\n\tvar _WHITESPACE_TOKENS, _Object$assign;\n\tfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\tfunction _interopRequireWildcard(obj, nodeInterop) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\tfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\tfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\tvar WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);\n\tvar WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));\n\tfunction tokenStart(token) {\n\t  return {\n\t    line: token[_tokenize.FIELDS.START_LINE],\n\t    column: token[_tokenize.FIELDS.START_COL]\n\t  };\n\t}\n\tfunction tokenEnd(token) {\n\t  return {\n\t    line: token[_tokenize.FIELDS.END_LINE],\n\t    column: token[_tokenize.FIELDS.END_COL]\n\t  };\n\t}\n\tfunction getSource(startLine, startColumn, endLine, endColumn) {\n\t  return {\n\t    start: {\n\t      line: startLine,\n\t      column: startColumn\n\t    },\n\t    end: {\n\t      line: endLine,\n\t      column: endColumn\n\t    }\n\t  };\n\t}\n\tfunction getTokenSource(token) {\n\t  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);\n\t}\n\tfunction getTokenSourceSpan(startToken, endToken) {\n\t  if (!startToken) {\n\t    return undefined;\n\t  }\n\t  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);\n\t}\n\tfunction unescapeProp(node, prop) {\n\t  var value = node[prop];\n\t  if (typeof value !== \"string\") {\n\t    return;\n\t  }\n\t  if (value.indexOf(\"\\\\\") !== -1) {\n\t    (0, _util.ensureObject)(node, 'raws');\n\t    node[prop] = (0, _util.unesc)(value);\n\t    if (node.raws[prop] === undefined) {\n\t      node.raws[prop] = value;\n\t    }\n\t  }\n\t  return node;\n\t}\n\tfunction indexesOf(array, item) {\n\t  var i = -1;\n\t  var indexes = [];\n\t  while ((i = array.indexOf(item, i + 1)) !== -1) {\n\t    indexes.push(i);\n\t  }\n\t  return indexes;\n\t}\n\tfunction uniqs() {\n\t  var list = Array.prototype.concat.apply([], arguments);\n\t  return list.filter(function (item, i) {\n\t    return i === list.indexOf(item);\n\t  });\n\t}\n\tvar Parser = /*#__PURE__*/function () {\n\t  function Parser(rule, options) {\n\t    if (options === void 0) {\n\t      options = {};\n\t    }\n\t    this.rule = rule;\n\t    this.options = Object.assign({\n\t      lossy: false,\n\t      safe: false\n\t    }, options);\n\t    this.position = 0;\n\t    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n\t    this.tokens = (0, _tokenize[\"default\"])({\n\t      css: this.css,\n\t      error: this._errorGenerator(),\n\t      safe: this.options.safe\n\t    });\n\t    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n\t    this.root = new _root[\"default\"]({\n\t      source: rootSource\n\t    });\n\t    this.root.errorGenerator = this._errorGenerator();\n\t    var selector = new _selector[\"default\"]({\n\t      source: {\n\t        start: {\n\t          line: 1,\n\t          column: 1\n\t        }\n\t      },\n\t      sourceIndex: 0\n\t    });\n\t    this.root.append(selector);\n\t    this.current = selector;\n\t    this.loop();\n\t  }\n\t  var _proto = Parser.prototype;\n\t  _proto._errorGenerator = function _errorGenerator() {\n\t    var _this = this;\n\t    return function (message, errorOptions) {\n\t      if (typeof _this.rule === 'string') {\n\t        return new Error(message);\n\t      }\n\t      return _this.rule.error(message, errorOptions);\n\t    };\n\t  };\n\t  _proto.attribute = function attribute() {\n\t    var attr = [];\n\t    var startingToken = this.currToken;\n\t    this.position++;\n\t    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n\t      attr.push(this.currToken);\n\t      this.position++;\n\t    }\n\t    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n\t      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n\t    }\n\t    var len = attr.length;\n\t    var node = {\n\t      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n\t      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n\t    };\n\t    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {\n\t      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);\n\t    }\n\t    var pos = 0;\n\t    var spaceBefore = '';\n\t    var commentBefore = '';\n\t    var lastAdded = null;\n\t    var spaceAfterMeaningfulToken = false;\n\t    while (pos < len) {\n\t      var token = attr[pos];\n\t      var content = this.content(token);\n\t      var next = attr[pos + 1];\n\t      switch (token[_tokenize.FIELDS.TYPE]) {\n\t        case tokens.space:\n\t          // if (\n\t          //     len === 1 ||\n\t          //     pos === 0 && this.content(next) === '|'\n\t          // ) {\n\t          //     return this.expected('attribute', token[TOKEN.START_POS], content);\n\t          // }\n\t          spaceAfterMeaningfulToken = true;\n\t          if (this.options.lossy) {\n\t            break;\n\t          }\n\t          if (lastAdded) {\n\t            (0, _util.ensureObject)(node, 'spaces', lastAdded);\n\t            var prevContent = node.spaces[lastAdded].after || '';\n\t            node.spaces[lastAdded].after = prevContent + content;\n\t            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;\n\t            if (existingComment) {\n\t              node.raws.spaces[lastAdded].after = existingComment + content;\n\t            }\n\t          } else {\n\t            spaceBefore = spaceBefore + content;\n\t            commentBefore = commentBefore + content;\n\t          }\n\t          break;\n\t        case tokens.asterisk:\n\t          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n\t            node.operator = content;\n\t            lastAdded = 'operator';\n\t          } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n\t            if (spaceBefore) {\n\t              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n\t              node.spaces.attribute.before = spaceBefore;\n\t              spaceBefore = '';\n\t            }\n\t            if (commentBefore) {\n\t              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n\t              node.raws.spaces.attribute.before = spaceBefore;\n\t              commentBefore = '';\n\t            }\n\t            node.namespace = (node.namespace || \"\") + content;\n\t            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;\n\t            if (rawValue) {\n\t              node.raws.namespace += content;\n\t            }\n\t            lastAdded = 'namespace';\n\t          }\n\t          spaceAfterMeaningfulToken = false;\n\t          break;\n\t        case tokens.dollar:\n\t          if (lastAdded === \"value\") {\n\t            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');\n\t            node.value += \"$\";\n\t            if (oldRawValue) {\n\t              node.raws.value = oldRawValue + \"$\";\n\t            }\n\t            break;\n\t          }\n\t        // Falls through\n\t        case tokens.caret:\n\t          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n\t            node.operator = content;\n\t            lastAdded = 'operator';\n\t          }\n\t          spaceAfterMeaningfulToken = false;\n\t          break;\n\t        case tokens.combinator:\n\t          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n\t            node.operator = content;\n\t            lastAdded = 'operator';\n\t          }\n\t          if (content !== '|') {\n\t            spaceAfterMeaningfulToken = false;\n\t            break;\n\t          }\n\t          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n\t            node.operator = content;\n\t            lastAdded = 'operator';\n\t          } else if (!node.namespace && !node.attribute) {\n\t            node.namespace = true;\n\t          }\n\t          spaceAfterMeaningfulToken = false;\n\t          break;\n\t        case tokens.word:\n\t          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals &&\n\t          // this look-ahead probably fails with comment nodes involved.\n\t          !node.operator && !node.namespace) {\n\t            node.namespace = content;\n\t            lastAdded = 'namespace';\n\t          } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n\t            if (spaceBefore) {\n\t              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n\t              node.spaces.attribute.before = spaceBefore;\n\t              spaceBefore = '';\n\t            }\n\t            if (commentBefore) {\n\t              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n\t              node.raws.spaces.attribute.before = commentBefore;\n\t              commentBefore = '';\n\t            }\n\t            node.attribute = (node.attribute || \"\") + content;\n\t            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;\n\t            if (_rawValue) {\n\t              node.raws.attribute += content;\n\t            }\n\t            lastAdded = 'attribute';\n\t          } else if (!node.value && node.value !== \"\" || lastAdded === \"value\" && !(spaceAfterMeaningfulToken || node.quoteMark)) {\n\t            var _unescaped = (0, _util.unesc)(content);\n\t            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';\n\t            var oldValue = node.value || '';\n\t            node.value = oldValue + _unescaped;\n\t            node.quoteMark = null;\n\t            if (_unescaped !== content || _oldRawValue) {\n\t              (0, _util.ensureObject)(node, 'raws');\n\t              node.raws.value = (_oldRawValue || oldValue) + content;\n\t            }\n\t            lastAdded = 'value';\n\t          } else {\n\t            var insensitive = content === 'i' || content === \"I\";\n\t            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {\n\t              node.insensitive = insensitive;\n\t              if (!insensitive || content === \"I\") {\n\t                (0, _util.ensureObject)(node, 'raws');\n\t                node.raws.insensitiveFlag = content;\n\t              }\n\t              lastAdded = 'insensitive';\n\t              if (spaceBefore) {\n\t                (0, _util.ensureObject)(node, 'spaces', 'insensitive');\n\t                node.spaces.insensitive.before = spaceBefore;\n\t                spaceBefore = '';\n\t              }\n\t              if (commentBefore) {\n\t                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');\n\t                node.raws.spaces.insensitive.before = commentBefore;\n\t                commentBefore = '';\n\t              }\n\t            } else if (node.value || node.value === '') {\n\t              lastAdded = 'value';\n\t              node.value += content;\n\t              if (node.raws.value) {\n\t                node.raws.value += content;\n\t              }\n\t            }\n\t          }\n\t          spaceAfterMeaningfulToken = false;\n\t          break;\n\t        case tokens.str:\n\t          if (!node.attribute || !node.operator) {\n\t            return this.error(\"Expected an attribute followed by an operator preceding the string.\", {\n\t              index: token[_tokenize.FIELDS.START_POS]\n\t            });\n\t          }\n\t          var _unescapeValue = (0, _attribute.unescapeValue)(content),\n\t            unescaped = _unescapeValue.unescaped,\n\t            quoteMark = _unescapeValue.quoteMark;\n\t          node.value = unescaped;\n\t          node.quoteMark = quoteMark;\n\t          lastAdded = 'value';\n\t          (0, _util.ensureObject)(node, 'raws');\n\t          node.raws.value = content;\n\t          spaceAfterMeaningfulToken = false;\n\t          break;\n\t        case tokens.equals:\n\t          if (!node.attribute) {\n\t            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);\n\t          }\n\t          if (node.value) {\n\t            return this.error('Unexpected \"=\" found; an operator was already defined.', {\n\t              index: token[_tokenize.FIELDS.START_POS]\n\t            });\n\t          }\n\t          node.operator = node.operator ? node.operator + content : content;\n\t          lastAdded = 'operator';\n\t          spaceAfterMeaningfulToken = false;\n\t          break;\n\t        case tokens.comment:\n\t          if (lastAdded) {\n\t            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {\n\t              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';\n\t              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n\t              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);\n\t              node.raws.spaces[lastAdded].after = rawLastComment + content;\n\t            } else {\n\t              var lastValue = node[lastAdded] || '';\n\t              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;\n\t              (0, _util.ensureObject)(node, 'raws');\n\t              node.raws[lastAdded] = rawLastValue + content;\n\t            }\n\t          } else {\n\t            commentBefore = commentBefore + content;\n\t          }\n\t          break;\n\t        default:\n\t          return this.error(\"Unexpected \\\"\" + content + \"\\\" found.\", {\n\t            index: token[_tokenize.FIELDS.START_POS]\n\t          });\n\t      }\n\t      pos++;\n\t    }\n\t    unescapeProp(node, \"attribute\");\n\t    unescapeProp(node, \"namespace\");\n\t    this.newNode(new _attribute[\"default\"](node));\n\t    this.position++;\n\t  }\n\n\t  /**\n\t   * return a node containing meaningless garbage up to (but not including) the specified token position.\n\t   * if the token position is negative, all remaining tokens are consumed.\n\t   *\n\t   * This returns an array containing a single string node if all whitespace,\n\t   * otherwise an array of comment nodes with space before and after.\n\t   *\n\t   * These tokens are not added to the current selector, the caller can add them or use them to amend\n\t   * a previous node's space metadata.\n\t   *\n\t   * In lossy mode, this returns only comments.\n\t   */;\n\t  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {\n\t    if (stopPosition < 0) {\n\t      stopPosition = this.tokens.length;\n\t    }\n\t    var startPosition = this.position;\n\t    var nodes = [];\n\t    var space = \"\";\n\t    var lastComment = undefined;\n\t    do {\n\t      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n\t        if (!this.options.lossy) {\n\t          space += this.content();\n\t        }\n\t      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {\n\t        var spaces = {};\n\t        if (space) {\n\t          spaces.before = space;\n\t          space = \"\";\n\t        }\n\t        lastComment = new _comment[\"default\"]({\n\t          value: this.content(),\n\t          source: getTokenSource(this.currToken),\n\t          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n\t          spaces: spaces\n\t        });\n\t        nodes.push(lastComment);\n\t      }\n\t    } while (++this.position < stopPosition);\n\t    if (space) {\n\t      if (lastComment) {\n\t        lastComment.spaces.after = space;\n\t      } else if (!this.options.lossy) {\n\t        var firstToken = this.tokens[startPosition];\n\t        var lastToken = this.tokens[this.position - 1];\n\t        nodes.push(new _string[\"default\"]({\n\t          value: '',\n\t          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),\n\t          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n\t          spaces: {\n\t            before: space,\n\t            after: ''\n\t          }\n\t        }));\n\t      }\n\t    }\n\t    return nodes;\n\t  }\n\n\t  /**\n\t   *\n\t   * @param {*} nodes\n\t   */;\n\t  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {\n\t    var _this2 = this;\n\t    if (requiredSpace === void 0) {\n\t      requiredSpace = false;\n\t    }\n\t    var space = \"\";\n\t    var rawSpace = \"\";\n\t    nodes.forEach(function (n) {\n\t      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);\n\t      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);\n\t      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n\t      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n\t    });\n\t    if (rawSpace === space) {\n\t      rawSpace = undefined;\n\t    }\n\t    var result = {\n\t      space: space,\n\t      rawSpace: rawSpace\n\t    };\n\t    return result;\n\t  };\n\t  _proto.isNamedCombinator = function isNamedCombinator(position) {\n\t    if (position === void 0) {\n\t      position = this.position;\n\t    }\n\t    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;\n\t  };\n\t  _proto.namedCombinator = function namedCombinator() {\n\t    if (this.isNamedCombinator()) {\n\t      var nameRaw = this.content(this.tokens[this.position + 1]);\n\t      var name = (0, _util.unesc)(nameRaw).toLowerCase();\n\t      var raws = {};\n\t      if (name !== nameRaw) {\n\t        raws.value = \"/\" + nameRaw + \"/\";\n\t      }\n\t      var node = new _combinator[\"default\"]({\n\t        value: \"/\" + name + \"/\",\n\t        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),\n\t        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n\t        raws: raws\n\t      });\n\t      this.position = this.position + 3;\n\t      return node;\n\t    } else {\n\t      this.unexpected();\n\t    }\n\t  };\n\t  _proto.combinator = function combinator() {\n\t    var _this3 = this;\n\t    if (this.content() === '|') {\n\t      return this.namespace();\n\t    }\n\t    // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n\t    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n\t    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {\n\t      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n\t      if (nodes.length > 0) {\n\t        var last = this.current.last;\n\t        if (last) {\n\t          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),\n\t            space = _this$convertWhitespa.space,\n\t            rawSpace = _this$convertWhitespa.rawSpace;\n\t          if (rawSpace !== undefined) {\n\t            last.rawSpaceAfter += rawSpace;\n\t          }\n\t          last.spaces.after += space;\n\t        } else {\n\t          nodes.forEach(function (n) {\n\t            return _this3.newNode(n);\n\t          });\n\t        }\n\t      }\n\t      return;\n\t    }\n\t    var firstToken = this.currToken;\n\t    var spaceOrDescendantSelectorNodes = undefined;\n\t    if (nextSigTokenPos > this.position) {\n\t      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n\t    }\n\t    var node;\n\t    if (this.isNamedCombinator()) {\n\t      node = this.namedCombinator();\n\t    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {\n\t      node = new _combinator[\"default\"]({\n\t        value: this.content(),\n\t        source: getTokenSource(this.currToken),\n\t        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]\n\t      });\n\t      this.position++;\n\t    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) ; else if (!spaceOrDescendantSelectorNodes) {\n\t      this.unexpected();\n\t    }\n\t    if (node) {\n\t      if (spaceOrDescendantSelectorNodes) {\n\t        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),\n\t          _space = _this$convertWhitespa2.space,\n\t          _rawSpace = _this$convertWhitespa2.rawSpace;\n\t        node.spaces.before = _space;\n\t        node.rawSpaceBefore = _rawSpace;\n\t      }\n\t    } else {\n\t      // descendant combinator\n\t      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),\n\t        _space2 = _this$convertWhitespa3.space,\n\t        _rawSpace2 = _this$convertWhitespa3.rawSpace;\n\t      if (!_rawSpace2) {\n\t        _rawSpace2 = _space2;\n\t      }\n\t      var spaces = {};\n\t      var raws = {\n\t        spaces: {}\n\t      };\n\t      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {\n\t        spaces.before = _space2.slice(0, _space2.length - 1);\n\t        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);\n\t      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {\n\t        spaces.after = _space2.slice(1);\n\t        raws.spaces.after = _rawSpace2.slice(1);\n\t      } else {\n\t        raws.value = _rawSpace2;\n\t      }\n\t      node = new _combinator[\"default\"]({\n\t        value: ' ',\n\t        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n\t        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n\t        spaces: spaces,\n\t        raws: raws\n\t      });\n\t    }\n\t    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {\n\t      node.spaces.after = this.optionalSpace(this.content());\n\t      this.position++;\n\t    }\n\t    return this.newNode(node);\n\t  };\n\t  _proto.comma = function comma() {\n\t    if (this.position === this.tokens.length - 1) {\n\t      this.root.trailingComma = true;\n\t      this.position++;\n\t      return;\n\t    }\n\t    this.current._inferEndPosition();\n\t    var selector = new _selector[\"default\"]({\n\t      source: {\n\t        start: tokenStart(this.tokens[this.position + 1])\n\t      },\n\t      sourceIndex: this.tokens[this.position + 1][_tokenize.FIELDS.START_POS]\n\t    });\n\t    this.current.parent.append(selector);\n\t    this.current = selector;\n\t    this.position++;\n\t  };\n\t  _proto.comment = function comment() {\n\t    var current = this.currToken;\n\t    this.newNode(new _comment[\"default\"]({\n\t      value: this.content(),\n\t      source: getTokenSource(current),\n\t      sourceIndex: current[_tokenize.FIELDS.START_POS]\n\t    }));\n\t    this.position++;\n\t  };\n\t  _proto.error = function error(message, opts) {\n\t    throw this.root.error(message, opts);\n\t  };\n\t  _proto.missingBackslash = function missingBackslash() {\n\t    return this.error('Expected a backslash preceding the semicolon.', {\n\t      index: this.currToken[_tokenize.FIELDS.START_POS]\n\t    });\n\t  };\n\t  _proto.missingParenthesis = function missingParenthesis() {\n\t    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n\t  };\n\t  _proto.missingSquareBracket = function missingSquareBracket() {\n\t    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n\t  };\n\t  _proto.unexpected = function unexpected() {\n\t    return this.error(\"Unexpected '\" + this.content() + \"'. Escaping special characters with \\\\ may help.\", this.currToken[_tokenize.FIELDS.START_POS]);\n\t  };\n\t  _proto.unexpectedPipe = function unexpectedPipe() {\n\t    return this.error(\"Unexpected '|'.\", this.currToken[_tokenize.FIELDS.START_POS]);\n\t  };\n\t  _proto.namespace = function namespace() {\n\t    var before = this.prevToken && this.content(this.prevToken) || true;\n\t    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n\t      this.position++;\n\t      return this.word(before);\n\t    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {\n\t      this.position++;\n\t      return this.universal(before);\n\t    }\n\t    this.unexpectedPipe();\n\t  };\n\t  _proto.nesting = function nesting() {\n\t    if (this.nextToken) {\n\t      var nextContent = this.content(this.nextToken);\n\t      if (nextContent === \"|\") {\n\t        this.position++;\n\t        return;\n\t      }\n\t    }\n\t    var current = this.currToken;\n\t    this.newNode(new _nesting[\"default\"]({\n\t      value: this.content(),\n\t      source: getTokenSource(current),\n\t      sourceIndex: current[_tokenize.FIELDS.START_POS]\n\t    }));\n\t    this.position++;\n\t  };\n\t  _proto.parentheses = function parentheses() {\n\t    var last = this.current.last;\n\t    var unbalanced = 1;\n\t    this.position++;\n\t    if (last && last.type === types$1.PSEUDO) {\n\t      var selector = new _selector[\"default\"]({\n\t        source: {\n\t          start: tokenStart(this.tokens[this.position])\n\t        },\n\t        sourceIndex: this.tokens[this.position][_tokenize.FIELDS.START_POS]\n\t      });\n\t      var cache = this.current;\n\t      last.append(selector);\n\t      this.current = selector;\n\t      while (this.position < this.tokens.length && unbalanced) {\n\t        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n\t          unbalanced++;\n\t        }\n\t        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n\t          unbalanced--;\n\t        }\n\t        if (unbalanced) {\n\t          this.parse();\n\t        } else {\n\t          this.current.source.end = tokenEnd(this.currToken);\n\t          this.current.parent.source.end = tokenEnd(this.currToken);\n\t          this.position++;\n\t        }\n\t      }\n\t      this.current = cache;\n\t    } else {\n\t      // I think this case should be an error. It's used to implement a basic parse of media queries\n\t      // but I don't think it's a good idea.\n\t      var parenStart = this.currToken;\n\t      var parenValue = \"(\";\n\t      var parenEnd;\n\t      while (this.position < this.tokens.length && unbalanced) {\n\t        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n\t          unbalanced++;\n\t        }\n\t        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n\t          unbalanced--;\n\t        }\n\t        parenEnd = this.currToken;\n\t        parenValue += this.parseParenthesisToken(this.currToken);\n\t        this.position++;\n\t      }\n\t      if (last) {\n\t        last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n\t      } else {\n\t        this.newNode(new _string[\"default\"]({\n\t          value: parenValue,\n\t          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),\n\t          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]\n\t        }));\n\t      }\n\t    }\n\t    if (unbalanced) {\n\t      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n\t    }\n\t  };\n\t  _proto.pseudo = function pseudo() {\n\t    var _this4 = this;\n\t    var pseudoStr = '';\n\t    var startingToken = this.currToken;\n\t    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {\n\t      pseudoStr += this.content();\n\t      this.position++;\n\t    }\n\t    if (!this.currToken) {\n\t      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n\t    }\n\t    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n\t      this.splitWord(false, function (first, length) {\n\t        pseudoStr += first;\n\t        _this4.newNode(new _pseudo[\"default\"]({\n\t          value: pseudoStr,\n\t          source: getTokenSourceSpan(startingToken, _this4.currToken),\n\t          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n\t        }));\n\t        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n\t          _this4.error('Misplaced parenthesis.', {\n\t            index: _this4.nextToken[_tokenize.FIELDS.START_POS]\n\t          });\n\t        }\n\t      });\n\t    } else {\n\t      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);\n\t    }\n\t  };\n\t  _proto.space = function space() {\n\t    var content = this.content();\n\t    // Handle space before and after the selector\n\t    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {\n\t      return node.type === 'comment';\n\t    })) {\n\t      this.spaces = this.optionalSpace(content);\n\t      this.position++;\n\t    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n\t      this.current.last.spaces.after = this.optionalSpace(content);\n\t      this.position++;\n\t    } else {\n\t      this.combinator();\n\t    }\n\t  };\n\t  _proto.string = function string() {\n\t    var current = this.currToken;\n\t    this.newNode(new _string[\"default\"]({\n\t      value: this.content(),\n\t      source: getTokenSource(current),\n\t      sourceIndex: current[_tokenize.FIELDS.START_POS]\n\t    }));\n\t    this.position++;\n\t  };\n\t  _proto.universal = function universal(namespace) {\n\t    var nextToken = this.nextToken;\n\t    if (nextToken && this.content(nextToken) === '|') {\n\t      this.position++;\n\t      return this.namespace();\n\t    }\n\t    var current = this.currToken;\n\t    this.newNode(new _universal[\"default\"]({\n\t      value: this.content(),\n\t      source: getTokenSource(current),\n\t      sourceIndex: current[_tokenize.FIELDS.START_POS]\n\t    }), namespace);\n\t    this.position++;\n\t  };\n\t  _proto.splitWord = function splitWord(namespace, firstCallback) {\n\t    var _this5 = this;\n\t    var nextToken = this.nextToken;\n\t    var word = this.content();\n\t    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {\n\t      this.position++;\n\t      var current = this.content();\n\t      word += current;\n\t      if (current.lastIndexOf('\\\\') === current.length - 1) {\n\t        var next = this.nextToken;\n\t        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {\n\t          word += this.requiredSpace(this.content(next));\n\t          this.position++;\n\t        }\n\t      }\n\t      nextToken = this.nextToken;\n\t    }\n\t    var hasClass = indexesOf(word, '.').filter(function (i) {\n\t      // Allow escaped dot within class name\n\t      var escapedDot = word[i - 1] === '\\\\';\n\t      // Allow decimal numbers percent in @keyframes\n\t      var isKeyframesPercent = /^\\d+\\.\\d+%$/.test(word);\n\t      return !escapedDot && !isKeyframesPercent;\n\t    });\n\t    var hasId = indexesOf(word, '#').filter(function (i) {\n\t      return word[i - 1] !== '\\\\';\n\t    });\n\t    // Eliminate Sass interpolations from the list of id indexes\n\t    var interpolations = indexesOf(word, '#{');\n\t    if (interpolations.length) {\n\t      hasId = hasId.filter(function (hashIndex) {\n\t        return !~interpolations.indexOf(hashIndex);\n\t      });\n\t    }\n\t    var indices = (0, _sortAscending[\"default\"])(uniqs([0].concat(hasClass, hasId)));\n\t    indices.forEach(function (ind, i) {\n\t      var index = indices[i + 1] || word.length;\n\t      var value = word.slice(ind, index);\n\t      if (i === 0 && firstCallback) {\n\t        return firstCallback.call(_this5, value, indices.length);\n\t      }\n\t      var node;\n\t      var current = _this5.currToken;\n\t      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];\n\t      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n\t      if (~hasClass.indexOf(ind)) {\n\t        var classNameOpts = {\n\t          value: value.slice(1),\n\t          source: source,\n\t          sourceIndex: sourceIndex\n\t        };\n\t        node = new _className[\"default\"](unescapeProp(classNameOpts, \"value\"));\n\t      } else if (~hasId.indexOf(ind)) {\n\t        var idOpts = {\n\t          value: value.slice(1),\n\t          source: source,\n\t          sourceIndex: sourceIndex\n\t        };\n\t        node = new _id[\"default\"](unescapeProp(idOpts, \"value\"));\n\t      } else {\n\t        var tagOpts = {\n\t          value: value,\n\t          source: source,\n\t          sourceIndex: sourceIndex\n\t        };\n\t        unescapeProp(tagOpts, \"value\");\n\t        node = new _tag[\"default\"](tagOpts);\n\t      }\n\t      _this5.newNode(node, namespace);\n\t      // Ensure that the namespace is used only once\n\t      namespace = null;\n\t    });\n\t    this.position++;\n\t  };\n\t  _proto.word = function word(namespace) {\n\t    var nextToken = this.nextToken;\n\t    if (nextToken && this.content(nextToken) === '|') {\n\t      this.position++;\n\t      return this.namespace();\n\t    }\n\t    return this.splitWord(namespace);\n\t  };\n\t  _proto.loop = function loop() {\n\t    while (this.position < this.tokens.length) {\n\t      this.parse(true);\n\t    }\n\t    this.current._inferEndPosition();\n\t    return this.root;\n\t  };\n\t  _proto.parse = function parse(throwOnParenthesis) {\n\t    switch (this.currToken[_tokenize.FIELDS.TYPE]) {\n\t      case tokens.space:\n\t        this.space();\n\t        break;\n\t      case tokens.comment:\n\t        this.comment();\n\t        break;\n\t      case tokens.openParenthesis:\n\t        this.parentheses();\n\t        break;\n\t      case tokens.closeParenthesis:\n\t        if (throwOnParenthesis) {\n\t          this.missingParenthesis();\n\t        }\n\t        break;\n\t      case tokens.openSquare:\n\t        this.attribute();\n\t        break;\n\t      case tokens.dollar:\n\t      case tokens.caret:\n\t      case tokens.equals:\n\t      case tokens.word:\n\t        this.word();\n\t        break;\n\t      case tokens.colon:\n\t        this.pseudo();\n\t        break;\n\t      case tokens.comma:\n\t        this.comma();\n\t        break;\n\t      case tokens.asterisk:\n\t        this.universal();\n\t        break;\n\t      case tokens.ampersand:\n\t        this.nesting();\n\t        break;\n\t      case tokens.slash:\n\t      case tokens.combinator:\n\t        this.combinator();\n\t        break;\n\t      case tokens.str:\n\t        this.string();\n\t        break;\n\t      // These cases throw; no break needed.\n\t      case tokens.closeSquare:\n\t        this.missingSquareBracket();\n\t      case tokens.semicolon:\n\t        this.missingBackslash();\n\t      default:\n\t        this.unexpected();\n\t    }\n\t  }\n\n\t  /**\n\t   * Helpers\n\t   */;\n\t  _proto.expected = function expected(description, index, found) {\n\t    if (Array.isArray(description)) {\n\t      var last = description.pop();\n\t      description = description.join(', ') + \" or \" + last;\n\t    }\n\t    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n\t    if (!found) {\n\t      return this.error(\"Expected \" + an + \" \" + description + \".\", {\n\t        index: index\n\t      });\n\t    }\n\t    return this.error(\"Expected \" + an + \" \" + description + \", found \\\"\" + found + \"\\\" instead.\", {\n\t      index: index\n\t    });\n\t  };\n\t  _proto.requiredSpace = function requiredSpace(space) {\n\t    return this.options.lossy ? ' ' : space;\n\t  };\n\t  _proto.optionalSpace = function optionalSpace(space) {\n\t    return this.options.lossy ? '' : space;\n\t  };\n\t  _proto.lossySpace = function lossySpace(space, required) {\n\t    if (this.options.lossy) {\n\t      return required ? ' ' : '';\n\t    } else {\n\t      return space;\n\t    }\n\t  };\n\t  _proto.parseParenthesisToken = function parseParenthesisToken(token) {\n\t    var content = this.content(token);\n\t    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {\n\t      return this.requiredSpace(content);\n\t    } else {\n\t      return content;\n\t    }\n\t  };\n\t  _proto.newNode = function newNode(node, namespace) {\n\t    if (namespace) {\n\t      if (/^ +$/.test(namespace)) {\n\t        if (!this.options.lossy) {\n\t          this.spaces = (this.spaces || '') + namespace;\n\t        }\n\t        namespace = true;\n\t      }\n\t      node.namespace = namespace;\n\t      unescapeProp(node, \"namespace\");\n\t    }\n\t    if (this.spaces) {\n\t      node.spaces.before = this.spaces;\n\t      this.spaces = '';\n\t    }\n\t    return this.current.append(node);\n\t  };\n\t  _proto.content = function content(token) {\n\t    if (token === void 0) {\n\t      token = this.currToken;\n\t    }\n\t    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);\n\t  };\n\t  /**\n\t   * returns the index of the next non-whitespace, non-comment token.\n\t   * returns -1 if no meaningful token is found.\n\t   */\n\t  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {\n\t    if (startPosition === void 0) {\n\t      startPosition = this.position + 1;\n\t    }\n\t    var searchPosition = startPosition;\n\t    while (searchPosition < this.tokens.length) {\n\t      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {\n\t        searchPosition++;\n\t        continue;\n\t      } else {\n\t        return searchPosition;\n\t      }\n\t    }\n\t    return -1;\n\t  };\n\t  _createClass(Parser, [{\n\t    key: \"currToken\",\n\t    get: function get() {\n\t      return this.tokens[this.position];\n\t    }\n\t  }, {\n\t    key: \"nextToken\",\n\t    get: function get() {\n\t      return this.tokens[this.position + 1];\n\t    }\n\t  }, {\n\t    key: \"prevToken\",\n\t    get: function get() {\n\t      return this.tokens[this.position - 1];\n\t    }\n\t  }]);\n\t  return Parser;\n\t}();\n\texports[\"default\"] = Parser;\n\tmodule.exports = exports.default; \n} (parser, parser.exports));\n\nvar parserExports = parser.exports;\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\tvar _parser = _interopRequireDefault(parserExports);\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\tvar Processor = /*#__PURE__*/function () {\n\t  function Processor(func, options) {\n\t    this.func = func || function noop() {};\n\t    this.funcRes = null;\n\t    this.options = options;\n\t  }\n\t  var _proto = Processor.prototype;\n\t  _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {\n\t    if (options === void 0) {\n\t      options = {};\n\t    }\n\t    var merged = Object.assign({}, this.options, options);\n\t    if (merged.updateSelector === false) {\n\t      return false;\n\t    } else {\n\t      return typeof rule !== \"string\";\n\t    }\n\t  };\n\t  _proto._isLossy = function _isLossy(options) {\n\t    if (options === void 0) {\n\t      options = {};\n\t    }\n\t    var merged = Object.assign({}, this.options, options);\n\t    if (merged.lossless === false) {\n\t      return true;\n\t    } else {\n\t      return false;\n\t    }\n\t  };\n\t  _proto._root = function _root(rule, options) {\n\t    if (options === void 0) {\n\t      options = {};\n\t    }\n\t    var parser = new _parser[\"default\"](rule, this._parseOptions(options));\n\t    return parser.root;\n\t  };\n\t  _proto._parseOptions = function _parseOptions(options) {\n\t    return {\n\t      lossy: this._isLossy(options)\n\t    };\n\t  };\n\t  _proto._run = function _run(rule, options) {\n\t    var _this = this;\n\t    if (options === void 0) {\n\t      options = {};\n\t    }\n\t    return new Promise(function (resolve, reject) {\n\t      try {\n\t        var root = _this._root(rule, options);\n\t        Promise.resolve(_this.func(root)).then(function (transform) {\n\t          var string = undefined;\n\t          if (_this._shouldUpdateSelector(rule, options)) {\n\t            string = root.toString();\n\t            rule.selector = string;\n\t          }\n\t          return {\n\t            transform: transform,\n\t            root: root,\n\t            string: string\n\t          };\n\t        }).then(resolve, reject);\n\t      } catch (e) {\n\t        reject(e);\n\t        return;\n\t      }\n\t    });\n\t  };\n\t  _proto._runSync = function _runSync(rule, options) {\n\t    if (options === void 0) {\n\t      options = {};\n\t    }\n\t    var root = this._root(rule, options);\n\t    var transform = this.func(root);\n\t    if (transform && typeof transform.then === \"function\") {\n\t      throw new Error(\"Selector processor returned a promise to a synchronous call.\");\n\t    }\n\t    var string = undefined;\n\t    if (options.updateSelector && typeof rule !== \"string\") {\n\t      string = root.toString();\n\t      rule.selector = string;\n\t    }\n\t    return {\n\t      transform: transform,\n\t      root: root,\n\t      string: string\n\t    };\n\t  }\n\n\t  /**\n\t   * Process rule into a selector AST.\n\t   *\n\t   * @param rule {postcss.Rule | string} The css selector to be processed\n\t   * @param options The options for processing\n\t   * @returns {Promise<parser.Root>} The AST of the selector after processing it.\n\t   */;\n\t  _proto.ast = function ast(rule, options) {\n\t    return this._run(rule, options).then(function (result) {\n\t      return result.root;\n\t    });\n\t  }\n\n\t  /**\n\t   * Process rule into a selector AST synchronously.\n\t   *\n\t   * @param rule {postcss.Rule | string} The css selector to be processed\n\t   * @param options The options for processing\n\t   * @returns {parser.Root} The AST of the selector after processing it.\n\t   */;\n\t  _proto.astSync = function astSync(rule, options) {\n\t    return this._runSync(rule, options).root;\n\t  }\n\n\t  /**\n\t   * Process a selector into a transformed value asynchronously\n\t   *\n\t   * @param rule {postcss.Rule | string} The css selector to be processed\n\t   * @param options The options for processing\n\t   * @returns {Promise<any>} The value returned by the processor.\n\t   */;\n\t  _proto.transform = function transform(rule, options) {\n\t    return this._run(rule, options).then(function (result) {\n\t      return result.transform;\n\t    });\n\t  }\n\n\t  /**\n\t   * Process a selector into a transformed value synchronously.\n\t   *\n\t   * @param rule {postcss.Rule | string} The css selector to be processed\n\t   * @param options The options for processing\n\t   * @returns {any} The value returned by the processor.\n\t   */;\n\t  _proto.transformSync = function transformSync(rule, options) {\n\t    return this._runSync(rule, options).transform;\n\t  }\n\n\t  /**\n\t   * Process a selector into a new selector string asynchronously.\n\t   *\n\t   * @param rule {postcss.Rule | string} The css selector to be processed\n\t   * @param options The options for processing\n\t   * @returns {string} the selector after processing.\n\t   */;\n\t  _proto.process = function process(rule, options) {\n\t    return this._run(rule, options).then(function (result) {\n\t      return result.string || result.root.toString();\n\t    });\n\t  }\n\n\t  /**\n\t   * Process a selector into a new selector string synchronously.\n\t   *\n\t   * @param rule {postcss.Rule | string} The css selector to be processed\n\t   * @param options The options for processing\n\t   * @returns {string} the selector after processing.\n\t   */;\n\t  _proto.processSync = function processSync(rule, options) {\n\t    var result = this._runSync(rule, options);\n\t    return result.string || result.root.toString();\n\t  };\n\t  return Processor;\n\t}();\n\texports[\"default\"] = Processor;\n\tmodule.exports = exports.default; \n} (processor, processor.exports));\n\nvar processorExports = processor.exports;\n\nvar selectors = {};\n\nvar constructors = {};\n\nconstructors.__esModule = true;\nconstructors.universal = constructors.tag = constructors.string = constructors.selector = constructors.root = constructors.pseudo = constructors.nesting = constructors.id = constructors.comment = constructors.combinator = constructors.className = constructors.attribute = void 0;\nvar _attribute = _interopRequireDefault$2(attribute$1);\nvar _className = _interopRequireDefault$2(classNameExports);\nvar _combinator = _interopRequireDefault$2(combinatorExports);\nvar _comment = _interopRequireDefault$2(commentExports);\nvar _id = _interopRequireDefault$2(idExports);\nvar _nesting = _interopRequireDefault$2(nestingExports);\nvar _pseudo = _interopRequireDefault$2(pseudoExports);\nvar _root = _interopRequireDefault$2(rootExports);\nvar _selector = _interopRequireDefault$2(selectorExports);\nvar _string = _interopRequireDefault$2(stringExports);\nvar _tag = _interopRequireDefault$2(tagExports);\nvar _universal = _interopRequireDefault$2(universalExports);\nfunction _interopRequireDefault$2(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar attribute = function attribute(opts) {\n  return new _attribute[\"default\"](opts);\n};\nconstructors.attribute = attribute;\nvar className = function className(opts) {\n  return new _className[\"default\"](opts);\n};\nconstructors.className = className;\nvar combinator = function combinator(opts) {\n  return new _combinator[\"default\"](opts);\n};\nconstructors.combinator = combinator;\nvar comment = function comment(opts) {\n  return new _comment[\"default\"](opts);\n};\nconstructors.comment = comment;\nvar id = function id(opts) {\n  return new _id[\"default\"](opts);\n};\nconstructors.id = id;\nvar nesting = function nesting(opts) {\n  return new _nesting[\"default\"](opts);\n};\nconstructors.nesting = nesting;\nvar pseudo = function pseudo(opts) {\n  return new _pseudo[\"default\"](opts);\n};\nconstructors.pseudo = pseudo;\nvar root = function root(opts) {\n  return new _root[\"default\"](opts);\n};\nconstructors.root = root;\nvar selector = function selector(opts) {\n  return new _selector[\"default\"](opts);\n};\nconstructors.selector = selector;\nvar string = function string(opts) {\n  return new _string[\"default\"](opts);\n};\nconstructors.string = string;\nvar tag = function tag(opts) {\n  return new _tag[\"default\"](opts);\n};\nconstructors.tag = tag;\nvar universal = function universal(opts) {\n  return new _universal[\"default\"](opts);\n};\nconstructors.universal = universal;\n\nvar guards = {};\n\nguards.__esModule = true;\nguards.isComment = guards.isCombinator = guards.isClassName = guards.isAttribute = void 0;\nguards.isContainer = isContainer;\nguards.isIdentifier = void 0;\nguards.isNamespace = isNamespace;\nguards.isNesting = void 0;\nguards.isNode = isNode;\nguards.isPseudo = void 0;\nguards.isPseudoClass = isPseudoClass;\nguards.isPseudoElement = isPseudoElement;\nguards.isUniversal = guards.isTag = guards.isString = guards.isSelector = guards.isRoot = void 0;\nvar _types = types;\nvar _IS_TYPE;\nvar IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);\nfunction isNode(node) {\n  return typeof node === \"object\" && IS_TYPE[node.type];\n}\nfunction isNodeType(type, node) {\n  return isNode(node) && node.type === type;\n}\nvar isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);\nguards.isAttribute = isAttribute;\nvar isClassName = isNodeType.bind(null, _types.CLASS);\nguards.isClassName = isClassName;\nvar isCombinator = isNodeType.bind(null, _types.COMBINATOR);\nguards.isCombinator = isCombinator;\nvar isComment = isNodeType.bind(null, _types.COMMENT);\nguards.isComment = isComment;\nvar isIdentifier = isNodeType.bind(null, _types.ID);\nguards.isIdentifier = isIdentifier;\nvar isNesting = isNodeType.bind(null, _types.NESTING);\nguards.isNesting = isNesting;\nvar isPseudo = isNodeType.bind(null, _types.PSEUDO);\nguards.isPseudo = isPseudo;\nvar isRoot = isNodeType.bind(null, _types.ROOT);\nguards.isRoot = isRoot;\nvar isSelector = isNodeType.bind(null, _types.SELECTOR);\nguards.isSelector = isSelector;\nvar isString = isNodeType.bind(null, _types.STRING);\nguards.isString = isString;\nvar isTag = isNodeType.bind(null, _types.TAG);\nguards.isTag = isTag;\nvar isUniversal = isNodeType.bind(null, _types.UNIVERSAL);\nguards.isUniversal = isUniversal;\nfunction isPseudoElement(node) {\n  return isPseudo(node) && node.value && (node.value.startsWith(\"::\") || node.value.toLowerCase() === \":before\" || node.value.toLowerCase() === \":after\" || node.value.toLowerCase() === \":first-letter\" || node.value.toLowerCase() === \":first-line\");\n}\nfunction isPseudoClass(node) {\n  return isPseudo(node) && !isPseudoElement(node);\n}\nfunction isContainer(node) {\n  return !!(isNode(node) && node.walk);\n}\nfunction isNamespace(node) {\n  return isAttribute(node) || isTag(node);\n}\n\n(function (exports) {\n\n\texports.__esModule = true;\n\tvar _types = types;\n\tObject.keys(_types).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  if (key in exports && exports[key] === _types[key]) return;\n\t  exports[key] = _types[key];\n\t});\n\tvar _constructors = constructors;\n\tObject.keys(_constructors).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  if (key in exports && exports[key] === _constructors[key]) return;\n\t  exports[key] = _constructors[key];\n\t});\n\tvar _guards = guards;\n\tObject.keys(_guards).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  if (key in exports && exports[key] === _guards[key]) return;\n\t  exports[key] = _guards[key];\n\t}); \n} (selectors));\n\n(function (module, exports) {\n\n\texports.__esModule = true;\n\texports[\"default\"] = void 0;\n\tvar _processor = _interopRequireDefault(processorExports);\n\tvar selectors$1 = _interopRequireWildcard(selectors);\n\tfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\tfunction _interopRequireWildcard(obj, nodeInterop) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\tvar parser = function parser(processor) {\n\t  return new _processor[\"default\"](processor);\n\t};\n\tObject.assign(parser, selectors$1);\n\tdelete parser.__esModule;\n\tvar _default = parser;\n\texports[\"default\"] = _default;\n\tmodule.exports = exports.default; \n} (dist, dist.exports));\n\nvar distExports = dist.exports;\n\nconst selectorParser$1 = distExports;\nconst valueParser = _dep_IQS_Za7F_js__WEBPACK_IMPORTED_MODULE_4__.l;\nconst { extractICSS } = src$4;\n\nconst isSpacing = (node) => node.type === \"combinator\" && node.value === \" \";\n\nfunction normalizeNodeArray(nodes) {\n  const array = [];\n\n  nodes.forEach((x) => {\n    if (Array.isArray(x)) {\n      normalizeNodeArray(x).forEach((item) => {\n        array.push(item);\n      });\n    } else if (x) {\n      array.push(x);\n    }\n  });\n\n  if (array.length > 0 && isSpacing(array[array.length - 1])) {\n    array.pop();\n  }\n  return array;\n}\n\nfunction localizeNode(rule, mode, localAliasMap) {\n  const transform = (node, context) => {\n    if (context.ignoreNextSpacing && !isSpacing(node)) {\n      throw new Error(\"Missing whitespace after \" + context.ignoreNextSpacing);\n    }\n\n    if (context.enforceNoSpacing && isSpacing(node)) {\n      throw new Error(\"Missing whitespace before \" + context.enforceNoSpacing);\n    }\n\n    let newNodes;\n\n    switch (node.type) {\n      case \"root\": {\n        let resultingGlobal;\n\n        context.hasPureGlobals = false;\n\n        newNodes = node.nodes.map((n) => {\n          const nContext = {\n            global: context.global,\n            lastWasSpacing: true,\n            hasLocals: false,\n            explicit: false,\n          };\n\n          n = transform(n, nContext);\n\n          if (typeof resultingGlobal === \"undefined\") {\n            resultingGlobal = nContext.global;\n          } else if (resultingGlobal !== nContext.global) {\n            throw new Error(\n              'Inconsistent rule global/local result in rule \"' +\n                node +\n                '\" (multiple selectors must result in the same mode for the rule)'\n            );\n          }\n\n          if (!nContext.hasLocals) {\n            context.hasPureGlobals = true;\n          }\n\n          return n;\n        });\n\n        context.global = resultingGlobal;\n\n        node.nodes = normalizeNodeArray(newNodes);\n        break;\n      }\n      case \"selector\": {\n        newNodes = node.map((childNode) => transform(childNode, context));\n\n        node = node.clone();\n        node.nodes = normalizeNodeArray(newNodes);\n        break;\n      }\n      case \"combinator\": {\n        if (isSpacing(node)) {\n          if (context.ignoreNextSpacing) {\n            context.ignoreNextSpacing = false;\n            context.lastWasSpacing = false;\n            context.enforceNoSpacing = false;\n            return null;\n          }\n          context.lastWasSpacing = true;\n          return node;\n        }\n        break;\n      }\n      case \"pseudo\": {\n        let childContext;\n        const isNested = !!node.length;\n        const isScoped = node.value === \":local\" || node.value === \":global\";\n        const isImportExport =\n          node.value === \":import\" || node.value === \":export\";\n\n        if (isImportExport) {\n          context.hasLocals = true;\n          // :local(.foo)\n        } else if (isNested) {\n          if (isScoped) {\n            if (node.nodes.length === 0) {\n              throw new Error(`${node.value}() can't be empty`);\n            }\n\n            if (context.inside) {\n              throw new Error(\n                `A ${node.value} is not allowed inside of a ${context.inside}(...)`\n              );\n            }\n\n            childContext = {\n              global: node.value === \":global\",\n              inside: node.value,\n              hasLocals: false,\n              explicit: true,\n            };\n\n            newNodes = node\n              .map((childNode) => transform(childNode, childContext))\n              .reduce((acc, next) => acc.concat(next.nodes), []);\n\n            if (newNodes.length) {\n              const { before, after } = node.spaces;\n\n              const first = newNodes[0];\n              const last = newNodes[newNodes.length - 1];\n\n              first.spaces = { before, after: first.spaces.after };\n              last.spaces = { before: last.spaces.before, after };\n            }\n\n            node = newNodes;\n\n            break;\n          } else {\n            childContext = {\n              global: context.global,\n              inside: context.inside,\n              lastWasSpacing: true,\n              hasLocals: false,\n              explicit: context.explicit,\n            };\n            newNodes = node.map((childNode) => {\n              const newContext = {\n                ...childContext,\n                enforceNoSpacing: false,\n              };\n\n              const result = transform(childNode, newContext);\n\n              childContext.global = newContext.global;\n              childContext.hasLocals = newContext.hasLocals;\n\n              return result;\n            });\n\n            node = node.clone();\n            node.nodes = normalizeNodeArray(newNodes);\n\n            if (childContext.hasLocals) {\n              context.hasLocals = true;\n            }\n          }\n          break;\n\n          //:local .foo .bar\n        } else if (isScoped) {\n          if (context.inside) {\n            throw new Error(\n              `A ${node.value} is not allowed inside of a ${context.inside}(...)`\n            );\n          }\n\n          const addBackSpacing = !!node.spaces.before;\n\n          context.ignoreNextSpacing = context.lastWasSpacing\n            ? node.value\n            : false;\n\n          context.enforceNoSpacing = context.lastWasSpacing\n            ? false\n            : node.value;\n\n          context.global = node.value === \":global\";\n          context.explicit = true;\n\n          // because this node has spacing that is lost when we remove it\n          // we make up for it by adding an extra combinator in since adding\n          // spacing on the parent selector doesn't work\n          return addBackSpacing\n            ? selectorParser$1.combinator({ value: \" \" })\n            : null;\n        }\n        break;\n      }\n      case \"id\":\n      case \"class\": {\n        if (!node.value) {\n          throw new Error(\"Invalid class or id selector syntax\");\n        }\n\n        if (context.global) {\n          break;\n        }\n\n        const isImportedValue = localAliasMap.has(node.value);\n        const isImportedWithExplicitScope = isImportedValue && context.explicit;\n\n        if (!isImportedValue || isImportedWithExplicitScope) {\n          const innerNode = node.clone();\n          innerNode.spaces = { before: \"\", after: \"\" };\n\n          node = selectorParser$1.pseudo({\n            value: \":local\",\n            nodes: [innerNode],\n            spaces: node.spaces,\n          });\n\n          context.hasLocals = true;\n        }\n\n        break;\n      }\n      case \"nesting\": {\n        if (node.value === \"&\") {\n          context.hasLocals = true;\n        }\n      }\n    }\n\n    context.lastWasSpacing = false;\n    context.ignoreNextSpacing = false;\n    context.enforceNoSpacing = false;\n\n    return node;\n  };\n\n  const rootContext = {\n    global: mode === \"global\",\n    hasPureGlobals: false,\n  };\n\n  rootContext.selector = selectorParser$1((root) => {\n    transform(root, rootContext);\n  }).processSync(rule, { updateSelector: false, lossless: true });\n\n  return rootContext;\n}\n\nfunction localizeDeclNode(node, context) {\n  switch (node.type) {\n    case \"word\":\n      if (context.localizeNextItem) {\n        if (!context.localAliasMap.has(node.value)) {\n          node.value = \":local(\" + node.value + \")\";\n          context.localizeNextItem = false;\n        }\n      }\n      break;\n\n    case \"function\":\n      if (\n        context.options &&\n        context.options.rewriteUrl &&\n        node.value.toLowerCase() === \"url\"\n      ) {\n        node.nodes.map((nestedNode) => {\n          if (nestedNode.type !== \"string\" && nestedNode.type !== \"word\") {\n            return;\n          }\n\n          let newUrl = context.options.rewriteUrl(\n            context.global,\n            nestedNode.value\n          );\n\n          switch (nestedNode.type) {\n            case \"string\":\n              if (nestedNode.quote === \"'\") {\n                newUrl = newUrl.replace(/(\\\\)/g, \"\\\\$1\").replace(/'/g, \"\\\\'\");\n              }\n\n              if (nestedNode.quote === '\"') {\n                newUrl = newUrl.replace(/(\\\\)/g, \"\\\\$1\").replace(/\"/g, '\\\\\"');\n              }\n\n              break;\n            case \"word\":\n              newUrl = newUrl.replace(/(\"|'|\\)|\\\\)/g, \"\\\\$1\");\n              break;\n          }\n\n          nestedNode.value = newUrl;\n        });\n      }\n      break;\n  }\n  return node;\n}\n\n// `none` is special value, other is global values\nconst specialKeywords = [\n  \"none\",\n  \"inherit\",\n  \"initial\",\n  \"revert\",\n  \"revert-layer\",\n  \"unset\",\n];\n\nfunction localizeDeclarationValues(localize, declaration, context) {\n  const valueNodes = valueParser(declaration.value);\n\n  valueNodes.walk((node, index, nodes) => {\n    if (\n      node.type === \"function\" &&\n      (node.value.toLowerCase() === \"var\" || node.value.toLowerCase() === \"env\")\n    ) {\n      return false;\n    }\n\n    if (\n      node.type === \"word\" &&\n      specialKeywords.includes(node.value.toLowerCase())\n    ) {\n      return;\n    }\n\n    const subContext = {\n      options: context.options,\n      global: context.global,\n      localizeNextItem: localize && !context.global,\n      localAliasMap: context.localAliasMap,\n    };\n    nodes[index] = localizeDeclNode(node, subContext);\n  });\n\n  declaration.value = valueNodes.toString();\n}\n\nfunction localizeDeclaration(declaration, context) {\n  const isAnimation = /animation$/i.test(declaration.prop);\n\n  if (isAnimation) {\n    // letter\n    // An uppercase letter or a lowercase letter.\n    //\n    // ident-start code point\n    // A letter, a non-ASCII code point, or U+005F LOW LINE (_).\n    //\n    // ident code point\n    // An ident-start code point, a digit, or U+002D HYPHEN-MINUS (-).\n\n    // We don't validate `hex digits`, because we don't need it, it is work of linters.\n    const validIdent =\n      /^-?([a-z\\u0080-\\uFFFF_]|(\\\\[^\\r\\n\\f])|-(?![0-9]))((\\\\[^\\r\\n\\f])|[a-z\\u0080-\\uFFFF_0-9-])*$/i;\n\n    /*\n    The spec defines some keywords that you can use to describe properties such as the timing\n    function. These are still valid animation names, so as long as there is a property that accepts\n    a keyword, it is given priority. Only when all the properties that can take a keyword are\n    exhausted can the animation name be set to the keyword. I.e.\n\n    animation: infinite infinite;\n\n    The animation will repeat an infinite number of times from the first argument, and will have an\n    animation name of infinite from the second.\n    */\n    const animationKeywords = {\n      // animation-direction\n      $normal: 1,\n      $reverse: 1,\n      $alternate: 1,\n      \"$alternate-reverse\": 1,\n      // animation-fill-mode\n      $forwards: 1,\n      $backwards: 1,\n      $both: 1,\n      // animation-iteration-count\n      $infinite: 1,\n      // animation-play-state\n      $paused: 1,\n      $running: 1,\n      // animation-timing-function\n      $ease: 1,\n      \"$ease-in\": 1,\n      \"$ease-out\": 1,\n      \"$ease-in-out\": 1,\n      $linear: 1,\n      \"$step-end\": 1,\n      \"$step-start\": 1,\n      // Special\n      $none: Infinity, // No matter how many times you write none, it will never be an animation name\n      // Global values\n      $initial: Infinity,\n      $inherit: Infinity,\n      $unset: Infinity,\n      $revert: Infinity,\n      \"$revert-layer\": Infinity,\n    };\n    let parsedAnimationKeywords = {};\n    const valueNodes = valueParser(declaration.value).walk((node) => {\n      // If div-token appeared (represents as comma ','), a possibility of an animation-keywords should be reflesh.\n      if (node.type === \"div\") {\n        parsedAnimationKeywords = {};\n\n        return;\n      }\n      // Do not handle nested functions\n      else if (node.type === \"function\") {\n        return false;\n      }\n      // Ignore all except word\n      else if (node.type !== \"word\") {\n        return;\n      }\n\n      const value = node.type === \"word\" ? node.value.toLowerCase() : null;\n\n      let shouldParseAnimationName = false;\n\n      if (value && validIdent.test(value)) {\n        if (\"$\" + value in animationKeywords) {\n          parsedAnimationKeywords[\"$\" + value] =\n            \"$\" + value in parsedAnimationKeywords\n              ? parsedAnimationKeywords[\"$\" + value] + 1\n              : 0;\n\n          shouldParseAnimationName =\n            parsedAnimationKeywords[\"$\" + value] >=\n            animationKeywords[\"$\" + value];\n        } else {\n          shouldParseAnimationName = true;\n        }\n      }\n\n      const subContext = {\n        options: context.options,\n        global: context.global,\n        localizeNextItem: shouldParseAnimationName && !context.global,\n        localAliasMap: context.localAliasMap,\n      };\n\n      return localizeDeclNode(node, subContext);\n    });\n\n    declaration.value = valueNodes.toString();\n\n    return;\n  }\n\n  const isAnimationName = /animation(-name)?$/i.test(declaration.prop);\n\n  if (isAnimationName) {\n    return localizeDeclarationValues(true, declaration, context);\n  }\n\n  const hasUrl = /url\\(/i.test(declaration.value);\n\n  if (hasUrl) {\n    return localizeDeclarationValues(false, declaration, context);\n  }\n}\n\nsrc$2.exports = (options = {}) => {\n  if (\n    options &&\n    options.mode &&\n    options.mode !== \"global\" &&\n    options.mode !== \"local\" &&\n    options.mode !== \"pure\"\n  ) {\n    throw new Error(\n      'options.mode must be either \"global\", \"local\" or \"pure\" (default \"local\")'\n    );\n  }\n\n  const pureMode = options && options.mode === \"pure\";\n  const globalMode = options && options.mode === \"global\";\n\n  return {\n    postcssPlugin: \"postcss-modules-local-by-default\",\n    prepare() {\n      const localAliasMap = new Map();\n\n      return {\n        Once(root) {\n          const { icssImports } = extractICSS(root, false);\n\n          Object.keys(icssImports).forEach((key) => {\n            Object.keys(icssImports[key]).forEach((prop) => {\n              localAliasMap.set(prop, icssImports[key][prop]);\n            });\n          });\n\n          root.walkAtRules((atRule) => {\n            if (/keyframes$/i.test(atRule.name)) {\n              const globalMatch = /^\\s*:global\\s*\\((.+)\\)\\s*$/.exec(\n                atRule.params\n              );\n              const localMatch = /^\\s*:local\\s*\\((.+)\\)\\s*$/.exec(\n                atRule.params\n              );\n\n              let globalKeyframes = globalMode;\n\n              if (globalMatch) {\n                if (pureMode) {\n                  throw atRule.error(\n                    \"@keyframes :global(...) is not allowed in pure mode\"\n                  );\n                }\n                atRule.params = globalMatch[1];\n                globalKeyframes = true;\n              } else if (localMatch) {\n                atRule.params = localMatch[0];\n                globalKeyframes = false;\n              } else if (\n                atRule.params &&\n                !globalMode &&\n                !localAliasMap.has(atRule.params)\n              ) {\n                atRule.params = \":local(\" + atRule.params + \")\";\n              }\n\n              atRule.walkDecls((declaration) => {\n                localizeDeclaration(declaration, {\n                  localAliasMap,\n                  options: options,\n                  global: globalKeyframes,\n                });\n              });\n            } else if (/scope$/i.test(atRule.name)) {\n              if (atRule.params) {\n                atRule.params = atRule.params\n                  .split(\"to\")\n                  .map((item) => {\n                    const selector = item.trim().slice(1, -1).trim();\n                    const context = localizeNode(\n                      selector,\n                      options.mode,\n                      localAliasMap\n                    );\n\n                    context.options = options;\n                    context.localAliasMap = localAliasMap;\n\n                    if (pureMode && context.hasPureGlobals) {\n                      throw atRule.error(\n                        'Selector in at-rule\"' +\n                          selector +\n                          '\" is not pure ' +\n                          \"(pure selectors must contain at least one local class or id)\"\n                      );\n                    }\n\n                    return `(${context.selector})`;\n                  })\n                  .join(\" to \");\n              }\n\n              atRule.nodes.forEach((declaration) => {\n                if (declaration.type === \"decl\") {\n                  localizeDeclaration(declaration, {\n                    localAliasMap,\n                    options: options,\n                    global: globalMode,\n                  });\n                }\n              });\n            } else if (atRule.nodes) {\n              atRule.nodes.forEach((declaration) => {\n                if (declaration.type === \"decl\") {\n                  localizeDeclaration(declaration, {\n                    localAliasMap,\n                    options: options,\n                    global: globalMode,\n                  });\n                }\n              });\n            }\n          });\n\n          root.walkRules((rule) => {\n            if (\n              rule.parent &&\n              rule.parent.type === \"atrule\" &&\n              /keyframes$/i.test(rule.parent.name)\n            ) {\n              // ignore keyframe rules\n              return;\n            }\n\n            const context = localizeNode(rule, options.mode, localAliasMap);\n\n            context.options = options;\n            context.localAliasMap = localAliasMap;\n\n            if (pureMode && context.hasPureGlobals) {\n              throw rule.error(\n                'Selector \"' +\n                  rule.selector +\n                  '\" is not pure ' +\n                  \"(pure selectors must contain at least one local class or id)\"\n              );\n            }\n\n            rule.selector = context.selector;\n\n            // Less-syntax mixins parse as rules with no nodes\n            if (rule.nodes) {\n              rule.nodes.forEach((declaration) =>\n                localizeDeclaration(declaration, context)\n              );\n            }\n          });\n        },\n      };\n    },\n  };\n};\nsrc$2.exports.postcss = true;\n\nvar srcExports$1 = src$2.exports;\n\nconst selectorParser = distExports;\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction isNestedRule(rule) {\n  if (!rule.parent || rule.parent.type === \"root\") {\n    return false;\n  }\n\n  if (rule.parent.type === \"rule\") {\n    return true;\n  }\n\n  return isNestedRule(rule.parent);\n}\n\nfunction getSingleLocalNamesForComposes(root, rule) {\n  if (isNestedRule(rule)) {\n    throw new Error(`composition is not allowed in nested rule \\n\\n${rule}`);\n  }\n\n  return root.nodes.map((node) => {\n    if (node.type !== \"selector\" || node.nodes.length !== 1) {\n      throw new Error(\n        `composition is only allowed when selector is single :local class name not in \"${root}\"`\n      );\n    }\n\n    node = node.nodes[0];\n\n    if (\n      node.type !== \"pseudo\" ||\n      node.value !== \":local\" ||\n      node.nodes.length !== 1\n    ) {\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    node = node.first;\n\n    if (node.type !== \"selector\" || node.length !== 1) {\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    node = node.first;\n\n    if (node.type !== \"class\") {\n      // 'id' is not possible, because you can't compose ids\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    return node.value;\n  });\n}\n\nconst whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\";\nconst unescapeRegExp = new RegExp(\n  \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\",\n  \"ig\"\n);\n\nfunction unescape(str) {\n  return str.replace(unescapeRegExp, (_, escaped, escapedWhitespace) => {\n    const high = \"0x\" + escaped - 0x10000;\n\n    // NaN means non-codepoint\n    // Workaround erroneous numeric interpretation of +\"0x\"\n    return high !== high || escapedWhitespace\n      ? escaped\n      : high < 0\n      ? // BMP codepoint\n        String.fromCharCode(high + 0x10000)\n      : // Supplemental Plane codepoint (surrogate pair)\n        String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);\n  });\n}\n\nconst plugin = (options = {}) => {\n  const generateScopedName =\n    (options && options.generateScopedName) || plugin.generateScopedName;\n  const generateExportEntry =\n    (options && options.generateExportEntry) || plugin.generateExportEntry;\n  const exportGlobals = options && options.exportGlobals;\n\n  return {\n    postcssPlugin: \"postcss-modules-scope\",\n    Once(root, { rule }) {\n      const exports = Object.create(null);\n\n      function exportScopedName(name, rawName, node) {\n        const scopedName = generateScopedName(\n          rawName ? rawName : name,\n          root.source.input.from,\n          root.source.input.css,\n          node\n        );\n        const exportEntry = generateExportEntry(\n          rawName ? rawName : name,\n          scopedName,\n          root.source.input.from,\n          root.source.input.css,\n          node\n        );\n        const { key, value } = exportEntry;\n\n        exports[key] = exports[key] || [];\n\n        if (exports[key].indexOf(value) < 0) {\n          exports[key].push(value);\n        }\n\n        return scopedName;\n      }\n\n      function localizeNode(node) {\n        switch (node.type) {\n          case \"selector\":\n            node.nodes = node.map((item) => localizeNode(item));\n            return node;\n          case \"class\":\n            return selectorParser.className({\n              value: exportScopedName(\n                node.value,\n                node.raws && node.raws.value ? node.raws.value : null,\n                node\n              ),\n            });\n          case \"id\": {\n            return selectorParser.id({\n              value: exportScopedName(\n                node.value,\n                node.raws && node.raws.value ? node.raws.value : null,\n                node\n              ),\n            });\n          }\n          case \"attribute\": {\n            if (node.attribute === \"class\" && node.operator === \"=\") {\n              return selectorParser.attribute({\n                attribute: node.attribute,\n                operator: node.operator,\n                quoteMark: \"'\",\n                value: exportScopedName(node.value, null, null),\n              });\n            }\n          }\n        }\n\n        throw new Error(\n          `${node.type} (\"${node}\") is not allowed in a :local block`\n        );\n      }\n\n      function traverseNode(node) {\n        switch (node.type) {\n          case \"pseudo\":\n            if (node.value === \":local\") {\n              if (node.nodes.length !== 1) {\n                throw new Error('Unexpected comma (\",\") in :local block');\n              }\n\n              const selector = localizeNode(node.first);\n              // move the spaces that were around the pseudo selector to the first\n              // non-container node\n              selector.first.spaces = node.spaces;\n\n              const nextNode = node.next();\n\n              if (\n                nextNode &&\n                nextNode.type === \"combinator\" &&\n                nextNode.value === \" \" &&\n                /\\\\[A-F0-9]{1,6}$/.test(selector.last.value)\n              ) {\n                selector.last.spaces.after = \" \";\n              }\n\n              node.replaceWith(selector);\n\n              return;\n            }\n          /* falls through */\n          case \"root\":\n          case \"selector\": {\n            node.each((item) => traverseNode(item));\n            break;\n          }\n          case \"id\":\n          case \"class\":\n            if (exportGlobals) {\n              exports[node.value] = [node.value];\n            }\n            break;\n        }\n        return node;\n      }\n\n      // Find any :import and remember imported names\n      const importedNames = {};\n\n      root.walkRules(/^:import\\(.+\\)$/, (rule) => {\n        rule.walkDecls((decl) => {\n          importedNames[decl.prop] = true;\n        });\n      });\n\n      // Find any :local selectors\n      root.walkRules((rule) => {\n        let parsedSelector = selectorParser().astSync(rule);\n\n        rule.selector = traverseNode(parsedSelector.clone()).toString();\n\n        rule.walkDecls(/^(composes|compose-with)$/i, (decl) => {\n          const localNames = getSingleLocalNamesForComposes(\n            parsedSelector,\n            decl.parent\n          );\n          const multiple = decl.value.split(\",\");\n\n          multiple.forEach((value) => {\n            const classes = value.trim().split(/\\s+/);\n\n            classes.forEach((className) => {\n              const global = /^global\\(([^)]+)\\)$/.exec(className);\n\n              if (global) {\n                localNames.forEach((exportedName) => {\n                  exports[exportedName].push(global[1]);\n                });\n              } else if (hasOwnProperty.call(importedNames, className)) {\n                localNames.forEach((exportedName) => {\n                  exports[exportedName].push(className);\n                });\n              } else if (hasOwnProperty.call(exports, className)) {\n                localNames.forEach((exportedName) => {\n                  exports[className].forEach((item) => {\n                    exports[exportedName].push(item);\n                  });\n                });\n              } else {\n                throw decl.error(\n                  `referenced class name \"${className}\" in ${decl.prop} not found`\n                );\n              }\n            });\n          });\n\n          decl.remove();\n        });\n\n        // Find any :local values\n        rule.walkDecls((decl) => {\n          if (!/:local\\s*\\((.+?)\\)/.test(decl.value)) {\n            return;\n          }\n\n          let tokens = decl.value.split(/(,|'[^']*'|\"[^\"]*\")/);\n\n          tokens = tokens.map((token, idx) => {\n            if (idx === 0 || tokens[idx - 1] === \",\") {\n              let result = token;\n\n              const localMatch = /:local\\s*\\((.+?)\\)/.exec(token);\n\n              if (localMatch) {\n                const input = localMatch.input;\n                const matchPattern = localMatch[0];\n                const matchVal = localMatch[1];\n                const newVal = exportScopedName(matchVal);\n\n                result = input.replace(matchPattern, newVal);\n              } else {\n                return token;\n              }\n\n              return result;\n            } else {\n              return token;\n            }\n          });\n\n          decl.value = tokens.join(\"\");\n        });\n      });\n\n      // Find any :local keyframes\n      root.walkAtRules(/keyframes$/i, (atRule) => {\n        const localMatch = /^\\s*:local\\s*\\((.+?)\\)\\s*$/.exec(atRule.params);\n\n        if (!localMatch) {\n          return;\n        }\n\n        atRule.params = exportScopedName(localMatch[1]);\n      });\n\n      root.walkAtRules(/scope$/i, (atRule) => {\n        if (atRule.params) {\n          atRule.params = atRule.params\n            .split(\"to\")\n            .map((item) => {\n              const selector = item.trim().slice(1, -1).trim();\n\n              const localMatch = /^\\s*:local\\s*\\((.+?)\\)\\s*$/.exec(selector);\n\n              if (!localMatch) {\n                return `(${selector})`;\n              }\n\n              let parsedSelector = selectorParser().astSync(selector);\n\n              return `(${traverseNode(parsedSelector).toString()})`;\n            })\n            .join(\" to \");\n        }\n      });\n\n      // If we found any :locals, insert an :export rule\n      const exportedNames = Object.keys(exports);\n\n      if (exportedNames.length > 0) {\n        const exportRule = rule({ selector: \":export\" });\n\n        exportedNames.forEach((exportedName) =>\n          exportRule.append({\n            prop: exportedName,\n            value: exports[exportedName].join(\" \"),\n            raws: { before: \"\\n  \" },\n          })\n        );\n\n        root.append(exportRule);\n      }\n    },\n  };\n};\n\nplugin.postcss = true;\n\nplugin.generateScopedName = function (name, path) {\n  const sanitisedPath = path\n    .replace(/\\.[^./\\\\]+$/, \"\")\n    .replace(/[\\W_]+/g, \"_\")\n    .replace(/^_|_$/g, \"\");\n\n  return `_${sanitisedPath}__${name}`.trim();\n};\n\nplugin.generateExportEntry = function (name, scopedName) {\n  return {\n    key: unescape(name),\n    value: unescape(scopedName),\n  };\n};\n\nvar src$1 = plugin;\n\nfunction hash(str) {\n  var hash = 5381,\n      i    = str.length;\n\n  while(i) {\n    hash = (hash * 33) ^ str.charCodeAt(--i);\n  }\n\n  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */\n  return hash >>> 0;\n}\n\nvar stringHash = hash;\n\nvar src = {exports: {}};\n\nconst ICSSUtils = src$4;\n\nconst matchImports = /^(.+?|\\([\\s\\S]+?\\))\\s+from\\s+(\"[^\"]*\"|'[^']*'|[\\w-]+)$/;\nconst matchValueDefinition = /(?:\\s+|^)([\\w-]+):?(.*?)$/;\nconst matchImport = /^([\\w-]+)(?:\\s+as\\s+([\\w-]+))?/;\n\nsrc.exports = (options) => {\n  let importIndex = 0;\n  const createImportedName =\n    (options && options.createImportedName) ||\n    ((importName /*, path*/) =>\n      `i__const_${importName.replace(/\\W/g, \"_\")}_${importIndex++}`);\n\n  return {\n    postcssPlugin: \"postcss-modules-values\",\n    prepare(result) {\n      const importAliases = [];\n      const definitions = {};\n\n      return {\n        Once(root, postcss) {\n          root.walkAtRules(/value/i, (atRule) => {\n            const matches = atRule.params.match(matchImports);\n\n            if (matches) {\n              let [, /*match*/ aliases, path] = matches;\n\n              // We can use constants for path names\n              if (definitions[path]) {\n                path = definitions[path];\n              }\n\n              const imports = aliases\n                .replace(/^\\(\\s*([\\s\\S]+)\\s*\\)$/, \"$1\")\n                .split(/\\s*,\\s*/)\n                .map((alias) => {\n                  const tokens = matchImport.exec(alias);\n\n                  if (tokens) {\n                    const [, /*match*/ theirName, myName = theirName] = tokens;\n                    const importedName = createImportedName(myName);\n                    definitions[myName] = importedName;\n                    return { theirName, importedName };\n                  } else {\n                    throw new Error(`@import statement \"${alias}\" is invalid!`);\n                  }\n                });\n\n              importAliases.push({ path, imports });\n\n              atRule.remove();\n\n              return;\n            }\n\n            if (atRule.params.indexOf(\"@value\") !== -1) {\n              result.warn(\"Invalid value definition: \" + atRule.params);\n            }\n\n            let [, key, value] = `${atRule.params}${atRule.raws.between}`.match(\n              matchValueDefinition\n            );\n\n            const normalizedValue = value.replace(/\\/\\*((?!\\*\\/).*?)\\*\\//g, \"\");\n\n            if (normalizedValue.length === 0) {\n              result.warn(\"Invalid value definition: \" + atRule.params);\n              atRule.remove();\n\n              return;\n            }\n\n            let isOnlySpace = /^\\s+$/.test(normalizedValue);\n\n            if (!isOnlySpace) {\n              value = value.trim();\n            }\n\n            // Add to the definitions, knowing that values can refer to each other\n            definitions[key] = ICSSUtils.replaceValueSymbols(\n              value,\n              definitions\n            );\n\n            atRule.remove();\n          });\n\n          /* If we have no definitions, don't continue */\n          if (!Object.keys(definitions).length) {\n            return;\n          }\n\n          /* Perform replacements */\n          ICSSUtils.replaceSymbols(root, definitions);\n\n          /* We want to export anything defined by now, but don't add it to the CSS yet or it well get picked up by the replacement stuff */\n          const exportDeclarations = Object.keys(definitions).map((key) =>\n            postcss.decl({\n              value: definitions[key],\n              prop: key,\n              raws: { before: \"\\n  \" },\n            })\n          );\n\n          /* Add export rules if any */\n          if (exportDeclarations.length > 0) {\n            const exportRule = postcss.rule({\n              selector: \":export\",\n              raws: { after: \"\\n\" },\n            });\n\n            exportRule.append(exportDeclarations);\n\n            root.prepend(exportRule);\n          }\n\n          /* Add import rules */\n          importAliases.reverse().forEach(({ path, imports }) => {\n            const importRule = postcss.rule({\n              selector: `:import(${path})`,\n              raws: { after: \"\\n\" },\n            });\n\n            imports.forEach(({ theirName, importedName }) => {\n              importRule.append({\n                value: theirName,\n                prop: importedName,\n                raws: { before: \"\\n  \" },\n              });\n            });\n\n            root.prepend(importRule);\n          });\n        },\n      };\n    },\n  };\n};\n\nsrc.exports.postcss = true;\n\nvar srcExports = src.exports;\n\nObject.defineProperty(scoping, \"__esModule\", {\n  value: true\n});\nscoping.behaviours = void 0;\nscoping.getDefaultPlugins = getDefaultPlugins;\nscoping.getDefaultScopeBehaviour = getDefaultScopeBehaviour;\nscoping.getScopedNameGenerator = getScopedNameGenerator;\n\nvar _postcssModulesExtractImports = _interopRequireDefault$1(srcExports$2);\n\nvar _genericNames = _interopRequireDefault$1(genericNames);\n\nvar _postcssModulesLocalByDefault = _interopRequireDefault$1(srcExports$1);\n\nvar _postcssModulesScope = _interopRequireDefault$1(src$1);\n\nvar _stringHash = _interopRequireDefault$1(stringHash);\n\nvar _postcssModulesValues = _interopRequireDefault$1(srcExports);\n\nfunction _interopRequireDefault$1(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst behaviours = {\n  LOCAL: \"local\",\n  GLOBAL: \"global\"\n};\nscoping.behaviours = behaviours;\n\nfunction getDefaultPlugins({\n  behaviour,\n  generateScopedName,\n  exportGlobals\n}) {\n  const scope = (0, _postcssModulesScope.default)({\n    generateScopedName,\n    exportGlobals\n  });\n  const plugins = {\n    [behaviours.LOCAL]: [_postcssModulesValues.default, (0, _postcssModulesLocalByDefault.default)({\n      mode: \"local\"\n    }), _postcssModulesExtractImports.default, scope],\n    [behaviours.GLOBAL]: [_postcssModulesValues.default, (0, _postcssModulesLocalByDefault.default)({\n      mode: \"global\"\n    }), _postcssModulesExtractImports.default, scope]\n  };\n  return plugins[behaviour];\n}\n\nfunction isValidBehaviour(behaviour) {\n  return Object.keys(behaviours).map(key => behaviours[key]).indexOf(behaviour) > -1;\n}\n\nfunction getDefaultScopeBehaviour(scopeBehaviour) {\n  return scopeBehaviour && isValidBehaviour(scopeBehaviour) ? scopeBehaviour : behaviours.LOCAL;\n}\n\nfunction generateScopedNameDefault(name, filename, css) {\n  const i = css.indexOf(`.${name}`);\n  const lineNumber = css.substr(0, i).split(/[\\r\\n]/).length;\n  const hash = (0, _stringHash.default)(css).toString(36).substr(0, 5);\n  return `_${name}_${hash}_${lineNumber}`;\n}\n\nfunction getScopedNameGenerator(generateScopedName, hashPrefix) {\n  const scopedNameGenerator = generateScopedName || generateScopedNameDefault;\n\n  if (typeof scopedNameGenerator === \"function\") {\n    return scopedNameGenerator;\n  }\n\n  return (0, _genericNames.default)(scopedNameGenerator, {\n    context: process.cwd(),\n    hashPrefix: hashPrefix\n  });\n}\n\nObject.defineProperty(pluginFactory, \"__esModule\", {\n  value: true\n});\npluginFactory.makePlugin = makePlugin;\n\nvar _postcss = _interopRequireDefault(postcss__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n\nvar _unquote = _interopRequireDefault(unquote$1);\n\nvar _Parser = _interopRequireDefault(Parser$1);\n\nvar _saveJSON = _interopRequireDefault(saveJSON$1);\n\nvar _localsConvention = localsConvention;\n\nvar _FileSystemLoader = _interopRequireDefault(FileSystemLoader$1);\n\nvar _scoping = scoping;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst PLUGIN_NAME = \"postcss-modules\";\n\nfunction isGlobalModule(globalModules, inputFile) {\n  return globalModules.some(regex => inputFile.match(regex));\n}\n\nfunction getDefaultPluginsList(opts, inputFile) {\n  const globalModulesList = opts.globalModulePaths || null;\n  const exportGlobals = opts.exportGlobals || false;\n  const defaultBehaviour = (0, _scoping.getDefaultScopeBehaviour)(opts.scopeBehaviour);\n  const generateScopedName = (0, _scoping.getScopedNameGenerator)(opts.generateScopedName, opts.hashPrefix);\n\n  if (globalModulesList && isGlobalModule(globalModulesList, inputFile)) {\n    return (0, _scoping.getDefaultPlugins)({\n      behaviour: _scoping.behaviours.GLOBAL,\n      generateScopedName,\n      exportGlobals\n    });\n  }\n\n  return (0, _scoping.getDefaultPlugins)({\n    behaviour: defaultBehaviour,\n    generateScopedName,\n    exportGlobals\n  });\n}\n\nfunction getLoader(opts, plugins) {\n  const root = typeof opts.root === \"undefined\" ? \"/\" : opts.root;\n  return typeof opts.Loader === \"function\" ? new opts.Loader(root, plugins, opts.resolve) : new _FileSystemLoader.default(root, plugins, opts.resolve);\n}\n\nfunction isOurPlugin(plugin) {\n  return plugin.postcssPlugin === PLUGIN_NAME;\n}\n\nfunction makePlugin(opts) {\n  return {\n    postcssPlugin: PLUGIN_NAME,\n\n    async OnceExit(css, {\n      result\n    }) {\n      const getJSON = opts.getJSON || _saveJSON.default;\n      const inputFile = css.source.input.file;\n      const pluginList = getDefaultPluginsList(opts, inputFile);\n      const resultPluginIndex = result.processor.plugins.findIndex(plugin => isOurPlugin(plugin));\n\n      if (resultPluginIndex === -1) {\n        throw new Error(\"Plugin missing from options.\");\n      }\n\n      const earlierPlugins = result.processor.plugins.slice(0, resultPluginIndex);\n      const loaderPlugins = [...earlierPlugins, ...pluginList];\n      const loader = getLoader(opts, loaderPlugins);\n\n      const fetcher = async (file, relativeTo, depTrace) => {\n        const unquoteFile = (0, _unquote.default)(file);\n        return loader.fetch.call(loader, unquoteFile, relativeTo, depTrace);\n      };\n\n      const parser = new _Parser.default(fetcher);\n      await (0, _postcss.default)([...pluginList, parser.plugin()]).process(css, {\n        from: inputFile\n      });\n      const out = loader.finalSource;\n      if (out) css.prepend(out);\n\n      if (opts.localsConvention) {\n        const reducer = (0, _localsConvention.makeLocalsConventionReducer)(opts.localsConvention, inputFile);\n        parser.exportTokens = Object.entries(parser.exportTokens).reduce(reducer, {});\n      }\n\n      result.messages.push({\n        type: \"export\",\n        plugin: \"postcss-modules\",\n        exportTokens: parser.exportTokens\n      }); // getJSON may return a promise\n\n      return getJSON(css.source.input.file, parser.exportTokens, result.opts.to);\n    }\n\n  };\n}\n\nvar _fs = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\nvar _fs2 = fs;\n\nvar _pluginFactory = pluginFactory;\n\n(0, _fs2.setFileSystem)({\n  readFile: _fs.readFile,\n  writeFile: _fs.writeFile\n});\n\nbuild.exports = (opts = {}) => (0, _pluginFactory.makePlugin)(opts);\n\nvar postcss = build.exports.postcss = true;\n\nvar buildExports = build.exports;\nvar index = /*@__PURE__*/(0,_dep_CB_7IfJ_js__WEBPACK_IMPORTED_MODULE_0__.B)(buildExports);\n\nvar index$1 = /*#__PURE__*/_mergeNamespaces({\n  __proto__: null,\n  default: index,\n  postcss: postcss\n}, [buildExports]);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdml0ZS9kaXN0L25vZGUvY2h1bmtzL2RlcC1CYTFrTjZNcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXNGO0FBQ2pEO0FBQ0o7QUFDRDtBQUNBO0FBQ0E7QUFDYTs7QUFFbUI7QUFDWDtBQUNjOztBQUVuRSxtQkFBbUIsdURBQW1CLENBQUMsdUZBQWU7QUFDdEQsa0JBQWtCLGtEQUFhO0FBQy9CLGdCQUFnQiwwREFBbUIsQ0FBQyx1RkFBZTtBQUNuRDtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyw2QkFBNkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxXQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSztBQUN2QyxvQkFBb0Isb0NBQW9DO0FBQ3hELFdBQVc7QUFDWDtBQUNBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0Isb0JBQW9CLG9DQUFvQztBQUN4RCxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUIsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0IsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQixTQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04saUJBQWlCLFFBQVE7QUFDekIsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsRUFBRTtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxHQUFHOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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TTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdEQUFnRCx1Q0FBdUMsc0NBQXNDLG9GQUFvRiw0REFBNEQ7QUFDL1Qsc0RBQXNELDZCQUE2QixjQUFjLDRFQUE0RSxTQUFTLG9CQUFvQixtREFBbUQsK0JBQStCLHlCQUF5QixpQkFBaUIsc0ZBQXNGLHVCQUF1QiwyRUFBMkUscUZBQXFGLHNDQUFzQyw0Q0FBNEMsT0FBTyw4QkFBOEIseUJBQXlCLGFBQWEsMEJBQTBCO0FBQzF3Qix3Q0FBd0MsdUNBQXVDO0FBQy9FLDZDQUE2QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEO0FBQ2hRLCtEQUErRCxzRUFBc0Usa0RBQWtELGlCQUFpQixHQUFHO0FBQzNNLGlEQUFpRDtBQUNqRCwrQ0FBK0MseUNBQXlDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLEdBQUc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE9BQU8scUVBQXFFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRyxzQkFBc0IsdUNBQXVDOztBQUVoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxHQUFHOztBQUVWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLGlJQUFtQjs7QUFFN0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCwwQkFBMEI7O0FBRTFCOztBQUVBO0FBQ0EseUJBQXlCLGtEQUF1Qjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUV1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2ppbWlwdWxzYXJAZ2l0aHViLmNvbS8uL25vZGVfbW9kdWxlcy92aXRlL2Rpc3Qvbm9kZS9jaHVua3MvZGVwLUJhMWtONk1wLmpzP2Q0MzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQyBhcyBjb21tb25qc0dsb2JhbCwgQiBhcyBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyB9IGZyb20gJy4vZGVwLUNCXzdJZkotLmpzJztcbmltcG9ydCByZXF1aXJlJCQwX19kZWZhdWx0IGZyb20gJ2ZzJztcbmltcG9ydCByZXF1aXJlJCQwIGZyb20gJ3Bvc3Rjc3MnO1xuaW1wb3J0IHJlcXVpcmUkJDAkMSBmcm9tICdwYXRoJztcbmltcG9ydCByZXF1aXJlJCQzIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgcmVxdWlyZSQkMCQyIGZyb20gJ3V0aWwnO1xuaW1wb3J0IHsgbCBhcyBsaWIgfSBmcm9tICcuL2RlcC1JUVMtWmE3Ri5qcyc7XG5cbmltcG9ydCB7IGZpbGVVUkxUb1BhdGggYXMgX19janNfZmlsZVVSTFRvUGF0aCB9IGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IGRpcm5hbWUgYXMgX19janNfZGlybmFtZSB9IGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIGFzIF9fY2pzX2NyZWF0ZVJlcXVpcmUgfSBmcm9tICdub2RlOm1vZHVsZSc7XG5cbmNvbnN0IF9fZmlsZW5hbWUgPSBfX2Nqc19maWxlVVJMVG9QYXRoKGltcG9ydC5tZXRhLnVybCk7XG5jb25zdCBfX2Rpcm5hbWUgPSBfX2Nqc19kaXJuYW1lKF9fZmlsZW5hbWUpO1xuY29uc3QgcmVxdWlyZSA9IF9fY2pzX2NyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcbmNvbnN0IF9fcmVxdWlyZSA9IHJlcXVpcmU7XG5mdW5jdGlvbiBfbWVyZ2VOYW1lc3BhY2VzKG4sIG0pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGUgPSBtW2ldO1xuICAgIGlmICh0eXBlb2YgZSAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkoZSkpIHsgZm9yICh2YXIgayBpbiBlKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnICYmICEoayBpbiBuKSkge1xuICAgICAgICBuW2tdID0gZVtrXTtcbiAgICAgIH1cbiAgICB9IH1cbiAgfVxuICByZXR1cm4gbjtcbn1cblxudmFyIGJ1aWxkID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGZzID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShmcywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZnMuZ2V0RmlsZVN5c3RlbSA9IGdldEZpbGVTeXN0ZW07XG5mcy5zZXRGaWxlU3lzdGVtID0gc2V0RmlsZVN5c3RlbTtcbmxldCBmaWxlU3lzdGVtID0ge1xuICByZWFkRmlsZTogKCkgPT4ge1xuICAgIHRocm93IEVycm9yKFwicmVhZEZpbGUgbm90IGltcGxlbWVudGVkXCIpO1xuICB9LFxuICB3cml0ZUZpbGU6ICgpID0+IHtcbiAgICB0aHJvdyBFcnJvcihcIndyaXRlRmlsZSBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldEZpbGVTeXN0ZW0oZnMpIHtcbiAgZmlsZVN5c3RlbS5yZWFkRmlsZSA9IGZzLnJlYWRGaWxlO1xuICBmaWxlU3lzdGVtLndyaXRlRmlsZSA9IGZzLndyaXRlRmlsZTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsZVN5c3RlbSgpIHtcbiAgcmV0dXJuIGZpbGVTeXN0ZW07XG59XG5cbnZhciBwbHVnaW5GYWN0b3J5ID0ge307XG5cbnZhciB1bnF1b3RlJDEgPSB7fTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHVucXVvdGUkMSwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudW5xdW90ZSQxLmRlZmF1bHQgPSB1bnF1b3RlO1xuLy8gY29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xha2VuZW4vbm9kZS11bnF1b3RlXG5jb25zdCByZWcgPSAvWydcIl0vO1xuXG5mdW5jdGlvbiB1bnF1b3RlKHN0cikge1xuICBpZiAoIXN0cikge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgaWYgKHJlZy50ZXN0KHN0ci5jaGFyQXQoMCkpKSB7XG4gICAgc3RyID0gc3RyLnN1YnN0cigxKTtcbiAgfVxuXG4gIGlmIChyZWcudGVzdChzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSkpIHtcbiAgICBzdHIgPSBzdHIuc3Vic3RyKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbnZhciBQYXJzZXIkMSA9IHt9O1xuXG5jb25zdCBtYXRjaFZhbHVlTmFtZSA9IC9bJF0/W1xcdy1dKy9nO1xuXG5jb25zdCByZXBsYWNlVmFsdWVTeW1ib2xzJDIgPSAodmFsdWUsIHJlcGxhY2VtZW50cykgPT4ge1xuICBsZXQgbWF0Y2hlcztcblxuICB3aGlsZSAoKG1hdGNoZXMgPSBtYXRjaFZhbHVlTmFtZS5leGVjKHZhbHVlKSkpIHtcbiAgICBjb25zdCByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50c1ttYXRjaGVzWzBdXTtcblxuICAgIGlmIChyZXBsYWNlbWVudCkge1xuICAgICAgdmFsdWUgPVxuICAgICAgICB2YWx1ZS5zbGljZSgwLCBtYXRjaGVzLmluZGV4KSArXG4gICAgICAgIHJlcGxhY2VtZW50ICtcbiAgICAgICAgdmFsdWUuc2xpY2UobWF0Y2hWYWx1ZU5hbWUubGFzdEluZGV4KTtcblxuICAgICAgbWF0Y2hWYWx1ZU5hbWUubGFzdEluZGV4IC09IG1hdGNoZXNbMF0ubGVuZ3RoIC0gcmVwbGFjZW1lbnQubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciByZXBsYWNlVmFsdWVTeW1ib2xzXzEgPSByZXBsYWNlVmFsdWVTeW1ib2xzJDI7XG5cbmNvbnN0IHJlcGxhY2VWYWx1ZVN5bWJvbHMkMSA9IHJlcGxhY2VWYWx1ZVN5bWJvbHNfMTtcblxuY29uc3QgcmVwbGFjZVN5bWJvbHMkMSA9IChjc3MsIHJlcGxhY2VtZW50cykgPT4ge1xuICBjc3Mud2Fsaygobm9kZSkgPT4ge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiZGVjbFwiICYmIG5vZGUudmFsdWUpIHtcbiAgICAgIG5vZGUudmFsdWUgPSByZXBsYWNlVmFsdWVTeW1ib2xzJDEobm9kZS52YWx1ZS50b1N0cmluZygpLCByZXBsYWNlbWVudHMpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcInJ1bGVcIiAmJiBub2RlLnNlbGVjdG9yKSB7XG4gICAgICBub2RlLnNlbGVjdG9yID0gcmVwbGFjZVZhbHVlU3ltYm9scyQxKFxuICAgICAgICBub2RlLnNlbGVjdG9yLnRvU3RyaW5nKCksXG4gICAgICAgIHJlcGxhY2VtZW50c1xuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJhdHJ1bGVcIiAmJiBub2RlLnBhcmFtcykge1xuICAgICAgbm9kZS5wYXJhbXMgPSByZXBsYWNlVmFsdWVTeW1ib2xzJDEobm9kZS5wYXJhbXMudG9TdHJpbmcoKSwgcmVwbGFjZW1lbnRzKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIHJlcGxhY2VTeW1ib2xzXzEgPSByZXBsYWNlU3ltYm9scyQxO1xuXG5jb25zdCBpbXBvcnRQYXR0ZXJuID0gL146aW1wb3J0XFwoKFwiW15cIl0qXCJ8J1teJ10qJ3xbXlwiJ10rKVxcKSQvO1xuY29uc3QgYmFsYW5jZWRRdW90ZXMgPSAvXihcIlteXCJdKlwifCdbXiddKid8W15cIiddKykkLztcblxuY29uc3QgZ2V0RGVjbHNPYmplY3QgPSAocnVsZSkgPT4ge1xuICBjb25zdCBvYmplY3QgPSB7fTtcblxuICBydWxlLndhbGtEZWNscygoZGVjbCkgPT4ge1xuICAgIGNvbnN0IGJlZm9yZSA9IGRlY2wucmF3cy5iZWZvcmUgPyBkZWNsLnJhd3MuYmVmb3JlLnRyaW0oKSA6IFwiXCI7XG5cbiAgICBvYmplY3RbYmVmb3JlICsgZGVjbC5wcm9wXSA9IGRlY2wudmFsdWU7XG4gIH0pO1xuXG4gIHJldHVybiBvYmplY3Q7XG59O1xuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1xuICogQHBhcmFtIHtib29sZWFufSByZW1vdmVSdWxlc1xuICogQHBhcmFtIHsnYXV0bycgfCAncnVsZScgfCAnYXQtcnVsZSd9IG1vZGVcbiAqL1xuY29uc3QgZXh0cmFjdElDU1MkMiA9IChjc3MsIHJlbW92ZVJ1bGVzID0gdHJ1ZSwgbW9kZSA9IFwiYXV0b1wiKSA9PiB7XG4gIGNvbnN0IGljc3NJbXBvcnRzID0ge307XG4gIGNvbnN0IGljc3NFeHBvcnRzID0ge307XG5cbiAgZnVuY3Rpb24gYWRkSW1wb3J0cyhub2RlLCBwYXRoKSB7XG4gICAgY29uc3QgdW5xdW90ZWQgPSBwYXRoLnJlcGxhY2UoLyd8XCIvZywgXCJcIik7XG4gICAgaWNzc0ltcG9ydHNbdW5xdW90ZWRdID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIGljc3NJbXBvcnRzW3VucXVvdGVkXSB8fCB7fSxcbiAgICAgIGdldERlY2xzT2JqZWN0KG5vZGUpXG4gICAgKTtcblxuICAgIGlmIChyZW1vdmVSdWxlcykge1xuICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRFeHBvcnRzKG5vZGUpIHtcbiAgICBPYmplY3QuYXNzaWduKGljc3NFeHBvcnRzLCBnZXREZWNsc09iamVjdChub2RlKSk7XG4gICAgaWYgKHJlbW92ZVJ1bGVzKSB7XG4gICAgICBub2RlLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGNzcy5lYWNoKChub2RlKSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJydWxlXCIgJiYgbW9kZSAhPT0gXCJhdC1ydWxlXCIpIHtcbiAgICAgIGlmIChub2RlLnNlbGVjdG9yLnNsaWNlKDAsIDcpID09PSBcIjppbXBvcnRcIikge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gaW1wb3J0UGF0dGVybi5leGVjKG5vZGUuc2VsZWN0b3IpO1xuXG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgYWRkSW1wb3J0cyhub2RlLCBtYXRjaGVzWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5zZWxlY3RvciA9PT0gXCI6ZXhwb3J0XCIpIHtcbiAgICAgICAgYWRkRXhwb3J0cyhub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcImF0cnVsZVwiICYmIG1vZGUgIT09IFwicnVsZVwiKSB7XG4gICAgICBpZiAobm9kZS5uYW1lID09PSBcImljc3MtaW1wb3J0XCIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGJhbGFuY2VkUXVvdGVzLmV4ZWMobm9kZS5wYXJhbXMpO1xuXG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgYWRkSW1wb3J0cyhub2RlLCBtYXRjaGVzWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJpY3NzLWV4cG9ydFwiKSB7XG4gICAgICAgIGFkZEV4cG9ydHMobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4geyBpY3NzSW1wb3J0cywgaWNzc0V4cG9ydHMgfTtcbn07XG5cbnZhciBleHRyYWN0SUNTU18xID0gZXh0cmFjdElDU1MkMjtcblxuY29uc3QgY3JlYXRlSW1wb3J0cyA9IChpbXBvcnRzLCBwb3N0Y3NzLCBtb2RlID0gXCJydWxlXCIpID0+IHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGltcG9ydHMpLm1hcCgocGF0aCkgPT4ge1xuICAgIGNvbnN0IGFsaWFzZXMgPSBpbXBvcnRzW3BhdGhdO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IE9iamVjdC5rZXlzKGFsaWFzZXMpLm1hcCgoa2V5KSA9PlxuICAgICAgcG9zdGNzcy5kZWNsKHtcbiAgICAgICAgcHJvcDoga2V5LFxuICAgICAgICB2YWx1ZTogYWxpYXNlc1trZXldLFxuICAgICAgICByYXdzOiB7IGJlZm9yZTogXCJcXG4gIFwiIH0sXG4gICAgICB9KVxuICAgICk7XG5cbiAgICBjb25zdCBoYXNEZWNsYXJhdGlvbnMgPSBkZWNsYXJhdGlvbnMubGVuZ3RoID4gMDtcblxuICAgIGNvbnN0IHJ1bGUgPVxuICAgICAgbW9kZSA9PT0gXCJydWxlXCJcbiAgICAgICAgPyBwb3N0Y3NzLnJ1bGUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6IGA6aW1wb3J0KCcke3BhdGh9JylgLFxuICAgICAgICAgICAgcmF3czogeyBhZnRlcjogaGFzRGVjbGFyYXRpb25zID8gXCJcXG5cIiA6IFwiXCIgfSxcbiAgICAgICAgICB9KVxuICAgICAgICA6IHBvc3Rjc3MuYXRSdWxlKHtcbiAgICAgICAgICAgIG5hbWU6IFwiaWNzcy1pbXBvcnRcIixcbiAgICAgICAgICAgIHBhcmFtczogYCcke3BhdGh9J2AsXG4gICAgICAgICAgICByYXdzOiB7IGFmdGVyOiBoYXNEZWNsYXJhdGlvbnMgPyBcIlxcblwiIDogXCJcIiB9LFxuICAgICAgICAgIH0pO1xuXG4gICAgaWYgKGhhc0RlY2xhcmF0aW9ucykge1xuICAgICAgcnVsZS5hcHBlbmQoZGVjbGFyYXRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnVsZTtcbiAgfSk7XG59O1xuXG5jb25zdCBjcmVhdGVFeHBvcnRzID0gKGV4cG9ydHMsIHBvc3Rjc3MsIG1vZGUgPSBcInJ1bGVcIikgPT4ge1xuICBjb25zdCBkZWNsYXJhdGlvbnMgPSBPYmplY3Qua2V5cyhleHBvcnRzKS5tYXAoKGtleSkgPT5cbiAgICBwb3N0Y3NzLmRlY2woe1xuICAgICAgcHJvcDoga2V5LFxuICAgICAgdmFsdWU6IGV4cG9ydHNba2V5XSxcbiAgICAgIHJhd3M6IHsgYmVmb3JlOiBcIlxcbiAgXCIgfSxcbiAgICB9KVxuICApO1xuXG4gIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IHJ1bGUgPVxuICAgIG1vZGUgPT09IFwicnVsZVwiXG4gICAgICA/IHBvc3Rjc3MucnVsZSh7XG4gICAgICAgICAgc2VsZWN0b3I6IGA6ZXhwb3J0YCxcbiAgICAgICAgICByYXdzOiB7IGFmdGVyOiBcIlxcblwiIH0sXG4gICAgICAgIH0pXG4gICAgICA6IHBvc3Rjc3MuYXRSdWxlKHtcbiAgICAgICAgICBuYW1lOiBcImljc3MtZXhwb3J0XCIsXG4gICAgICAgICAgcmF3czogeyBhZnRlcjogXCJcXG5cIiB9LFxuICAgICAgICB9KTtcblxuICBydWxlLmFwcGVuZChkZWNsYXJhdGlvbnMpO1xuXG4gIHJldHVybiBbcnVsZV07XG59O1xuXG5jb25zdCBjcmVhdGVJQ1NTUnVsZXMkMSA9IChpbXBvcnRzLCBleHBvcnRzLCBwb3N0Y3NzLCBtb2RlKSA9PiBbXG4gIC4uLmNyZWF0ZUltcG9ydHMoaW1wb3J0cywgcG9zdGNzcywgbW9kZSksXG4gIC4uLmNyZWF0ZUV4cG9ydHMoZXhwb3J0cywgcG9zdGNzcywgbW9kZSksXG5dO1xuXG52YXIgY3JlYXRlSUNTU1J1bGVzXzEgPSBjcmVhdGVJQ1NTUnVsZXMkMTtcblxuY29uc3QgcmVwbGFjZVZhbHVlU3ltYm9scyA9IHJlcGxhY2VWYWx1ZVN5bWJvbHNfMTtcbmNvbnN0IHJlcGxhY2VTeW1ib2xzID0gcmVwbGFjZVN5bWJvbHNfMTtcbmNvbnN0IGV4dHJhY3RJQ1NTJDEgPSBleHRyYWN0SUNTU18xO1xuY29uc3QgY3JlYXRlSUNTU1J1bGVzID0gY3JlYXRlSUNTU1J1bGVzXzE7XG5cbnZhciBzcmMkNCA9IHtcbiAgcmVwbGFjZVZhbHVlU3ltYm9scyxcbiAgcmVwbGFjZVN5bWJvbHMsXG4gIGV4dHJhY3RJQ1NTOiBleHRyYWN0SUNTUyQxLFxuICBjcmVhdGVJQ1NTUnVsZXMsXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGFyc2VyJDEsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblBhcnNlciQxLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfaWNzc1V0aWxzID0gc3JjJDQ7XG5cbi8vIEluaXRpYWxseSBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY3NzLW1vZHVsZXMvY3NzLW1vZHVsZXMtbG9hZGVyLWNvcmVcbmNvbnN0IGltcG9ydFJlZ2V4cCA9IC9eOmltcG9ydFxcKCguKylcXCkkLztcblxuY2xhc3MgUGFyc2VyIHtcbiAgY29uc3RydWN0b3IocGF0aEZldGNoZXIsIHRyYWNlKSB7XG4gICAgdGhpcy5wYXRoRmV0Y2hlciA9IHBhdGhGZXRjaGVyO1xuICAgIHRoaXMucGx1Z2luID0gdGhpcy5wbHVnaW4uYmluZCh0aGlzKTtcbiAgICB0aGlzLmV4cG9ydFRva2VucyA9IHt9O1xuICAgIHRoaXMudHJhbnNsYXRpb25zID0ge307XG4gICAgdGhpcy50cmFjZSA9IHRyYWNlO1xuICB9XG5cbiAgcGx1Z2luKCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3Rjc3NQbHVnaW46IFwiY3NzLW1vZHVsZXMtcGFyc2VyXCIsXG5cbiAgICAgIGFzeW5jIE9uY2VFeGl0KGNzcykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwYXJzZXIuZmV0Y2hBbGxJbXBvcnRzKGNzcykpO1xuICAgICAgICBwYXJzZXIubGlua0ltcG9ydGVkU3ltYm9scyhjc3MpO1xuICAgICAgICByZXR1cm4gcGFyc2VyLmV4dHJhY3RFeHBvcnRzKGNzcyk7XG4gICAgICB9XG5cbiAgICB9O1xuICB9XG5cbiAgZmV0Y2hBbGxJbXBvcnRzKGNzcykge1xuICAgIGxldCBpbXBvcnRzID0gW107XG4gICAgY3NzLmVhY2gobm9kZSA9PiB7XG4gICAgICBpZiAobm9kZS50eXBlID09IFwicnVsZVwiICYmIG5vZGUuc2VsZWN0b3IubWF0Y2goaW1wb3J0UmVnZXhwKSkge1xuICAgICAgICBpbXBvcnRzLnB1c2godGhpcy5mZXRjaEltcG9ydChub2RlLCBjc3Muc291cmNlLmlucHV0LmZyb20sIGltcG9ydHMubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGltcG9ydHM7XG4gIH1cblxuICBsaW5rSW1wb3J0ZWRTeW1ib2xzKGNzcykge1xuICAgICgwLCBfaWNzc1V0aWxzLnJlcGxhY2VTeW1ib2xzKShjc3MsIHRoaXMudHJhbnNsYXRpb25zKTtcbiAgfVxuXG4gIGV4dHJhY3RFeHBvcnRzKGNzcykge1xuICAgIGNzcy5lYWNoKG5vZGUgPT4ge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PSBcInJ1bGVcIiAmJiBub2RlLnNlbGVjdG9yID09IFwiOmV4cG9ydFwiKSB0aGlzLmhhbmRsZUV4cG9ydChub2RlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGhhbmRsZUV4cG9ydChleHBvcnROb2RlKSB7XG4gICAgZXhwb3J0Tm9kZS5lYWNoKGRlY2wgPT4ge1xuICAgICAgaWYgKGRlY2wudHlwZSA9PSBcImRlY2xcIikge1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnRyYW5zbGF0aW9ucykuZm9yRWFjaCh0cmFuc2xhdGlvbiA9PiB7XG4gICAgICAgICAgZGVjbC52YWx1ZSA9IGRlY2wudmFsdWUucmVwbGFjZSh0cmFuc2xhdGlvbiwgdGhpcy50cmFuc2xhdGlvbnNbdHJhbnNsYXRpb25dKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXhwb3J0VG9rZW5zW2RlY2wucHJvcF0gPSBkZWNsLnZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGV4cG9ydE5vZGUucmVtb3ZlKCk7XG4gIH1cblxuICBhc3luYyBmZXRjaEltcG9ydChpbXBvcnROb2RlLCByZWxhdGl2ZVRvLCBkZXBOcikge1xuICAgIGNvbnN0IGZpbGUgPSBpbXBvcnROb2RlLnNlbGVjdG9yLm1hdGNoKGltcG9ydFJlZ2V4cClbMV07XG4gICAgY29uc3QgZGVwVHJhY2UgPSB0aGlzLnRyYWNlICsgU3RyaW5nLmZyb21DaGFyQ29kZShkZXBOcik7XG4gICAgY29uc3QgZXhwb3J0cyA9IGF3YWl0IHRoaXMucGF0aEZldGNoZXIoZmlsZSwgcmVsYXRpdmVUbywgZGVwVHJhY2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGltcG9ydE5vZGUuZWFjaChkZWNsID0+IHtcbiAgICAgICAgaWYgKGRlY2wudHlwZSA9PSBcImRlY2xcIikge1xuICAgICAgICAgIHRoaXMudHJhbnNsYXRpb25zW2RlY2wucHJvcF0gPSBleHBvcnRzW2RlY2wudmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGltcG9ydE5vZGUucmVtb3ZlKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgIH1cbiAgfVxuXG59XG5cblBhcnNlciQxLmRlZmF1bHQgPSBQYXJzZXI7XG5cbnZhciBzYXZlSlNPTiQxID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzYXZlSlNPTiQxLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5zYXZlSlNPTiQxLmRlZmF1bHQgPSBzYXZlSlNPTjtcblxudmFyIF9mcyQyID0gZnM7XG5cbmZ1bmN0aW9uIHNhdmVKU09OKGNzc0ZpbGUsIGpzb24pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB3cml0ZUZpbGVcbiAgICB9ID0gKDAsIF9mcyQyLmdldEZpbGVTeXN0ZW0pKCk7XG4gICAgd3JpdGVGaWxlKGAke2Nzc0ZpbGV9Lmpzb25gLCBKU09OLnN0cmluZ2lmeShqc29uKSwgZSA9PiBlID8gcmVqZWN0KGUpIDogcmVzb2x2ZShqc29uKSk7XG4gIH0pO1xufVxuXG52YXIgbG9jYWxzQ29udmVudGlvbiA9IHt9O1xuXG4vKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cbnZhciByZUFzY2lpV29yZCA9IC9bXlxceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdmXSsvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG52YXIgcmVMYXRpbiA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxceGZmXFx1MDEwMC1cXHUwMTdmXS9nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmXFxcXHVmZTIwLVxcXFx1ZmUyMycsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGYwJyxcbiAgICByc0RpbmdiYXRSYW5nZSA9ICdcXFxcdTI3MDAtXFxcXHUyN2JmJyxcbiAgICByc0xvd2VyUmFuZ2UgPSAnYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmJyxcbiAgICByc01hdGhPcFJhbmdlID0gJ1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjcnLFxuICAgIHJzTm9uQ2hhclJhbmdlID0gJ1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZicsXG4gICAgcnNQdW5jdHVhdGlvblJhbmdlID0gJ1xcXFx1MjAwMC1cXFxcdTIwNmYnLFxuICAgIHJzU3BhY2VSYW5nZSA9ICcgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMCcsXG4gICAgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZScsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLFxuICAgIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc0JyZWFrID0gJ1snICsgcnNCcmVha1JhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UgKyAnXScsXG4gICAgcnNEaWdpdHMgPSAnXFxcXGQrJyxcbiAgICByc0RpbmdiYXQgPSAnWycgKyByc0RpbmdiYXRSYW5nZSArICddJyxcbiAgICByc0xvd2VyID0gJ1snICsgcnNMb3dlclJhbmdlICsgJ10nLFxuICAgIHJzTWlzYyA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgcnNCcmVha1JhbmdlICsgcnNEaWdpdHMgKyByc0RpbmdiYXRSYW5nZSArIHJzTG93ZXJSYW5nZSArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNVcHBlciA9ICdbJyArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByc0xvd2VyTWlzYyA9ICcoPzonICsgcnNMb3dlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICByc1VwcGVyTWlzYyA9ICcoPzonICsgcnNVcHBlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICByc09wdExvd2VyQ29udHIgPSAnKD86JyArIHJzQXBvcyArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICByc09wdFVwcGVyQ29udHIgPSAnKD86JyArIHJzQXBvcyArICcoPzpEfExMfE18UkV8U3xUfFZFKSk/JyxcbiAgICByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICByc0Vtb2ppID0gJyg/OicgKyBbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc1NlcSxcbiAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYXBvc3Ryb3BoZXMuICovXG52YXIgcmVBcG9zID0gUmVnRXhwKHJzQXBvcywgJ2cnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXG4gKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxuICovXG52YXIgcmVDb21ib01hcmsgPSBSZWdFeHAocnNDb21ibywgJ2cnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbnZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggY29tcGxleCBvciBjb21wb3VuZCB3b3Jkcy4gKi9cbnZhciByZVVuaWNvZGVXb3JkID0gUmVnRXhwKFtcbiAgcnNVcHBlciArICc/JyArIHJzTG93ZXIgKyAnKycgKyByc09wdExvd2VyQ29udHIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgcnNVcHBlck1pc2MgKyAnKycgKyByc09wdFVwcGVyQ29udHIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyICsgcnNMb3dlck1pc2MsICckJ10uam9pbignfCcpICsgJyknLFxuICByc1VwcGVyICsgJz8nICsgcnNMb3dlck1pc2MgKyAnKycgKyByc09wdExvd2VyQ29udHIsXG4gIHJzVXBwZXIgKyAnKycgKyByc09wdFVwcGVyQ29udHIsXG4gIHJzRGlnaXRzLFxuICByc0Vtb2ppXG5dLmpvaW4oJ3wnKSwgJ2cnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG52YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3MgdGhhdCBuZWVkIGEgbW9yZSByb2J1c3QgcmVnZXhwIHRvIG1hdGNoIHdvcmRzLiAqL1xudmFyIHJlSGFzVW5pY29kZVdvcmQgPSAvW2Etel1bQS1aXXxbQS1aXXsyLH1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87XG5cbi8qKiBVc2VkIHRvIG1hcCBMYXRpbiBVbmljb2RlIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy4gKi9cbnZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgJ1xceGNjJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgJ1xceGVjJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAnXFx4ZGYnOiAnc3MnLFxuICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAnXFx1MDEwMCc6ICdBJywgICdcXHUwMTAyJzogJ0EnLCAnXFx1MDEwNCc6ICdBJyxcbiAgJ1xcdTAxMDEnOiAnYScsICAnXFx1MDEwMyc6ICdhJywgJ1xcdTAxMDUnOiAnYScsXG4gICdcXHUwMTA2JzogJ0MnLCAgJ1xcdTAxMDgnOiAnQycsICdcXHUwMTBhJzogJ0MnLCAnXFx1MDEwYyc6ICdDJyxcbiAgJ1xcdTAxMDcnOiAnYycsICAnXFx1MDEwOSc6ICdjJywgJ1xcdTAxMGInOiAnYycsICdcXHUwMTBkJzogJ2MnLFxuICAnXFx1MDEwZSc6ICdEJywgICdcXHUwMTEwJzogJ0QnLCAnXFx1MDEwZic6ICdkJywgJ1xcdTAxMTEnOiAnZCcsXG4gICdcXHUwMTEyJzogJ0UnLCAgJ1xcdTAxMTQnOiAnRScsICdcXHUwMTE2JzogJ0UnLCAnXFx1MDExOCc6ICdFJywgJ1xcdTAxMWEnOiAnRScsXG4gICdcXHUwMTEzJzogJ2UnLCAgJ1xcdTAxMTUnOiAnZScsICdcXHUwMTE3JzogJ2UnLCAnXFx1MDExOSc6ICdlJywgJ1xcdTAxMWInOiAnZScsXG4gICdcXHUwMTFjJzogJ0cnLCAgJ1xcdTAxMWUnOiAnRycsICdcXHUwMTIwJzogJ0cnLCAnXFx1MDEyMic6ICdHJyxcbiAgJ1xcdTAxMWQnOiAnZycsICAnXFx1MDExZic6ICdnJywgJ1xcdTAxMjEnOiAnZycsICdcXHUwMTIzJzogJ2cnLFxuICAnXFx1MDEyNCc6ICdIJywgICdcXHUwMTI2JzogJ0gnLCAnXFx1MDEyNSc6ICdoJywgJ1xcdTAxMjcnOiAnaCcsXG4gICdcXHUwMTI4JzogJ0knLCAgJ1xcdTAxMmEnOiAnSScsICdcXHUwMTJjJzogJ0knLCAnXFx1MDEyZSc6ICdJJywgJ1xcdTAxMzAnOiAnSScsXG4gICdcXHUwMTI5JzogJ2knLCAgJ1xcdTAxMmInOiAnaScsICdcXHUwMTJkJzogJ2knLCAnXFx1MDEyZic6ICdpJywgJ1xcdTAxMzEnOiAnaScsXG4gICdcXHUwMTM0JzogJ0onLCAgJ1xcdTAxMzUnOiAnaicsXG4gICdcXHUwMTM2JzogJ0snLCAgJ1xcdTAxMzcnOiAnaycsICdcXHUwMTM4JzogJ2snLFxuICAnXFx1MDEzOSc6ICdMJywgICdcXHUwMTNiJzogJ0wnLCAnXFx1MDEzZCc6ICdMJywgJ1xcdTAxM2YnOiAnTCcsICdcXHUwMTQxJzogJ0wnLFxuICAnXFx1MDEzYSc6ICdsJywgICdcXHUwMTNjJzogJ2wnLCAnXFx1MDEzZSc6ICdsJywgJ1xcdTAxNDAnOiAnbCcsICdcXHUwMTQyJzogJ2wnLFxuICAnXFx1MDE0Myc6ICdOJywgICdcXHUwMTQ1JzogJ04nLCAnXFx1MDE0Nyc6ICdOJywgJ1xcdTAxNGEnOiAnTicsXG4gICdcXHUwMTQ0JzogJ24nLCAgJ1xcdTAxNDYnOiAnbicsICdcXHUwMTQ4JzogJ24nLCAnXFx1MDE0Yic6ICduJyxcbiAgJ1xcdTAxNGMnOiAnTycsICAnXFx1MDE0ZSc6ICdPJywgJ1xcdTAxNTAnOiAnTycsXG4gICdcXHUwMTRkJzogJ28nLCAgJ1xcdTAxNGYnOiAnbycsICdcXHUwMTUxJzogJ28nLFxuICAnXFx1MDE1NCc6ICdSJywgICdcXHUwMTU2JzogJ1InLCAnXFx1MDE1OCc6ICdSJyxcbiAgJ1xcdTAxNTUnOiAncicsICAnXFx1MDE1Nyc6ICdyJywgJ1xcdTAxNTknOiAncicsXG4gICdcXHUwMTVhJzogJ1MnLCAgJ1xcdTAxNWMnOiAnUycsICdcXHUwMTVlJzogJ1MnLCAnXFx1MDE2MCc6ICdTJyxcbiAgJ1xcdTAxNWInOiAncycsICAnXFx1MDE1ZCc6ICdzJywgJ1xcdTAxNWYnOiAncycsICdcXHUwMTYxJzogJ3MnLFxuICAnXFx1MDE2Mic6ICdUJywgICdcXHUwMTY0JzogJ1QnLCAnXFx1MDE2Nic6ICdUJyxcbiAgJ1xcdTAxNjMnOiAndCcsICAnXFx1MDE2NSc6ICd0JywgJ1xcdTAxNjcnOiAndCcsXG4gICdcXHUwMTY4JzogJ1UnLCAgJ1xcdTAxNmEnOiAnVScsICdcXHUwMTZjJzogJ1UnLCAnXFx1MDE2ZSc6ICdVJywgJ1xcdTAxNzAnOiAnVScsICdcXHUwMTcyJzogJ1UnLFxuICAnXFx1MDE2OSc6ICd1JywgICdcXHUwMTZiJzogJ3UnLCAnXFx1MDE2ZCc6ICd1JywgJ1xcdTAxNmYnOiAndScsICdcXHUwMTcxJzogJ3UnLCAnXFx1MDE3Myc6ICd1JyxcbiAgJ1xcdTAxNzQnOiAnVycsICAnXFx1MDE3NSc6ICd3JyxcbiAgJ1xcdTAxNzYnOiAnWScsICAnXFx1MDE3Nyc6ICd5JywgJ1xcdTAxNzgnOiAnWScsXG4gICdcXHUwMTc5JzogJ1onLCAgJ1xcdTAxN2InOiAnWicsICdcXHUwMTdkJzogJ1onLFxuICAnXFx1MDE3YSc6ICd6JywgICdcXHUwMTdjJzogJ3onLCAnXFx1MDE3ZSc6ICd6JyxcbiAgJ1xcdTAxMzInOiAnSUonLCAnXFx1MDEzMyc6ICdpaicsXG4gICdcXHUwMTUyJzogJ09lJywgJ1xcdTAxNTMnOiAnb2UnLFxuICAnXFx1MDE0OSc6IFwiJ25cIiwgJ1xcdTAxN2YnOiAnc3MnXG59O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgY29tbW9uanNHbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCQyID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xufVxuXG4vKipcbiAqIFNwbGl0cyBhbiBBU0NJSSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIGFzY2lpV29yZHMoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVBc2NpaVdvcmQpIHx8IFtdO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXG4gKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cbiAqL1xudmFyIGRlYnVyckxldHRlciA9IGJhc2VQcm9wZXJ0eU9mKGRlYnVycmVkTGV0dGVycyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHtcbiAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgd29yZCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlV29yZChzdHJpbmcpIHtcbiAgcmV0dXJuIHJlSGFzVW5pY29kZVdvcmQudGVzdChzdHJpbmcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpXG4gICAgOiBhc2NpaVRvQXJyYXkoc3RyaW5nKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG59XG5cbi8qKlxuICogU3BsaXRzIGEgVW5pY29kZSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVXb3JkcyhzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3JkKSB8fCBbXTtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCQxID0gcm9vdCQyLlN5bWJvbDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wkMSA/IFN5bWJvbCQxLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gKi9cbmZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcbiAgcmV0dXJuICghc3RhcnQgJiYgZW5kID49IGxlbmd0aCkgPyBhcnJheSA6IGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ubG93ZXJGaXJzdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgU3RyaW5nYCBjYXNlIG1ldGhvZCB0byB1c2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgIHZhciBzdHJTeW1ib2xzID0gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY2hyID0gc3RyU3ltYm9sc1xuICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICA6IHN0cmluZy5jaGFyQXQoMCk7XG5cbiAgICB2YXIgdHJhaWxpbmcgPSBzdHJTeW1ib2xzXG4gICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxuICAgICAgOiBzdHJpbmcuc2xpY2UoMSk7XG5cbiAgICByZXR1cm4gY2hyW21ldGhvZE5hbWVdKCkgKyB0cmFpbGluZztcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5jYW1lbENhc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3VuZGVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gYXJyYXlSZWR1Y2Uod29yZHMoZGVidXJyKHN0cmluZykucmVwbGFjZShyZUFwb3MsICcnKSksIGNhbGxiYWNrLCAnJyk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbY2FtZWwgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FtZWxDYXNlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FtZWwgY2FzZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmNhbWVsQ2FzZSgnRm9vIEJhcicpO1xuICogLy8gPT4gJ2Zvb0JhcidcbiAqXG4gKiBfLmNhbWVsQ2FzZSgnLS1mb28tYmFyLS0nKTtcbiAqIC8vID0+ICdmb29CYXInXG4gKlxuICogXy5jYW1lbENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gKiAvLyA9PiAnZm9vQmFyJ1xuICovXG52YXIgY2FtZWxDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyBjYXBpdGFsaXplKHdvcmQpIDogd29yZCk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UgYW5kIHRoZSByZW1haW5pbmdcbiAqIHRvIGxvd2VyIGNhc2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5jYXBpdGFsaXplKCdGUkVEJyk7XG4gKiAvLyA9PiAnRnJlZCdcbiAqL1xuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbn1cblxuLyoqXG4gKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmdcbiAqIFtMYXRpbi0xIFN1cHBsZW1lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICogYW5kIFtMYXRpbiBFeHRlbmRlZC1BXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9FeHRlbmRlZC1BKVxuICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZ1xuICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcbiAqIC8vID0+ICdkZWphIHZ1J1xuICovXG5mdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbiwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVwcGVyRmlyc3QoJ2ZyZWQnKTtcbiAqIC8vID0+ICdGcmVkJ1xuICpcbiAqIF8udXBwZXJGaXJzdCgnRlJFRCcpO1xuICogLy8gPT4gJ0ZSRUQnXG4gKi9cbnZhciB1cHBlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG4vKipcbiAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gKlxuICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICovXG5mdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHBhdHRlcm4gPSBwYXR0ZXJuO1xuXG4gIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSA/IHVuaWNvZGVXb3JkcyhzdHJpbmcpIDogYXNjaWlXb3JkcyhzdHJpbmcpO1xuICB9XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG59XG5cbnZhciBsb2Rhc2hfY2FtZWxjYXNlID0gY2FtZWxDYXNlO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobG9jYWxzQ29udmVudGlvbiwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xubG9jYWxzQ29udmVudGlvbi5tYWtlTG9jYWxzQ29udmVudGlvblJlZHVjZXIgPSBtYWtlTG9jYWxzQ29udmVudGlvblJlZHVjZXI7XG5cbnZhciBfbG9kYXNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQ1KGxvZGFzaF9jYW1lbGNhc2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0JDUob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGRhc2hlc0NhbWVsQ2FzZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8tKyhcXHcpL2csIChfLCBmaXJzdExldHRlcikgPT4gZmlyc3RMZXR0ZXIudG9VcHBlckNhc2UoKSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VMb2NhbHNDb252ZW50aW9uUmVkdWNlcihsb2NhbHNDb252ZW50aW9uLCBpbnB1dEZpbGUpIHtcbiAgY29uc3QgaXNGdW5jID0gdHlwZW9mIGxvY2Fsc0NvbnZlbnRpb24gPT09IFwiZnVuY3Rpb25cIjtcbiAgcmV0dXJuICh0b2tlbnMsIFtjbGFzc05hbWUsIHZhbHVlXSkgPT4ge1xuICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgIGNvbnN0IGNvbnZlbnRpb24gPSBsb2NhbHNDb252ZW50aW9uKGNsYXNzTmFtZSwgdmFsdWUsIGlucHV0RmlsZSk7XG4gICAgICB0b2tlbnNbY29udmVudGlvbl0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuXG4gICAgc3dpdGNoIChsb2NhbHNDb252ZW50aW9uKSB7XG4gICAgICBjYXNlIFwiY2FtZWxDYXNlXCI6XG4gICAgICAgIHRva2Vuc1tjbGFzc05hbWVdID0gdmFsdWU7XG4gICAgICAgIHRva2Vuc1soMCwgX2xvZGFzaC5kZWZhdWx0KShjbGFzc05hbWUpXSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImNhbWVsQ2FzZU9ubHlcIjpcbiAgICAgICAgdG9rZW5zWygwLCBfbG9kYXNoLmRlZmF1bHQpKGNsYXNzTmFtZSldID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiZGFzaGVzXCI6XG4gICAgICAgIHRva2Vuc1tjbGFzc05hbWVdID0gdmFsdWU7XG4gICAgICAgIHRva2Vuc1tkYXNoZXNDYW1lbENhc2UoY2xhc3NOYW1lKV0gPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJkYXNoZXNPbmx5XCI6XG4gICAgICAgIHRva2Vuc1tkYXNoZXNDYW1lbENhc2UoY2xhc3NOYW1lKV0gPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRva2VucztcbiAgfTtcbn1cblxudmFyIEZpbGVTeXN0ZW1Mb2FkZXIkMSA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRmlsZVN5c3RlbUxvYWRlciQxLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5GaWxlU3lzdGVtTG9hZGVyJDEuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9wb3N0Y3NzJDEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0JDQocmVxdWlyZSQkMCk7XG5cbnZhciBfcGF0aCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkNChyZXF1aXJlJCQwJDEpO1xuXG52YXIgX1BhcnNlciQxID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQ0KFBhcnNlciQxKTtcblxudmFyIF9mcyQxID0gZnM7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkNChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gSW5pdGlhbGx5IGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jc3MtbW9kdWxlcy9jc3MtbW9kdWxlcy1sb2FkZXItY29yZVxuY2xhc3MgQ29yZSB7XG4gIGNvbnN0cnVjdG9yKHBsdWdpbnMpIHtcbiAgICB0aGlzLnBsdWdpbnMgPSBwbHVnaW5zIHx8IENvcmUuZGVmYXVsdFBsdWdpbnM7XG4gIH1cblxuICBhc3luYyBsb2FkKHNvdXJjZVN0cmluZywgc291cmNlUGF0aCwgdHJhY2UsIHBhdGhGZXRjaGVyKSB7XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IF9QYXJzZXIkMS5kZWZhdWx0KHBhdGhGZXRjaGVyLCB0cmFjZSk7XG4gICAgY29uc3QgcGx1Z2lucyA9IHRoaXMucGx1Z2lucy5jb25jYXQoW3BhcnNlci5wbHVnaW4oKV0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0ICgwLCBfcG9zdGNzcyQxLmRlZmF1bHQpKHBsdWdpbnMpLnByb2Nlc3Moc291cmNlU3RyaW5nLCB7XG4gICAgICBmcm9tOiBzb3VyY2VQYXRoXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluamVjdGFibGVTb3VyY2U6IHJlc3VsdC5jc3MsXG4gICAgICBleHBvcnRUb2tlbnM6IHBhcnNlci5leHBvcnRUb2tlbnNcbiAgICB9O1xuICB9XG5cbn0gLy8gU29ydHMgZGVwZW5kZW5jaWVzIGluIHRoZSBmb2xsb3dpbmcgd2F5OlxuLy8gQUFBIGNvbWVzIGJlZm9yZSBBQSBhbmQgQVxuLy8gQUIgY29tZXMgYWZ0ZXIgQUEgYW5kIGJlZm9yZSBBXG4vLyBBbGwgQnMgY29tZSBhZnRlciBhbGwgQXNcbi8vIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBmaWxlcyBhcmUgYWx3YXlzIHJldHVybmVkIGluIHRoZSBmb2xsb3dpbmcgb3JkZXI6XG4vLyAtIEluIHRoZSBvcmRlciB0aGV5IHdlcmUgcmVxdWlyZWQsIGV4Y2VwdFxuLy8gLSBBZnRlciBhbGwgdGhlaXIgZGVwZW5kZW5jaWVzXG5cblxuY29uc3QgdHJhY2VLZXlTb3J0ZXIgPSAoYSwgYikgPT4ge1xuICBpZiAoYS5sZW5ndGggPCBiLmxlbmd0aCkge1xuICAgIHJldHVybiBhIDwgYi5zdWJzdHJpbmcoMCwgYS5sZW5ndGgpID8gLTEgOiAxO1xuICB9XG5cbiAgaWYgKGEubGVuZ3RoID4gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYS5zdWJzdHJpbmcoMCwgYi5sZW5ndGgpIDw9IGIgPyAtMSA6IDE7XG4gIH1cblxuICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XG59O1xuXG5jbGFzcyBGaWxlU3lzdGVtTG9hZGVyIHtcbiAgY29uc3RydWN0b3Iocm9vdCwgcGx1Z2lucywgZmlsZVJlc29sdmUpIHtcbiAgICBpZiAocm9vdCA9PT0gXCIvXCIgJiYgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG4gICAgICBjb25zdCBjd2REcml2ZSA9IHByb2Nlc3MuY3dkKCkuc2xpY2UoMCwgMyk7XG5cbiAgICAgIGlmICghL15bQS1aYS16XTpcXFxcJC8udGVzdChjd2REcml2ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gb2J0YWluIHJvb3QgZnJvbSBcIiR7cHJvY2Vzcy5jd2QoKX1cIi5gKTtcbiAgICAgIH1cblxuICAgICAgcm9vdCA9IGN3ZERyaXZlO1xuICAgIH1cblxuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgdGhpcy5maWxlUmVzb2x2ZSA9IGZpbGVSZXNvbHZlO1xuICAgIHRoaXMuc291cmNlcyA9IHt9O1xuICAgIHRoaXMudHJhY2VzID0ge307XG4gICAgdGhpcy5pbXBvcnROciA9IDA7XG4gICAgdGhpcy5jb3JlID0gbmV3IENvcmUocGx1Z2lucyk7XG4gICAgdGhpcy50b2tlbnNCeUZpbGUgPSB7fTtcbiAgICB0aGlzLmZzID0gKDAsIF9mcyQxLmdldEZpbGVTeXN0ZW0pKCk7XG4gIH1cblxuICBhc3luYyBmZXRjaChfbmV3UGF0aCwgcmVsYXRpdmVUbywgX3RyYWNlKSB7XG4gICAgY29uc3QgbmV3UGF0aCA9IF9uZXdQYXRoLnJlcGxhY2UoL15bXCInXXxbXCInXSQvZywgXCJcIik7XG5cbiAgICBjb25zdCB0cmFjZSA9IF90cmFjZSB8fCBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuaW1wb3J0TnIrKyk7XG5cbiAgICBjb25zdCB1c2VGaWxlUmVzb2x2ZSA9IHR5cGVvZiB0aGlzLmZpbGVSZXNvbHZlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgY29uc3QgZmlsZVJlc29sdmVkUGF0aCA9IHVzZUZpbGVSZXNvbHZlID8gYXdhaXQgdGhpcy5maWxlUmVzb2x2ZShuZXdQYXRoLCByZWxhdGl2ZVRvKSA6IGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgaWYgKGZpbGVSZXNvbHZlZFBhdGggJiYgIV9wYXRoLmRlZmF1bHQuaXNBYnNvbHV0ZShmaWxlUmVzb2x2ZWRQYXRoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmV0dXJuZWQgcGF0aCBmcm9tIHRoZSBcImZpbGVSZXNvbHZlXCIgb3B0aW9uIG11c3QgYmUgYWJzb2x1dGUuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVsYXRpdmVEaXIgPSBfcGF0aC5kZWZhdWx0LmRpcm5hbWUocmVsYXRpdmVUbyk7XG5cbiAgICBjb25zdCByb290UmVsYXRpdmVQYXRoID0gZmlsZVJlc29sdmVkUGF0aCB8fCBfcGF0aC5kZWZhdWx0LnJlc29sdmUocmVsYXRpdmVEaXIsIG5ld1BhdGgpO1xuXG4gICAgbGV0IGZpbGVSZWxhdGl2ZVBhdGggPSBmaWxlUmVzb2x2ZWRQYXRoIHx8IF9wYXRoLmRlZmF1bHQucmVzb2x2ZShfcGF0aC5kZWZhdWx0LnJlc29sdmUodGhpcy5yb290LCByZWxhdGl2ZURpciksIG5ld1BhdGgpOyAvLyBpZiB0aGUgcGF0aCBpcyBub3QgcmVsYXRpdmUgb3IgYWJzb2x1dGUsIHRyeSB0byByZXNvbHZlIGl0IGluIG5vZGVfbW9kdWxlc1xuXG5cbiAgICBpZiAoIXVzZUZpbGVSZXNvbHZlICYmIG5ld1BhdGhbMF0gIT09IFwiLlwiICYmICFfcGF0aC5kZWZhdWx0LmlzQWJzb2x1dGUobmV3UGF0aCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbGVSZWxhdGl2ZVBhdGggPSByZXF1aXJlLnJlc29sdmUobmV3UGF0aCk7XG4gICAgICB9IGNhdGNoIChlKSB7Ly8gbm9vcFxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRva2VucyA9IHRoaXMudG9rZW5zQnlGaWxlW2ZpbGVSZWxhdGl2ZVBhdGhdO1xuICAgIGlmICh0b2tlbnMpIHJldHVybiB0b2tlbnM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuZnMucmVhZEZpbGUoZmlsZVJlbGF0aXZlUGF0aCwgXCJ1dGYtOFwiLCBhc3luYyAoZXJyLCBzb3VyY2UpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmVqZWN0KGVycik7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpbmplY3RhYmxlU291cmNlLFxuICAgICAgICAgIGV4cG9ydFRva2Vuc1xuICAgICAgICB9ID0gYXdhaXQgdGhpcy5jb3JlLmxvYWQoc291cmNlLCByb290UmVsYXRpdmVQYXRoLCB0cmFjZSwgdGhpcy5mZXRjaC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zb3VyY2VzW2ZpbGVSZWxhdGl2ZVBhdGhdID0gaW5qZWN0YWJsZVNvdXJjZTtcbiAgICAgICAgdGhpcy50cmFjZXNbdHJhY2VdID0gZmlsZVJlbGF0aXZlUGF0aDtcbiAgICAgICAgdGhpcy50b2tlbnNCeUZpbGVbZmlsZVJlbGF0aXZlUGF0aF0gPSBleHBvcnRUb2tlbnM7XG4gICAgICAgIHJlc29sdmUoZXhwb3J0VG9rZW5zKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IGZpbmFsU291cmNlKCkge1xuICAgIGNvbnN0IHRyYWNlcyA9IHRoaXMudHJhY2VzO1xuICAgIGNvbnN0IHNvdXJjZXMgPSB0aGlzLnNvdXJjZXM7XG4gICAgbGV0IHdyaXR0ZW4gPSBuZXcgU2V0KCk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRyYWNlcykuc29ydCh0cmFjZUtleVNvcnRlcikubWFwKGtleSA9PiB7XG4gICAgICBjb25zdCBmaWxlbmFtZSA9IHRyYWNlc1trZXldO1xuXG4gICAgICBpZiAod3JpdHRlbi5oYXMoZmlsZW5hbWUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB3cml0dGVuLmFkZChmaWxlbmFtZSk7XG4gICAgICByZXR1cm4gc291cmNlc1tmaWxlbmFtZV07XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfVxuXG59XG5cbkZpbGVTeXN0ZW1Mb2FkZXIkMS5kZWZhdWx0ID0gRmlsZVN5c3RlbUxvYWRlcjtcblxudmFyIHNjb3BpbmcgPSB7fTtcblxudmFyIHNyYyQzID0ge2V4cG9ydHM6IHt9fTtcblxuY29uc3QgUEVSTUFORU5UX01BUktFUiA9IDI7XG5jb25zdCBURU1QT1JBUllfTUFSS0VSID0gMTtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3Iobm9kZSwgZ3JhcGgpIHtcbiAgY29uc3QgZXIgPSBuZXcgRXJyb3IoXCJOb25kZXRlcm1pbmlzdGljIGltcG9ydCdzIG9yZGVyXCIpO1xuXG4gIGNvbnN0IHJlbGF0ZWQgPSBncmFwaFtub2RlXTtcbiAgY29uc3QgcmVsYXRlZE5vZGUgPSByZWxhdGVkLmZpbmQoXG4gICAgKHJlbGF0ZWROb2RlKSA9PiBncmFwaFtyZWxhdGVkTm9kZV0uaW5kZXhPZihub2RlKSA+IC0xXG4gICk7XG5cbiAgZXIubm9kZXMgPSBbbm9kZSwgcmVsYXRlZE5vZGVdO1xuXG4gIHJldHVybiBlcjtcbn1cblxuZnVuY3Rpb24gd2Fsa0dyYXBoKG5vZGUsIGdyYXBoLCBzdGF0ZSwgcmVzdWx0LCBzdHJpY3QpIHtcbiAgaWYgKHN0YXRlW25vZGVdID09PSBQRVJNQU5FTlRfTUFSS0VSKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0YXRlW25vZGVdID09PSBURU1QT1JBUllfTUFSS0VSKSB7XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVycm9yKG5vZGUsIGdyYXBoKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZVtub2RlXSA9IFRFTVBPUkFSWV9NQVJLRVI7XG5cbiAgY29uc3QgY2hpbGRyZW4gPSBncmFwaFtub2RlXTtcbiAgY29uc3QgbGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBlcnJvciA9IHdhbGtHcmFwaChjaGlsZHJlbltpXSwgZ3JhcGgsIHN0YXRlLCByZXN1bHQsIHN0cmljdCk7XG5cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlW25vZGVdID0gUEVSTUFORU5UX01BUktFUjtcblxuICByZXN1bHQucHVzaChub2RlKTtcbn1cblxuZnVuY3Rpb24gdG9wb2xvZ2ljYWxTb3J0JDEoZ3JhcGgsIHN0cmljdCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc3RhdGUgPSB7fTtcblxuICBjb25zdCBub2RlcyA9IE9iamVjdC5rZXlzKGdyYXBoKTtcbiAgY29uc3QgbGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBlciA9IHdhbGtHcmFwaChub2Rlc1tpXSwgZ3JhcGgsIHN0YXRlLCByZXN1bHQsIHN0cmljdCk7XG5cbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIGVyO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciB0b3BvbG9naWNhbFNvcnRfMSA9IHRvcG9sb2dpY2FsU29ydCQxO1xuXG5jb25zdCB0b3BvbG9naWNhbFNvcnQgPSB0b3BvbG9naWNhbFNvcnRfMTtcblxuY29uc3QgbWF0Y2hJbXBvcnRzJDEgPSAvXiguKz8pXFxzK2Zyb21cXHMrKD86XCIoW15cIl0rKVwifCcoW14nXSspJ3woZ2xvYmFsKSkkLztcbmNvbnN0IGljc3NJbXBvcnQgPSAvXjppbXBvcnRcXCgoPzpcIihbXlwiXSspXCJ8JyhbXiddKyknKVxcKS87XG5cbmNvbnN0IFZJU0lURURfTUFSS0VSID0gMTtcblxuLyoqXG4gKiA6aW1wb3J0KCdHJykge31cbiAqXG4gKiBSdWxlXG4gKiAgIGNvbXBvc2VzOiAuLi4gZnJvbSAnQSdcbiAqICAgY29tcG9zZXM6IC4uLiBmcm9tICdCJ1xuXG4gKiBSdWxlXG4gKiAgIGNvbXBvc2VzOiAuLi4gZnJvbSAnQSdcbiAqICAgY29tcG9zZXM6IC4uLiBmcm9tICdBJ1xuICogICBjb21wb3NlczogLi4uIGZyb20gJ0MnXG4gKlxuICogUmVzdWx0cyBpbjpcbiAqXG4gKiBncmFwaDoge1xuICogICBHOiBbXSxcbiAqICAgQTogW10sXG4gKiAgIEI6IFsnQSddLFxuICogICBDOiBbJ0EnXSxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYWRkSW1wb3J0VG9HcmFwaChpbXBvcnRJZCwgcGFyZW50SWQsIGdyYXBoLCB2aXNpdGVkKSB7XG4gIGNvbnN0IHNpYmxpbmdzSWQgPSBwYXJlbnRJZCArIFwiX1wiICsgXCJzaWJsaW5nc1wiO1xuICBjb25zdCB2aXNpdGVkSWQgPSBwYXJlbnRJZCArIFwiX1wiICsgaW1wb3J0SWQ7XG5cbiAgaWYgKHZpc2l0ZWRbdmlzaXRlZElkXSAhPT0gVklTSVRFRF9NQVJLRVIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmlzaXRlZFtzaWJsaW5nc0lkXSkpIHtcbiAgICAgIHZpc2l0ZWRbc2libGluZ3NJZF0gPSBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBzaWJsaW5ncyA9IHZpc2l0ZWRbc2libGluZ3NJZF07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShncmFwaFtpbXBvcnRJZF0pKSB7XG4gICAgICBncmFwaFtpbXBvcnRJZF0gPSBncmFwaFtpbXBvcnRJZF0uY29uY2F0KHNpYmxpbmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JhcGhbaW1wb3J0SWRdID0gc2libGluZ3Muc2xpY2UoKTtcbiAgICB9XG5cbiAgICB2aXNpdGVkW3Zpc2l0ZWRJZF0gPSBWSVNJVEVEX01BUktFUjtcblxuICAgIHNpYmxpbmdzLnB1c2goaW1wb3J0SWQpO1xuICB9XG59XG5cbnNyYyQzLmV4cG9ydHMgPSAob3B0aW9ucyA9IHt9KSA9PiB7XG4gIGxldCBpbXBvcnRJbmRleCA9IDA7XG4gIGNvbnN0IGNyZWF0ZUltcG9ydGVkTmFtZSA9XG4gICAgdHlwZW9mIG9wdGlvbnMuY3JlYXRlSW1wb3J0ZWROYW1lICE9PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGltcG9ydE5hbWUgLyosIHBhdGgqLykgPT5cbiAgICAgICAgICBgaV9faW1wb3J0ZWRfJHtpbXBvcnROYW1lLnJlcGxhY2UoL1xcVy9nLCBcIl9cIil9XyR7aW1wb3J0SW5kZXgrK31gXG4gICAgICA6IG9wdGlvbnMuY3JlYXRlSW1wb3J0ZWROYW1lO1xuICBjb25zdCBmYWlsT25Xcm9uZ09yZGVyID0gb3B0aW9ucy5mYWlsT25Xcm9uZ09yZGVyO1xuXG4gIHJldHVybiB7XG4gICAgcG9zdGNzc1BsdWdpbjogXCJwb3N0Y3NzLW1vZHVsZXMtZXh0cmFjdC1pbXBvcnRzXCIsXG4gICAgcHJlcGFyZSgpIHtcbiAgICAgIGNvbnN0IGdyYXBoID0ge307XG4gICAgICBjb25zdCB2aXNpdGVkID0ge307XG4gICAgICBjb25zdCBleGlzdGluZ0ltcG9ydHMgPSB7fTtcbiAgICAgIGNvbnN0IGltcG9ydERlY2xzID0ge307XG4gICAgICBjb25zdCBpbXBvcnRzID0ge307XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIE9uY2Uocm9vdCwgcG9zdGNzcykge1xuICAgICAgICAgIC8vIENoZWNrIHRoZSBleGlzdGluZyBpbXBvcnRzIG9yZGVyIGFuZCBzYXZlIHJlZnNcbiAgICAgICAgICByb290LndhbGtSdWxlcygocnVsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGljc3NJbXBvcnQuZXhlYyhydWxlLnNlbGVjdG9yKTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgWywgLyptYXRjaCovIGRvdWJsZVF1b3RlUGF0aCwgc2luZ2xlUXVvdGVQYXRoXSA9IG1hdGNoZXM7XG4gICAgICAgICAgICAgIGNvbnN0IGltcG9ydFBhdGggPSBkb3VibGVRdW90ZVBhdGggfHwgc2luZ2xlUXVvdGVQYXRoO1xuXG4gICAgICAgICAgICAgIGFkZEltcG9ydFRvR3JhcGgoaW1wb3J0UGF0aCwgXCJyb290XCIsIGdyYXBoLCB2aXNpdGVkKTtcblxuICAgICAgICAgICAgICBleGlzdGluZ0ltcG9ydHNbaW1wb3J0UGF0aF0gPSBydWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcm9vdC53YWxrRGVjbHMoL15jb21wb3NlcyQvLCAoZGVjbGFyYXRpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG11bHRpcGxlID0gZGVjbGFyYXRpb24udmFsdWUuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG5cbiAgICAgICAgICAgIG11bHRpcGxlLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZS50cmltKCkubWF0Y2gobWF0Y2hJbXBvcnRzJDEpO1xuXG4gICAgICAgICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxldCB0bXBTeW1ib2xzO1xuICAgICAgICAgICAgICBsZXQgW1xuICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAvKm1hdGNoKi8gc3ltYm9scyxcbiAgICAgICAgICAgICAgICBkb3VibGVRdW90ZVBhdGgsXG4gICAgICAgICAgICAgICAgc2luZ2xlUXVvdGVQYXRoLFxuICAgICAgICAgICAgICAgIGdsb2JhbCxcbiAgICAgICAgICAgICAgXSA9IG1hdGNoZXM7XG5cbiAgICAgICAgICAgICAgaWYgKGdsb2JhbCkge1xuICAgICAgICAgICAgICAgIC8vIENvbXBvc2luZyBnbG9iYWxzIHNpbXBseSBtZWFucyBjaGFuZ2luZyB0aGVzZSBjbGFzc2VzIHRvIHdyYXAgdGhlbSBpbiBnbG9iYWwobmFtZSlcbiAgICAgICAgICAgICAgICB0bXBTeW1ib2xzID0gc3ltYm9scy5zcGxpdCgvXFxzKy8pLm1hcCgocykgPT4gYGdsb2JhbCgke3N9KWApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGltcG9ydFBhdGggPSBkb3VibGVRdW90ZVBhdGggfHwgc2luZ2xlUXVvdGVQYXRoO1xuXG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IGRlY2xhcmF0aW9uLnBhcmVudDtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50SW5kZXhlcyA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocGFyZW50LnR5cGUgIT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnRJbmRleGVzID1cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnBhcmVudC5pbmRleChwYXJlbnQpICsgXCJfXCIgKyBwYXJlbnRJbmRleGVzO1xuICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdG9yIH0gPSBkZWNsYXJhdGlvbi5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50UnVsZSA9IGBfJHtwYXJlbnRJbmRleGVzfSR7c2VsZWN0b3J9YDtcblxuICAgICAgICAgICAgICAgIGFkZEltcG9ydFRvR3JhcGgoaW1wb3J0UGF0aCwgcGFyZW50UnVsZSwgZ3JhcGgsIHZpc2l0ZWQpO1xuXG4gICAgICAgICAgICAgICAgaW1wb3J0RGVjbHNbaW1wb3J0UGF0aF0gPSBkZWNsYXJhdGlvbjtcbiAgICAgICAgICAgICAgICBpbXBvcnRzW2ltcG9ydFBhdGhdID0gaW1wb3J0c1tpbXBvcnRQYXRoXSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIHRtcFN5bWJvbHMgPSBzeW1ib2xzLnNwbGl0KC9cXHMrLykubWFwKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWltcG9ydHNbaW1wb3J0UGF0aF1bc10pIHtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0c1tpbXBvcnRQYXRoXVtzXSA9IGNyZWF0ZUltcG9ydGVkTmFtZShzLCBpbXBvcnRQYXRoKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydHNbaW1wb3J0UGF0aF1bc107XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0bXBTeW1ib2xzLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZWNsYXJhdGlvbi52YWx1ZSA9IHZhbHVlcy5qb2luKFwiLCBcIik7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25zdCBpbXBvcnRzT3JkZXIgPSB0b3BvbG9naWNhbFNvcnQoZ3JhcGgsIGZhaWxPbldyb25nT3JkZXIpO1xuXG4gICAgICAgICAgaWYgKGltcG9ydHNPcmRlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBpbXBvcnRQYXRoID0gaW1wb3J0c09yZGVyLm5vZGVzLmZpbmQoKGltcG9ydFBhdGgpID0+XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgICAgICAgaW1wb3J0RGVjbHMuaGFzT3duUHJvcGVydHkoaW1wb3J0UGF0aClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBkZWNsID0gaW1wb3J0RGVjbHNbaW1wb3J0UGF0aF07XG5cbiAgICAgICAgICAgIHRocm93IGRlY2wuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgb3JkZXIgb2YgY29tcG9zZWQgbW9kdWxlcyBcIiArXG4gICAgICAgICAgICAgICAgaW1wb3J0c09yZGVyLm5vZGVzXG4gICAgICAgICAgICAgICAgICAubWFwKChpbXBvcnRQYXRoKSA9PiBcImBcIiArIGltcG9ydFBhdGggKyBcImBcIilcbiAgICAgICAgICAgICAgICAgIC5qb2luKFwiLCBcIikgK1xuICAgICAgICAgICAgICAgIFwiLlwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcGx1Z2luOiBcInBvc3Rjc3MtbW9kdWxlcy1leHRyYWN0LWltcG9ydHNcIixcbiAgICAgICAgICAgICAgICB3b3JkOiBcImNvbXBvc2VzXCIsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGxhc3RJbXBvcnRSdWxlO1xuXG4gICAgICAgICAgaW1wb3J0c09yZGVyLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydGVkU3ltYm9scyA9IGltcG9ydHNbcGF0aF07XG4gICAgICAgICAgICBsZXQgcnVsZSA9IGV4aXN0aW5nSW1wb3J0c1twYXRoXTtcblxuICAgICAgICAgICAgaWYgKCFydWxlICYmIGltcG9ydGVkU3ltYm9scykge1xuICAgICAgICAgICAgICBydWxlID0gcG9zdGNzcy5ydWxlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogYDppbXBvcnQoXCIke3BhdGh9XCIpYCxcbiAgICAgICAgICAgICAgICByYXdzOiB7IGFmdGVyOiBcIlxcblwiIH0sXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmIChsYXN0SW1wb3J0UnVsZSkge1xuICAgICAgICAgICAgICAgIHJvb3QuaW5zZXJ0QWZ0ZXIobGFzdEltcG9ydFJ1bGUsIHJ1bGUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvb3QucHJlcGVuZChydWxlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0SW1wb3J0UnVsZSA9IHJ1bGU7XG5cbiAgICAgICAgICAgIGlmICghaW1wb3J0ZWRTeW1ib2xzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmtleXMoaW1wb3J0ZWRTeW1ib2xzKS5mb3JFYWNoKChpbXBvcnRlZFN5bWJvbCkgPT4ge1xuICAgICAgICAgICAgICBydWxlLmFwcGVuZChcbiAgICAgICAgICAgICAgICBwb3N0Y3NzLmRlY2woe1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IGltcG9ydGVkU3ltYm9sLFxuICAgICAgICAgICAgICAgICAgcHJvcDogaW1wb3J0ZWRTeW1ib2xzW2ltcG9ydGVkU3ltYm9sXSxcbiAgICAgICAgICAgICAgICAgIHJhd3M6IHsgYmVmb3JlOiBcIlxcbiAgXCIgfSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0sXG4gIH07XG59O1xuXG5zcmMkMy5leHBvcnRzLnBvc3Rjc3MgPSB0cnVlO1xuXG52YXIgc3JjRXhwb3J0cyQyID0gc3JjJDMuZXhwb3J0cztcblxudmFyIHdhc21IYXNoID0ge2V4cG9ydHM6IHt9fTtcblxuLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIGhhc1JlcXVpcmVkV2FzbUhhc2g7XG5cbmZ1bmN0aW9uIHJlcXVpcmVXYXNtSGFzaCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFdhc21IYXNoKSByZXR1cm4gd2FzbUhhc2guZXhwb3J0cztcblx0aGFzUmVxdWlyZWRXYXNtSGFzaCA9IDE7XG5cblx0Ly8gNjU1MzYgaXMgdGhlIHNpemUgb2YgYSB3YXNtIG1lbW9yeSBwYWdlXG5cdC8vIDY0IGlzIHRoZSBtYXhpbXVtIGNodW5rIHNpemUgZm9yIGV2ZXJ5IHBvc3NpYmxlIHdhc20gaGFzaCBpbXBsZW1lbnRhdGlvblxuXHQvLyA0IGlzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBieXRlcyBwZXIgY2hhciBmb3Igc3RyaW5nIGVuY29kaW5nIChtYXggaXMgdXRmLTgpXG5cdC8vIH4zIG1ha2VzIHN1cmUgdGhhdCBpdCdzIGFsd2F5cyBhIGJsb2NrIG9mIDQgY2hhcnMsIHNvIGF2b2lkIHBhcnRpYWxseSBlbmNvZGVkIGJ5dGVzIGZvciBiYXNlNjRcblx0Y29uc3QgTUFYX1NIT1JUX1NUUklORyA9IE1hdGguZmxvb3IoKDY1NTM2IC0gNjQpIC8gNCkgJiB+MztcblxuXHRjbGFzcyBXYXNtSGFzaCB7XG5cdCAgLyoqXG5cdCAgICogQHBhcmFtIHtXZWJBc3NlbWJseS5JbnN0YW5jZX0gaW5zdGFuY2Ugd2FzbSBpbnN0YW5jZVxuXHQgICAqIEBwYXJhbSB7V2ViQXNzZW1ibHkuSW5zdGFuY2VbXX0gaW5zdGFuY2VzUG9vbCBwb29sIG9mIGluc3RhbmNlc1xuXHQgICAqIEBwYXJhbSB7bnVtYmVyfSBjaHVua1NpemUgc2l6ZSBvZiBkYXRhIGNodW5rcyBwYXNzZWQgdG8gd2FzbVxuXHQgICAqIEBwYXJhbSB7bnVtYmVyfSBkaWdlc3RTaXplIHNpemUgb2YgZGlnZXN0IHJldHVybmVkIGJ5IHdhc21cblx0ICAgKi9cblx0ICBjb25zdHJ1Y3RvcihpbnN0YW5jZSwgaW5zdGFuY2VzUG9vbCwgY2h1bmtTaXplLCBkaWdlc3RTaXplKSB7XG5cdCAgICBjb25zdCBleHBvcnRzID0gLyoqIEB0eXBlIHthbnl9ICovIChpbnN0YW5jZS5leHBvcnRzKTtcblxuXHQgICAgZXhwb3J0cy5pbml0KCk7XG5cblx0ICAgIHRoaXMuZXhwb3J0cyA9IGV4cG9ydHM7XG5cdCAgICB0aGlzLm1lbSA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMubWVtb3J5LmJ1ZmZlciwgMCwgNjU1MzYpO1xuXHQgICAgdGhpcy5idWZmZXJlZCA9IDA7XG5cdCAgICB0aGlzLmluc3RhbmNlc1Bvb2wgPSBpbnN0YW5jZXNQb29sO1xuXHQgICAgdGhpcy5jaHVua1NpemUgPSBjaHVua1NpemU7XG5cdCAgICB0aGlzLmRpZ2VzdFNpemUgPSBkaWdlc3RTaXplO1xuXHQgIH1cblxuXHQgIHJlc2V0KCkge1xuXHQgICAgdGhpcy5idWZmZXJlZCA9IDA7XG5cdCAgICB0aGlzLmV4cG9ydHMuaW5pdCgpO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIEBwYXJhbSB7QnVmZmVyIHwgc3RyaW5nfSBkYXRhIGRhdGFcblx0ICAgKiBAcGFyYW0ge0J1ZmZlckVuY29kaW5nPX0gZW5jb2RpbmcgZW5jb2Rpbmdcblx0ICAgKiBAcmV0dXJucyB7dGhpc30gaXRzZWxmXG5cdCAgICovXG5cdCAgdXBkYXRlKGRhdGEsIGVuY29kaW5nKSB7XG5cdCAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgd2hpbGUgKGRhdGEubGVuZ3RoID4gTUFYX1NIT1JUX1NUUklORykge1xuXHQgICAgICAgIHRoaXMuX3VwZGF0ZVdpdGhTaG9ydFN0cmluZyhkYXRhLnNsaWNlKDAsIE1BWF9TSE9SVF9TVFJJTkcpLCBlbmNvZGluZyk7XG5cdCAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoTUFYX1NIT1JUX1NUUklORyk7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl91cGRhdGVXaXRoU2hvcnRTdHJpbmcoZGF0YSwgZW5jb2RpbmcpO1xuXG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl91cGRhdGVXaXRoQnVmZmVyKGRhdGEpO1xuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YSBkYXRhXG5cdCAgICogQHBhcmFtIHtCdWZmZXJFbmNvZGluZz19IGVuY29kaW5nIGVuY29kaW5nXG5cdCAgICogQHJldHVybnMge3ZvaWR9XG5cdCAgICovXG5cdCAgX3VwZGF0ZVdpdGhTaG9ydFN0cmluZyhkYXRhLCBlbmNvZGluZykge1xuXHQgICAgY29uc3QgeyBleHBvcnRzLCBidWZmZXJlZCwgbWVtLCBjaHVua1NpemUgfSA9IHRoaXM7XG5cblx0ICAgIGxldCBlbmRQb3M7XG5cblx0ICAgIGlmIChkYXRhLmxlbmd0aCA8IDcwKSB7XG5cdCAgICAgIGlmICghZW5jb2RpbmcgfHwgZW5jb2RpbmcgPT09IFwidXRmLThcIiB8fCBlbmNvZGluZyA9PT0gXCJ1dGY4XCIpIHtcblx0ICAgICAgICBlbmRQb3MgPSBidWZmZXJlZDtcblx0ICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGNvbnN0IGNjID0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuXG5cdCAgICAgICAgICBpZiAoY2MgPCAweDgwKSB7XG5cdCAgICAgICAgICAgIG1lbVtlbmRQb3MrK10gPSBjYztcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoY2MgPCAweDgwMCkge1xuXHQgICAgICAgICAgICBtZW1bZW5kUG9zXSA9IChjYyA+PiA2KSB8IDB4YzA7XG5cdCAgICAgICAgICAgIG1lbVtlbmRQb3MgKyAxXSA9IChjYyAmIDB4M2YpIHwgMHg4MDtcblx0ICAgICAgICAgICAgZW5kUG9zICs9IDI7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBiYWlsLW91dCBmb3Igd2VpcmQgY2hhcnNcblx0ICAgICAgICAgICAgZW5kUG9zICs9IG1lbS53cml0ZShkYXRhLnNsaWNlKGkpLCBlbmRQb3MsIGVuY29kaW5nKTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2UgaWYgKGVuY29kaW5nID09PSBcImxhdGluMVwiKSB7XG5cdCAgICAgICAgZW5kUG9zID0gYnVmZmVyZWQ7XG5cblx0ICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGNvbnN0IGNjID0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuXG5cdCAgICAgICAgICBtZW1bZW5kUG9zKytdID0gY2M7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGVuZFBvcyA9IGJ1ZmZlcmVkICsgbWVtLndyaXRlKGRhdGEsIGJ1ZmZlcmVkLCBlbmNvZGluZyk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGVuZFBvcyA9IGJ1ZmZlcmVkICsgbWVtLndyaXRlKGRhdGEsIGJ1ZmZlcmVkLCBlbmNvZGluZyk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChlbmRQb3MgPCBjaHVua1NpemUpIHtcblx0ICAgICAgdGhpcy5idWZmZXJlZCA9IGVuZFBvcztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGNvbnN0IGwgPSBlbmRQb3MgJiB+KHRoaXMuY2h1bmtTaXplIC0gMSk7XG5cblx0ICAgICAgZXhwb3J0cy51cGRhdGUobCk7XG5cblx0ICAgICAgY29uc3QgbmV3QnVmZmVyZWQgPSBlbmRQb3MgLSBsO1xuXG5cdCAgICAgIHRoaXMuYnVmZmVyZWQgPSBuZXdCdWZmZXJlZDtcblxuXHQgICAgICBpZiAobmV3QnVmZmVyZWQgPiAwKSB7XG5cdCAgICAgICAgbWVtLmNvcHlXaXRoaW4oMCwgbCwgZW5kUG9zKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIGRhdGFcblx0ICAgKiBAcmV0dXJucyB7dm9pZH1cblx0ICAgKi9cblx0ICBfdXBkYXRlV2l0aEJ1ZmZlcihkYXRhKSB7XG5cdCAgICBjb25zdCB7IGV4cG9ydHMsIGJ1ZmZlcmVkLCBtZW0gfSA9IHRoaXM7XG5cdCAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuXHQgICAgaWYgKGJ1ZmZlcmVkICsgbGVuZ3RoIDwgdGhpcy5jaHVua1NpemUpIHtcblx0ICAgICAgZGF0YS5jb3B5KG1lbSwgYnVmZmVyZWQsIDAsIGxlbmd0aCk7XG5cblx0ICAgICAgdGhpcy5idWZmZXJlZCArPSBsZW5ndGg7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBjb25zdCBsID0gKGJ1ZmZlcmVkICsgbGVuZ3RoKSAmIH4odGhpcy5jaHVua1NpemUgLSAxKTtcblxuXHQgICAgICBpZiAobCA+IDY1NTM2KSB7XG5cdCAgICAgICAgbGV0IGkgPSA2NTUzNiAtIGJ1ZmZlcmVkO1xuXG5cdCAgICAgICAgZGF0YS5jb3B5KG1lbSwgYnVmZmVyZWQsIDAsIGkpO1xuXHQgICAgICAgIGV4cG9ydHMudXBkYXRlKDY1NTM2KTtcblxuXHQgICAgICAgIGNvbnN0IHN0b3AgPSBsIC0gYnVmZmVyZWQgLSA2NTUzNjtcblxuXHQgICAgICAgIHdoaWxlIChpIDwgc3RvcCkge1xuXHQgICAgICAgICAgZGF0YS5jb3B5KG1lbSwgMCwgaSwgaSArIDY1NTM2KTtcblx0ICAgICAgICAgIGV4cG9ydHMudXBkYXRlKDY1NTM2KTtcblx0ICAgICAgICAgIGkgKz0gNjU1MzY7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZGF0YS5jb3B5KG1lbSwgMCwgaSwgbCAtIGJ1ZmZlcmVkKTtcblxuXHQgICAgICAgIGV4cG9ydHMudXBkYXRlKGwgLSBidWZmZXJlZCAtIGkpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGRhdGEuY29weShtZW0sIGJ1ZmZlcmVkLCAwLCBsIC0gYnVmZmVyZWQpO1xuXG5cdCAgICAgICAgZXhwb3J0cy51cGRhdGUobCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBjb25zdCBuZXdCdWZmZXJlZCA9IGxlbmd0aCArIGJ1ZmZlcmVkIC0gbDtcblxuXHQgICAgICB0aGlzLmJ1ZmZlcmVkID0gbmV3QnVmZmVyZWQ7XG5cblx0ICAgICAgaWYgKG5ld0J1ZmZlcmVkID4gMCkge1xuXHQgICAgICAgIGRhdGEuY29weShtZW0sIDAsIGxlbmd0aCAtIG5ld0J1ZmZlcmVkLCBsZW5ndGgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgZGlnZXN0KHR5cGUpIHtcblx0ICAgIGNvbnN0IHsgZXhwb3J0cywgYnVmZmVyZWQsIG1lbSwgZGlnZXN0U2l6ZSB9ID0gdGhpcztcblxuXHQgICAgZXhwb3J0cy5maW5hbChidWZmZXJlZCk7XG5cblx0ICAgIHRoaXMuaW5zdGFuY2VzUG9vbC5wdXNoKHRoaXMpO1xuXG5cdCAgICBjb25zdCBoZXggPSBtZW0udG9TdHJpbmcoXCJsYXRpbjFcIiwgMCwgZGlnZXN0U2l6ZSk7XG5cblx0ICAgIGlmICh0eXBlID09PSBcImhleFwiKSB7XG5cdCAgICAgIHJldHVybiBoZXg7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlID09PSBcImJpbmFyeVwiIHx8ICF0eXBlKSB7XG5cdCAgICAgIHJldHVybiBCdWZmZXIuZnJvbShoZXgsIFwiaGV4XCIpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gQnVmZmVyLmZyb20oaGV4LCBcImhleFwiKS50b1N0cmluZyh0eXBlKTtcblx0ICB9XG5cdH1cblxuXHRjb25zdCBjcmVhdGUgPSAod2FzbU1vZHVsZSwgaW5zdGFuY2VzUG9vbCwgY2h1bmtTaXplLCBkaWdlc3RTaXplKSA9PiB7XG5cdCAgaWYgKGluc3RhbmNlc1Bvb2wubGVuZ3RoID4gMCkge1xuXHQgICAgY29uc3Qgb2xkID0gaW5zdGFuY2VzUG9vbC5wb3AoKTtcblxuXHQgICAgb2xkLnJlc2V0KCk7XG5cblx0ICAgIHJldHVybiBvbGQ7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiBuZXcgV2FzbUhhc2goXG5cdCAgICAgIG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZSh3YXNtTW9kdWxlKSxcblx0ICAgICAgaW5zdGFuY2VzUG9vbCxcblx0ICAgICAgY2h1bmtTaXplLFxuXHQgICAgICBkaWdlc3RTaXplXG5cdCAgICApO1xuXHQgIH1cblx0fTtcblxuXHR3YXNtSGFzaC5leHBvcnRzID0gY3JlYXRlO1xuXHR3YXNtSGFzaC5leHBvcnRzLk1BWF9TSE9SVF9TVFJJTkcgPSBNQVhfU0hPUlRfU1RSSU5HO1xuXHRyZXR1cm4gd2FzbUhhc2guZXhwb3J0cztcbn1cblxuLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHh4aGFzaDY0XzE7XG52YXIgaGFzUmVxdWlyZWRYeGhhc2g2NDtcblxuZnVuY3Rpb24gcmVxdWlyZVh4aGFzaDY0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkWHhoYXNoNjQpIHJldHVybiB4eGhhc2g2NF8xO1xuXHRoYXNSZXF1aXJlZFh4aGFzaDY0ID0gMTtcblxuXHRjb25zdCBjcmVhdGUgPSByZXF1aXJlV2FzbUhhc2goKTtcblxuXHQvLyNyZWdpb24gd2FzbSBjb2RlOiB4eGhhc2g2NCAoLi4vLi4vLi4vYXNzZW1ibHkvaGFzaC94eGhhc2g2NC5hc20udHMpIC0taW5pdGlhbE1lbW9yeSAxXG5cdGNvbnN0IHh4aGFzaDY0ID0gbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShcblx0ICBCdWZmZXIuZnJvbShcblx0ICAgIC8vIDExNzMgYnl0ZXNcblx0ICAgIFwiQUdGemJRRUFBQUFCQ0FKZ0FYOEFZQUFBQXdRREFRQUFCUU1CQUFFR0dnVitBVUlBQzM0QlFnQUxmZ0ZDQUF0K0FVSUFDMzRCUWdBTEJ5SUVCR2x1YVhRQUFBWjFjR1JoZEdVQUFRVm1hVzVoYkFBQ0JtMWxiVzl5ZVFJQUNyVUlBekFBUXRicmd1N3EvWW4xNEFBa0FFTFAxdE8rMHNlcjJVSWtBVUlBSkFKQytlclEwT2ZKb2VUaEFDUURRZ0FrQkF2VUFRSUJmd1IrSUFCRkJFQVBDeU1FSUFDdGZDUUVJd0FoQWlNQklRTWpBaUVFSXdNaEJRTkFJQUlnQVNrREFFTFAxdE8rMHNlcjJVSitmRUlmaVVLSGxhK3ZtTGJlbTU1L2ZpRUNJQU1nQVNrRENFTFAxdE8rMHNlcjJVSitmRUlmaVVLSGxhK3ZtTGJlbTU1L2ZpRURJQVFnQVNrREVFTFAxdE8rMHNlcjJVSitmRUlmaVVLSGxhK3ZtTGJlbTU1L2ZpRUVJQVVnQVNrREdFTFAxdE8rMHNlcjJVSitmRUlmaVVLSGxhK3ZtTGJlbTU1L2ZpRUZJQUFnQVVFZ2FpSUJTdzBBQ3lBQ0pBQWdBeVFCSUFRa0FpQUZKQU1McXdZQ0FYOEVmaU1FUWdCU0JINGpBQ0lDUWdHSkl3RWlBMElIaVh3akFpSUVRZ3lKZkNNRElnVkNFb2w4SUFKQ3o5YlR2dExIcTlsQ2ZrSWZpVUtIbGErdm1MYmVtNTUvZm9WQ2g1V3ZyNWkyM3B1ZWYzNUNuYU8xNm9PeGpZcjZBSDBnQTBMUDF0Tyswc2VyMlVKK1FoK0pRb2VWcjYrWXR0NmJubjkraFVLSGxhK3ZtTGJlbTU1L2ZrS2RvN1hxZzdHTml2b0FmU0FFUXMvVzA3N1N4NnZaUW41Q0g0bENoNVd2cjVpMjNwdWVmMzZGUW9lVnI2K1l0dDZibm45K1FwMmp0ZXFEc1kySytnQjlJQVZDejliVHZ0TEhxOWxDZmtJZmlVS0hsYSt2bUxiZW01NS9mb1ZDaDVXdnI1aTIzcHVlZjM1Q25hTzE2b094allyNkFIMEZRc1hQMmJMeDVicnFKd3NqQkNBQXJYeDhJUUlEUUNBQlFRaHFJQUJOQkVBZ0FpQUJLUU1BUXMvVzA3N1N4NnZaUW41Q0g0bENoNVd2cjVpMjNwdWVmMzZGUWh1SlFvZVZyNitZdHQ2Ym5uOStRcDJqdGVxRHNZMksrZ0I5SVFJZ0FVRUlhaUVCREFFTEN5QUJRUVJxSUFCTkJFQUNmeUFDSUFFMUFnQkNoNVd2cjVpMjNwdWVmMzZGUWhlSlFzL1cwNzdTeDZ2WlFuNUMrZlBkOFpuMm1hc1dmQ0VDSUFGQkJHb0xJUUVMQTBBZ0FDQUJSd1JBSUFJZ0FURUFBRUxGejlteThlVzY2aWQraFVJTGlVS0hsYSt2bUxiZW01NS9maUVDSUFGQkFXb2hBUXdCQ3d0QkFDQUNJQUpDSVlpRlFzL1cwNzdTeDZ2WlFuNGlBaUFDUWgySWhVTDU4OTN4bWZhWnF4WitJZ0lnQWtJZ2lJVWlBa0lnaUNJRFF2Ly9BNE5DSUlZZ0EwS0FnUHovRDROQ0VJaUVJZ05DLzRHQWdQQWZnMElRaGlBRFFvRCtnNENBNEQrRFFnaUloQ0lEUW8rQXZJRHdnY0FIZzBJSWhpQURRdkNCd0llQW5vRDRBSU5DQklpRUlnTkNob3lZc09EQWdZTUdmRUlFaUVLQmdvU0lrS0RBZ0FHRFFpZCtJQU5Dc09EQWdZT0dqSmd3aEh3M0F3QkJDQ0FDUXYvLy8vOFBneUlDUXYvL0E0TkNJSVlnQWtLQWdQei9ENE5DRUlpRUlnSkMvNEdBZ1BBZmcwSVFoaUFDUW9EK2c0Q0E0RCtEUWdpSWhDSUNRbytBdklEd2djQUhnMElJaGlBQ1F2Q0J3SWVBbm9ENEFJTkNCSWlFSWdKQ2hveVlzT0RBZ1lNR2ZFSUVpRUtCZ29TSWtLREFnQUdEUWlkK0lBSkNzT0RBZ1lPR2pKZ3doSHczQXdBTFwiLFxuXHQgICAgXCJiYXNlNjRcIlxuXHQgIClcblx0KTtcblx0Ly8jZW5kcmVnaW9uXG5cblx0eHhoYXNoNjRfMSA9IGNyZWF0ZS5iaW5kKG51bGwsIHh4aGFzaDY0LCBbXSwgMzIsIDE2KTtcblx0cmV0dXJuIHh4aGFzaDY0XzE7XG59XG5cbnZhciBCYXRjaGVkSGFzaF8xO1xudmFyIGhhc1JlcXVpcmVkQmF0Y2hlZEhhc2g7XG5cbmZ1bmN0aW9uIHJlcXVpcmVCYXRjaGVkSGFzaCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEJhdGNoZWRIYXNoKSByZXR1cm4gQmF0Y2hlZEhhc2hfMTtcblx0aGFzUmVxdWlyZWRCYXRjaGVkSGFzaCA9IDE7XG5cdGNvbnN0IE1BWF9TSE9SVF9TVFJJTkcgPSByZXF1aXJlV2FzbUhhc2goKS5NQVhfU0hPUlRfU1RSSU5HO1xuXG5cdGNsYXNzIEJhdGNoZWRIYXNoIHtcblx0ICBjb25zdHJ1Y3RvcihoYXNoKSB7XG5cdCAgICB0aGlzLnN0cmluZyA9IHVuZGVmaW5lZDtcblx0ICAgIHRoaXMuZW5jb2RpbmcgPSB1bmRlZmluZWQ7XG5cdCAgICB0aGlzLmhhc2ggPSBoYXNoO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFVwZGF0ZSBoYXNoIHtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL2NyeXB0by5odG1sI2NyeXB0b19oYXNoX3VwZGF0ZV9kYXRhX2lucHV0ZW5jb2Rpbmd9XG5cdCAgICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBkYXRhIGRhdGFcblx0ICAgKiBAcGFyYW0ge3N0cmluZz19IGlucHV0RW5jb2RpbmcgZGF0YSBlbmNvZGluZ1xuXHQgICAqIEByZXR1cm5zIHt0aGlzfSB1cGRhdGVkIGhhc2hcblx0ICAgKi9cblx0ICB1cGRhdGUoZGF0YSwgaW5wdXRFbmNvZGluZykge1xuXHQgICAgaWYgKHRoaXMuc3RyaW5nICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgaWYgKFxuXHQgICAgICAgIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICYmXG5cdCAgICAgICAgaW5wdXRFbmNvZGluZyA9PT0gdGhpcy5lbmNvZGluZyAmJlxuXHQgICAgICAgIHRoaXMuc3RyaW5nLmxlbmd0aCArIGRhdGEubGVuZ3RoIDwgTUFYX1NIT1JUX1NUUklOR1xuXHQgICAgICApIHtcblx0ICAgICAgICB0aGlzLnN0cmluZyArPSBkYXRhO1xuXG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLmhhc2gudXBkYXRlKHRoaXMuc3RyaW5nLCB0aGlzLmVuY29kaW5nKTtcblx0ICAgICAgdGhpcy5zdHJpbmcgPSB1bmRlZmluZWQ7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICBpZiAoXG5cdCAgICAgICAgZGF0YS5sZW5ndGggPCBNQVhfU0hPUlRfU1RSSU5HICYmXG5cdCAgICAgICAgLy8gYmFzZTY0IGVuY29kaW5nIGlzIG5vdCB2YWxpZCBzaW5jZSBpdCBtYXkgY29udGFpbiBwYWRkaW5nIGNoYXJzXG5cdCAgICAgICAgKCFpbnB1dEVuY29kaW5nIHx8ICFpbnB1dEVuY29kaW5nLnN0YXJ0c1dpdGgoXCJiYVwiKSlcblx0ICAgICAgKSB7XG5cdCAgICAgICAgdGhpcy5zdHJpbmcgPSBkYXRhO1xuXHQgICAgICAgIHRoaXMuZW5jb2RpbmcgPSBpbnB1dEVuY29kaW5nO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuaGFzaC51cGRhdGUoZGF0YSwgaW5wdXRFbmNvZGluZyk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuaGFzaC51cGRhdGUoZGF0YSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIENhbGN1bGF0ZXMgdGhlIGRpZ2VzdCB7QGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9jcnlwdG8uaHRtbCNjcnlwdG9faGFzaF9kaWdlc3RfZW5jb2Rpbmd9XG5cdCAgICogQHBhcmFtIHtzdHJpbmc9fSBlbmNvZGluZyBlbmNvZGluZyBvZiB0aGUgcmV0dXJuIHZhbHVlXG5cdCAgICogQHJldHVybnMge3N0cmluZ3xCdWZmZXJ9IGRpZ2VzdFxuXHQgICAqL1xuXHQgIGRpZ2VzdChlbmNvZGluZykge1xuXHQgICAgaWYgKHRoaXMuc3RyaW5nICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgdGhpcy5oYXNoLnVwZGF0ZSh0aGlzLnN0cmluZywgdGhpcy5lbmNvZGluZyk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLmhhc2guZGlnZXN0KGVuY29kaW5nKTtcblx0ICB9XG5cdH1cblxuXHRCYXRjaGVkSGFzaF8xID0gQmF0Y2hlZEhhc2g7XG5cdHJldHVybiBCYXRjaGVkSGFzaF8xO1xufVxuXG4vKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgbWQ0XzE7XG52YXIgaGFzUmVxdWlyZWRNZDQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVNZDQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRNZDQpIHJldHVybiBtZDRfMTtcblx0aGFzUmVxdWlyZWRNZDQgPSAxO1xuXG5cdGNvbnN0IGNyZWF0ZSA9IHJlcXVpcmVXYXNtSGFzaCgpO1xuXG5cdC8vI3JlZ2lvbiB3YXNtIGNvZGU6IG1kNCAoLi4vLi4vLi4vYXNzZW1ibHkvaGFzaC9tZDQuYXNtLnRzKSAtLWluaXRpYWxNZW1vcnkgMVxuXHRjb25zdCBtZDQgPSBuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKFxuXHQgIEJ1ZmZlci5mcm9tKFxuXHQgICAgLy8gMjE1MCBieXRlc1xuXHQgICAgXCJBR0Z6YlFFQUFBQUJDQUpnQVg4QVlBQUFBd1VFQVFBQUFBVURBUUFCQmhvRmZ3RkJBQXQvQVVFQUMzOEJRUUFMZndGQkFBdC9BVUVBQ3djaUJBUnBibWwwQUFBR2RYQmtZWFJsQUFJRlptbHVZV3dBQXdadFpXMXZjbmtDQUFxRkVBUW1BRUdCeHBTNkJpUUJRWW5YdHY1K0pBSkIvcm5yeFhra0EwSDJxTW1CQVNRRVFRQWtBQXZNQ2dFWWZ5TUJJUW9qQWlFR0l3TWhCeU1FSVFnRFFDQUFJQVZMQkVBZ0JTZ0NDQ0lOSUFjZ0JpQUZLQUlFSWdzZ0NDQUhJQVVvQWdBaURDQUtJQWdnQmlBSElBaHpjWE5xYWtFRGR5SURJQVlnQjNOeGMycHFRUWQzSWdFZ0F5QUdjM0Z6YW1wQkMzY2hBaUFGS0FJVUlnOGdBU0FDSUFVb0FoQWlDU0FESUFFZ0JTZ0NEQ0lPSUFZZ0F5QUNJQUVnQTNOeGMycHFRUk4zSWdRZ0FTQUNjM0Z6YW1wQkEzY2lBeUFDSUFSemNYTnFha0VIZHlFQklBVW9BaUFpRWlBRElBRWdCU2dDSENJUklBUWdBeUFGS0FJWUloQWdBaUFFSUFFZ0F5QUVjM0Z6YW1wQkMzY2lBaUFCSUFOemNYTnFha0VUZHlJRUlBRWdBbk54YzJwcVFRTjNJUU1nQlNnQ0xDSVZJQVFnQXlBRktBSW9JaFFnQWlBRUlBVW9BaVFpRXlBQklBSWdBeUFDSUFSemNYTnFha0VIZHlJQklBTWdCSE54YzJwcVFRdDNJZ0lnQVNBRGMzRnphbXBCRTNjaEJDQVBJQkFnQ1NBVklCUWdFeUFGS0FJNEloWWdBaUFFSUFVb0FqUWlGeUFCSUFJZ0JTZ0NNQ0lZSUFNZ0FTQUVJQUVnQW5OeGMycHFRUU4zSWdFZ0FpQUVjM0Z6YW1wQkIzY2lBaUFCSUFSemNYTnFha0VMZHlJRElBa2dBaUFNSUFFZ0JTZ0NQQ0lKSUFRZ0FTQURJQUVnQW5OeGMycHFRUk4zSWdFZ0FpQURjbkVnQWlBRGNYSnFha0daODRuVUJXcEJBM2NpQWlBQklBTnljU0FCSUFOeGNtcHFRWm56aWRRRmFrRUZkeUlFSUFFZ0FuSnhJQUVnQW5GeWFpQVNha0daODRuVUJXcEJDWGNpQXlBUElBUWdDeUFDSUJnZ0FTQURJQUlnQkhKeElBSWdCSEZ5YW1wQm1mT0oxQVZxUVExM0lnRWdBeUFFY25FZ0F5QUVjWEpxYWtHWjg0blVCV3BCQTNjaUFpQUJJQU55Y1NBQklBTnhjbXBxUVpuemlkUUZha0VGZHlJRUlBRWdBbkp4SUFFZ0FuRnlhbXBCbWZPSjFBVnFRUWwzSWdNZ0VDQUVJQUlnRnlBQklBTWdBaUFFY25FZ0FpQUVjWEpxYWtHWjg0blVCV3BCRFhjaUFTQURJQVJ5Y1NBRElBUnhjbW9nRFdwQm1mT0oxQVZxUVFOM0lnSWdBU0FEY25FZ0FTQURjWEpxYWtHWjg0blVCV3BCQlhjaUJDQUJJQUp5Y1NBQklBSnhjbXBxUVpuemlkUUZha0VKZHlJRElCRWdCQ0FPSUFJZ0ZpQUJJQU1nQWlBRWNuRWdBaUFFY1hKcWFrR1o4NG5VQldwQkRYY2lBU0FESUFSeWNTQURJQVJ4Y21wcVFabnppZFFGYWtFRGR5SUNJQUVnQTNKeElBRWdBM0Z5YW1wQm1mT0oxQVZxUVFWM0lnUWdBU0FDY25FZ0FTQUNjWEpxYWtHWjg0blVCV3BCQ1hjaUF5QU1JQUlnQXlBSklBRWdBeUFDSUFSeWNTQUNJQVJ4Y21wcVFabnppZFFGYWtFTmR5SUJjeUFFYzJwcVFhSFg1L1lHYWtFRGR5SUNJQVFnQVNBQ2N5QURjMm9nRW1wQm9kZm45Z1pxUVFsM0lnUnpJQUZ6YW1wQm9kZm45Z1pxUVF0M0lnTWdBaUFESUJnZ0FTQURJQVJ6SUFKemFtcEJvZGZuOWdacVFROTNJZ0Z6SUFSemFpQU5ha0doMStmMkJtcEJBM2NpQWlBVUlBUWdBU0FDY3lBRGMycHFRYUhYNS9ZR2FrRUpkeUlFY3lBQmMycHFRYUhYNS9ZR2FrRUxkeUlESUFzZ0FpQURJQllnQVNBRElBUnpJQUp6YW1wQm9kZm45Z1pxUVE5M0lnRnpJQVJ6YW1wQm9kZm45Z1pxUVFOM0lnSWdFeUFFSUFFZ0FuTWdBM05xYWtHaDErZjJCbXBCQ1hjaUJITWdBWE5xYWtHaDErZjJCbXBCQzNjaEF5QUtJQTRnQWlBRElCY2dBU0FESUFSeklBSnphbXBCb2RmbjlnWnFRUTkzSWdGeklBUnphbXBCb2RmbjlnWnFRUU4zSWdKcUlRb2dCaUFKSUFFZ0VTQURJQUlnRlNBRUlBRWdBbk1nQTNOcWFrR2gxK2YyQm1wQkNYY2lCSE1nQVhOcWFrR2gxK2YyQm1wQkMzY2lBeUFFY3lBQ2MycHFRYUhYNS9ZR2FrRVBkMm9oQmlBRElBZHFJUWNnQkNBSWFpRUlJQVZCUUdzaEJRd0JDd3NnQ2lRQklBWWtBaUFISkFNZ0NDUUVDdzBBSUFBUUFTTUFJQUJxSkFBTC93UUNBMzhCZmlNQUlBQnFyVUlEaGlFRUlBQkJ5QUJxUVVCeElnSkJDR3NoQXlBQUlnRkJBV29oQUNBQlFZQUJPZ0FBQTBBZ0FDQUNTVUVBSUFCQkIzRWJCRUFnQUVFQU9nQUFJQUJCQVdvaEFBd0JDd3NEUUNBQUlBSkpCRUFnQUVJQU53TUFJQUJCQ0dvaEFBd0JDd3NnQXlBRU53TUFJQUlRQVVFQUl3R3RJZ1JDLy84RGd5QUVRb0NBL1A4UGcwSVFob1FpQkVML2dZQ0E4QitESUFSQ2dQNkRnSURnUDROQ0NJYUVJZ1JDajRDOGdQQ0J3QWVEUWdpR0lBUkM4SUhBaDRDZWdQZ0FnMElFaUlRaUJFS0dqSml3NE1DQmd3WjhRZ1NJUW9HQ2hJaVFvTUNBQVlOQ0ozNGdCRUt3NE1DQmc0YU1tRENFZkRjREFFRUlJd0t0SWdSQy8vOERneUFFUW9DQS9QOFBnMElRaG9RaUJFTC9nWUNBOEIrRElBUkNnUDZEZ0lEZ1A0TkNDSWFFSWdSQ2o0QzhnUENCd0FlRFFnaUdJQVJDOElIQWg0Q2VnUGdBZzBJRWlJUWlCRUtHakppdzRNQ0Jnd1o4UWdTSVFvR0NoSWlRb01DQUFZTkNKMzRnQkVLdzRNQ0JnNGFNbURDRWZEY0RBRUVRSXdPdElnUkMvLzhEZ3lBRVFvQ0EvUDhQZzBJUWhvUWlCRUwvZ1lDQThCK0RJQVJDZ1A2RGdJRGdQNE5DQ0lhRUlnUkNqNEM4Z1BDQndBZURRZ2lHSUFSQzhJSEFoNENlZ1BnQWcwSUVpSVFpQkVLR2pKaXc0TUNCZ3daOFFnU0lRb0dDaElpUW9NQ0FBWU5DSjM0Z0JFS3c0TUNCZzRhTW1EQ0VmRGNEQUVFWUl3U3RJZ1JDLy84RGd5QUVRb0NBL1A4UGcwSVFob1FpQkVML2dZQ0E4QitESUFSQ2dQNkRnSURnUDROQ0NJYUVJZ1JDajRDOGdQQ0J3QWVEUWdpR0lBUkM4SUhBaDRDZWdQZ0FnMElFaUlRaUJFS0dqSml3NE1DQmd3WjhRZ1NJUW9HQ2hJaVFvTUNBQVlOQ0ozNGdCRUt3NE1DQmc0YU1tRENFZkRjREFBcz1cIixcblx0ICAgIFwiYmFzZTY0XCJcblx0ICApXG5cdCk7XG5cdC8vI2VuZHJlZ2lvblxuXG5cdG1kNF8xID0gY3JlYXRlLmJpbmQobnVsbCwgbWQ0LCBbXSwgNjQsIDMyKTtcblx0cmV0dXJuIG1kNF8xO1xufVxuXG52YXIgQnVsa1VwZGF0ZURlY29yYXRvcl8xO1xudmFyIGhhc1JlcXVpcmVkQnVsa1VwZGF0ZURlY29yYXRvcjtcblxuZnVuY3Rpb24gcmVxdWlyZUJ1bGtVcGRhdGVEZWNvcmF0b3IgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRCdWxrVXBkYXRlRGVjb3JhdG9yKSByZXR1cm4gQnVsa1VwZGF0ZURlY29yYXRvcl8xO1xuXHRoYXNSZXF1aXJlZEJ1bGtVcGRhdGVEZWNvcmF0b3IgPSAxO1xuXHRjb25zdCBCVUxLX1NJWkUgPSAyMDAwO1xuXG5cdC8vIFdlIGFyZSB1c2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhIE1hcCBhcyB0aGlzIHdpbGwgc3RheSBzdGF0aWMgZHVyaW5nIHRoZSBydW50aW1lXG5cdC8vIHNvIGFjY2VzcyB0byBpdCBjYW4gYmUgb3B0aW1pemVkIGJ5IHY4XG5cdGNvbnN0IGRpZ2VzdENhY2hlcyA9IHt9O1xuXG5cdGNsYXNzIEJ1bGtVcGRhdGVEZWNvcmF0b3Ige1xuXHQgIC8qKlxuXHQgICAqIEBwYXJhbSB7SGFzaCB8IGZ1bmN0aW9uKCk6IEhhc2h9IGhhc2hPckZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIGEgaGFzaFxuXHQgICAqIEBwYXJhbSB7c3RyaW5nPX0gaGFzaEtleSBrZXkgZm9yIGNhY2hpbmdcblx0ICAgKi9cblx0ICBjb25zdHJ1Y3RvcihoYXNoT3JGYWN0b3J5LCBoYXNoS2V5KSB7XG5cdCAgICB0aGlzLmhhc2hLZXkgPSBoYXNoS2V5O1xuXG5cdCAgICBpZiAodHlwZW9mIGhhc2hPckZhY3RvcnkgPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICB0aGlzLmhhc2hGYWN0b3J5ID0gaGFzaE9yRmFjdG9yeTtcblx0ICAgICAgdGhpcy5oYXNoID0gdW5kZWZpbmVkO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5oYXNoRmFjdG9yeSA9IHVuZGVmaW5lZDtcblx0ICAgICAgdGhpcy5oYXNoID0gaGFzaE9yRmFjdG9yeTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5idWZmZXIgPSBcIlwiO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFVwZGF0ZSBoYXNoIHtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL2NyeXB0by5odG1sI2NyeXB0b19oYXNoX3VwZGF0ZV9kYXRhX2lucHV0ZW5jb2Rpbmd9XG5cdCAgICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBkYXRhIGRhdGFcblx0ICAgKiBAcGFyYW0ge3N0cmluZz19IGlucHV0RW5jb2RpbmcgZGF0YSBlbmNvZGluZ1xuXHQgICAqIEByZXR1cm5zIHt0aGlzfSB1cGRhdGVkIGhhc2hcblx0ICAgKi9cblx0ICB1cGRhdGUoZGF0YSwgaW5wdXRFbmNvZGluZykge1xuXHQgICAgaWYgKFxuXHQgICAgICBpbnB1dEVuY29kaW5nICE9PSB1bmRlZmluZWQgfHxcblx0ICAgICAgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgfHxcblx0ICAgICAgZGF0YS5sZW5ndGggPiBCVUxLX1NJWkVcblx0ICAgICkge1xuXHQgICAgICBpZiAodGhpcy5oYXNoID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICB0aGlzLmhhc2ggPSB0aGlzLmhhc2hGYWN0b3J5KCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuXHQgICAgICAgIHRoaXMuaGFzaC51cGRhdGUodGhpcy5idWZmZXIpO1xuXHQgICAgICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuaGFzaC51cGRhdGUoZGF0YSwgaW5wdXRFbmNvZGluZyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLmJ1ZmZlciArPSBkYXRhO1xuXG5cdCAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiBCVUxLX1NJWkUpIHtcblx0ICAgICAgICBpZiAodGhpcy5oYXNoID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgIHRoaXMuaGFzaCA9IHRoaXMuaGFzaEZhY3RvcnkoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLmhhc2gudXBkYXRlKHRoaXMuYnVmZmVyKTtcblx0ICAgICAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogQ2FsY3VsYXRlcyB0aGUgZGlnZXN0IHtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL2NyeXB0by5odG1sI2NyeXB0b19oYXNoX2RpZ2VzdF9lbmNvZGluZ31cblx0ICAgKiBAcGFyYW0ge3N0cmluZz19IGVuY29kaW5nIGVuY29kaW5nIG9mIHRoZSByZXR1cm4gdmFsdWVcblx0ICAgKiBAcmV0dXJucyB7c3RyaW5nfEJ1ZmZlcn0gZGlnZXN0XG5cdCAgICovXG5cdCAgZGlnZXN0KGVuY29kaW5nKSB7XG5cdCAgICBsZXQgZGlnZXN0Q2FjaGU7XG5cblx0ICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuXG5cdCAgICBpZiAodGhpcy5oYXNoID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgLy8gc2hvcnQgZGF0YSBmb3IgaGFzaCwgd2UgY2FuIHVzZSBjYWNoaW5nXG5cdCAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7dGhpcy5oYXNoS2V5fS0ke2VuY29kaW5nfWA7XG5cblx0ICAgICAgZGlnZXN0Q2FjaGUgPSBkaWdlc3RDYWNoZXNbY2FjaGVLZXldO1xuXG5cdCAgICAgIGlmIChkaWdlc3RDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgZGlnZXN0Q2FjaGUgPSBkaWdlc3RDYWNoZXNbY2FjaGVLZXldID0gbmV3IE1hcCgpO1xuXHQgICAgICB9XG5cblx0ICAgICAgY29uc3QgY2FjaGVFbnRyeSA9IGRpZ2VzdENhY2hlLmdldChidWZmZXIpO1xuXG5cdCAgICAgIGlmIChjYWNoZUVudHJ5ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByZXR1cm4gY2FjaGVFbnRyeTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuaGFzaCA9IHRoaXMuaGFzaEZhY3RvcnkoKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG5cdCAgICAgIHRoaXMuaGFzaC51cGRhdGUoYnVmZmVyKTtcblx0ICAgIH1cblxuXHQgICAgY29uc3QgZGlnZXN0UmVzdWx0ID0gdGhpcy5oYXNoLmRpZ2VzdChlbmNvZGluZyk7XG5cblx0ICAgIGlmIChkaWdlc3RDYWNoZSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIGRpZ2VzdENhY2hlLnNldChidWZmZXIsIGRpZ2VzdFJlc3VsdCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBkaWdlc3RSZXN1bHQ7XG5cdCAgfVxuXHR9XG5cblx0QnVsa1VwZGF0ZURlY29yYXRvcl8xID0gQnVsa1VwZGF0ZURlY29yYXRvcjtcblx0cmV0dXJuIEJ1bGtVcGRhdGVEZWNvcmF0b3JfMTtcbn1cblxuY29uc3QgYmFzZUVuY29kZVRhYmxlcyA9IHtcbiAgMjY6IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIixcbiAgMzI6IFwiMTIzNDU2Nzg5YWJjZGVmZ2hqa21ucHFyc3R1dnd4eXpcIiwgLy8gbm8gMGxpb1xuICAzNjogXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIixcbiAgNDk6IFwiYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWlwiLCAvLyBubyBsSU9cbiAgNTI6IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiLFxuICA1ODogXCIxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaXCIsIC8vIG5vIDBsSU9cbiAgNjI6IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIixcbiAgNjQ6IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotX1wiLFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQzMkFycmF5fSB1aW50MzJBcnJheSBUcmVhdGVkIGFzIGEgbG9uZyBiYXNlLTB4MTAwMDAwMDAwIG51bWJlciwgbGl0dGxlIGVuZGlhblxuICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzb3IgVGhlIGRpdmlzb3JcbiAqIEByZXR1cm4ge251bWJlcn0gTW9kdWxvIChyZW1haW5kZXIpIG9mIHRoZSBkaXZpc2lvblxuICovXG5mdW5jdGlvbiBkaXZtb2QzMih1aW50MzJBcnJheSwgZGl2aXNvcikge1xuICBsZXQgY2FycnkgPSAwO1xuICBmb3IgKGxldCBpID0gdWludDMyQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCB2YWx1ZSA9IGNhcnJ5ICogMHgxMDAwMDAwMDAgKyB1aW50MzJBcnJheVtpXTtcbiAgICBjYXJyeSA9IHZhbHVlICUgZGl2aXNvcjtcbiAgICB1aW50MzJBcnJheVtpXSA9IE1hdGguZmxvb3IodmFsdWUgLyBkaXZpc29yKTtcbiAgfVxuICByZXR1cm4gY2Fycnk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJ1ZmZlclRvQmFzZShidWZmZXIsIGJhc2UsIGxlbmd0aCkge1xuICBjb25zdCBlbmNvZGVUYWJsZSA9IGJhc2VFbmNvZGVUYWJsZXNbYmFzZV07XG5cbiAgaWYgKCFlbmNvZGVUYWJsZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZW5jb2RpbmcgYmFzZVwiICsgYmFzZSk7XG4gIH1cblxuICAvLyBJbnB1dCBiaXRzIGFyZSBvbmx5IGVub3VnaCB0byBnZW5lcmF0ZSB0aGlzIG1hbnkgY2hhcmFjdGVyc1xuICBjb25zdCBsaW1pdCA9IE1hdGguY2VpbCgoYnVmZmVyLmxlbmd0aCAqIDgpIC8gTWF0aC5sb2cyKGJhc2UpKTtcbiAgbGVuZ3RoID0gTWF0aC5taW4obGVuZ3RoLCBsaW1pdCk7XG5cbiAgLy8gTW9zdCBvZiB0aGUgY3J5cHRvIGRpZ2VzdHMgKGlmIG5vdCBhbGwpIGhhcyBsZW5ndGggYSBtdWx0aXBsZSBvZiA0IGJ5dGVzLlxuICAvLyBGZXdlciBudW1iZXJzIGluIHRoZSBhcnJheSBtZWFucyBmYXN0ZXIgbWF0aC5cbiAgY29uc3QgdWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoTWF0aC5jZWlsKGJ1ZmZlci5sZW5ndGggLyA0KSk7XG5cbiAgLy8gTWFrZSBzdXJlIHRoZSBpbnB1dCBidWZmZXIgZGF0YSBpcyBjb3BpZWQgYW5kIGlzIG5vdCBtdXRhdGVkIGJ5IHJlZmVyZW5jZS5cbiAgLy8gZGl2bW9kMzIoKSB3b3VsZCBjb3JydXB0IHRoZSBCdWxrVXBkYXRlRGVjb3JhdG9yIGNhY2hlIG90aGVyd2lzZS5cbiAgYnVmZmVyLmNvcHkoQnVmZmVyLmZyb20odWludDMyQXJyYXkuYnVmZmVyKSk7XG5cbiAgbGV0IG91dHB1dCA9IFwiXCI7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIG91dHB1dCA9IGVuY29kZVRhYmxlW2Rpdm1vZDMyKHVpbnQzMkFycmF5LCBiYXNlKV0gKyBvdXRwdXQ7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5sZXQgY3J5cHRvID0gdW5kZWZpbmVkO1xubGV0IGNyZWF0ZVhYSGFzaDY0ID0gdW5kZWZpbmVkO1xubGV0IGNyZWF0ZU1kNCA9IHVuZGVmaW5lZDtcbmxldCBCYXRjaGVkSGFzaCA9IHVuZGVmaW5lZDtcbmxldCBCdWxrVXBkYXRlRGVjb3JhdG9yID0gdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBnZXRIYXNoRGlnZXN0JDEoYnVmZmVyLCBhbGdvcml0aG0sIGRpZ2VzdFR5cGUsIG1heExlbmd0aCkge1xuICBhbGdvcml0aG0gPSBhbGdvcml0aG0gfHwgXCJ4eGhhc2g2NFwiO1xuICBtYXhMZW5ndGggPSBtYXhMZW5ndGggfHwgOTk5OTtcblxuICBsZXQgaGFzaDtcblxuICBpZiAoYWxnb3JpdGhtID09PSBcInh4aGFzaDY0XCIpIHtcbiAgICBpZiAoY3JlYXRlWFhIYXNoNjQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3JlYXRlWFhIYXNoNjQgPSByZXF1aXJlWHhoYXNoNjQoKTtcblxuICAgICAgaWYgKEJhdGNoZWRIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgQmF0Y2hlZEhhc2ggPSByZXF1aXJlQmF0Y2hlZEhhc2goKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNoID0gbmV3IEJhdGNoZWRIYXNoKGNyZWF0ZVhYSGFzaDY0KCkpO1xuICB9IGVsc2UgaWYgKGFsZ29yaXRobSA9PT0gXCJtZDRcIikge1xuICAgIGlmIChjcmVhdGVNZDQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3JlYXRlTWQ0ID0gcmVxdWlyZU1kNCgpO1xuXG4gICAgICBpZiAoQmF0Y2hlZEhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBCYXRjaGVkSGFzaCA9IHJlcXVpcmVCYXRjaGVkSGFzaCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhc2ggPSBuZXcgQmF0Y2hlZEhhc2goY3JlYXRlTWQ0KCkpO1xuICB9IGVsc2UgaWYgKGFsZ29yaXRobSA9PT0gXCJuYXRpdmUtbWQ0XCIpIHtcbiAgICBpZiAodHlwZW9mIGNyeXB0byA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY3J5cHRvID0gcmVxdWlyZSQkMztcblxuICAgICAgaWYgKEJ1bGtVcGRhdGVEZWNvcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBCdWxrVXBkYXRlRGVjb3JhdG9yID0gcmVxdWlyZUJ1bGtVcGRhdGVEZWNvcmF0b3IoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNoID0gbmV3IEJ1bGtVcGRhdGVEZWNvcmF0b3IoKCkgPT4gY3J5cHRvLmNyZWF0ZUhhc2goXCJtZDRcIiksIFwibWQ0XCIpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgY3J5cHRvID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjcnlwdG8gPSByZXF1aXJlJCQzO1xuXG4gICAgICBpZiAoQnVsa1VwZGF0ZURlY29yYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIEJ1bGtVcGRhdGVEZWNvcmF0b3IgPSByZXF1aXJlQnVsa1VwZGF0ZURlY29yYXRvcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhc2ggPSBuZXcgQnVsa1VwZGF0ZURlY29yYXRvcihcbiAgICAgICgpID0+IGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSksXG4gICAgICBhbGdvcml0aG1cbiAgICApO1xuICB9XG5cbiAgaGFzaC51cGRhdGUoYnVmZmVyKTtcblxuICBpZiAoXG4gICAgZGlnZXN0VHlwZSA9PT0gXCJiYXNlMjZcIiB8fFxuICAgIGRpZ2VzdFR5cGUgPT09IFwiYmFzZTMyXCIgfHxcbiAgICBkaWdlc3RUeXBlID09PSBcImJhc2UzNlwiIHx8XG4gICAgZGlnZXN0VHlwZSA9PT0gXCJiYXNlNDlcIiB8fFxuICAgIGRpZ2VzdFR5cGUgPT09IFwiYmFzZTUyXCIgfHxcbiAgICBkaWdlc3RUeXBlID09PSBcImJhc2U1OFwiIHx8XG4gICAgZGlnZXN0VHlwZSA9PT0gXCJiYXNlNjJcIlxuICApIHtcbiAgICByZXR1cm4gZW5jb2RlQnVmZmVyVG9CYXNlKGhhc2guZGlnZXN0KCksIGRpZ2VzdFR5cGUuc3Vic3RyKDQpLCBtYXhMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBoYXNoLmRpZ2VzdChkaWdlc3RUeXBlIHx8IFwiaGV4XCIpLnN1YnN0cigwLCBtYXhMZW5ndGgpO1xuICB9XG59XG5cbnZhciBnZXRIYXNoRGlnZXN0XzEgPSBnZXRIYXNoRGlnZXN0JDE7XG5cbmNvbnN0IHBhdGgkMSA9IHJlcXVpcmUkJDAkMTtcbmNvbnN0IGdldEhhc2hEaWdlc3QgPSBnZXRIYXNoRGlnZXN0XzE7XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlTmFtZSQxKGxvYWRlckNvbnRleHQsIG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgZmlsZW5hbWU7XG5cbiAgY29uc3QgaGFzUXVlcnkgPVxuICAgIGxvYWRlckNvbnRleHQucmVzb3VyY2VRdWVyeSAmJiBsb2FkZXJDb250ZXh0LnJlc291cmNlUXVlcnkubGVuZ3RoID4gMTtcblxuICBpZiAodHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZpbGVuYW1lID0gbmFtZShcbiAgICAgIGxvYWRlckNvbnRleHQucmVzb3VyY2VQYXRoLFxuICAgICAgaGFzUXVlcnkgPyBsb2FkZXJDb250ZXh0LnJlc291cmNlUXVlcnkgOiB1bmRlZmluZWRcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGZpbGVuYW1lID0gbmFtZSB8fCBcIltoYXNoXS5bZXh0XVwiO1xuICB9XG5cbiAgY29uc3QgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dDtcbiAgY29uc3QgY29udGVudCA9IG9wdGlvbnMuY29udGVudDtcbiAgY29uc3QgcmVnRXhwID0gb3B0aW9ucy5yZWdFeHA7XG5cbiAgbGV0IGV4dCA9IFwiYmluXCI7XG4gIGxldCBiYXNlbmFtZSA9IFwiZmlsZVwiO1xuICBsZXQgZGlyZWN0b3J5ID0gXCJcIjtcbiAgbGV0IGZvbGRlciA9IFwiXCI7XG4gIGxldCBxdWVyeSA9IFwiXCI7XG5cbiAgaWYgKGxvYWRlckNvbnRleHQucmVzb3VyY2VQYXRoKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGF0aCQxLnBhcnNlKGxvYWRlckNvbnRleHQucmVzb3VyY2VQYXRoKTtcbiAgICBsZXQgcmVzb3VyY2VQYXRoID0gbG9hZGVyQ29udGV4dC5yZXNvdXJjZVBhdGg7XG5cbiAgICBpZiAocGFyc2VkLmV4dCkge1xuICAgICAgZXh0ID0gcGFyc2VkLmV4dC5zdWJzdHIoMSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcnNlZC5kaXIpIHtcbiAgICAgIGJhc2VuYW1lID0gcGFyc2VkLm5hbWU7XG4gICAgICByZXNvdXJjZVBhdGggPSBwYXJzZWQuZGlyICsgcGF0aCQxLnNlcDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGRpcmVjdG9yeSA9IHBhdGgkMVxuICAgICAgICAucmVsYXRpdmUoY29udGV4dCwgcmVzb3VyY2VQYXRoICsgXCJfXCIpXG4gICAgICAgIC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKVxuICAgICAgICAucmVwbGFjZSgvXFwuXFwuKFxcLyk/L2csIFwiXyQxXCIpO1xuICAgICAgZGlyZWN0b3J5ID0gZGlyZWN0b3J5LnN1YnN0cigwLCBkaXJlY3RvcnkubGVuZ3RoIC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcmVjdG9yeSA9IHJlc291cmNlUGF0aC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKS5yZXBsYWNlKC9cXC5cXC4oXFwvKT8vZywgXCJfJDFcIik7XG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdG9yeS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGRpcmVjdG9yeSA9IFwiXCI7XG4gICAgfSBlbHNlIGlmIChkaXJlY3RvcnkubGVuZ3RoID4gMSkge1xuICAgICAgZm9sZGVyID0gcGF0aCQxLmJhc2VuYW1lKGRpcmVjdG9yeSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvYWRlckNvbnRleHQucmVzb3VyY2VRdWVyeSAmJiBsb2FkZXJDb250ZXh0LnJlc291cmNlUXVlcnkubGVuZ3RoID4gMSkge1xuICAgIHF1ZXJ5ID0gbG9hZGVyQ29udGV4dC5yZXNvdXJjZVF1ZXJ5O1xuXG4gICAgY29uc3QgaGFzaElkeCA9IHF1ZXJ5LmluZGV4T2YoXCIjXCIpO1xuXG4gICAgaWYgKGhhc2hJZHggPj0gMCkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5zdWJzdHIoMCwgaGFzaElkeCk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHVybCA9IGZpbGVuYW1lO1xuXG4gIGlmIChjb250ZW50KSB7XG4gICAgLy8gTWF0Y2ggaGFzaCB0ZW1wbGF0ZVxuICAgIHVybCA9IHVybFxuICAgICAgLy8gYGhhc2hgIGFuZCBgY29udGVudGhhc2hgIGFyZSBzYW1lIGluIGBsb2FkZXItdXRpbHNgIGNvbnRleHRcbiAgICAgIC8vIGxldCdzIGtlZXAgYGhhc2hgIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAucmVwbGFjZShcbiAgICAgICAgL1xcWyg/OihbXls6XFxdXSspOik/KD86aGFzaHxjb250ZW50aGFzaCkoPzo6KFthLXpdK1xcZCopKT8oPzo6KFxcZCspKT9cXF0vZ2ksXG4gICAgICAgIChhbGwsIGhhc2hUeXBlLCBkaWdlc3RUeXBlLCBtYXhMZW5ndGgpID0+XG4gICAgICAgICAgZ2V0SGFzaERpZ2VzdChjb250ZW50LCBoYXNoVHlwZSwgZGlnZXN0VHlwZSwgcGFyc2VJbnQobWF4TGVuZ3RoLCAxMCkpXG4gICAgICApO1xuICB9XG5cbiAgdXJsID0gdXJsXG4gICAgLnJlcGxhY2UoL1xcW2V4dFxcXS9naSwgKCkgPT4gZXh0KVxuICAgIC5yZXBsYWNlKC9cXFtuYW1lXFxdL2dpLCAoKSA9PiBiYXNlbmFtZSlcbiAgICAucmVwbGFjZSgvXFxbcGF0aFxcXS9naSwgKCkgPT4gZGlyZWN0b3J5KVxuICAgIC5yZXBsYWNlKC9cXFtmb2xkZXJcXF0vZ2ksICgpID0+IGZvbGRlcilcbiAgICAucmVwbGFjZSgvXFxbcXVlcnlcXF0vZ2ksICgpID0+IHF1ZXJ5KTtcblxuICBpZiAocmVnRXhwICYmIGxvYWRlckNvbnRleHQucmVzb3VyY2VQYXRoKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBsb2FkZXJDb250ZXh0LnJlc291cmNlUGF0aC5tYXRjaChuZXcgUmVnRXhwKHJlZ0V4cCkpO1xuXG4gICAgbWF0Y2ggJiZcbiAgICAgIG1hdGNoLmZvckVhY2goKG1hdGNoZWQsIGkpID0+IHtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFxbXCIgKyBpICsgXCJcXFxcXVwiLCBcImlnXCIpLCBtYXRjaGVkKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgaWYgKFxuICAgIHR5cGVvZiBsb2FkZXJDb250ZXh0Lm9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiZcbiAgICB0eXBlb2YgbG9hZGVyQ29udGV4dC5vcHRpb25zLmN1c3RvbUludGVycG9sYXRlTmFtZSA9PT0gXCJmdW5jdGlvblwiXG4gICkge1xuICAgIHVybCA9IGxvYWRlckNvbnRleHQub3B0aW9ucy5jdXN0b21JbnRlcnBvbGF0ZU5hbWUuY2FsbChcbiAgICAgIGxvYWRlckNvbnRleHQsXG4gICAgICB1cmwsXG4gICAgICBuYW1lLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufVxuXG52YXIgaW50ZXJwb2xhdGVOYW1lXzEgPSBpbnRlcnBvbGF0ZU5hbWUkMTtcblxudmFyIGludGVycG9sYXRlTmFtZSA9IGludGVycG9sYXRlTmFtZV8xO1xudmFyIHBhdGggPSByZXF1aXJlJCQwJDE7XG5cbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBwYXR0ZXJuXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSAge3N0cmluZ30gb3B0aW9ucy5jb250ZXh0XG4gKiBAcGFyYW0gIHtzdHJpbmd9IG9wdGlvbnMuaGFzaFByZWZpeFxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbnZhciBnZW5lcmljTmFtZXMgPSBmdW5jdGlvbiBjcmVhdGVHZW5lcmF0b3IocGF0dGVybiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGNvbnRleHQgPVxuICAgIG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyBvcHRpb25zLmNvbnRleHRcbiAgICAgIDogcHJvY2Vzcy5jd2QoKTtcbiAgdmFyIGhhc2hQcmVmaXggPVxuICAgIG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuaGFzaFByZWZpeCA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMuaGFzaFByZWZpeCA6IFwiXCI7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbG9jYWxOYW1lIFVzdWFsbHkgYSBjbGFzcyBuYW1lXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZmlsZXBhdGggIEFic29sdXRlIHBhdGhcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgcmV0dXJuIGZ1bmN0aW9uIGdlbmVyYXRlKGxvY2FsTmFtZSwgZmlsZXBhdGgpIHtcbiAgICB2YXIgbmFtZSA9IHBhdHRlcm4ucmVwbGFjZSgvXFxbbG9jYWxcXF0vZ2ksIGxvY2FsTmFtZSk7XG4gICAgdmFyIGxvYWRlckNvbnRleHQgPSB7XG4gICAgICByZXNvdXJjZVBhdGg6IGZpbGVwYXRoLFxuICAgIH07XG5cbiAgICB2YXIgbG9hZGVyT3B0aW9ucyA9IHtcbiAgICAgIGNvbnRlbnQ6XG4gICAgICAgIGhhc2hQcmVmaXggK1xuICAgICAgICBwYXRoLnJlbGF0aXZlKGNvbnRleHQsIGZpbGVwYXRoKS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKSArXG4gICAgICAgIFwiXFx4MDBcIiArXG4gICAgICAgIGxvY2FsTmFtZSxcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgfTtcblxuICAgIHZhciBnZW5lcmljTmFtZSA9IGludGVycG9sYXRlTmFtZShsb2FkZXJDb250ZXh0LCBuYW1lLCBsb2FkZXJPcHRpb25zKTtcbiAgICByZXR1cm4gZ2VuZXJpY05hbWVcbiAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoXCJbXmEtekEtWjAtOVxcXFwtX1xcdTAwQTAtXFx1RkZGRl1cIiwgXCJnXCIpLCBcIi1cIilcbiAgICAgIC5yZXBsYWNlKC9eKCgtP1swLTldKXwtLSkvLCBcIl8kMVwiKTtcbiAgfTtcbn07XG5cbnZhciBzcmMkMiA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBkaXN0ID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIHByb2Nlc3NvciA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBwYXJzZXIgPSB7ZXhwb3J0czoge319O1xuXG52YXIgcm9vdCQxID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGNvbnRhaW5lciA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBub2RlJDEgPSB7ZXhwb3J0czoge319O1xuXG52YXIgdXRpbCA9IHt9O1xuXG52YXIgdW5lc2MgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdW5lc2M7XG5cdC8vIE1hbnkgdGhhbmtzIGZvciB0aGlzIHBvc3Qgd2hpY2ggbWFkZSB0aGlzIG1pZ3JhdGlvbiBtdWNoIGVhc2llci5cblx0Ly8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2Nzcy1lc2NhcGVzXG5cblx0LyoqXG5cdCAqIFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFxuXHQgKiBAcmV0dXJucyB7W3N0cmluZywgbnVtYmVyXXx1bmRlZmluZWR9XG5cdCAqL1xuXHRmdW5jdGlvbiBnb2JibGVIZXgoc3RyKSB7XG5cdCAgdmFyIGxvd2VyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG5cdCAgdmFyIGhleCA9ICcnO1xuXHQgIHZhciBzcGFjZVRlcm1pbmF0ZWQgPSBmYWxzZTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IDYgJiYgbG93ZXJbaV0gIT09IHVuZGVmaW5lZDsgaSsrKSB7XG5cdCAgICB2YXIgY29kZSA9IGxvd2VyLmNoYXJDb2RlQXQoaSk7XG5cdCAgICAvLyBjaGVjayB0byBzZWUgaWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBhIHZhbGlkIGhleCBjaGFyIFthLWZ8MC05XVxuXHQgICAgdmFyIHZhbGlkID0gY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEwMiB8fCBjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTc7XG5cdCAgICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXN5bnRheC8jY29uc3VtZS1lc2NhcGVkLWNvZGUtcG9pbnRcblx0ICAgIHNwYWNlVGVybWluYXRlZCA9IGNvZGUgPT09IDMyO1xuXHQgICAgaWYgKCF2YWxpZCkge1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblx0ICAgIGhleCArPSBsb3dlcltpXTtcblx0ICB9XG5cdCAgaWYgKGhleC5sZW5ndGggPT09IDApIHtcblx0ICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgfVxuXHQgIHZhciBjb2RlUG9pbnQgPSBwYXJzZUludChoZXgsIDE2KTtcblx0ICB2YXIgaXNTdXJyb2dhdGUgPSBjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkY7XG5cdCAgLy8gQWRkIHNwZWNpYWwgY2FzZSBmb3Jcblx0ICAvLyBcIklmIHRoaXMgbnVtYmVyIGlzIHplcm8sIG9yIGlzIGZvciBhIHN1cnJvZ2F0ZSwgb3IgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgY29kZSBwb2ludFwiXG5cdCAgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy1zeW50YXgvI21heGltdW0tYWxsb3dlZC1jb2RlLXBvaW50XG5cdCAgaWYgKGlzU3Vycm9nYXRlIHx8IGNvZGVQb2ludCA9PT0gMHgwMDAwIHx8IGNvZGVQb2ludCA+IDB4MTBGRkZGKSB7XG5cdCAgICByZXR1cm4gW1wiXFx1RkZGRFwiLCBoZXgubGVuZ3RoICsgKHNwYWNlVGVybWluYXRlZCA/IDEgOiAwKV07XG5cdCAgfVxuXHQgIHJldHVybiBbU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZVBvaW50KSwgaGV4Lmxlbmd0aCArIChzcGFjZVRlcm1pbmF0ZWQgPyAxIDogMCldO1xuXHR9XG5cdHZhciBDT05UQUlOU19FU0NBUEUgPSAvXFxcXC87XG5cdGZ1bmN0aW9uIHVuZXNjKHN0cikge1xuXHQgIHZhciBuZWVkVG9Qcm9jZXNzID0gQ09OVEFJTlNfRVNDQVBFLnRlc3Qoc3RyKTtcblx0ICBpZiAoIW5lZWRUb1Byb2Nlc3MpIHtcblx0ICAgIHJldHVybiBzdHI7XG5cdCAgfVxuXHQgIHZhciByZXQgPSBcIlwiO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAoc3RyW2ldID09PSBcIlxcXFxcIikge1xuXHQgICAgICB2YXIgZ29iYmxlZCA9IGdvYmJsZUhleChzdHIuc2xpY2UoaSArIDEsIGkgKyA3KSk7XG5cdCAgICAgIGlmIChnb2JibGVkICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByZXQgKz0gZ29iYmxlZFswXTtcblx0ICAgICAgICBpICs9IGdvYmJsZWRbMV07XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBSZXRhaW4gYSBwYWlyIG9mIFxcXFwgaWYgZG91YmxlIGVzY2FwZWQgYFxcXFxcXFxcYFxuXHQgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9zdGNzcy9wb3N0Y3NzLXNlbGVjdG9yLXBhcnNlci9jb21taXQvMjY4YzlhNzY1NmZiNTNmNTQzZGM2MjBhYTViNzNhMzBlYzNmZjIwZVxuXHQgICAgICBpZiAoc3RyW2kgKyAxXSA9PT0gXCJcXFxcXCIpIHtcblx0ICAgICAgICByZXQgKz0gXCJcXFxcXCI7XG5cdCAgICAgICAgaSsrO1xuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gaWYgXFxcXCBpcyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcgcmV0YWluIGl0XG5cdCAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3N0Y3NzL3Bvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyL2NvbW1pdC8wMWE2YjM0NmUzNjEyY2UxYWIyMDIxOWFjYzI2YWJkYzI1OWNjZWZiXG5cdCAgICAgIGlmIChzdHIubGVuZ3RoID09PSBpICsgMSkge1xuXHQgICAgICAgIHJldCArPSBzdHJbaV07XG5cdCAgICAgIH1cblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cdCAgICByZXQgKz0gc3RyW2ldO1xuXHQgIH1cblx0ICByZXR1cm4gcmV0O1xuXHR9XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyBcbn0gKHVuZXNjLCB1bmVzYy5leHBvcnRzKSk7XG5cbnZhciB1bmVzY0V4cG9ydHMgPSB1bmVzYy5leHBvcnRzO1xuXG52YXIgZ2V0UHJvcCA9IHtleHBvcnRzOiB7fX07XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBnZXRQcm9wO1xuXHRmdW5jdGlvbiBnZXRQcm9wKG9iaikge1xuXHQgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwcm9wcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdCAgICBwcm9wc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG5cdCAgfVxuXHQgIHdoaWxlIChwcm9wcy5sZW5ndGggPiAwKSB7XG5cdCAgICB2YXIgcHJvcCA9IHByb3BzLnNoaWZ0KCk7XG5cdCAgICBpZiAoIW9ialtwcm9wXSkge1xuXHQgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgfVxuXHQgICAgb2JqID0gb2JqW3Byb3BdO1xuXHQgIH1cblx0ICByZXR1cm4gb2JqO1xuXHR9XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyBcbn0gKGdldFByb3AsIGdldFByb3AuZXhwb3J0cykpO1xuXG52YXIgZ2V0UHJvcEV4cG9ydHMgPSBnZXRQcm9wLmV4cG9ydHM7XG5cbnZhciBlbnN1cmVPYmplY3QgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZW5zdXJlT2JqZWN0O1xuXHRmdW5jdGlvbiBlbnN1cmVPYmplY3Qob2JqKSB7XG5cdCAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHByb3BzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0ICAgIHByb3BzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICB9XG5cdCAgd2hpbGUgKHByb3BzLmxlbmd0aCA+IDApIHtcblx0ICAgIHZhciBwcm9wID0gcHJvcHMuc2hpZnQoKTtcblx0ICAgIGlmICghb2JqW3Byb3BdKSB7XG5cdCAgICAgIG9ialtwcm9wXSA9IHt9O1xuXHQgICAgfVxuXHQgICAgb2JqID0gb2JqW3Byb3BdO1xuXHQgIH1cblx0fVxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsgXG59IChlbnN1cmVPYmplY3QsIGVuc3VyZU9iamVjdC5leHBvcnRzKSk7XG5cbnZhciBlbnN1cmVPYmplY3RFeHBvcnRzID0gZW5zdXJlT2JqZWN0LmV4cG9ydHM7XG5cbnZhciBzdHJpcENvbW1lbnRzID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHN0cmlwQ29tbWVudHM7XG5cdGZ1bmN0aW9uIHN0cmlwQ29tbWVudHMoc3RyKSB7XG5cdCAgdmFyIHMgPSBcIlwiO1xuXHQgIHZhciBjb21tZW50U3RhcnQgPSBzdHIuaW5kZXhPZihcIi8qXCIpO1xuXHQgIHZhciBsYXN0RW5kID0gMDtcblx0ICB3aGlsZSAoY29tbWVudFN0YXJ0ID49IDApIHtcblx0ICAgIHMgPSBzICsgc3RyLnNsaWNlKGxhc3RFbmQsIGNvbW1lbnRTdGFydCk7XG5cdCAgICB2YXIgY29tbWVudEVuZCA9IHN0ci5pbmRleE9mKFwiKi9cIiwgY29tbWVudFN0YXJ0ICsgMik7XG5cdCAgICBpZiAoY29tbWVudEVuZCA8IDApIHtcblx0ICAgICAgcmV0dXJuIHM7XG5cdCAgICB9XG5cdCAgICBsYXN0RW5kID0gY29tbWVudEVuZCArIDI7XG5cdCAgICBjb21tZW50U3RhcnQgPSBzdHIuaW5kZXhPZihcIi8qXCIsIGxhc3RFbmQpO1xuXHQgIH1cblx0ICBzID0gcyArIHN0ci5zbGljZShsYXN0RW5kKTtcblx0ICByZXR1cm4gcztcblx0fVxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsgXG59IChzdHJpcENvbW1lbnRzLCBzdHJpcENvbW1lbnRzLmV4cG9ydHMpKTtcblxudmFyIHN0cmlwQ29tbWVudHNFeHBvcnRzID0gc3RyaXBDb21tZW50cy5leHBvcnRzO1xuXG51dGlsLl9fZXNNb2R1bGUgPSB0cnVlO1xudXRpbC51bmVzYyA9IHV0aWwuc3RyaXBDb21tZW50cyA9IHV0aWwuZ2V0UHJvcCA9IHV0aWwuZW5zdXJlT2JqZWN0ID0gdm9pZCAwO1xudmFyIF91bmVzYyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkMyh1bmVzY0V4cG9ydHMpO1xudXRpbC51bmVzYyA9IF91bmVzY1tcImRlZmF1bHRcIl07XG52YXIgX2dldFByb3AgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0JDMoZ2V0UHJvcEV4cG9ydHMpO1xudXRpbC5nZXRQcm9wID0gX2dldFByb3BbXCJkZWZhdWx0XCJdO1xudmFyIF9lbnN1cmVPYmplY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0JDMoZW5zdXJlT2JqZWN0RXhwb3J0cyk7XG51dGlsLmVuc3VyZU9iamVjdCA9IF9lbnN1cmVPYmplY3RbXCJkZWZhdWx0XCJdO1xudmFyIF9zdHJpcENvbW1lbnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQzKHN0cmlwQ29tbWVudHNFeHBvcnRzKTtcbnV0aWwuc3RyaXBDb21tZW50cyA9IF9zdHJpcENvbW1lbnRzW1wiZGVmYXVsdFwiXTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkMyhvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cdHZhciBfdXRpbCA9IHV0aWw7XG5cdGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblx0ZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cdHZhciBjbG9uZU5vZGUgPSBmdW5jdGlvbiBjbG9uZU5vZGUob2JqLCBwYXJlbnQpIHtcblx0ICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG5cdCAgICByZXR1cm4gb2JqO1xuXHQgIH1cblx0ICB2YXIgY2xvbmVkID0gbmV3IG9iai5jb25zdHJ1Y3RvcigpO1xuXHQgIGZvciAodmFyIGkgaW4gb2JqKSB7XG5cdCAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblx0ICAgIHZhciB2YWx1ZSA9IG9ialtpXTtcblx0ICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXHQgICAgaWYgKGkgPT09ICdwYXJlbnQnICYmIHR5cGUgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgIGlmIChwYXJlbnQpIHtcblx0ICAgICAgICBjbG9uZWRbaV0gPSBwYXJlbnQ7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuXHQgICAgICBjbG9uZWRbaV0gPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKGopIHtcblx0ICAgICAgICByZXR1cm4gY2xvbmVOb2RlKGosIGNsb25lZCk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgY2xvbmVkW2ldID0gY2xvbmVOb2RlKHZhbHVlLCBjbG9uZWQpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gY2xvbmVkO1xuXHR9O1xuXHR2YXIgTm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gTm9kZShvcHRzKSB7XG5cdCAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIG9wdHMgPSB7fTtcblx0ICAgIH1cblx0ICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0cyk7XG5cdCAgICB0aGlzLnNwYWNlcyA9IHRoaXMuc3BhY2VzIHx8IHt9O1xuXHQgICAgdGhpcy5zcGFjZXMuYmVmb3JlID0gdGhpcy5zcGFjZXMuYmVmb3JlIHx8ICcnO1xuXHQgICAgdGhpcy5zcGFjZXMuYWZ0ZXIgPSB0aGlzLnNwYWNlcy5hZnRlciB8fCAnJztcblx0ICB9XG5cdCAgdmFyIF9wcm90byA9IE5vZGUucHJvdG90eXBlO1xuXHQgIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG5cdCAgICBpZiAodGhpcy5wYXJlbnQpIHtcblx0ICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG5cdCAgICB9XG5cdCAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgX3Byb3RvLnJlcGxhY2VXaXRoID0gZnVuY3Rpb24gcmVwbGFjZVdpdGgoKSB7XG5cdCAgICBpZiAodGhpcy5wYXJlbnQpIHtcblx0ICAgICAgZm9yICh2YXIgaW5kZXggaW4gYXJndW1lbnRzKSB7XG5cdCAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIGFyZ3VtZW50c1tpbmRleF0pO1xuXHQgICAgICB9XG5cdCAgICAgIHRoaXMucmVtb3ZlKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIF9wcm90by5uZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcblx0ICAgIHJldHVybiB0aGlzLnBhcmVudC5hdCh0aGlzLnBhcmVudC5pbmRleCh0aGlzKSArIDEpO1xuXHQgIH07XG5cdCAgX3Byb3RvLnByZXYgPSBmdW5jdGlvbiBwcmV2KCkge1xuXHQgICAgcmV0dXJuIHRoaXMucGFyZW50LmF0KHRoaXMucGFyZW50LmluZGV4KHRoaXMpIC0gMSk7XG5cdCAgfTtcblx0ICBfcHJvdG8uY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShvdmVycmlkZXMpIHtcblx0ICAgIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkge1xuXHQgICAgICBvdmVycmlkZXMgPSB7fTtcblx0ICAgIH1cblx0ICAgIHZhciBjbG9uZWQgPSBjbG9uZU5vZGUodGhpcyk7XG5cdCAgICBmb3IgKHZhciBuYW1lIGluIG92ZXJyaWRlcykge1xuXHQgICAgICBjbG9uZWRbbmFtZV0gPSBvdmVycmlkZXNbbmFtZV07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY2xvbmVkO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFNvbWUgbm9uLXN0YW5kYXJkIHN5bnRheCBkb2Vzbid0IGZvbGxvdyBub3JtYWwgZXNjYXBpbmcgcnVsZXMgZm9yIGNzcy5cblx0ICAgKiBUaGlzIGFsbG93cyBub24gc3RhbmRhcmQgc3ludGF4IHRvIGJlIGFwcGVuZGVkIHRvIGFuIGV4aXN0aW5nIHByb3BlcnR5XG5cdCAgICogYnkgc3BlY2lmeWluZyB0aGUgZXNjYXBlZCB2YWx1ZS4gQnkgc3BlY2lmeWluZyB0aGUgZXNjYXBlZCB2YWx1ZSxcblx0ICAgKiBpbGxlZ2FsIGNoYXJhY3RlcnMgYXJlIGFsbG93ZWQgdG8gYmUgZGlyZWN0bHkgaW5zZXJ0ZWQgaW50byBjc3Mgb3V0cHV0LlxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBwcm9wZXJ0eSB0byBzZXRcblx0ICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgdGhlIHVuZXNjYXBlZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVFc2NhcGVkIG9wdGlvbmFsLiB0aGUgZXNjYXBlZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG5cdCAgICovO1xuXHQgIF9wcm90by5hcHBlbmRUb1Byb3BlcnR5QW5kRXNjYXBlID0gZnVuY3Rpb24gYXBwZW5kVG9Qcm9wZXJ0eUFuZEVzY2FwZShuYW1lLCB2YWx1ZSwgdmFsdWVFc2NhcGVkKSB7XG5cdCAgICBpZiAoIXRoaXMucmF3cykge1xuXHQgICAgICB0aGlzLnJhd3MgPSB7fTtcblx0ICAgIH1cblx0ICAgIHZhciBvcmlnaW5hbFZhbHVlID0gdGhpc1tuYW1lXTtcblx0ICAgIHZhciBvcmlnaW5hbEVzY2FwZWQgPSB0aGlzLnJhd3NbbmFtZV07XG5cdCAgICB0aGlzW25hbWVdID0gb3JpZ2luYWxWYWx1ZSArIHZhbHVlOyAvLyB0aGlzIG1heSB0cmlnZ2VyIGEgc2V0dGVyIHRoYXQgdXBkYXRlcyByYXdzLCBzbyBpdCBoYXMgdG8gYmUgc2V0IGZpcnN0LlxuXHQgICAgaWYgKG9yaWdpbmFsRXNjYXBlZCB8fCB2YWx1ZUVzY2FwZWQgIT09IHZhbHVlKSB7XG5cdCAgICAgIHRoaXMucmF3c1tuYW1lXSA9IChvcmlnaW5hbEVzY2FwZWQgfHwgb3JpZ2luYWxWYWx1ZSkgKyB2YWx1ZUVzY2FwZWQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBkZWxldGUgdGhpcy5yYXdzW25hbWVdOyAvLyBkZWxldGUgYW55IGVzY2FwZWQgdmFsdWUgdGhhdCB3YXMgY3JlYXRlZCBieSB0aGUgc2V0dGVyLlxuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFNvbWUgbm9uLXN0YW5kYXJkIHN5bnRheCBkb2Vzbid0IGZvbGxvdyBub3JtYWwgZXNjYXBpbmcgcnVsZXMgZm9yIGNzcy5cblx0ICAgKiBUaGlzIGFsbG93cyB0aGUgZXNjYXBlZCB2YWx1ZSB0byBiZSBzcGVjaWZpZWQgZGlyZWN0bHksIGFsbG93aW5nIGlsbGVnYWxcblx0ICAgKiBjaGFyYWN0ZXJzIHRvIGJlIGRpcmVjdGx5IGluc2VydGVkIGludG8gY3NzIG91dHB1dC5cblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcHJvcGVydHkgdG8gc2V0XG5cdCAgICogQHBhcmFtIHthbnl9IHZhbHVlIHRoZSB1bmVzY2FwZWQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlRXNjYXBlZCB0aGUgZXNjYXBlZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG5cdCAgICovO1xuXHQgIF9wcm90by5zZXRQcm9wZXJ0eUFuZEVzY2FwZSA9IGZ1bmN0aW9uIHNldFByb3BlcnR5QW5kRXNjYXBlKG5hbWUsIHZhbHVlLCB2YWx1ZUVzY2FwZWQpIHtcblx0ICAgIGlmICghdGhpcy5yYXdzKSB7XG5cdCAgICAgIHRoaXMucmF3cyA9IHt9O1xuXHQgICAgfVxuXHQgICAgdGhpc1tuYW1lXSA9IHZhbHVlOyAvLyB0aGlzIG1heSB0cmlnZ2VyIGEgc2V0dGVyIHRoYXQgdXBkYXRlcyByYXdzLCBzbyBpdCBoYXMgdG8gYmUgc2V0IGZpcnN0LlxuXHQgICAgdGhpcy5yYXdzW25hbWVdID0gdmFsdWVFc2NhcGVkO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFdoZW4geW91IHdhbnQgYSB2YWx1ZSB0byBwYXNzZWQgdGhyb3VnaCB0byBDU1MgZGlyZWN0bHkuIFRoaXMgbWV0aG9kXG5cdCAgICogZGVsZXRlcyB0aGUgY29ycmVzcG9uZGluZyByYXcgdmFsdWUgY2F1c2luZyB0aGUgc3RyaW5naWZpZXIgdG8gZmFsbGJhY2tcblx0ICAgKiB0byB0aGUgdW5lc2NhcGVkIHZhbHVlLlxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG5cdCAgICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZSB0aGF0IGlzIGJvdGggZXNjYXBlZCBhbmQgdW5lc2NhcGVkLlxuXHQgICAqLztcblx0ICBfcHJvdG8uc2V0UHJvcGVydHlXaXRob3V0RXNjYXBlID0gZnVuY3Rpb24gc2V0UHJvcGVydHlXaXRob3V0RXNjYXBlKG5hbWUsIHZhbHVlKSB7XG5cdCAgICB0aGlzW25hbWVdID0gdmFsdWU7IC8vIHRoaXMgbWF5IHRyaWdnZXIgYSBzZXR0ZXIgdGhhdCB1cGRhdGVzIHJhd3MsIHNvIGl0IGhhcyB0byBiZSBzZXQgZmlyc3QuXG5cdCAgICBpZiAodGhpcy5yYXdzKSB7XG5cdCAgICAgIGRlbGV0ZSB0aGlzLnJhd3NbbmFtZV07XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge251bWJlcn0gbGluZSBUaGUgbnVtYmVyIChzdGFydGluZyB3aXRoIDEpXG5cdCAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbiBUaGUgY29sdW1uIG51bWJlciAoc3RhcnRpbmcgd2l0aCAxKVxuXHQgICAqLztcblx0ICBfcHJvdG8uaXNBdFBvc2l0aW9uID0gZnVuY3Rpb24gaXNBdFBvc2l0aW9uKGxpbmUsIGNvbHVtbikge1xuXHQgICAgaWYgKHRoaXMuc291cmNlICYmIHRoaXMuc291cmNlLnN0YXJ0ICYmIHRoaXMuc291cmNlLmVuZCkge1xuXHQgICAgICBpZiAodGhpcy5zb3VyY2Uuc3RhcnQubGluZSA+IGxpbmUpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHRoaXMuc291cmNlLmVuZC5saW5lIDwgbGluZSkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodGhpcy5zb3VyY2Uuc3RhcnQubGluZSA9PT0gbGluZSAmJiB0aGlzLnNvdXJjZS5zdGFydC5jb2x1bW4gPiBjb2x1bW4pIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHRoaXMuc291cmNlLmVuZC5saW5lID09PSBsaW5lICYmIHRoaXMuc291cmNlLmVuZC5jb2x1bW4gPCBjb2x1bW4pIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgIH07XG5cdCAgX3Byb3RvLnN0cmluZ2lmeVByb3BlcnR5ID0gZnVuY3Rpb24gc3RyaW5naWZ5UHJvcGVydHkobmFtZSkge1xuXHQgICAgcmV0dXJuIHRoaXMucmF3cyAmJiB0aGlzLnJhd3NbbmFtZV0gfHwgdGhpc1tuYW1lXTtcblx0ICB9O1xuXHQgIF9wcm90by52YWx1ZVRvU3RyaW5nID0gZnVuY3Rpb24gdmFsdWVUb1N0cmluZygpIHtcblx0ICAgIHJldHVybiBTdHJpbmcodGhpcy5zdHJpbmdpZnlQcm9wZXJ0eShcInZhbHVlXCIpKTtcblx0ICB9O1xuXHQgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHQgICAgcmV0dXJuIFt0aGlzLnJhd1NwYWNlQmVmb3JlLCB0aGlzLnZhbHVlVG9TdHJpbmcoKSwgdGhpcy5yYXdTcGFjZUFmdGVyXS5qb2luKCcnKTtcblx0ICB9O1xuXHQgIF9jcmVhdGVDbGFzcyhOb2RlLCBbe1xuXHQgICAga2V5OiBcInJhd1NwYWNlQmVmb3JlXCIsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgdmFyIHJhd1NwYWNlID0gdGhpcy5yYXdzICYmIHRoaXMucmF3cy5zcGFjZXMgJiYgdGhpcy5yYXdzLnNwYWNlcy5iZWZvcmU7XG5cdCAgICAgIGlmIChyYXdTcGFjZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgcmF3U3BhY2UgPSB0aGlzLnNwYWNlcyAmJiB0aGlzLnNwYWNlcy5iZWZvcmU7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJhd1NwYWNlIHx8IFwiXCI7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbiBzZXQocmF3KSB7XG5cdCAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKHRoaXMsIFwicmF3c1wiLCBcInNwYWNlc1wiKTtcblx0ICAgICAgdGhpcy5yYXdzLnNwYWNlcy5iZWZvcmUgPSByYXc7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcInJhd1NwYWNlQWZ0ZXJcIixcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICB2YXIgcmF3U3BhY2UgPSB0aGlzLnJhd3MgJiYgdGhpcy5yYXdzLnNwYWNlcyAmJiB0aGlzLnJhd3Muc3BhY2VzLmFmdGVyO1xuXHQgICAgICBpZiAocmF3U3BhY2UgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHJhd1NwYWNlID0gdGhpcy5zcGFjZXMuYWZ0ZXI7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJhd1NwYWNlIHx8IFwiXCI7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbiBzZXQocmF3KSB7XG5cdCAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKHRoaXMsIFwicmF3c1wiLCBcInNwYWNlc1wiKTtcblx0ICAgICAgdGhpcy5yYXdzLnNwYWNlcy5hZnRlciA9IHJhdztcblx0ICAgIH1cblx0ICB9XSk7XG5cdCAgcmV0dXJuIE5vZGU7XG5cdH0oKTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBOb2RlO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsgXG59IChub2RlJDEsIG5vZGUkMS5leHBvcnRzKSk7XG5cbnZhciBub2RlRXhwb3J0cyA9IG5vZGUkMS5leHBvcnRzO1xuXG52YXIgdHlwZXMgPSB7fTtcblxudHlwZXMuX19lc01vZHVsZSA9IHRydWU7XG50eXBlcy5VTklWRVJTQUwgPSB0eXBlcy5UQUcgPSB0eXBlcy5TVFJJTkcgPSB0eXBlcy5TRUxFQ1RPUiA9IHR5cGVzLlJPT1QgPSB0eXBlcy5QU0VVRE8gPSB0eXBlcy5ORVNUSU5HID0gdHlwZXMuSUQgPSB0eXBlcy5DT01NRU5UID0gdHlwZXMuQ09NQklOQVRPUiA9IHR5cGVzLkNMQVNTID0gdHlwZXMuQVRUUklCVVRFID0gdm9pZCAwO1xudmFyIFRBRyA9ICd0YWcnO1xudHlwZXMuVEFHID0gVEFHO1xudmFyIFNUUklORyA9ICdzdHJpbmcnO1xudHlwZXMuU1RSSU5HID0gU1RSSU5HO1xudmFyIFNFTEVDVE9SID0gJ3NlbGVjdG9yJztcbnR5cGVzLlNFTEVDVE9SID0gU0VMRUNUT1I7XG52YXIgUk9PVCA9ICdyb290JztcbnR5cGVzLlJPT1QgPSBST09UO1xudmFyIFBTRVVETyA9ICdwc2V1ZG8nO1xudHlwZXMuUFNFVURPID0gUFNFVURPO1xudmFyIE5FU1RJTkcgPSAnbmVzdGluZyc7XG50eXBlcy5ORVNUSU5HID0gTkVTVElORztcbnZhciBJRCA9ICdpZCc7XG50eXBlcy5JRCA9IElEO1xudmFyIENPTU1FTlQgPSAnY29tbWVudCc7XG50eXBlcy5DT01NRU5UID0gQ09NTUVOVDtcbnZhciBDT01CSU5BVE9SID0gJ2NvbWJpbmF0b3InO1xudHlwZXMuQ09NQklOQVRPUiA9IENPTUJJTkFUT1I7XG52YXIgQ0xBU1MgPSAnY2xhc3MnO1xudHlwZXMuQ0xBU1MgPSBDTEFTUztcbnZhciBBVFRSSUJVVEUgPSAnYXR0cmlidXRlJztcbnR5cGVzLkFUVFJJQlVURSA9IEFUVFJJQlVURTtcbnZhciBVTklWRVJTQUwgPSAndW5pdmVyc2FsJztcbnR5cGVzLlVOSVZFUlNBTCA9IFVOSVZFUlNBTDtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblx0dmFyIF9ub2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChub2RlRXhwb3J0cyk7XG5cdHZhciB0eXBlcyQxID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQodHlwZXMpO1xuXHRmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXHRmdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpOyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHJldHVybiBmdW5jdGlvbiAoKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cdGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXHRmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblx0ZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXHRmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblx0ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cdGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cdHZhciBDb250YWluZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG5cdCAgX2luaGVyaXRzTG9vc2UoQ29udGFpbmVyLCBfTm9kZSk7XG5cdCAgZnVuY3Rpb24gQ29udGFpbmVyKG9wdHMpIHtcblx0ICAgIHZhciBfdGhpcztcblx0ICAgIF90aGlzID0gX05vZGUuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuXHQgICAgaWYgKCFfdGhpcy5ub2Rlcykge1xuXHQgICAgICBfdGhpcy5ub2RlcyA9IFtdO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH1cblx0ICB2YXIgX3Byb3RvID0gQ29udGFpbmVyLnByb3RvdHlwZTtcblx0ICBfcHJvdG8uYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKHNlbGVjdG9yKSB7XG5cdCAgICBzZWxlY3Rvci5wYXJlbnQgPSB0aGlzO1xuXHQgICAgdGhpcy5ub2Rlcy5wdXNoKHNlbGVjdG9yKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgX3Byb3RvLnByZXBlbmQgPSBmdW5jdGlvbiBwcmVwZW5kKHNlbGVjdG9yKSB7XG5cdCAgICBzZWxlY3Rvci5wYXJlbnQgPSB0aGlzO1xuXHQgICAgdGhpcy5ub2Rlcy51bnNoaWZ0KHNlbGVjdG9yKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgX3Byb3RvLmF0ID0gZnVuY3Rpb24gYXQoaW5kZXgpIHtcblx0ICAgIHJldHVybiB0aGlzLm5vZGVzW2luZGV4XTtcblx0ICB9O1xuXHQgIF9wcm90by5pbmRleCA9IGZ1bmN0aW9uIGluZGV4KGNoaWxkKSB7XG5cdCAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuXHQgICAgICByZXR1cm4gY2hpbGQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5ub2Rlcy5pbmRleE9mKGNoaWxkKTtcblx0ICB9O1xuXHQgIF9wcm90by5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG5cdCAgICBjaGlsZCA9IHRoaXMuaW5kZXgoY2hpbGQpO1xuXHQgICAgdGhpcy5hdChjaGlsZCkucGFyZW50ID0gdW5kZWZpbmVkO1xuXHQgICAgdGhpcy5ub2Rlcy5zcGxpY2UoY2hpbGQsIDEpO1xuXHQgICAgdmFyIGluZGV4O1xuXHQgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5pbmRleGVzKSB7XG5cdCAgICAgIGluZGV4ID0gdGhpcy5pbmRleGVzW2lkXTtcblx0ICAgICAgaWYgKGluZGV4ID49IGNoaWxkKSB7XG5cdCAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4IC0gMTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICBfcHJvdG8ucmVtb3ZlQWxsID0gZnVuY3Rpb24gcmVtb3ZlQWxsKCkge1xuXHQgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0aGlzLm5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcblx0ICAgICAgdmFyIG5vZGUgPSBfc3RlcC52YWx1ZTtcblx0ICAgICAgbm9kZS5wYXJlbnQgPSB1bmRlZmluZWQ7XG5cdCAgICB9XG5cdCAgICB0aGlzLm5vZGVzID0gW107XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIF9wcm90by5lbXB0eSA9IGZ1bmN0aW9uIGVtcHR5KCkge1xuXHQgICAgcmV0dXJuIHRoaXMucmVtb3ZlQWxsKCk7XG5cdCAgfTtcblx0ICBfcHJvdG8uaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiBpbnNlcnRBZnRlcihvbGROb2RlLCBuZXdOb2RlKSB7XG5cdCAgICBuZXdOb2RlLnBhcmVudCA9IHRoaXM7XG5cdCAgICB2YXIgb2xkSW5kZXggPSB0aGlzLmluZGV4KG9sZE5vZGUpO1xuXHQgICAgdGhpcy5ub2Rlcy5zcGxpY2Uob2xkSW5kZXggKyAxLCAwLCBuZXdOb2RlKTtcblx0ICAgIG5ld05vZGUucGFyZW50ID0gdGhpcztcblx0ICAgIHZhciBpbmRleDtcblx0ICAgIGZvciAodmFyIGlkIGluIHRoaXMuaW5kZXhlcykge1xuXHQgICAgICBpbmRleCA9IHRoaXMuaW5kZXhlc1tpZF07XG5cdCAgICAgIGlmIChvbGRJbmRleCA8PSBpbmRleCkge1xuXHQgICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleCArIDE7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgX3Byb3RvLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZShvbGROb2RlLCBuZXdOb2RlKSB7XG5cdCAgICBuZXdOb2RlLnBhcmVudCA9IHRoaXM7XG5cdCAgICB2YXIgb2xkSW5kZXggPSB0aGlzLmluZGV4KG9sZE5vZGUpO1xuXHQgICAgdGhpcy5ub2Rlcy5zcGxpY2Uob2xkSW5kZXgsIDAsIG5ld05vZGUpO1xuXHQgICAgbmV3Tm9kZS5wYXJlbnQgPSB0aGlzO1xuXHQgICAgdmFyIGluZGV4O1xuXHQgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5pbmRleGVzKSB7XG5cdCAgICAgIGluZGV4ID0gdGhpcy5pbmRleGVzW2lkXTtcblx0ICAgICAgaWYgKGluZGV4IDw9IG9sZEluZGV4KSB7XG5cdCAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4ICsgMTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICBfcHJvdG8uX2ZpbmRDaGlsZEF0UG9zaXRpb24gPSBmdW5jdGlvbiBfZmluZENoaWxkQXRQb3NpdGlvbihsaW5lLCBjb2wpIHtcblx0ICAgIHZhciBmb3VuZCA9IHVuZGVmaW5lZDtcblx0ICAgIHRoaXMuZWFjaChmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICBpZiAobm9kZS5hdFBvc2l0aW9uKSB7XG5cdCAgICAgICAgdmFyIGZvdW5kQ2hpbGQgPSBub2RlLmF0UG9zaXRpb24obGluZSwgY29sKTtcblx0ICAgICAgICBpZiAoZm91bmRDaGlsZCkge1xuXHQgICAgICAgICAgZm91bmQgPSBmb3VuZENoaWxkO1xuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIGlmIChub2RlLmlzQXRQb3NpdGlvbihsaW5lLCBjb2wpKSB7XG5cdCAgICAgICAgZm91bmQgPSBub2RlO1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gZm91bmQ7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogUmV0dXJuIHRoZSBtb3N0IHNwZWNpZmljIG5vZGUgYXQgdGhlIGxpbmUgYW5kIGNvbHVtbiBudW1iZXIgZ2l2ZW4uXG5cdCAgICogVGhlIHNvdXJjZSBsb2NhdGlvbiBpcyBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgcGFyc2VkIGxvY2F0aW9uLCBsb2NhdGlvbnMgYXJlbid0XG5cdCAgICogdXBkYXRlZCBhcyBzZWxlY3RvciBub2RlcyBhcmUgbXV0YXRlZC5cblx0ICAgKiBcblx0ICAgKiBOb3RlIHRoYXQgdGhpcyBsb2NhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbG9jYXRpb24gb2YgdGhlIGZpcnN0IGNoYXJhY3RlclxuXHQgICAqIG9mIHRoZSBzZWxlY3RvciwgYW5kIG5vdCB0aGUgbG9jYXRpb24gb2YgdGhlIHNlbGVjdG9yIGluIHRoZSBvdmVyYWxsIGRvY3VtZW50XG5cdCAgICogd2hlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggcG9zdGNzcy5cblx0ICAgKlxuXHQgICAqIElmIG5vdCBmb3VuZCwgcmV0dXJucyB1bmRlZmluZWQuXG5cdCAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmUgVGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBub2RlIHRvIGZpbmQuICgxLWJhc2VkIGluZGV4KVxuXHQgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2wgIFRoZSBjb2x1bW4gbnVtYmVyIG9mIHRoZSBub2RlIHRvIGZpbmQuICgxLWJhc2VkIGluZGV4KVxuXHQgICAqLztcblx0ICBfcHJvdG8uYXRQb3NpdGlvbiA9IGZ1bmN0aW9uIGF0UG9zaXRpb24obGluZSwgY29sKSB7XG5cdCAgICBpZiAodGhpcy5pc0F0UG9zaXRpb24obGluZSwgY29sKSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fZmluZENoaWxkQXRQb3NpdGlvbihsaW5lLCBjb2wpIHx8IHRoaXM7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgX3Byb3RvLl9pbmZlckVuZFBvc2l0aW9uID0gZnVuY3Rpb24gX2luZmVyRW5kUG9zaXRpb24oKSB7XG5cdCAgICBpZiAodGhpcy5sYXN0ICYmIHRoaXMubGFzdC5zb3VyY2UgJiYgdGhpcy5sYXN0LnNvdXJjZS5lbmQpIHtcblx0ICAgICAgdGhpcy5zb3VyY2UgPSB0aGlzLnNvdXJjZSB8fCB7fTtcblx0ICAgICAgdGhpcy5zb3VyY2UuZW5kID0gdGhpcy5zb3VyY2UuZW5kIHx8IHt9O1xuXHQgICAgICBPYmplY3QuYXNzaWduKHRoaXMuc291cmNlLmVuZCwgdGhpcy5sYXN0LnNvdXJjZS5lbmQpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgX3Byb3RvLmVhY2ggPSBmdW5jdGlvbiBlYWNoKGNhbGxiYWNrKSB7XG5cdCAgICBpZiAoIXRoaXMubGFzdEVhY2gpIHtcblx0ICAgICAgdGhpcy5sYXN0RWFjaCA9IDA7XG5cdCAgICB9XG5cdCAgICBpZiAoIXRoaXMuaW5kZXhlcykge1xuXHQgICAgICB0aGlzLmluZGV4ZXMgPSB7fTtcblx0ICAgIH1cblx0ICAgIHRoaXMubGFzdEVhY2grKztcblx0ICAgIHZhciBpZCA9IHRoaXMubGFzdEVhY2g7XG5cdCAgICB0aGlzLmluZGV4ZXNbaWRdID0gMDtcblx0ICAgIGlmICghdGhpcy5sZW5ndGgpIHtcblx0ICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgIH1cblx0ICAgIHZhciBpbmRleCwgcmVzdWx0O1xuXHQgICAgd2hpbGUgKHRoaXMuaW5kZXhlc1tpZF0gPCB0aGlzLmxlbmd0aCkge1xuXHQgICAgICBpbmRleCA9IHRoaXMuaW5kZXhlc1tpZF07XG5cdCAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKHRoaXMuYXQoaW5kZXgpLCBpbmRleCk7XG5cdCAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5pbmRleGVzW2lkXSArPSAxO1xuXHQgICAgfVxuXHQgICAgZGVsZXRlIHRoaXMuaW5kZXhlc1tpZF07XG5cdCAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfTtcblx0ICBfcHJvdG8ud2FsayA9IGZ1bmN0aW9uIHdhbGsoY2FsbGJhY2spIHtcblx0ICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKG5vZGUsIGkpIHtcblx0ICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrKG5vZGUsIGkpO1xuXHQgICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSAmJiBub2RlLmxlbmd0aCkge1xuXHQgICAgICAgIHJlc3VsdCA9IG5vZGUud2FsayhjYWxsYmFjayk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cdCAgX3Byb3RvLndhbGtBdHRyaWJ1dGVzID0gZnVuY3Rpb24gd2Fsa0F0dHJpYnV0ZXMoY2FsbGJhY2spIHtcblx0ICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXHQgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcblx0ICAgICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09IHR5cGVzJDEuQVRUUklCVVRFKSB7XG5cdCAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXMyLCBzZWxlY3Rvcik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cdCAgX3Byb3RvLndhbGtDbGFzc2VzID0gZnVuY3Rpb24gd2Fsa0NsYXNzZXMoY2FsbGJhY2spIHtcblx0ICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXHQgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcblx0ICAgICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09IHR5cGVzJDEuQ0xBU1MpIHtcblx0ICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChfdGhpczMsIHNlbGVjdG9yKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfTtcblx0ICBfcHJvdG8ud2Fsa0NvbWJpbmF0b3JzID0gZnVuY3Rpb24gd2Fsa0NvbWJpbmF0b3JzKGNhbGxiYWNrKSB7XG5cdCAgICB2YXIgX3RoaXM0ID0gdGhpcztcblx0ICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG5cdCAgICAgIGlmIChzZWxlY3Rvci50eXBlID09PSB0eXBlcyQxLkNPTUJJTkFUT1IpIHtcblx0ICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChfdGhpczQsIHNlbGVjdG9yKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfTtcblx0ICBfcHJvdG8ud2Fsa0NvbW1lbnRzID0gZnVuY3Rpb24gd2Fsa0NvbW1lbnRzKGNhbGxiYWNrKSB7XG5cdCAgICB2YXIgX3RoaXM1ID0gdGhpcztcblx0ICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG5cdCAgICAgIGlmIChzZWxlY3Rvci50eXBlID09PSB0eXBlcyQxLkNPTU1FTlQpIHtcblx0ICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChfdGhpczUsIHNlbGVjdG9yKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfTtcblx0ICBfcHJvdG8ud2Fsa0lkcyA9IGZ1bmN0aW9uIHdhbGtJZHMoY2FsbGJhY2spIHtcblx0ICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXHQgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcblx0ICAgICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09IHR5cGVzJDEuSUQpIHtcblx0ICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChfdGhpczYsIHNlbGVjdG9yKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfTtcblx0ICBfcHJvdG8ud2Fsa05lc3RpbmcgPSBmdW5jdGlvbiB3YWxrTmVzdGluZyhjYWxsYmFjaykge1xuXHQgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cdCAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuXHQgICAgICBpZiAoc2VsZWN0b3IudHlwZSA9PT0gdHlwZXMkMS5ORVNUSU5HKSB7XG5cdCAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXM3LCBzZWxlY3Rvcik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cdCAgX3Byb3RvLndhbGtQc2V1ZG9zID0gZnVuY3Rpb24gd2Fsa1BzZXVkb3MoY2FsbGJhY2spIHtcblx0ICAgIHZhciBfdGhpczggPSB0aGlzO1xuXHQgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcblx0ICAgICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09IHR5cGVzJDEuUFNFVURPKSB7XG5cdCAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXM4LCBzZWxlY3Rvcik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cdCAgX3Byb3RvLndhbGtUYWdzID0gZnVuY3Rpb24gd2Fsa1RhZ3MoY2FsbGJhY2spIHtcblx0ICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXHQgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcblx0ICAgICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09IHR5cGVzJDEuVEFHKSB7XG5cdCAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXM5LCBzZWxlY3Rvcik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cdCAgX3Byb3RvLndhbGtVbml2ZXJzYWxzID0gZnVuY3Rpb24gd2Fsa1VuaXZlcnNhbHMoY2FsbGJhY2spIHtcblx0ICAgIHZhciBfdGhpczEwID0gdGhpcztcblx0ICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG5cdCAgICAgIGlmIChzZWxlY3Rvci50eXBlID09PSB0eXBlcyQxLlVOSVZFUlNBTCkge1xuXHQgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKF90aGlzMTAsIHNlbGVjdG9yKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfTtcblx0ICBfcHJvdG8uc3BsaXQgPSBmdW5jdGlvbiBzcGxpdChjYWxsYmFjaykge1xuXHQgICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuXHQgICAgdmFyIGN1cnJlbnQgPSBbXTtcblx0ICAgIHJldHVybiB0aGlzLnJlZHVjZShmdW5jdGlvbiAobWVtbywgbm9kZSwgaW5kZXgpIHtcblx0ICAgICAgdmFyIHNwbGl0ID0gY2FsbGJhY2suY2FsbChfdGhpczExLCBub2RlKTtcblx0ICAgICAgY3VycmVudC5wdXNoKG5vZGUpO1xuXHQgICAgICBpZiAoc3BsaXQpIHtcblx0ICAgICAgICBtZW1vLnB1c2goY3VycmVudCk7XG5cdCAgICAgICAgY3VycmVudCA9IFtdO1xuXHQgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBfdGhpczExLmxlbmd0aCAtIDEpIHtcblx0ICAgICAgICBtZW1vLnB1c2goY3VycmVudCk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG1lbW87XG5cdCAgICB9LCBbXSk7XG5cdCAgfTtcblx0ICBfcHJvdG8ubWFwID0gZnVuY3Rpb24gbWFwKGNhbGxiYWNrKSB7XG5cdCAgICByZXR1cm4gdGhpcy5ub2Rlcy5tYXAoY2FsbGJhY2spO1xuXHQgIH07XG5cdCAgX3Byb3RvLnJlZHVjZSA9IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFjaywgbWVtbykge1xuXHQgICAgcmV0dXJuIHRoaXMubm9kZXMucmVkdWNlKGNhbGxiYWNrLCBtZW1vKTtcblx0ICB9O1xuXHQgIF9wcm90by5ldmVyeSA9IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrKSB7XG5cdCAgICByZXR1cm4gdGhpcy5ub2Rlcy5ldmVyeShjYWxsYmFjayk7XG5cdCAgfTtcblx0ICBfcHJvdG8uc29tZSA9IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2spIHtcblx0ICAgIHJldHVybiB0aGlzLm5vZGVzLnNvbWUoY2FsbGJhY2spO1xuXHQgIH07XG5cdCAgX3Byb3RvLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFjaykge1xuXHQgICAgcmV0dXJuIHRoaXMubm9kZXMuZmlsdGVyKGNhbGxiYWNrKTtcblx0ICB9O1xuXHQgIF9wcm90by5zb3J0ID0gZnVuY3Rpb24gc29ydChjYWxsYmFjaykge1xuXHQgICAgcmV0dXJuIHRoaXMubm9kZXMuc29ydChjYWxsYmFjayk7XG5cdCAgfTtcblx0ICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0ICAgIHJldHVybiB0aGlzLm1hcChTdHJpbmcpLmpvaW4oJycpO1xuXHQgIH07XG5cdCAgX2NyZWF0ZUNsYXNzKENvbnRhaW5lciwgW3tcblx0ICAgIGtleTogXCJmaXJzdFwiLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmF0KDApO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJsYXN0XCIsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuYXQodGhpcy5sZW5ndGggLSAxKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwibGVuZ3RoXCIsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoO1xuXHQgICAgfVxuXHQgIH1dKTtcblx0ICByZXR1cm4gQ29udGFpbmVyO1xuXHR9KF9ub2RlW1wiZGVmYXVsdFwiXSk7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ29udGFpbmVyO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsgXG59IChjb250YWluZXIsIGNvbnRhaW5lci5leHBvcnRzKSk7XG5cbnZhciBjb250YWluZXJFeHBvcnRzID0gY29udGFpbmVyLmV4cG9ydHM7XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cdHZhciBfY29udGFpbmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChjb250YWluZXJFeHBvcnRzKTtcblx0dmFyIF90eXBlcyA9IHR5cGVzO1xuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblx0ZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXHRmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblx0ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cdGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cdHZhciBSb290ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29udGFpbmVyKSB7XG5cdCAgX2luaGVyaXRzTG9vc2UoUm9vdCwgX0NvbnRhaW5lcik7XG5cdCAgZnVuY3Rpb24gUm9vdChvcHRzKSB7XG5cdCAgICB2YXIgX3RoaXM7XG5cdCAgICBfdGhpcyA9IF9Db250YWluZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuXHQgICAgX3RoaXMudHlwZSA9IF90eXBlcy5ST09UO1xuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH1cblx0ICB2YXIgX3Byb3RvID0gUm9vdC5wcm90b3R5cGU7XG5cdCAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdCAgICB2YXIgc3RyID0gdGhpcy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIHNlbGVjdG9yKSB7XG5cdCAgICAgIG1lbW8ucHVzaChTdHJpbmcoc2VsZWN0b3IpKTtcblx0ICAgICAgcmV0dXJuIG1lbW87XG5cdCAgICB9LCBbXSkuam9pbignLCcpO1xuXHQgICAgcmV0dXJuIHRoaXMudHJhaWxpbmdDb21tYSA/IHN0ciArICcsJyA6IHN0cjtcblx0ICB9O1xuXHQgIF9wcm90by5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcblx0ICAgIGlmICh0aGlzLl9lcnJvcikge1xuXHQgICAgICByZXR1cm4gdGhpcy5fZXJyb3IobWVzc2FnZSwgb3B0aW9ucyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgX2NyZWF0ZUNsYXNzKFJvb3QsIFt7XG5cdCAgICBrZXk6IFwiZXJyb3JHZW5lcmF0b3JcIixcblx0ICAgIHNldDogZnVuY3Rpb24gc2V0KGhhbmRsZXIpIHtcblx0ICAgICAgdGhpcy5fZXJyb3IgPSBoYW5kbGVyO1xuXHQgICAgfVxuXHQgIH1dKTtcblx0ICByZXR1cm4gUm9vdDtcblx0fShfY29udGFpbmVyW1wiZGVmYXVsdFwiXSk7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUm9vdDtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IFxufSAocm9vdCQxLCByb290JDEuZXhwb3J0cykpO1xuXG52YXIgcm9vdEV4cG9ydHMgPSByb290JDEuZXhwb3J0cztcblxudmFyIHNlbGVjdG9yJDEgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXHR2YXIgX2NvbnRhaW5lciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoY29udGFpbmVyRXhwb3J0cyk7XG5cdHZhciBfdHlwZXMgPSB0eXBlcztcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cdGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXHRmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXHR2YXIgU2VsZWN0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db250YWluZXIpIHtcblx0ICBfaW5oZXJpdHNMb29zZShTZWxlY3RvciwgX0NvbnRhaW5lcik7XG5cdCAgZnVuY3Rpb24gU2VsZWN0b3Iob3B0cykge1xuXHQgICAgdmFyIF90aGlzO1xuXHQgICAgX3RoaXMgPSBfQ29udGFpbmVyLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcblx0ICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuU0VMRUNUT1I7XG5cdCAgICByZXR1cm4gX3RoaXM7XG5cdCAgfVxuXHQgIHJldHVybiBTZWxlY3Rvcjtcblx0fShfY29udGFpbmVyW1wiZGVmYXVsdFwiXSk7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU2VsZWN0b3I7XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyBcbn0gKHNlbGVjdG9yJDEsIHNlbGVjdG9yJDEuZXhwb3J0cykpO1xuXG52YXIgc2VsZWN0b3JFeHBvcnRzID0gc2VsZWN0b3IkMS5leHBvcnRzO1xuXG52YXIgY2xhc3NOYW1lJDEgPSB7ZXhwb3J0czoge319O1xuXG4vKiEgaHR0cHM6Ly9tdGhzLmJlL2Nzc2VzYyB2My4wLjAgYnkgQG1hdGhpYXMgKi9cblxudmFyIG9iamVjdCA9IHt9O1xudmFyIGhhc093blByb3BlcnR5JDEgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XG52YXIgbWVyZ2UgPSBmdW5jdGlvbiBtZXJnZShvcHRpb25zLCBkZWZhdWx0cykge1xuXHRpZiAoIW9wdGlvbnMpIHtcblx0XHRyZXR1cm4gZGVmYXVsdHM7XG5cdH1cblx0dmFyIHJlc3VsdCA9IHt9O1xuXHRmb3IgKHZhciBrZXkgaW4gZGVmYXVsdHMpIHtcblx0XHQvLyBgaWYgKGRlZmF1bHRzLmhhc093blByb3BlcnR5KGtleSkgeyDigKYgfWAgaXMgbm90IG5lZWRlZCBoZXJlLCBzaW5jZVxuXHRcdC8vIG9ubHkgcmVjb2duaXplZCBvcHRpb24gbmFtZXMgYXJlIHVzZWQuXG5cdFx0cmVzdWx0W2tleV0gPSBoYXNPd25Qcm9wZXJ0eSQxLmNhbGwob3B0aW9ucywga2V5KSA/IG9wdGlvbnNba2V5XSA6IGRlZmF1bHRzW2tleV07XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciByZWdleEFueVNpbmdsZUVzY2FwZSA9IC9bIC0sXFwuXFwvOi1AXFxbLVxcXmBcXHstfl0vO1xudmFyIHJlZ2V4U2luZ2xlRXNjYXBlID0gL1sgLSxcXC5cXC86LUBcXFtcXF1cXF5gXFx7LX5dLztcbnZhciByZWdleEV4Y2Vzc2l2ZVNwYWNlcyA9IC8oXnxcXFxcKyk/KFxcXFxbQS1GMC05XXsxLDZ9KVxceDIwKD8hW2EtZkEtRjAtOVxceDIwXSkvZztcblxuLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2Nzcy1lc2NhcGVzI2Nzc1xudmFyIGNzc2VzYyA9IGZ1bmN0aW9uIGNzc2VzYyhzdHJpbmcsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMsIGNzc2VzYy5vcHRpb25zKTtcblx0aWYgKG9wdGlvbnMucXVvdGVzICE9ICdzaW5nbGUnICYmIG9wdGlvbnMucXVvdGVzICE9ICdkb3VibGUnKSB7XG5cdFx0b3B0aW9ucy5xdW90ZXMgPSAnc2luZ2xlJztcblx0fVxuXHR2YXIgcXVvdGUgPSBvcHRpb25zLnF1b3RlcyA9PSAnZG91YmxlJyA/ICdcIicgOiAnXFwnJztcblx0dmFyIGlzSWRlbnRpZmllciA9IG9wdGlvbnMuaXNJZGVudGlmaWVyO1xuXG5cdHZhciBmaXJzdENoYXIgPSBzdHJpbmcuY2hhckF0KDApO1xuXHR2YXIgb3V0cHV0ID0gJyc7XG5cdHZhciBjb3VudGVyID0gMDtcblx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0dmFyIGNoYXJhY3RlciA9IHN0cmluZy5jaGFyQXQoY291bnRlcisrKTtcblx0XHR2YXIgY29kZVBvaW50ID0gY2hhcmFjdGVyLmNoYXJDb2RlQXQoKTtcblx0XHR2YXIgdmFsdWUgPSB2b2lkIDA7XG5cdFx0Ly8gSWYgaXTigJlzIG5vdCBhIHByaW50YWJsZSBBU0NJSSBjaGFyYWN0ZXLigKZcblx0XHRpZiAoY29kZVBvaW50IDwgMHgyMCB8fCBjb2RlUG9pbnQgPiAweDdFKSB7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gSXTigJlzIGEgaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyLlxuXHRcdFx0XHR2YXIgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHtcblx0XHRcdFx0XHQvLyBuZXh0IGNoYXJhY3RlciBpcyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0Y29kZVBvaW50ID0gKChjb2RlUG9pbnQgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBJdOKAmXMgYW4gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2Vcblx0XHRcdFx0XHQvLyB0aGUgbmV4dCBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuXG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9ICdcXFxcJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArICcgJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKG9wdGlvbnMuZXNjYXBlRXZlcnl0aGluZykge1xuXHRcdFx0XHRpZiAocmVnZXhBbnlTaW5nbGVFc2NhcGUudGVzdChjaGFyYWN0ZXIpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSAnXFxcXCcgKyBjaGFyYWN0ZXI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSAnXFxcXCcgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyAnICc7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoL1tcXHRcXG5cXGZcXHJcXHgwQl0vLnRlc3QoY2hhcmFjdGVyKSkge1xuXHRcdFx0XHR2YWx1ZSA9ICdcXFxcJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArICcgJztcblx0XHRcdH0gZWxzZSBpZiAoY2hhcmFjdGVyID09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyICYmIChjaGFyYWN0ZXIgPT0gJ1wiJyAmJiBxdW90ZSA9PSBjaGFyYWN0ZXIgfHwgY2hhcmFjdGVyID09ICdcXCcnICYmIHF1b3RlID09IGNoYXJhY3RlcikgfHwgaXNJZGVudGlmaWVyICYmIHJlZ2V4U2luZ2xlRXNjYXBlLnRlc3QoY2hhcmFjdGVyKSkge1xuXHRcdFx0XHR2YWx1ZSA9ICdcXFxcJyArIGNoYXJhY3Rlcjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbHVlID0gY2hhcmFjdGVyO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRvdXRwdXQgKz0gdmFsdWU7XG5cdH1cblxuXHRpZiAoaXNJZGVudGlmaWVyKSB7XG5cdFx0aWYgKC9eLVstXFxkXS8udGVzdChvdXRwdXQpKSB7XG5cdFx0XHRvdXRwdXQgPSAnXFxcXC0nICsgb3V0cHV0LnNsaWNlKDEpO1xuXHRcdH0gZWxzZSBpZiAoL1xcZC8udGVzdChmaXJzdENoYXIpKSB7XG5cdFx0XHRvdXRwdXQgPSAnXFxcXDMnICsgZmlyc3RDaGFyICsgJyAnICsgb3V0cHV0LnNsaWNlKDEpO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSBzcGFjZXMgYWZ0ZXIgYFxcSEVYYCBlc2NhcGVzIHRoYXQgYXJlIG5vdCBmb2xsb3dlZCBieSBhIGhleCBkaWdpdCxcblx0Ly8gc2luY2UgdGhleeKAmXJlIHJlZHVuZGFudC4gTm90ZSB0aGF0IHRoaXMgaXMgb25seSBwb3NzaWJsZSBpZiB0aGUgZXNjYXBlXG5cdC8vIHNlcXVlbmNlIGlzbuKAmXQgcHJlY2VkZWQgYnkgYW4gb2RkIG51bWJlciBvZiBiYWNrc2xhc2hlcy5cblx0b3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UocmVnZXhFeGNlc3NpdmVTcGFjZXMsIGZ1bmN0aW9uICgkMCwgJDEsICQyKSB7XG5cdFx0aWYgKCQxICYmICQxLmxlbmd0aCAlIDIpIHtcblx0XHRcdC8vIEl04oCZcyBub3Qgc2FmZSB0byByZW1vdmUgdGhlIHNwYWNlLCBzbyBkb27igJl0LlxuXHRcdFx0cmV0dXJuICQwO1xuXHRcdH1cblx0XHQvLyBTdHJpcCB0aGUgc3BhY2UuXG5cdFx0cmV0dXJuICgkMSB8fCAnJykgKyAkMjtcblx0fSk7XG5cblx0aWYgKCFpc0lkZW50aWZpZXIgJiYgb3B0aW9ucy53cmFwKSB7XG5cdFx0cmV0dXJuIHF1b3RlICsgb3V0cHV0ICsgcXVvdGU7XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn07XG5cbi8vIEV4cG9zZSBkZWZhdWx0IG9wdGlvbnMgKHNvIHRoZXkgY2FuIGJlIG92ZXJyaWRkZW4gZ2xvYmFsbHkpLlxuY3NzZXNjLm9wdGlvbnMgPSB7XG5cdCdlc2NhcGVFdmVyeXRoaW5nJzogZmFsc2UsXG5cdCdpc0lkZW50aWZpZXInOiBmYWxzZSxcblx0J3F1b3Rlcyc6ICdzaW5nbGUnLFxuXHQnd3JhcCc6IGZhbHNlXG59O1xuXG5jc3Nlc2MudmVyc2lvbiA9ICczLjAuMCc7XG5cbnZhciBjc3Nlc2NfMSA9IGNzc2VzYztcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblx0dmFyIF9jc3Nlc2MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGNzc2VzY18xKTtcblx0dmFyIF91dGlsID0gdXRpbDtcblx0dmFyIF9ub2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChub2RlRXhwb3J0cyk7XG5cdHZhciBfdHlwZXMgPSB0eXBlcztcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cdGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblx0ZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cdGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXHRmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXHR2YXIgQ2xhc3NOYW1lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuXHQgIF9pbmhlcml0c0xvb3NlKENsYXNzTmFtZSwgX05vZGUpO1xuXHQgIGZ1bmN0aW9uIENsYXNzTmFtZShvcHRzKSB7XG5cdCAgICB2YXIgX3RoaXM7XG5cdCAgICBfdGhpcyA9IF9Ob2RlLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcblx0ICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuQ0xBU1M7XG5cdCAgICBfdGhpcy5fY29uc3RydWN0ZWQgPSB0cnVlO1xuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH1cblx0ICB2YXIgX3Byb3RvID0gQ2xhc3NOYW1lLnByb3RvdHlwZTtcblx0ICBfcHJvdG8udmFsdWVUb1N0cmluZyA9IGZ1bmN0aW9uIHZhbHVlVG9TdHJpbmcoKSB7XG5cdCAgICByZXR1cm4gJy4nICsgX05vZGUucHJvdG90eXBlLnZhbHVlVG9TdHJpbmcuY2FsbCh0aGlzKTtcblx0ICB9O1xuXHQgIF9jcmVhdGVDbGFzcyhDbGFzc05hbWUsIFt7XG5cdCAgICBrZXk6IFwidmFsdWVcIixcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbiBzZXQodikge1xuXHQgICAgICBpZiAodGhpcy5fY29uc3RydWN0ZWQpIHtcblx0ICAgICAgICB2YXIgZXNjYXBlZCA9ICgwLCBfY3NzZXNjW1wiZGVmYXVsdFwiXSkodiwge1xuXHQgICAgICAgICAgaXNJZGVudGlmaWVyOiB0cnVlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgaWYgKGVzY2FwZWQgIT09IHYpIHtcblx0ICAgICAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKHRoaXMsIFwicmF3c1wiKTtcblx0ICAgICAgICAgIHRoaXMucmF3cy52YWx1ZSA9IGVzY2FwZWQ7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJhd3MpIHtcblx0ICAgICAgICAgIGRlbGV0ZSB0aGlzLnJhd3MudmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHRoaXMuX3ZhbHVlID0gdjtcblx0ICAgIH1cblx0ICB9XSk7XG5cdCAgcmV0dXJuIENsYXNzTmFtZTtcblx0fShfbm9kZVtcImRlZmF1bHRcIl0pO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IENsYXNzTmFtZTtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IFxufSAoY2xhc3NOYW1lJDEsIGNsYXNzTmFtZSQxLmV4cG9ydHMpKTtcblxudmFyIGNsYXNzTmFtZUV4cG9ydHMgPSBjbGFzc05hbWUkMS5leHBvcnRzO1xuXG52YXIgY29tbWVudCQyID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblx0dmFyIF9ub2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChub2RlRXhwb3J0cyk7XG5cdHZhciBfdHlwZXMgPSB0eXBlcztcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cdGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXHRmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXHR2YXIgQ29tbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcblx0ICBfaW5oZXJpdHNMb29zZShDb21tZW50LCBfTm9kZSk7XG5cdCAgZnVuY3Rpb24gQ29tbWVudChvcHRzKSB7XG5cdCAgICB2YXIgX3RoaXM7XG5cdCAgICBfdGhpcyA9IF9Ob2RlLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcblx0ICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuQ09NTUVOVDtcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9XG5cdCAgcmV0dXJuIENvbW1lbnQ7XG5cdH0oX25vZGVbXCJkZWZhdWx0XCJdKTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDb21tZW50O1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsgXG59IChjb21tZW50JDIsIGNvbW1lbnQkMi5leHBvcnRzKSk7XG5cbnZhciBjb21tZW50RXhwb3J0cyA9IGNvbW1lbnQkMi5leHBvcnRzO1xuXG52YXIgaWQkMSA9IHtleHBvcnRzOiB7fX07XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cdHZhciBfbm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQobm9kZUV4cG9ydHMpO1xuXHR2YXIgX3R5cGVzID0gdHlwZXM7XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXHRmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblx0ZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblx0dmFyIElEID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuXHQgIF9pbmhlcml0c0xvb3NlKElELCBfTm9kZSk7XG5cdCAgZnVuY3Rpb24gSUQob3B0cykge1xuXHQgICAgdmFyIF90aGlzO1xuXHQgICAgX3RoaXMgPSBfTm9kZS5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG5cdCAgICBfdGhpcy50eXBlID0gX3R5cGVzLklEO1xuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH1cblx0ICB2YXIgX3Byb3RvID0gSUQucHJvdG90eXBlO1xuXHQgIF9wcm90by52YWx1ZVRvU3RyaW5nID0gZnVuY3Rpb24gdmFsdWVUb1N0cmluZygpIHtcblx0ICAgIHJldHVybiAnIycgKyBfTm9kZS5wcm90b3R5cGUudmFsdWVUb1N0cmluZy5jYWxsKHRoaXMpO1xuXHQgIH07XG5cdCAgcmV0dXJuIElEO1xuXHR9KF9ub2RlW1wiZGVmYXVsdFwiXSk7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gSUQ7XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyBcbn0gKGlkJDEsIGlkJDEuZXhwb3J0cykpO1xuXG52YXIgaWRFeHBvcnRzID0gaWQkMS5leHBvcnRzO1xuXG52YXIgdGFnJDEgPSB7ZXhwb3J0czoge319O1xuXG52YXIgbmFtZXNwYWNlID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblx0dmFyIF9jc3Nlc2MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGNzc2VzY18xKTtcblx0dmFyIF91dGlsID0gdXRpbDtcblx0dmFyIF9ub2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChub2RlRXhwb3J0cyk7XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXHRmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cdGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXHRmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblx0ZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblx0dmFyIE5hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcblx0ICBfaW5oZXJpdHNMb29zZShOYW1lc3BhY2UsIF9Ob2RlKTtcblx0ICBmdW5jdGlvbiBOYW1lc3BhY2UoKSB7XG5cdCAgICByZXR1cm4gX05vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgIH1cblx0ICB2YXIgX3Byb3RvID0gTmFtZXNwYWNlLnByb3RvdHlwZTtcblx0ICBfcHJvdG8ucXVhbGlmaWVkTmFtZSA9IGZ1bmN0aW9uIHF1YWxpZmllZE5hbWUodmFsdWUpIHtcblx0ICAgIGlmICh0aGlzLm5hbWVzcGFjZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VTdHJpbmcgKyBcInxcIiArIHZhbHVlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgX3Byb3RvLnZhbHVlVG9TdHJpbmcgPSBmdW5jdGlvbiB2YWx1ZVRvU3RyaW5nKCkge1xuXHQgICAgcmV0dXJuIHRoaXMucXVhbGlmaWVkTmFtZShfTm9kZS5wcm90b3R5cGUudmFsdWVUb1N0cmluZy5jYWxsKHRoaXMpKTtcblx0ICB9O1xuXHQgIF9jcmVhdGVDbGFzcyhOYW1lc3BhY2UsIFt7XG5cdCAgICBrZXk6IFwibmFtZXNwYWNlXCIsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX25hbWVzcGFjZTtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uIHNldChuYW1lc3BhY2UpIHtcblx0ICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gdHJ1ZSB8fCBuYW1lc3BhY2UgPT09IFwiKlwiIHx8IG5hbWVzcGFjZSA9PT0gXCImXCIpIHtcblx0ICAgICAgICB0aGlzLl9uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdCAgICAgICAgaWYgKHRoaXMucmF3cykge1xuXHQgICAgICAgICAgZGVsZXRlIHRoaXMucmF3cy5uYW1lc3BhY2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgZXNjYXBlZCA9ICgwLCBfY3NzZXNjW1wiZGVmYXVsdFwiXSkobmFtZXNwYWNlLCB7XG5cdCAgICAgICAgaXNJZGVudGlmaWVyOiB0cnVlXG5cdCAgICAgIH0pO1xuXHQgICAgICB0aGlzLl9uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdCAgICAgIGlmIChlc2NhcGVkICE9PSBuYW1lc3BhY2UpIHtcblx0ICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KSh0aGlzLCBcInJhd3NcIik7XG5cdCAgICAgICAgdGhpcy5yYXdzLm5hbWVzcGFjZSA9IGVzY2FwZWQ7XG5cdCAgICAgIH0gZWxzZSBpZiAodGhpcy5yYXdzKSB7XG5cdCAgICAgICAgZGVsZXRlIHRoaXMucmF3cy5uYW1lc3BhY2U7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwibnNcIixcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fbmFtZXNwYWNlO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24gc2V0KG5hbWVzcGFjZSkge1xuXHQgICAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwibmFtZXNwYWNlU3RyaW5nXCIsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgaWYgKHRoaXMubmFtZXNwYWNlKSB7XG5cdCAgICAgICAgdmFyIG5zID0gdGhpcy5zdHJpbmdpZnlQcm9wZXJ0eShcIm5hbWVzcGFjZVwiKTtcblx0ICAgICAgICBpZiAobnMgPT09IHRydWUpIHtcblx0ICAgICAgICAgIHJldHVybiAnJztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmV0dXJuIG5zO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gJyc7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XSk7XG5cdCAgcmV0dXJuIE5hbWVzcGFjZTtcblx0fShfbm9kZVtcImRlZmF1bHRcIl0pO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IE5hbWVzcGFjZTtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IFxufSAobmFtZXNwYWNlLCBuYW1lc3BhY2UuZXhwb3J0cykpO1xuXG52YXIgbmFtZXNwYWNlRXhwb3J0cyA9IG5hbWVzcGFjZS5leHBvcnRzO1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXHR2YXIgX25hbWVzcGFjZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQobmFtZXNwYWNlRXhwb3J0cyk7XG5cdHZhciBfdHlwZXMgPSB0eXBlcztcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cdGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXHRmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXHR2YXIgVGFnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTmFtZXNwYWNlKSB7XG5cdCAgX2luaGVyaXRzTG9vc2UoVGFnLCBfTmFtZXNwYWNlKTtcblx0ICBmdW5jdGlvbiBUYWcob3B0cykge1xuXHQgICAgdmFyIF90aGlzO1xuXHQgICAgX3RoaXMgPSBfTmFtZXNwYWNlLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcblx0ICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuVEFHO1xuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH1cblx0ICByZXR1cm4gVGFnO1xuXHR9KF9uYW1lc3BhY2VbXCJkZWZhdWx0XCJdKTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBUYWc7XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyBcbn0gKHRhZyQxLCB0YWckMS5leHBvcnRzKSk7XG5cbnZhciB0YWdFeHBvcnRzID0gdGFnJDEuZXhwb3J0cztcblxudmFyIHN0cmluZyQxID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblx0dmFyIF9ub2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChub2RlRXhwb3J0cyk7XG5cdHZhciBfdHlwZXMgPSB0eXBlcztcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cdGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXHRmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXHR2YXIgU3RyaW5nID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuXHQgIF9pbmhlcml0c0xvb3NlKFN0cmluZywgX05vZGUpO1xuXHQgIGZ1bmN0aW9uIFN0cmluZyhvcHRzKSB7XG5cdCAgICB2YXIgX3RoaXM7XG5cdCAgICBfdGhpcyA9IF9Ob2RlLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcblx0ICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuU1RSSU5HO1xuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH1cblx0ICByZXR1cm4gU3RyaW5nO1xuXHR9KF9ub2RlW1wiZGVmYXVsdFwiXSk7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU3RyaW5nO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsgXG59IChzdHJpbmckMSwgc3RyaW5nJDEuZXhwb3J0cykpO1xuXG52YXIgc3RyaW5nRXhwb3J0cyA9IHN0cmluZyQxLmV4cG9ydHM7XG5cbnZhciBwc2V1ZG8kMSA9IHtleHBvcnRzOiB7fX07XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cdHZhciBfY29udGFpbmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChjb250YWluZXJFeHBvcnRzKTtcblx0dmFyIF90eXBlcyA9IHR5cGVzO1xuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblx0ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cdGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cdHZhciBQc2V1ZG8gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db250YWluZXIpIHtcblx0ICBfaW5oZXJpdHNMb29zZShQc2V1ZG8sIF9Db250YWluZXIpO1xuXHQgIGZ1bmN0aW9uIFBzZXVkbyhvcHRzKSB7XG5cdCAgICB2YXIgX3RoaXM7XG5cdCAgICBfdGhpcyA9IF9Db250YWluZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuXHQgICAgX3RoaXMudHlwZSA9IF90eXBlcy5QU0VVRE87XG5cdCAgICByZXR1cm4gX3RoaXM7XG5cdCAgfVxuXHQgIHZhciBfcHJvdG8gPSBQc2V1ZG8ucHJvdG90eXBlO1xuXHQgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHQgICAgdmFyIHBhcmFtcyA9IHRoaXMubGVuZ3RoID8gJygnICsgdGhpcy5tYXAoU3RyaW5nKS5qb2luKCcsJykgKyAnKScgOiAnJztcblx0ICAgIHJldHVybiBbdGhpcy5yYXdTcGFjZUJlZm9yZSwgdGhpcy5zdHJpbmdpZnlQcm9wZXJ0eShcInZhbHVlXCIpLCBwYXJhbXMsIHRoaXMucmF3U3BhY2VBZnRlcl0uam9pbignJyk7XG5cdCAgfTtcblx0ICByZXR1cm4gUHNldWRvO1xuXHR9KF9jb250YWluZXJbXCJkZWZhdWx0XCJdKTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBQc2V1ZG87XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyBcbn0gKHBzZXVkbyQxLCBwc2V1ZG8kMS5leHBvcnRzKSk7XG5cbnZhciBwc2V1ZG9FeHBvcnRzID0gcHNldWRvJDEuZXhwb3J0cztcblxudmFyIGF0dHJpYnV0ZSQxID0ge307XG5cbi8qKlxuICogRm9yIE5vZGUuanMsIHNpbXBseSByZS1leHBvcnQgdGhlIGNvcmUgYHV0aWwuZGVwcmVjYXRlYCBmdW5jdGlvbi5cbiAqL1xuXG52YXIgbm9kZSA9IHJlcXVpcmUkJDAkMi5kZXByZWNhdGU7XG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXHRleHBvcnRzLnVuZXNjYXBlVmFsdWUgPSB1bmVzY2FwZVZhbHVlO1xuXHR2YXIgX2Nzc2VzYyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoY3NzZXNjXzEpO1xuXHR2YXIgX3VuZXNjID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCh1bmVzY0V4cG9ydHMpO1xuXHR2YXIgX25hbWVzcGFjZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQobmFtZXNwYWNlRXhwb3J0cyk7XG5cdHZhciBfdHlwZXMgPSB0eXBlcztcblx0dmFyIF9DU1NFU0NfUVVPVEVfT1BUSU9OUztcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cdGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblx0ZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cdGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXHRmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXHR2YXIgZGVwcmVjYXRlID0gbm9kZTtcblx0dmFyIFdSQVBQRURfSU5fUVVPVEVTID0gL14oJ3xcIikoW15dKilcXDEkLztcblx0dmFyIHdhcm5PZkRlcHJlY2F0ZWRWYWx1ZUFzc2lnbm1lbnQgPSBkZXByZWNhdGUoZnVuY3Rpb24gKCkge30sIFwiQXNzaWduaW5nIGFuIGF0dHJpYnV0ZSBhIHZhbHVlIGNvbnRhaW5pbmcgY2hhcmFjdGVycyB0aGF0IG1pZ2h0IG5lZWQgdG8gYmUgZXNjYXBlZCBpcyBkZXByZWNhdGVkLiBcIiArIFwiQ2FsbCBhdHRyaWJ1dGUuc2V0VmFsdWUoKSBpbnN0ZWFkLlwiKTtcblx0dmFyIHdhcm5PZkRlcHJlY2F0ZWRRdW90ZWRBc3NpZ25tZW50ID0gZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHt9LCBcIkFzc2lnbmluZyBhdHRyLnF1b3RlZCBpcyBkZXByZWNhdGVkIGFuZCBoYXMgbm8gZWZmZWN0LiBBc3NpZ24gdG8gYXR0ci5xdW90ZU1hcmsgaW5zdGVhZC5cIik7XG5cdHZhciB3YXJuT2ZEZXByZWNhdGVkQ29uc3RydWN0b3IgPSBkZXByZWNhdGUoZnVuY3Rpb24gKCkge30sIFwiQ29uc3RydWN0aW5nIGFuIEF0dHJpYnV0ZSBzZWxlY3RvciB3aXRoIGEgdmFsdWUgd2l0aG91dCBzcGVjaWZ5aW5nIHF1b3RlTWFyayBpcyBkZXByZWNhdGVkLiBOb3RlOiBUaGUgdmFsdWUgc2hvdWxkIGJlIHVuZXNjYXBlZCBub3cuXCIpO1xuXHRmdW5jdGlvbiB1bmVzY2FwZVZhbHVlKHZhbHVlKSB7XG5cdCAgdmFyIGRlcHJlY2F0ZWRVc2FnZSA9IGZhbHNlO1xuXHQgIHZhciBxdW90ZU1hcmsgPSBudWxsO1xuXHQgIHZhciB1bmVzY2FwZWQgPSB2YWx1ZTtcblx0ICB2YXIgbSA9IHVuZXNjYXBlZC5tYXRjaChXUkFQUEVEX0lOX1FVT1RFUyk7XG5cdCAgaWYgKG0pIHtcblx0ICAgIHF1b3RlTWFyayA9IG1bMV07XG5cdCAgICB1bmVzY2FwZWQgPSBtWzJdO1xuXHQgIH1cblx0ICB1bmVzY2FwZWQgPSAoMCwgX3VuZXNjW1wiZGVmYXVsdFwiXSkodW5lc2NhcGVkKTtcblx0ICBpZiAodW5lc2NhcGVkICE9PSB2YWx1ZSkge1xuXHQgICAgZGVwcmVjYXRlZFVzYWdlID0gdHJ1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIHtcblx0ICAgIGRlcHJlY2F0ZWRVc2FnZTogZGVwcmVjYXRlZFVzYWdlLFxuXHQgICAgdW5lc2NhcGVkOiB1bmVzY2FwZWQsXG5cdCAgICBxdW90ZU1hcms6IHF1b3RlTWFya1xuXHQgIH07XG5cdH1cblx0ZnVuY3Rpb24gaGFuZGxlRGVwcmVjYXRlZENvbnRydWN0b3JPcHRzKG9wdHMpIHtcblx0ICBpZiAob3B0cy5xdW90ZU1hcmsgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuIG9wdHM7XG5cdCAgfVxuXHQgIGlmIChvcHRzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHJldHVybiBvcHRzO1xuXHQgIH1cblx0ICB3YXJuT2ZEZXByZWNhdGVkQ29uc3RydWN0b3IoKTtcblx0ICB2YXIgX3VuZXNjYXBlVmFsdWUgPSB1bmVzY2FwZVZhbHVlKG9wdHMudmFsdWUpLFxuXHQgICAgcXVvdGVNYXJrID0gX3VuZXNjYXBlVmFsdWUucXVvdGVNYXJrLFxuXHQgICAgdW5lc2NhcGVkID0gX3VuZXNjYXBlVmFsdWUudW5lc2NhcGVkO1xuXHQgIGlmICghb3B0cy5yYXdzKSB7XG5cdCAgICBvcHRzLnJhd3MgPSB7fTtcblx0ICB9XG5cdCAgaWYgKG9wdHMucmF3cy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICBvcHRzLnJhd3MudmFsdWUgPSBvcHRzLnZhbHVlO1xuXHQgIH1cblx0ICBvcHRzLnZhbHVlID0gdW5lc2NhcGVkO1xuXHQgIG9wdHMucXVvdGVNYXJrID0gcXVvdGVNYXJrO1xuXHQgIHJldHVybiBvcHRzO1xuXHR9XG5cdHZhciBBdHRyaWJ1dGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9OYW1lc3BhY2UpIHtcblx0ICBfaW5oZXJpdHNMb29zZShBdHRyaWJ1dGUsIF9OYW1lc3BhY2UpO1xuXHQgIGZ1bmN0aW9uIEF0dHJpYnV0ZShvcHRzKSB7XG5cdCAgICB2YXIgX3RoaXM7XG5cdCAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIG9wdHMgPSB7fTtcblx0ICAgIH1cblx0ICAgIF90aGlzID0gX05hbWVzcGFjZS5jYWxsKHRoaXMsIGhhbmRsZURlcHJlY2F0ZWRDb250cnVjdG9yT3B0cyhvcHRzKSkgfHwgdGhpcztcblx0ICAgIF90aGlzLnR5cGUgPSBfdHlwZXMuQVRUUklCVVRFO1xuXHQgICAgX3RoaXMucmF3cyA9IF90aGlzLnJhd3MgfHwge307XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMucmF3cywgJ3VucXVvdGVkJywge1xuXHQgICAgICBnZXQ6IGRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzLnZhbHVlO1xuXHQgICAgICB9LCBcImF0dHIucmF3cy51bnF1b3RlZCBpcyBkZXByZWNhdGVkLiBDYWxsIGF0dHIudmFsdWUgaW5zdGVhZC5cIiksXG5cdCAgICAgIHNldDogZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX3RoaXMudmFsdWU7XG5cdCAgICAgIH0sIFwiU2V0dGluZyBhdHRyLnJhd3MudW5xdW90ZWQgaXMgZGVwcmVjYXRlZCBhbmQgaGFzIG5vIGVmZmVjdC4gYXR0ci52YWx1ZSBpcyB1bmVzY2FwZWQgYnkgZGVmYXVsdCBub3cuXCIpXG5cdCAgICB9KTtcblx0ICAgIF90aGlzLl9jb25zdHJ1Y3RlZCA9IHRydWU7XG5cdCAgICByZXR1cm4gX3RoaXM7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogUmV0dXJucyB0aGUgQXR0cmlidXRlJ3MgdmFsdWUgcXVvdGVkIHN1Y2ggdGhhdCBpdCB3b3VsZCBiZSBsZWdhbCB0byB1c2Vcblx0ICAgKiBpbiB0aGUgdmFsdWUgb2YgYSBjc3MgZmlsZS4gVGhlIG9yaWdpbmFsIHZhbHVlJ3MgcXVvdGF0aW9uIHNldHRpbmdcblx0ICAgKiB1c2VkIGZvciBzdHJpbmdpZmljYXRpb24gaXMgbGVmdCB1bmNoYW5nZWQuIFNlZSBgc2V0VmFsdWUodmFsdWUsIG9wdGlvbnMpYFxuXHQgICAqIGlmIHlvdSB3YW50IHRvIGNvbnRyb2wgdGhlIHF1b3RlIHNldHRpbmdzIG9mIGEgbmV3IHZhbHVlIGZvciB0aGUgYXR0cmlidXRlLlxuXHQgICAqXG5cdCAgICogWW91IGNhbiBhbHNvIGNoYW5nZSB0aGUgcXVvdGF0aW9uIHVzZWQgZm9yIHRoZSBjdXJyZW50IHZhbHVlIGJ5IHNldHRpbmcgcXVvdGVNYXJrLlxuXHQgICAqXG5cdCAgICogT3B0aW9uczpcblx0ICAgKiAgICogcXVvdGVNYXJrIHsnXCInIHwgXCInXCIgfCBudWxsfSAtIFVzZSB0aGlzIHZhbHVlIHRvIHF1b3RlIHRoZSB2YWx1ZS4gSWYgdGhpc1xuXHQgICAqICAgICBvcHRpb24gaXMgbm90IHNldCwgdGhlIG9yaWdpbmFsIHZhbHVlIGZvciBxdW90ZU1hcmsgd2lsbCBiZSB1c2VkLiBJZlxuXHQgICAqICAgICBpbmRldGVybWluYXRlLCBhIGRvdWJsZSBxdW90ZSBpcyB1c2VkLiBUaGUgbGVnYWwgdmFsdWVzIGFyZTpcblx0ICAgKiAgICAgKiBgbnVsbGAgLSB0aGUgdmFsdWUgd2lsbCBiZSB1bnF1b3RlZCBhbmQgY2hhcmFjdGVycyB3aWxsIGJlIGVzY2FwZWQgYXMgbmVjZXNzYXJ5LlxuXHQgICAqICAgICAqIGAnYCAtIHRoZSB2YWx1ZSB3aWxsIGJlIHF1b3RlZCB3aXRoIGEgc2luZ2xlIHF1b3RlIGFuZCBzaW5nbGUgcXVvdGVzIGFyZSBlc2NhcGVkLlxuXHQgICAqICAgICAqIGBcImAgLSB0aGUgdmFsdWUgd2lsbCBiZSBxdW90ZWQgd2l0aCBhIGRvdWJsZSBxdW90ZSBhbmQgZG91YmxlIHF1b3RlcyBhcmUgZXNjYXBlZC5cblx0ICAgKiAgICogcHJlZmVyQ3VycmVudFF1b3RlTWFyayB7Ym9vbGVhbn0gLSBpZiB0cnVlLCBwcmVmZXIgdGhlIHNvdXJjZSBxdW90ZSBtYXJrXG5cdCAgICogICAgIG92ZXIgdGhlIHF1b3RlTWFyayBvcHRpb24gdmFsdWUuXG5cdCAgICogICAqIHNtYXJ0IHtib29sZWFufSAtIGlmIHRydWUsIHdpbGwgc2VsZWN0IGEgcXVvdGUgbWFyayBiYXNlZCBvbiB0aGUgdmFsdWVcblx0ICAgKiAgICAgYW5kIHRoZSBvdGhlciBvcHRpb25zIHNwZWNpZmllZCBoZXJlLiBTZWUgdGhlIGBzbWFydFF1b3RlTWFyaygpYFxuXHQgICAqICAgICBtZXRob2QuXG5cdCAgICoqL1xuXHQgIHZhciBfcHJvdG8gPSBBdHRyaWJ1dGUucHJvdG90eXBlO1xuXHQgIF9wcm90by5nZXRRdW90ZWRWYWx1ZSA9IGZ1bmN0aW9uIGdldFF1b3RlZFZhbHVlKG9wdGlvbnMpIHtcblx0ICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcblx0ICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgfVxuXHQgICAgdmFyIHF1b3RlTWFyayA9IHRoaXMuX2RldGVybWluZVF1b3RlTWFyayhvcHRpb25zKTtcblx0ICAgIHZhciBjc3Nlc2NvcHRzID0gQ1NTRVNDX1FVT1RFX09QVElPTlNbcXVvdGVNYXJrXTtcblx0ICAgIHZhciBlc2NhcGVkID0gKDAsIF9jc3Nlc2NbXCJkZWZhdWx0XCJdKSh0aGlzLl92YWx1ZSwgY3NzZXNjb3B0cyk7XG5cdCAgICByZXR1cm4gZXNjYXBlZDtcblx0ICB9O1xuXHQgIF9wcm90by5fZGV0ZXJtaW5lUXVvdGVNYXJrID0gZnVuY3Rpb24gX2RldGVybWluZVF1b3RlTWFyayhvcHRpb25zKSB7XG5cdCAgICByZXR1cm4gb3B0aW9ucy5zbWFydCA/IHRoaXMuc21hcnRRdW90ZU1hcmsob3B0aW9ucykgOiB0aGlzLnByZWZlcnJlZFF1b3RlTWFyayhvcHRpb25zKTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBTZXQgdGhlIHVuZXNjYXBlZCB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQgcXVvdGF0aW9uIG9wdGlvbnMuIFRoZSB2YWx1ZVxuXHQgICAqIHByb3ZpZGVkIG11c3Qgbm90IGluY2x1ZGUgYW55IHdyYXBwaW5nIHF1b3RlIG1hcmtzIC0tIHRob3NlIHF1b3RlcyB3aWxsXG5cdCAgICogYmUgaW50ZXJwcmV0ZWQgYXMgcGFydCBvZiB0aGUgdmFsdWUgYW5kIGVzY2FwZWQgYWNjb3JkaW5nbHkuXG5cdCAgICovO1xuXHQgIF9wcm90by5zZXRWYWx1ZSA9IGZ1bmN0aW9uIHNldFZhbHVlKHZhbHVlLCBvcHRpb25zKSB7XG5cdCAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cdCAgICB0aGlzLl9xdW90ZU1hcmsgPSB0aGlzLl9kZXRlcm1pbmVRdW90ZU1hcmsob3B0aW9ucyk7XG5cdCAgICB0aGlzLl9zeW5jUmF3VmFsdWUoKTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBJbnRlbGxpZ2VudGx5IHNlbGVjdCBhIHF1b3RlTWFyayB2YWx1ZSBiYXNlZCBvbiB0aGUgdmFsdWUncyBjb250ZW50cy4gSWZcblx0ICAgKiB0aGUgdmFsdWUgaXMgYSBsZWdhbCBDU1MgaWRlbnQsIGl0IHdpbGwgbm90IGJlIHF1b3RlZC4gT3RoZXJ3aXNlIGEgcXVvdGVcblx0ICAgKiBtYXJrIHdpbGwgYmUgcGlja2VkIHRoYXQgbWluaW1pemVzIHRoZSBudW1iZXIgb2YgZXNjYXBlcy5cblx0ICAgKlxuXHQgICAqIElmIHRoZXJlJ3Mgbm8gY2xlYXIgd2lubmVyLCB0aGUgcXVvdGUgbWFyayBmcm9tIHRoZXNlIG9wdGlvbnMgaXMgdXNlZCxcblx0ICAgKiB0aGVuIHRoZSBzb3VyY2UgcXVvdGUgbWFyayAodGhpcyBpcyBpbnZlcnRlZCBpZiBgcHJlZmVyQ3VycmVudFF1b3RlTWFya2AgaXNcblx0ICAgKiB0cnVlKS4gSWYgdGhlIHF1b3RlTWFyayBpcyB1bnNwZWNpZmllZCwgYSBkb3VibGUgcXVvdGUgaXMgdXNlZC5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSBvcHRpb25zIFRoaXMgdGFrZXMgdGhlIHF1b3RlTWFyayBhbmQgcHJlZmVyQ3VycmVudFF1b3RlTWFyayBvcHRpb25zXG5cdCAgICogZnJvbSB0aGUgcXVvdGVWYWx1ZSBtZXRob2QuXG5cdCAgICovO1xuXHQgIF9wcm90by5zbWFydFF1b3RlTWFyayA9IGZ1bmN0aW9uIHNtYXJ0UXVvdGVNYXJrKG9wdGlvbnMpIHtcblx0ICAgIHZhciB2ID0gdGhpcy52YWx1ZTtcblx0ICAgIHZhciBudW1TaW5nbGVRdW90ZXMgPSB2LnJlcGxhY2UoL1teJ10vZywgJycpLmxlbmd0aDtcblx0ICAgIHZhciBudW1Eb3VibGVRdW90ZXMgPSB2LnJlcGxhY2UoL1teXCJdL2csICcnKS5sZW5ndGg7XG5cdCAgICBpZiAobnVtU2luZ2xlUXVvdGVzICsgbnVtRG91YmxlUXVvdGVzID09PSAwKSB7XG5cdCAgICAgIHZhciBlc2NhcGVkID0gKDAsIF9jc3Nlc2NbXCJkZWZhdWx0XCJdKSh2LCB7XG5cdCAgICAgICAgaXNJZGVudGlmaWVyOiB0cnVlXG5cdCAgICAgIH0pO1xuXHQgICAgICBpZiAoZXNjYXBlZCA9PT0gdikge1xuXHQgICAgICAgIHJldHVybiBBdHRyaWJ1dGUuTk9fUVVPVEU7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIHByZWYgPSB0aGlzLnByZWZlcnJlZFF1b3RlTWFyayhvcHRpb25zKTtcblx0ICAgICAgICBpZiAocHJlZiA9PT0gQXR0cmlidXRlLk5PX1FVT1RFKSB7XG5cdCAgICAgICAgICAvLyBwaWNrIGEgcXVvdGUgbWFyayB0aGF0IGlzbid0IG5vbmUgYW5kIHNlZSBpZiBpdCdzIHNtYWxsZXJcblx0ICAgICAgICAgIHZhciBxdW90ZSA9IHRoaXMucXVvdGVNYXJrIHx8IG9wdGlvbnMucXVvdGVNYXJrIHx8IEF0dHJpYnV0ZS5ET1VCTEVfUVVPVEU7XG5cdCAgICAgICAgICB2YXIgb3B0cyA9IENTU0VTQ19RVU9URV9PUFRJT05TW3F1b3RlXTtcblx0ICAgICAgICAgIHZhciBxdW90ZVZhbHVlID0gKDAsIF9jc3Nlc2NbXCJkZWZhdWx0XCJdKSh2LCBvcHRzKTtcblx0ICAgICAgICAgIGlmIChxdW90ZVZhbHVlLmxlbmd0aCA8IGVzY2FwZWQubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBxdW90ZTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHByZWY7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAobnVtRG91YmxlUXVvdGVzID09PSBudW1TaW5nbGVRdW90ZXMpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucHJlZmVycmVkUXVvdGVNYXJrKG9wdGlvbnMpO1xuXHQgICAgfSBlbHNlIGlmIChudW1Eb3VibGVRdW90ZXMgPCBudW1TaW5nbGVRdW90ZXMpIHtcblx0ICAgICAgcmV0dXJuIEF0dHJpYnV0ZS5ET1VCTEVfUVVPVEU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gQXR0cmlidXRlLlNJTkdMRV9RVU9URTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBTZWxlY3RzIHRoZSBwcmVmZXJyZWQgcXVvdGUgbWFyayBiYXNlZCBvbiB0aGUgb3B0aW9ucyBhbmQgdGhlIGN1cnJlbnQgcXVvdGUgbWFyayB2YWx1ZS5cblx0ICAgKiBJZiB5b3Ugd2FudCB0aGUgcXVvdGUgbWFyayB0byBkZXBlbmQgb24gdGhlIGF0dHJpYnV0ZSB2YWx1ZSwgY2FsbCBgc21hcnRRdW90ZU1hcmsob3B0cylgXG5cdCAgICogaW5zdGVhZC5cblx0ICAgKi87XG5cdCAgX3Byb3RvLnByZWZlcnJlZFF1b3RlTWFyayA9IGZ1bmN0aW9uIHByZWZlcnJlZFF1b3RlTWFyayhvcHRpb25zKSB7XG5cdCAgICB2YXIgcXVvdGVNYXJrID0gb3B0aW9ucy5wcmVmZXJDdXJyZW50UXVvdGVNYXJrID8gdGhpcy5xdW90ZU1hcmsgOiBvcHRpb25zLnF1b3RlTWFyaztcblx0ICAgIGlmIChxdW90ZU1hcmsgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBxdW90ZU1hcmsgPSBvcHRpb25zLnByZWZlckN1cnJlbnRRdW90ZU1hcmsgPyBvcHRpb25zLnF1b3RlTWFyayA6IHRoaXMucXVvdGVNYXJrO1xuXHQgICAgfVxuXHQgICAgaWYgKHF1b3RlTWFyayA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIHF1b3RlTWFyayA9IEF0dHJpYnV0ZS5ET1VCTEVfUVVPVEU7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcXVvdGVNYXJrO1xuXHQgIH07XG5cdCAgX3Byb3RvLl9zeW5jUmF3VmFsdWUgPSBmdW5jdGlvbiBfc3luY1Jhd1ZhbHVlKCkge1xuXHQgICAgdmFyIHJhd1ZhbHVlID0gKDAsIF9jc3Nlc2NbXCJkZWZhdWx0XCJdKSh0aGlzLl92YWx1ZSwgQ1NTRVNDX1FVT1RFX09QVElPTlNbdGhpcy5xdW90ZU1hcmtdKTtcblx0ICAgIGlmIChyYXdWYWx1ZSA9PT0gdGhpcy5fdmFsdWUpIHtcblx0ICAgICAgaWYgKHRoaXMucmF3cykge1xuXHQgICAgICAgIGRlbGV0ZSB0aGlzLnJhd3MudmFsdWU7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMucmF3cy52YWx1ZSA9IHJhd1ZhbHVlO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgX3Byb3RvLl9oYW5kbGVFc2NhcGVzID0gZnVuY3Rpb24gX2hhbmRsZUVzY2FwZXMocHJvcCwgdmFsdWUpIHtcblx0ICAgIGlmICh0aGlzLl9jb25zdHJ1Y3RlZCkge1xuXHQgICAgICB2YXIgZXNjYXBlZCA9ICgwLCBfY3NzZXNjW1wiZGVmYXVsdFwiXSkodmFsdWUsIHtcblx0ICAgICAgICBpc0lkZW50aWZpZXI6IHRydWVcblx0ICAgICAgfSk7XG5cdCAgICAgIGlmIChlc2NhcGVkICE9PSB2YWx1ZSkge1xuXHQgICAgICAgIHRoaXMucmF3c1twcm9wXSA9IGVzY2FwZWQ7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZGVsZXRlIHRoaXMucmF3c1twcm9wXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdCAgX3Byb3RvLl9zcGFjZXNGb3IgPSBmdW5jdGlvbiBfc3BhY2VzRm9yKG5hbWUpIHtcblx0ICAgIHZhciBhdHRyU3BhY2VzID0ge1xuXHQgICAgICBiZWZvcmU6ICcnLFxuXHQgICAgICBhZnRlcjogJydcblx0ICAgIH07XG5cdCAgICB2YXIgc3BhY2VzID0gdGhpcy5zcGFjZXNbbmFtZV0gfHwge307XG5cdCAgICB2YXIgcmF3U3BhY2VzID0gdGhpcy5yYXdzLnNwYWNlcyAmJiB0aGlzLnJhd3Muc3BhY2VzW25hbWVdIHx8IHt9O1xuXHQgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYXR0clNwYWNlcywgc3BhY2VzLCByYXdTcGFjZXMpO1xuXHQgIH07XG5cdCAgX3Byb3RvLl9zdHJpbmdGb3IgPSBmdW5jdGlvbiBfc3RyaW5nRm9yKG5hbWUsIHNwYWNlTmFtZSwgY29uY2F0KSB7XG5cdCAgICBpZiAoc3BhY2VOYW1lID09PSB2b2lkIDApIHtcblx0ICAgICAgc3BhY2VOYW1lID0gbmFtZTtcblx0ICAgIH1cblx0ICAgIGlmIChjb25jYXQgPT09IHZvaWQgMCkge1xuXHQgICAgICBjb25jYXQgPSBkZWZhdWx0QXR0ckNvbmNhdDtcblx0ICAgIH1cblx0ICAgIHZhciBhdHRyU3BhY2VzID0gdGhpcy5fc3BhY2VzRm9yKHNwYWNlTmFtZSk7XG5cdCAgICByZXR1cm4gY29uY2F0KHRoaXMuc3RyaW5naWZ5UHJvcGVydHkobmFtZSksIGF0dHJTcGFjZXMpO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIHJldHVybnMgdGhlIG9mZnNldCBvZiB0aGUgYXR0cmlidXRlIHBhcnQgc3BlY2lmaWVkIHJlbGF0aXZlIHRvIHRoZVxuXHQgICAqIHN0YXJ0IG9mIHRoZSBub2RlIG9mIHRoZSBvdXRwdXQgc3RyaW5nLlxuXHQgICAqXG5cdCAgICogKiBcIm5zXCIgLSBhbGlhcyBmb3IgXCJuYW1lc3BhY2VcIlxuXHQgICAqICogXCJuYW1lc3BhY2VcIiAtIHRoZSBuYW1lc3BhY2UgaWYgaXQgZXhpc3RzLlxuXHQgICAqICogXCJhdHRyaWJ1dGVcIiAtIHRoZSBhdHRyaWJ1dGUgbmFtZVxuXHQgICAqICogXCJhdHRyaWJ1dGVOU1wiIC0gdGhlIHN0YXJ0IG9mIHRoZSBhdHRyaWJ1dGUgb3IgaXRzIG5hbWVzcGFjZVxuXHQgICAqICogXCJvcGVyYXRvclwiIC0gdGhlIG1hdGNoIG9wZXJhdG9yIG9mIHRoZSBhdHRyaWJ1dGVcblx0ICAgKiAqIFwidmFsdWVcIiAtIFRoZSB2YWx1ZSAoc3RyaW5nIG9yIGlkZW50aWZpZXIpXG5cdCAgICogKiBcImluc2Vuc2l0aXZlXCIgLSB0aGUgY2FzZSBpbnNlbnNpdGl2aXR5IGZsYWc7XG5cdCAgICogQHBhcmFtIHBhcnQgT25lIG9mIHRoZSBwb3NzaWJsZSB2YWx1ZXMgaW5zaWRlIGFuIGF0dHJpYnV0ZS5cblx0ICAgKiBAcmV0dXJucyAtMSBpZiB0aGUgbmFtZSBpcyBpbnZhbGlkIG9yIHRoZSB2YWx1ZSBkb2Vzbid0IGV4aXN0IGluIHRoaXMgYXR0cmlidXRlLlxuXHQgICAqLztcblx0ICBfcHJvdG8ub2Zmc2V0T2YgPSBmdW5jdGlvbiBvZmZzZXRPZihuYW1lKSB7XG5cdCAgICB2YXIgY291bnQgPSAxO1xuXHQgICAgdmFyIGF0dHJpYnV0ZVNwYWNlcyA9IHRoaXMuX3NwYWNlc0ZvcihcImF0dHJpYnV0ZVwiKTtcblx0ICAgIGNvdW50ICs9IGF0dHJpYnV0ZVNwYWNlcy5iZWZvcmUubGVuZ3RoO1xuXHQgICAgaWYgKG5hbWUgPT09IFwibmFtZXNwYWNlXCIgfHwgbmFtZSA9PT0gXCJuc1wiKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLm5hbWVzcGFjZSA/IGNvdW50IDogLTE7XG5cdCAgICB9XG5cdCAgICBpZiAobmFtZSA9PT0gXCJhdHRyaWJ1dGVOU1wiKSB7XG5cdCAgICAgIHJldHVybiBjb3VudDtcblx0ICAgIH1cblx0ICAgIGNvdW50ICs9IHRoaXMubmFtZXNwYWNlU3RyaW5nLmxlbmd0aDtcblx0ICAgIGlmICh0aGlzLm5hbWVzcGFjZSkge1xuXHQgICAgICBjb3VudCArPSAxO1xuXHQgICAgfVxuXHQgICAgaWYgKG5hbWUgPT09IFwiYXR0cmlidXRlXCIpIHtcblx0ICAgICAgcmV0dXJuIGNvdW50O1xuXHQgICAgfVxuXHQgICAgY291bnQgKz0gdGhpcy5zdHJpbmdpZnlQcm9wZXJ0eShcImF0dHJpYnV0ZVwiKS5sZW5ndGg7XG5cdCAgICBjb3VudCArPSBhdHRyaWJ1dGVTcGFjZXMuYWZ0ZXIubGVuZ3RoO1xuXHQgICAgdmFyIG9wZXJhdG9yU3BhY2VzID0gdGhpcy5fc3BhY2VzRm9yKFwib3BlcmF0b3JcIik7XG5cdCAgICBjb3VudCArPSBvcGVyYXRvclNwYWNlcy5iZWZvcmUubGVuZ3RoO1xuXHQgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5zdHJpbmdpZnlQcm9wZXJ0eShcIm9wZXJhdG9yXCIpO1xuXHQgICAgaWYgKG5hbWUgPT09IFwib3BlcmF0b3JcIikge1xuXHQgICAgICByZXR1cm4gb3BlcmF0b3IgPyBjb3VudCA6IC0xO1xuXHQgICAgfVxuXHQgICAgY291bnQgKz0gb3BlcmF0b3IubGVuZ3RoO1xuXHQgICAgY291bnQgKz0gb3BlcmF0b3JTcGFjZXMuYWZ0ZXIubGVuZ3RoO1xuXHQgICAgdmFyIHZhbHVlU3BhY2VzID0gdGhpcy5fc3BhY2VzRm9yKFwidmFsdWVcIik7XG5cdCAgICBjb3VudCArPSB2YWx1ZVNwYWNlcy5iZWZvcmUubGVuZ3RoO1xuXHQgICAgdmFyIHZhbHVlID0gdGhpcy5zdHJpbmdpZnlQcm9wZXJ0eShcInZhbHVlXCIpO1xuXHQgICAgaWYgKG5hbWUgPT09IFwidmFsdWVcIikge1xuXHQgICAgICByZXR1cm4gdmFsdWUgPyBjb3VudCA6IC0xO1xuXHQgICAgfVxuXHQgICAgY291bnQgKz0gdmFsdWUubGVuZ3RoO1xuXHQgICAgY291bnQgKz0gdmFsdWVTcGFjZXMuYWZ0ZXIubGVuZ3RoO1xuXHQgICAgdmFyIGluc2Vuc2l0aXZlU3BhY2VzID0gdGhpcy5fc3BhY2VzRm9yKFwiaW5zZW5zaXRpdmVcIik7XG5cdCAgICBjb3VudCArPSBpbnNlbnNpdGl2ZVNwYWNlcy5iZWZvcmUubGVuZ3RoO1xuXHQgICAgaWYgKG5hbWUgPT09IFwiaW5zZW5zaXRpdmVcIikge1xuXHQgICAgICByZXR1cm4gdGhpcy5pbnNlbnNpdGl2ZSA/IGNvdW50IDogLTE7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gLTE7XG5cdCAgfTtcblx0ICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0ICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXHQgICAgdmFyIHNlbGVjdG9yID0gW3RoaXMucmF3U3BhY2VCZWZvcmUsICdbJ107XG5cdCAgICBzZWxlY3Rvci5wdXNoKHRoaXMuX3N0cmluZ0ZvcigncXVhbGlmaWVkQXR0cmlidXRlJywgJ2F0dHJpYnV0ZScpKTtcblx0ICAgIGlmICh0aGlzLm9wZXJhdG9yICYmICh0aGlzLnZhbHVlIHx8IHRoaXMudmFsdWUgPT09ICcnKSkge1xuXHQgICAgICBzZWxlY3Rvci5wdXNoKHRoaXMuX3N0cmluZ0Zvcignb3BlcmF0b3InKSk7XG5cdCAgICAgIHNlbGVjdG9yLnB1c2godGhpcy5fc3RyaW5nRm9yKCd2YWx1ZScpKTtcblx0ICAgICAgc2VsZWN0b3IucHVzaCh0aGlzLl9zdHJpbmdGb3IoJ2luc2Vuc2l0aXZlRmxhZycsICdpbnNlbnNpdGl2ZScsIGZ1bmN0aW9uIChhdHRyVmFsdWUsIGF0dHJTcGFjZXMpIHtcblx0ICAgICAgICBpZiAoYXR0clZhbHVlLmxlbmd0aCA+IDAgJiYgIV90aGlzMi5xdW90ZWQgJiYgYXR0clNwYWNlcy5iZWZvcmUubGVuZ3RoID09PSAwICYmICEoX3RoaXMyLnNwYWNlcy52YWx1ZSAmJiBfdGhpczIuc3BhY2VzLnZhbHVlLmFmdGVyKSkge1xuXHQgICAgICAgICAgYXR0clNwYWNlcy5iZWZvcmUgPSBcIiBcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGRlZmF1bHRBdHRyQ29uY2F0KGF0dHJWYWx1ZSwgYXR0clNwYWNlcyk7XG5cdCAgICAgIH0pKTtcblx0ICAgIH1cblx0ICAgIHNlbGVjdG9yLnB1c2goJ10nKTtcblx0ICAgIHNlbGVjdG9yLnB1c2godGhpcy5yYXdTcGFjZUFmdGVyKTtcblx0ICAgIHJldHVybiBzZWxlY3Rvci5qb2luKCcnKTtcblx0ICB9O1xuXHQgIF9jcmVhdGVDbGFzcyhBdHRyaWJ1dGUsIFt7XG5cdCAgICBrZXk6IFwicXVvdGVkXCIsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgdmFyIHFtID0gdGhpcy5xdW90ZU1hcms7XG5cdCAgICAgIHJldHVybiBxbSA9PT0gXCInXCIgfHwgcW0gPT09ICdcIic7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcblx0ICAgICAgd2Fybk9mRGVwcmVjYXRlZFF1b3RlZEFzc2lnbm1lbnQoKTtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiByZXR1cm5zIGEgc2luZ2xlIChgJ2ApIG9yIGRvdWJsZSAoYFwiYCkgcXVvdGUgY2hhcmFjdGVyIGlmIHRoZSB2YWx1ZSBpcyBxdW90ZWQuXG5cdCAgICAgKiByZXR1cm5zIGBudWxsYCBpZiB0aGUgdmFsdWUgaXMgbm90IHF1b3RlZC5cblx0ICAgICAqIHJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIHF1b3RhdGlvbiBzdGF0ZSBpcyB1bmtub3duICh0aGlzIGNhbiBoYXBwZW4gd2hlblxuXHQgICAgICogdGhlIGF0dHJpYnV0ZSBpcyBjb25zdHJ1Y3RlZCB3aXRob3V0IHNwZWNpZnlpbmcgYSBxdW90ZSBtYXJrLilcblx0ICAgICAqL1xuXHQgIH0sIHtcblx0ICAgIGtleTogXCJxdW90ZU1hcmtcIixcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fcXVvdGVNYXJrO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIFNldCB0aGUgcXVvdGUgbWFyayB0byBiZSB1c2VkIGJ5IHRoaXMgYXR0cmlidXRlJ3MgdmFsdWUuXG5cdCAgICAgKiBJZiB0aGUgcXVvdGUgbWFyayBjaGFuZ2VzLCB0aGUgcmF3IChlc2NhcGVkKSB2YWx1ZSBhdCBgYXR0ci5yYXdzLnZhbHVlYCBvZiB0aGUgYXR0cmlidXRlXG5cdCAgICAgKiB2YWx1ZSBpcyB1cGRhdGVkIGFjY29yZGluZ2x5LlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7XCInXCIgfCAnXCInIHwgbnVsbH0gcXVvdGVNYXJrIFRoZSBxdW90ZSBtYXJrIG9yIGBudWxsYCBpZiB0aGUgdmFsdWUgc2hvdWxkIGJlIHVucXVvdGVkLlxuXHQgICAgICovLFxuXHQgICAgc2V0OiBmdW5jdGlvbiBzZXQocXVvdGVNYXJrKSB7XG5cdCAgICAgIGlmICghdGhpcy5fY29uc3RydWN0ZWQpIHtcblx0ICAgICAgICB0aGlzLl9xdW90ZU1hcmsgPSBxdW90ZU1hcms7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0aGlzLl9xdW90ZU1hcmsgIT09IHF1b3RlTWFyaykge1xuXHQgICAgICAgIHRoaXMuX3F1b3RlTWFyayA9IHF1b3RlTWFyaztcblx0ICAgICAgICB0aGlzLl9zeW5jUmF3VmFsdWUoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJxdWFsaWZpZWRBdHRyaWJ1dGVcIixcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5xdWFsaWZpZWROYW1lKHRoaXMucmF3cy5hdHRyaWJ1dGUgfHwgdGhpcy5hdHRyaWJ1dGUpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJpbnNlbnNpdGl2ZUZsYWdcIixcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5pbnNlbnNpdGl2ZSA/ICdpJyA6ICcnO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJ2YWx1ZVwiLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcblx0ICAgIH0sXG5cdCAgICBzZXQ6XG5cdCAgICAvKipcblx0ICAgICAqIEJlZm9yZSAzLjAsIHRoZSB2YWx1ZSBoYWQgdG8gYmUgc2V0IHRvIGFuIGVzY2FwZWQgdmFsdWUgaW5jbHVkaW5nIGFueSB3cmFwcGVkXG5cdCAgICAgKiBxdW90ZSBtYXJrcy4gSW4gMy4wLCB0aGUgc2VtYW50aWNzIG9mIGBBdHRyaWJ1dGUudmFsdWVgIGNoYW5nZWQgc28gdGhhdCB0aGUgdmFsdWVcblx0ICAgICAqIGlzIHVuZXNjYXBlZCBkdXJpbmcgcGFyc2luZyBhbmQgYW55IHF1b3RlIG1hcmtzIGFyZSByZW1vdmVkLlxuXHQgICAgICpcblx0ICAgICAqIEJlY2F1c2UgdGhlIGFtYmlndWl0eSBvZiB0aGlzIHNlbWFudGljIGNoYW5nZSwgaWYgeW91IHNldCBgYXR0ci52YWx1ZSA9IG5ld1ZhbHVlYCxcblx0ICAgICAqIGEgZGVwcmVjYXRpb24gd2FybmluZyBpcyByYWlzZWQgd2hlbiB0aGUgbmV3IHZhbHVlIGNvbnRhaW5zIGFueSBjaGFyYWN0ZXJzIHRoYXQgd291bGRcblx0ICAgICAqIHJlcXVpcmUgZXNjYXBpbmcgKGluY2x1ZGluZyBpZiBpdCBjb250YWlucyB3cmFwcGVkIHF1b3RlcykuXG5cdCAgICAgKlxuXHQgICAgICogSW5zdGVhZCwgeW91IHNob3VsZCBjYWxsIGBhdHRyLnNldFZhbHVlKG5ld1ZhbHVlLCBvcHRzKWAgYW5kIHBhc3Mgb3B0aW9ucyB0aGF0IGRlc2NyaWJlXG5cdCAgICAgKiBob3cgdGhlIG5ldyB2YWx1ZSBpcyBxdW90ZWQuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHNldCh2KSB7XG5cdCAgICAgIGlmICh0aGlzLl9jb25zdHJ1Y3RlZCkge1xuXHQgICAgICAgIHZhciBfdW5lc2NhcGVWYWx1ZTIgPSB1bmVzY2FwZVZhbHVlKHYpLFxuXHQgICAgICAgICAgZGVwcmVjYXRlZFVzYWdlID0gX3VuZXNjYXBlVmFsdWUyLmRlcHJlY2F0ZWRVc2FnZSxcblx0ICAgICAgICAgIHVuZXNjYXBlZCA9IF91bmVzY2FwZVZhbHVlMi51bmVzY2FwZWQsXG5cdCAgICAgICAgICBxdW90ZU1hcmsgPSBfdW5lc2NhcGVWYWx1ZTIucXVvdGVNYXJrO1xuXHQgICAgICAgIGlmIChkZXByZWNhdGVkVXNhZ2UpIHtcblx0ICAgICAgICAgIHdhcm5PZkRlcHJlY2F0ZWRWYWx1ZUFzc2lnbm1lbnQoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHVuZXNjYXBlZCA9PT0gdGhpcy5fdmFsdWUgJiYgcXVvdGVNYXJrID09PSB0aGlzLl9xdW90ZU1hcmspIHtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fdmFsdWUgPSB1bmVzY2FwZWQ7XG5cdCAgICAgICAgdGhpcy5fcXVvdGVNYXJrID0gcXVvdGVNYXJrO1xuXHQgICAgICAgIHRoaXMuX3N5bmNSYXdWYWx1ZSgpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJpbnNlbnNpdGl2ZVwiLFxuXHQgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9pbnNlbnNpdGl2ZTtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTZXQgdGhlIGNhc2UgaW5zZW5zaXRpdmUgZmxhZy5cblx0ICAgICAqIElmIHRoZSBjYXNlIGluc2Vuc2l0aXZlIGZsYWcgY2hhbmdlcywgdGhlIHJhdyAoZXNjYXBlZCkgdmFsdWUgYXQgYGF0dHIucmF3cy5pbnNlbnNpdGl2ZUZsYWdgXG5cdCAgICAgKiBvZiB0aGUgYXR0cmlidXRlIGlzIHVwZGF0ZWQgYWNjb3JkaW5nbHkuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHt0cnVlIHwgZmFsc2V9IGluc2Vuc2l0aXZlIHRydWUgaWYgdGhlIGF0dHJpYnV0ZSBzaG91bGQgbWF0Y2ggY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHQgICAgICovLFxuXHQgICAgc2V0OiBmdW5jdGlvbiBzZXQoaW5zZW5zaXRpdmUpIHtcblx0ICAgICAgaWYgKCFpbnNlbnNpdGl2ZSkge1xuXHQgICAgICAgIHRoaXMuX2luc2Vuc2l0aXZlID0gZmFsc2U7XG5cblx0ICAgICAgICAvLyBcImlcIiBhbmQgXCJJXCIgY2FuIGJlIHVzZWQgaW4gXCJ0aGlzLnJhd3MuaW5zZW5zaXRpdmVGbGFnXCIgdG8gc3RvcmUgdGhlIG9yaWdpbmFsIG5vdGF0aW9uLlxuXHQgICAgICAgIC8vIFdoZW4gc2V0dGluZyBgYXR0ci5pbnNlbnNpdGl2ZSA9IGZhbHNlYCBib3RoIHNob3VsZCBiZSBlcmFzZWQgdG8gZW5zdXJlIGNvcnJlY3Qgc2VyaWFsaXphdGlvbi5cblx0ICAgICAgICBpZiAodGhpcy5yYXdzICYmICh0aGlzLnJhd3MuaW5zZW5zaXRpdmVGbGFnID09PSAnSScgfHwgdGhpcy5yYXdzLmluc2Vuc2l0aXZlRmxhZyA9PT0gJ2knKSkge1xuXHQgICAgICAgICAgdGhpcy5yYXdzLmluc2Vuc2l0aXZlRmxhZyA9IHVuZGVmaW5lZDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5faW5zZW5zaXRpdmUgPSBpbnNlbnNpdGl2ZTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwiYXR0cmlidXRlXCIsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZTtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uIHNldChuYW1lKSB7XG5cdCAgICAgIHRoaXMuX2hhbmRsZUVzY2FwZXMoXCJhdHRyaWJ1dGVcIiwgbmFtZSk7XG5cdCAgICAgIHRoaXMuX2F0dHJpYnV0ZSA9IG5hbWU7XG5cdCAgICB9XG5cdCAgfV0pO1xuXHQgIHJldHVybiBBdHRyaWJ1dGU7XG5cdH0oX25hbWVzcGFjZVtcImRlZmF1bHRcIl0pO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IEF0dHJpYnV0ZTtcblx0QXR0cmlidXRlLk5PX1FVT1RFID0gbnVsbDtcblx0QXR0cmlidXRlLlNJTkdMRV9RVU9URSA9IFwiJ1wiO1xuXHRBdHRyaWJ1dGUuRE9VQkxFX1FVT1RFID0gJ1wiJztcblx0dmFyIENTU0VTQ19RVU9URV9PUFRJT05TID0gKF9DU1NFU0NfUVVPVEVfT1BUSU9OUyA9IHtcblx0ICBcIidcIjoge1xuXHQgICAgcXVvdGVzOiAnc2luZ2xlJyxcblx0ICAgIHdyYXA6IHRydWVcblx0ICB9LFxuXHQgICdcIic6IHtcblx0ICAgIHF1b3RlczogJ2RvdWJsZScsXG5cdCAgICB3cmFwOiB0cnVlXG5cdCAgfVxuXHR9LCBfQ1NTRVNDX1FVT1RFX09QVElPTlNbbnVsbF0gPSB7XG5cdCAgaXNJZGVudGlmaWVyOiB0cnVlXG5cdH0sIF9DU1NFU0NfUVVPVEVfT1BUSU9OUyk7XG5cdGZ1bmN0aW9uIGRlZmF1bHRBdHRyQ29uY2F0KGF0dHJWYWx1ZSwgYXR0clNwYWNlcykge1xuXHQgIHJldHVybiBcIlwiICsgYXR0clNwYWNlcy5iZWZvcmUgKyBhdHRyVmFsdWUgKyBhdHRyU3BhY2VzLmFmdGVyO1xuXHR9IFxufSAoYXR0cmlidXRlJDEpKTtcblxudmFyIHVuaXZlcnNhbCQxID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblx0dmFyIF9uYW1lc3BhY2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG5hbWVzcGFjZUV4cG9ydHMpO1xuXHR2YXIgX3R5cGVzID0gdHlwZXM7XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXHRmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblx0ZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblx0dmFyIFVuaXZlcnNhbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05hbWVzcGFjZSkge1xuXHQgIF9pbmhlcml0c0xvb3NlKFVuaXZlcnNhbCwgX05hbWVzcGFjZSk7XG5cdCAgZnVuY3Rpb24gVW5pdmVyc2FsKG9wdHMpIHtcblx0ICAgIHZhciBfdGhpcztcblx0ICAgIF90aGlzID0gX05hbWVzcGFjZS5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG5cdCAgICBfdGhpcy50eXBlID0gX3R5cGVzLlVOSVZFUlNBTDtcblx0ICAgIF90aGlzLnZhbHVlID0gJyonO1xuXHQgICAgcmV0dXJuIF90aGlzO1xuXHQgIH1cblx0ICByZXR1cm4gVW5pdmVyc2FsO1xuXHR9KF9uYW1lc3BhY2VbXCJkZWZhdWx0XCJdKTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBVbml2ZXJzYWw7XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyBcbn0gKHVuaXZlcnNhbCQxLCB1bml2ZXJzYWwkMS5leHBvcnRzKSk7XG5cbnZhciB1bml2ZXJzYWxFeHBvcnRzID0gdW5pdmVyc2FsJDEuZXhwb3J0cztcblxudmFyIGNvbWJpbmF0b3IkMiA9IHtleHBvcnRzOiB7fX07XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cdHZhciBfbm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQobm9kZUV4cG9ydHMpO1xuXHR2YXIgX3R5cGVzID0gdHlwZXM7XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXHRmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblx0ZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblx0dmFyIENvbWJpbmF0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG5cdCAgX2luaGVyaXRzTG9vc2UoQ29tYmluYXRvciwgX05vZGUpO1xuXHQgIGZ1bmN0aW9uIENvbWJpbmF0b3Iob3B0cykge1xuXHQgICAgdmFyIF90aGlzO1xuXHQgICAgX3RoaXMgPSBfTm9kZS5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG5cdCAgICBfdGhpcy50eXBlID0gX3R5cGVzLkNPTUJJTkFUT1I7XG5cdCAgICByZXR1cm4gX3RoaXM7XG5cdCAgfVxuXHQgIHJldHVybiBDb21iaW5hdG9yO1xuXHR9KF9ub2RlW1wiZGVmYXVsdFwiXSk7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ29tYmluYXRvcjtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IFxufSAoY29tYmluYXRvciQyLCBjb21iaW5hdG9yJDIuZXhwb3J0cykpO1xuXG52YXIgY29tYmluYXRvckV4cG9ydHMgPSBjb21iaW5hdG9yJDIuZXhwb3J0cztcblxudmFyIG5lc3RpbmckMSA9IHtleHBvcnRzOiB7fX07XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cdHZhciBfbm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQobm9kZUV4cG9ydHMpO1xuXHR2YXIgX3R5cGVzID0gdHlwZXM7XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXHRmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblx0ZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblx0dmFyIE5lc3RpbmcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG5cdCAgX2luaGVyaXRzTG9vc2UoTmVzdGluZywgX05vZGUpO1xuXHQgIGZ1bmN0aW9uIE5lc3Rpbmcob3B0cykge1xuXHQgICAgdmFyIF90aGlzO1xuXHQgICAgX3RoaXMgPSBfTm9kZS5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG5cdCAgICBfdGhpcy50eXBlID0gX3R5cGVzLk5FU1RJTkc7XG5cdCAgICBfdGhpcy52YWx1ZSA9ICcmJztcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9XG5cdCAgcmV0dXJuIE5lc3Rpbmc7XG5cdH0oX25vZGVbXCJkZWZhdWx0XCJdKTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBOZXN0aW5nO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsgXG59IChuZXN0aW5nJDEsIG5lc3RpbmckMS5leHBvcnRzKSk7XG5cbnZhciBuZXN0aW5nRXhwb3J0cyA9IG5lc3RpbmckMS5leHBvcnRzO1xuXG52YXIgc29ydEFzY2VuZGluZyA9IHtleHBvcnRzOiB7fX07XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBzb3J0QXNjZW5kaW5nO1xuXHRmdW5jdGlvbiBzb3J0QXNjZW5kaW5nKGxpc3QpIHtcblx0ICByZXR1cm4gbGlzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICByZXR1cm4gYSAtIGI7XG5cdCAgfSk7XG5cdH1cblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IFxufSAoc29ydEFzY2VuZGluZywgc29ydEFzY2VuZGluZy5leHBvcnRzKSk7XG5cbnZhciBzb3J0QXNjZW5kaW5nRXhwb3J0cyA9IHNvcnRBc2NlbmRpbmcuZXhwb3J0cztcblxudmFyIHRva2VuaXplID0ge307XG5cbnZhciB0b2tlblR5cGVzID0ge307XG5cbnRva2VuVHlwZXMuX19lc01vZHVsZSA9IHRydWU7XG50b2tlblR5cGVzLndvcmQgPSB0b2tlblR5cGVzLnRpbGRlID0gdG9rZW5UeXBlcy50YWIgPSB0b2tlblR5cGVzLnN0ciA9IHRva2VuVHlwZXMuc3BhY2UgPSB0b2tlblR5cGVzLnNsYXNoID0gdG9rZW5UeXBlcy5zaW5nbGVRdW90ZSA9IHRva2VuVHlwZXMuc2VtaWNvbG9uID0gdG9rZW5UeXBlcy5wbHVzID0gdG9rZW5UeXBlcy5waXBlID0gdG9rZW5UeXBlcy5vcGVuU3F1YXJlID0gdG9rZW5UeXBlcy5vcGVuUGFyZW50aGVzaXMgPSB0b2tlblR5cGVzLm5ld2xpbmUgPSB0b2tlblR5cGVzLmdyZWF0ZXJUaGFuID0gdG9rZW5UeXBlcy5mZWVkID0gdG9rZW5UeXBlcy5lcXVhbHMgPSB0b2tlblR5cGVzLmRvdWJsZVF1b3RlID0gdG9rZW5UeXBlcy5kb2xsYXIgPSB0b2tlblR5cGVzLmNyID0gdG9rZW5UeXBlcy5jb21tZW50ID0gdG9rZW5UeXBlcy5jb21tYSA9IHRva2VuVHlwZXMuY29tYmluYXRvciA9IHRva2VuVHlwZXMuY29sb24gPSB0b2tlblR5cGVzLmNsb3NlU3F1YXJlID0gdG9rZW5UeXBlcy5jbG9zZVBhcmVudGhlc2lzID0gdG9rZW5UeXBlcy5jYXJldCA9IHRva2VuVHlwZXMuYmFuZyA9IHRva2VuVHlwZXMuYmFja3NsYXNoID0gdG9rZW5UeXBlcy5hdCA9IHRva2VuVHlwZXMuYXN0ZXJpc2sgPSB0b2tlblR5cGVzLmFtcGVyc2FuZCA9IHZvaWQgMDtcbnZhciBhbXBlcnNhbmQgPSAzODsgLy8gYCZgLmNoYXJDb2RlQXQoMCk7XG50b2tlblR5cGVzLmFtcGVyc2FuZCA9IGFtcGVyc2FuZDtcbnZhciBhc3RlcmlzayA9IDQyOyAvLyBgKmAuY2hhckNvZGVBdCgwKTtcbnRva2VuVHlwZXMuYXN0ZXJpc2sgPSBhc3RlcmlzaztcbnZhciBhdCA9IDY0OyAvLyBgQGAuY2hhckNvZGVBdCgwKTtcbnRva2VuVHlwZXMuYXQgPSBhdDtcbnZhciBjb21tYSA9IDQ0OyAvLyBgLGAuY2hhckNvZGVBdCgwKTtcbnRva2VuVHlwZXMuY29tbWEgPSBjb21tYTtcbnZhciBjb2xvbiA9IDU4OyAvLyBgOmAuY2hhckNvZGVBdCgwKTtcbnRva2VuVHlwZXMuY29sb24gPSBjb2xvbjtcbnZhciBzZW1pY29sb24gPSA1OTsgLy8gYDtgLmNoYXJDb2RlQXQoMCk7XG50b2tlblR5cGVzLnNlbWljb2xvbiA9IHNlbWljb2xvbjtcbnZhciBvcGVuUGFyZW50aGVzaXMgPSA0MDsgLy8gYChgLmNoYXJDb2RlQXQoMCk7XG50b2tlblR5cGVzLm9wZW5QYXJlbnRoZXNpcyA9IG9wZW5QYXJlbnRoZXNpcztcbnZhciBjbG9zZVBhcmVudGhlc2lzID0gNDE7IC8vIGApYC5jaGFyQ29kZUF0KDApO1xudG9rZW5UeXBlcy5jbG9zZVBhcmVudGhlc2lzID0gY2xvc2VQYXJlbnRoZXNpcztcbnZhciBvcGVuU3F1YXJlID0gOTE7IC8vIGBbYC5jaGFyQ29kZUF0KDApO1xudG9rZW5UeXBlcy5vcGVuU3F1YXJlID0gb3BlblNxdWFyZTtcbnZhciBjbG9zZVNxdWFyZSA9IDkzOyAvLyBgXWAuY2hhckNvZGVBdCgwKTtcbnRva2VuVHlwZXMuY2xvc2VTcXVhcmUgPSBjbG9zZVNxdWFyZTtcbnZhciBkb2xsYXIgPSAzNjsgLy8gYCRgLmNoYXJDb2RlQXQoMCk7XG50b2tlblR5cGVzLmRvbGxhciA9IGRvbGxhcjtcbnZhciB0aWxkZSA9IDEyNjsgLy8gYH5gLmNoYXJDb2RlQXQoMCk7XG50b2tlblR5cGVzLnRpbGRlID0gdGlsZGU7XG52YXIgY2FyZXQgPSA5NDsgLy8gYF5gLmNoYXJDb2RlQXQoMCk7XG50b2tlblR5cGVzLmNhcmV0ID0gY2FyZXQ7XG52YXIgcGx1cyA9IDQzOyAvLyBgK2AuY2hhckNvZGVBdCgwKTtcbnRva2VuVHlwZXMucGx1cyA9IHBsdXM7XG52YXIgZXF1YWxzID0gNjE7IC8vIGA9YC5jaGFyQ29kZUF0KDApO1xudG9rZW5UeXBlcy5lcXVhbHMgPSBlcXVhbHM7XG52YXIgcGlwZSA9IDEyNDsgLy8gYHxgLmNoYXJDb2RlQXQoMCk7XG50b2tlblR5cGVzLnBpcGUgPSBwaXBlO1xudmFyIGdyZWF0ZXJUaGFuID0gNjI7IC8vIGA+YC5jaGFyQ29kZUF0KDApO1xudG9rZW5UeXBlcy5ncmVhdGVyVGhhbiA9IGdyZWF0ZXJUaGFuO1xudmFyIHNwYWNlID0gMzI7IC8vIGAgYC5jaGFyQ29kZUF0KDApO1xudG9rZW5UeXBlcy5zcGFjZSA9IHNwYWNlO1xudmFyIHNpbmdsZVF1b3RlID0gMzk7IC8vIGAnYC5jaGFyQ29kZUF0KDApO1xudG9rZW5UeXBlcy5zaW5nbGVRdW90ZSA9IHNpbmdsZVF1b3RlO1xudmFyIGRvdWJsZVF1b3RlID0gMzQ7IC8vIGBcImAuY2hhckNvZGVBdCgwKTtcbnRva2VuVHlwZXMuZG91YmxlUXVvdGUgPSBkb3VibGVRdW90ZTtcbnZhciBzbGFzaCA9IDQ3OyAvLyBgL2AuY2hhckNvZGVBdCgwKTtcbnRva2VuVHlwZXMuc2xhc2ggPSBzbGFzaDtcbnZhciBiYW5nID0gMzM7IC8vIGAhYC5jaGFyQ29kZUF0KDApO1xudG9rZW5UeXBlcy5iYW5nID0gYmFuZztcbnZhciBiYWNrc2xhc2ggPSA5MjsgLy8gJ1xcXFwnLmNoYXJDb2RlQXQoMCk7XG50b2tlblR5cGVzLmJhY2tzbGFzaCA9IGJhY2tzbGFzaDtcbnZhciBjciA9IDEzOyAvLyAnXFxyJy5jaGFyQ29kZUF0KDApO1xudG9rZW5UeXBlcy5jciA9IGNyO1xudmFyIGZlZWQgPSAxMjsgLy8gJ1xcZicuY2hhckNvZGVBdCgwKTtcbnRva2VuVHlwZXMuZmVlZCA9IGZlZWQ7XG52YXIgbmV3bGluZSA9IDEwOyAvLyAnXFxuJy5jaGFyQ29kZUF0KDApO1xudG9rZW5UeXBlcy5uZXdsaW5lID0gbmV3bGluZTtcbnZhciB0YWIgPSA5OyAvLyAnXFx0Jy5jaGFyQ29kZUF0KDApO1xuXG4vLyBFeHBvc2UgYWxpYXNlcyBwcmltYXJpbHkgZm9yIHJlYWRhYmlsaXR5LlxudG9rZW5UeXBlcy50YWIgPSB0YWI7XG52YXIgc3RyID0gc2luZ2xlUXVvdGU7XG5cbi8vIE5vIGdvb2Qgc2luZ2xlIGNoYXJhY3RlciByZXByZXNlbnRhdGlvbiFcbnRva2VuVHlwZXMuc3RyID0gc3RyO1xudmFyIGNvbW1lbnQkMSA9IC0xO1xudG9rZW5UeXBlcy5jb21tZW50ID0gY29tbWVudCQxO1xudmFyIHdvcmQgPSAtMjtcbnRva2VuVHlwZXMud29yZCA9IHdvcmQ7XG52YXIgY29tYmluYXRvciQxID0gLTM7XG50b2tlblR5cGVzLmNvbWJpbmF0b3IgPSBjb21iaW5hdG9yJDE7XG5cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cdGV4cG9ydHMuRklFTERTID0gdm9pZCAwO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHRva2VuaXplO1xuXHR2YXIgdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHRva2VuVHlwZXMpO1xuXHR2YXIgX3VuZXNjYXBhYmxlLCBfd29yZERlbGltaXRlcnM7XG5cdGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblx0dmFyIHVuZXNjYXBhYmxlID0gKF91bmVzY2FwYWJsZSA9IHt9LCBfdW5lc2NhcGFibGVbdC50YWJdID0gdHJ1ZSwgX3VuZXNjYXBhYmxlW3QubmV3bGluZV0gPSB0cnVlLCBfdW5lc2NhcGFibGVbdC5jcl0gPSB0cnVlLCBfdW5lc2NhcGFibGVbdC5mZWVkXSA9IHRydWUsIF91bmVzY2FwYWJsZSk7XG5cdHZhciB3b3JkRGVsaW1pdGVycyA9IChfd29yZERlbGltaXRlcnMgPSB7fSwgX3dvcmREZWxpbWl0ZXJzW3Quc3BhY2VdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QudGFiXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0Lm5ld2xpbmVdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuY3JdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuZmVlZF0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5hbXBlcnNhbmRdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuYXN0ZXJpc2tdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuYmFuZ10gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5jb21tYV0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5jb2xvbl0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5zZW1pY29sb25dID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3Qub3BlblBhcmVudGhlc2lzXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LmNsb3NlUGFyZW50aGVzaXNdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3Qub3BlblNxdWFyZV0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5jbG9zZVNxdWFyZV0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5zaW5nbGVRdW90ZV0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5kb3VibGVRdW90ZV0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5wbHVzXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LnBpcGVdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QudGlsZGVdID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuZ3JlYXRlclRoYW5dID0gdHJ1ZSwgX3dvcmREZWxpbWl0ZXJzW3QuZXF1YWxzXSA9IHRydWUsIF93b3JkRGVsaW1pdGVyc1t0LmRvbGxhcl0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5jYXJldF0gPSB0cnVlLCBfd29yZERlbGltaXRlcnNbdC5zbGFzaF0gPSB0cnVlLCBfd29yZERlbGltaXRlcnMpO1xuXHR2YXIgaGV4ID0ge307XG5cdHZhciBoZXhDaGFycyA9IFwiMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRlwiO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGhleENoYXJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgaGV4W2hleENoYXJzLmNoYXJDb2RlQXQoaSldID0gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiAgUmV0dXJucyB0aGUgbGFzdCBpbmRleCBvZiB0aGUgYmFyIGNzcyB3b3JkXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjc3MgVGhlIHN0cmluZyBpbiB3aGljaCB0aGUgd29yZCBiZWdpbnNcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBpbmRleCBpbnRvIHRoZSBzdHJpbmcgd2hlcmUgd29yZCdzIGZpcnN0IGxldHRlciBvY2N1cnNcblx0ICovXG5cdGZ1bmN0aW9uIGNvbnN1bWVXb3JkKGNzcywgc3RhcnQpIHtcblx0ICB2YXIgbmV4dCA9IHN0YXJ0O1xuXHQgIHZhciBjb2RlO1xuXHQgIGRvIHtcblx0ICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0KTtcblx0ICAgIGlmICh3b3JkRGVsaW1pdGVyc1tjb2RlXSkge1xuXHQgICAgICByZXR1cm4gbmV4dCAtIDE7XG5cdCAgICB9IGVsc2UgaWYgKGNvZGUgPT09IHQuYmFja3NsYXNoKSB7XG5cdCAgICAgIG5leHQgPSBjb25zdW1lRXNjYXBlKGNzcywgbmV4dCkgKyAxO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gQWxsIG90aGVyIGNoYXJhY3RlcnMgYXJlIHBhcnQgb2YgdGhlIHdvcmRcblx0ICAgICAgbmV4dCsrO1xuXHQgICAgfVxuXHQgIH0gd2hpbGUgKG5leHQgPCBjc3MubGVuZ3RoKTtcblx0ICByZXR1cm4gbmV4dCAtIDE7XG5cdH1cblxuXHQvKipcblx0ICogIFJldHVybnMgdGhlIGxhc3QgaW5kZXggb2YgdGhlIGVzY2FwZSBzZXF1ZW5jZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY3NzIFRoZSBzdHJpbmcgaW4gd2hpY2ggdGhlIHNlcXVlbmNlIGJlZ2luc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIGluZGV4IGludG8gdGhlIHN0cmluZyB3aGVyZSBlc2NhcGUgY2hhcmFjdGVyIChgXFxgKSBvY2N1cnMuXG5cdCAqL1xuXHRmdW5jdGlvbiBjb25zdW1lRXNjYXBlKGNzcywgc3RhcnQpIHtcblx0ICB2YXIgbmV4dCA9IHN0YXJ0O1xuXHQgIHZhciBjb2RlID0gY3NzLmNoYXJDb2RlQXQobmV4dCArIDEpO1xuXHQgIGlmICh1bmVzY2FwYWJsZVtjb2RlXSkgOyBlbHNlIGlmIChoZXhbY29kZV0pIHtcblx0ICAgIHZhciBoZXhEaWdpdHMgPSAwO1xuXHQgICAgLy8gY29uc3VtZSB1cCB0byA2IGhleCBjaGFyc1xuXHQgICAgZG8ge1xuXHQgICAgICBuZXh0Kys7XG5cdCAgICAgIGhleERpZ2l0cysrO1xuXHQgICAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQobmV4dCArIDEpO1xuXHQgICAgfSB3aGlsZSAoaGV4W2NvZGVdICYmIGhleERpZ2l0cyA8IDYpO1xuXHQgICAgLy8gaWYgZmV3ZXIgdGhhbiA2IGhleCBjaGFycywgYSB0cmFpbGluZyBzcGFjZSBlbmRzIHRoZSBlc2NhcGVcblx0ICAgIGlmIChoZXhEaWdpdHMgPCA2ICYmIGNvZGUgPT09IHQuc3BhY2UpIHtcblx0ICAgICAgbmV4dCsrO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyB0aGUgbmV4dCBjaGFyIGlzIHBhcnQgb2YgdGhlIGN1cnJlbnQgd29yZFxuXHQgICAgbmV4dCsrO1xuXHQgIH1cblx0ICByZXR1cm4gbmV4dDtcblx0fVxuXHR2YXIgRklFTERTID0ge1xuXHQgIFRZUEU6IDAsXG5cdCAgU1RBUlRfTElORTogMSxcblx0ICBTVEFSVF9DT0w6IDIsXG5cdCAgRU5EX0xJTkU6IDMsXG5cdCAgRU5EX0NPTDogNCxcblx0ICBTVEFSVF9QT1M6IDUsXG5cdCAgRU5EX1BPUzogNlxuXHR9O1xuXHRleHBvcnRzLkZJRUxEUyA9IEZJRUxEUztcblx0ZnVuY3Rpb24gdG9rZW5pemUoaW5wdXQpIHtcblx0ICB2YXIgdG9rZW5zID0gW107XG5cdCAgdmFyIGNzcyA9IGlucHV0LmNzcy52YWx1ZU9mKCk7XG5cdCAgdmFyIF9jc3MgPSBjc3MsXG5cdCAgICBsZW5ndGggPSBfY3NzLmxlbmd0aDtcblx0ICB2YXIgb2Zmc2V0ID0gLTE7XG5cdCAgdmFyIGxpbmUgPSAxO1xuXHQgIHZhciBzdGFydCA9IDA7XG5cdCAgdmFyIGVuZCA9IDA7XG5cdCAgdmFyIGNvZGUsIGNvbnRlbnQsIGVuZENvbHVtbiwgZW5kTGluZSwgZXNjYXBlZCwgZXNjYXBlUG9zLCBsYXN0LCBsaW5lcywgbmV4dCwgbmV4dExpbmUsIG5leHRPZmZzZXQsIHF1b3RlLCB0b2tlblR5cGU7XG5cdCAgZnVuY3Rpb24gdW5jbG9zZWQod2hhdCwgZml4KSB7XG5cdCAgICBpZiAoaW5wdXQuc2FmZSkge1xuXHQgICAgICAvLyBmeWk6IHRoaXMgaXMgbmV2ZXIgc2V0IHRvIHRydWUuXG5cdCAgICAgIGNzcyArPSBmaXg7XG5cdCAgICAgIG5leHQgPSBjc3MubGVuZ3RoIC0gMTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRocm93IGlucHV0LmVycm9yKCdVbmNsb3NlZCAnICsgd2hhdCwgbGluZSwgc3RhcnQgLSBvZmZzZXQsIHN0YXJ0KTtcblx0ICAgIH1cblx0ICB9XG5cdCAgd2hpbGUgKHN0YXJ0IDwgbGVuZ3RoKSB7XG5cdCAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQoc3RhcnQpO1xuXHQgICAgaWYgKGNvZGUgPT09IHQubmV3bGluZSkge1xuXHQgICAgICBvZmZzZXQgPSBzdGFydDtcblx0ICAgICAgbGluZSArPSAxO1xuXHQgICAgfVxuXHQgICAgc3dpdGNoIChjb2RlKSB7XG5cdCAgICAgIGNhc2UgdC5zcGFjZTpcblx0ICAgICAgY2FzZSB0LnRhYjpcblx0ICAgICAgY2FzZSB0Lm5ld2xpbmU6XG5cdCAgICAgIGNhc2UgdC5jcjpcblx0ICAgICAgY2FzZSB0LmZlZWQ6XG5cdCAgICAgICAgbmV4dCA9IHN0YXJ0O1xuXHQgICAgICAgIGRvIHtcblx0ICAgICAgICAgIG5leHQgKz0gMTtcblx0ICAgICAgICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0KTtcblx0ICAgICAgICAgIGlmIChjb2RlID09PSB0Lm5ld2xpbmUpIHtcblx0ICAgICAgICAgICAgb2Zmc2V0ID0gbmV4dDtcblx0ICAgICAgICAgICAgbGluZSArPSAxO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gd2hpbGUgKGNvZGUgPT09IHQuc3BhY2UgfHwgY29kZSA9PT0gdC5uZXdsaW5lIHx8IGNvZGUgPT09IHQudGFiIHx8IGNvZGUgPT09IHQuY3IgfHwgY29kZSA9PT0gdC5mZWVkKTtcblx0ICAgICAgICB0b2tlblR5cGUgPSB0LnNwYWNlO1xuXHQgICAgICAgIGVuZExpbmUgPSBsaW5lO1xuXHQgICAgICAgIGVuZENvbHVtbiA9IG5leHQgLSBvZmZzZXQgLSAxO1xuXHQgICAgICAgIGVuZCA9IG5leHQ7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGNhc2UgdC5wbHVzOlxuXHQgICAgICBjYXNlIHQuZ3JlYXRlclRoYW46XG5cdCAgICAgIGNhc2UgdC50aWxkZTpcblx0ICAgICAgY2FzZSB0LnBpcGU6XG5cdCAgICAgICAgbmV4dCA9IHN0YXJ0O1xuXHQgICAgICAgIGRvIHtcblx0ICAgICAgICAgIG5leHQgKz0gMTtcblx0ICAgICAgICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0KTtcblx0ICAgICAgICB9IHdoaWxlIChjb2RlID09PSB0LnBsdXMgfHwgY29kZSA9PT0gdC5ncmVhdGVyVGhhbiB8fCBjb2RlID09PSB0LnRpbGRlIHx8IGNvZGUgPT09IHQucGlwZSk7XG5cdCAgICAgICAgdG9rZW5UeXBlID0gdC5jb21iaW5hdG9yO1xuXHQgICAgICAgIGVuZExpbmUgPSBsaW5lO1xuXHQgICAgICAgIGVuZENvbHVtbiA9IHN0YXJ0IC0gb2Zmc2V0O1xuXHQgICAgICAgIGVuZCA9IG5leHQ7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgLy8gQ29uc3VtZSB0aGVzZSBjaGFyYWN0ZXJzIGFzIHNpbmdsZSB0b2tlbnMuXG5cdCAgICAgIGNhc2UgdC5hc3Rlcmlzazpcblx0ICAgICAgY2FzZSB0LmFtcGVyc2FuZDpcblx0ICAgICAgY2FzZSB0LmJhbmc6XG5cdCAgICAgIGNhc2UgdC5jb21tYTpcblx0ICAgICAgY2FzZSB0LmVxdWFsczpcblx0ICAgICAgY2FzZSB0LmRvbGxhcjpcblx0ICAgICAgY2FzZSB0LmNhcmV0OlxuXHQgICAgICBjYXNlIHQub3BlblNxdWFyZTpcblx0ICAgICAgY2FzZSB0LmNsb3NlU3F1YXJlOlxuXHQgICAgICBjYXNlIHQuY29sb246XG5cdCAgICAgIGNhc2UgdC5zZW1pY29sb246XG5cdCAgICAgIGNhc2UgdC5vcGVuUGFyZW50aGVzaXM6XG5cdCAgICAgIGNhc2UgdC5jbG9zZVBhcmVudGhlc2lzOlxuXHQgICAgICAgIG5leHQgPSBzdGFydDtcblx0ICAgICAgICB0b2tlblR5cGUgPSBjb2RlO1xuXHQgICAgICAgIGVuZExpbmUgPSBsaW5lO1xuXHQgICAgICAgIGVuZENvbHVtbiA9IHN0YXJ0IC0gb2Zmc2V0O1xuXHQgICAgICAgIGVuZCA9IG5leHQgKyAxO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBjYXNlIHQuc2luZ2xlUXVvdGU6XG5cdCAgICAgIGNhc2UgdC5kb3VibGVRdW90ZTpcblx0ICAgICAgICBxdW90ZSA9IGNvZGUgPT09IHQuc2luZ2xlUXVvdGUgPyBcIidcIiA6ICdcIic7XG5cdCAgICAgICAgbmV4dCA9IHN0YXJ0O1xuXHQgICAgICAgIGRvIHtcblx0ICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcblx0ICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihxdW90ZSwgbmV4dCArIDEpO1xuXHQgICAgICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG5cdCAgICAgICAgICAgIHVuY2xvc2VkKCdxdW90ZScsIHF1b3RlKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGVzY2FwZVBvcyA9IG5leHQ7XG5cdCAgICAgICAgICB3aGlsZSAoY3NzLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IHQuYmFja3NsYXNoKSB7XG5cdCAgICAgICAgICAgIGVzY2FwZVBvcyAtPSAxO1xuXHQgICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSB3aGlsZSAoZXNjYXBlZCk7XG5cdCAgICAgICAgdG9rZW5UeXBlID0gdC5zdHI7XG5cdCAgICAgICAgZW5kTGluZSA9IGxpbmU7XG5cdCAgICAgICAgZW5kQ29sdW1uID0gc3RhcnQgLSBvZmZzZXQ7XG5cdCAgICAgICAgZW5kID0gbmV4dCArIDE7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgaWYgKGNvZGUgPT09IHQuc2xhc2ggJiYgY3NzLmNoYXJDb2RlQXQoc3RhcnQgKyAxKSA9PT0gdC5hc3Rlcmlzaykge1xuXHQgICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKCcqLycsIHN0YXJ0ICsgMikgKyAxO1xuXHQgICAgICAgICAgaWYgKG5leHQgPT09IDApIHtcblx0ICAgICAgICAgICAgdW5jbG9zZWQoJ2NvbW1lbnQnLCAnKi8nKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGNvbnRlbnQgPSBjc3Muc2xpY2Uoc3RhcnQsIG5leHQgKyAxKTtcblx0ICAgICAgICAgIGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XG5cdCAgICAgICAgICBsYXN0ID0gbGluZXMubGVuZ3RoIC0gMTtcblx0ICAgICAgICAgIGlmIChsYXN0ID4gMCkge1xuXHQgICAgICAgICAgICBuZXh0TGluZSA9IGxpbmUgKyBsYXN0O1xuXHQgICAgICAgICAgICBuZXh0T2Zmc2V0ID0gbmV4dCAtIGxpbmVzW2xhc3RdLmxlbmd0aDtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIG5leHRMaW5lID0gbGluZTtcblx0ICAgICAgICAgICAgbmV4dE9mZnNldCA9IG9mZnNldDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHRva2VuVHlwZSA9IHQuY29tbWVudDtcblx0ICAgICAgICAgIGxpbmUgPSBuZXh0TGluZTtcblx0ICAgICAgICAgIGVuZExpbmUgPSBuZXh0TGluZTtcblx0ICAgICAgICAgIGVuZENvbHVtbiA9IG5leHQgLSBuZXh0T2Zmc2V0O1xuXHQgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gdC5zbGFzaCkge1xuXHQgICAgICAgICAgbmV4dCA9IHN0YXJ0O1xuXHQgICAgICAgICAgdG9rZW5UeXBlID0gY29kZTtcblx0ICAgICAgICAgIGVuZExpbmUgPSBsaW5lO1xuXHQgICAgICAgICAgZW5kQ29sdW1uID0gc3RhcnQgLSBvZmZzZXQ7XG5cdCAgICAgICAgICBlbmQgPSBuZXh0ICsgMTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgbmV4dCA9IGNvbnN1bWVXb3JkKGNzcywgc3RhcnQpO1xuXHQgICAgICAgICAgdG9rZW5UeXBlID0gdC53b3JkO1xuXHQgICAgICAgICAgZW5kTGluZSA9IGxpbmU7XG5cdCAgICAgICAgICBlbmRDb2x1bW4gPSBuZXh0IC0gb2Zmc2V0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbmQgPSBuZXh0ICsgMTtcblx0ICAgICAgICBicmVhaztcblx0ICAgIH1cblxuXHQgICAgLy8gRW5zdXJlIHRoYXQgdGhlIHRva2VuIHN0cnVjdHVyZSByZW1haW5zIGNvbnNpc3RlbnRcblx0ICAgIHRva2Vucy5wdXNoKFt0b2tlblR5cGUsXG5cdCAgICAvLyBbMF0gVG9rZW4gdHlwZVxuXHQgICAgbGluZSxcblx0ICAgIC8vIFsxXSBTdGFydGluZyBsaW5lXG5cdCAgICBzdGFydCAtIG9mZnNldCxcblx0ICAgIC8vIFsyXSBTdGFydGluZyBjb2x1bW5cblx0ICAgIGVuZExpbmUsXG5cdCAgICAvLyBbM10gRW5kaW5nIGxpbmVcblx0ICAgIGVuZENvbHVtbixcblx0ICAgIC8vIFs0XSBFbmRpbmcgY29sdW1uXG5cdCAgICBzdGFydCxcblx0ICAgIC8vIFs1XSBTdGFydCBwb3NpdGlvbiAvIFNvdXJjZSBpbmRleFxuXHQgICAgZW5kIC8vIFs2XSBFbmQgcG9zaXRpb25cblx0ICAgIF0pO1xuXG5cdCAgICAvLyBSZXNldCBvZmZzZXQgZm9yIHRoZSBuZXh0IHRva2VuXG5cdCAgICBpZiAobmV4dE9mZnNldCkge1xuXHQgICAgICBvZmZzZXQgPSBuZXh0T2Zmc2V0O1xuXHQgICAgICBuZXh0T2Zmc2V0ID0gbnVsbDtcblx0ICAgIH1cblx0ICAgIHN0YXJ0ID0gZW5kO1xuXHQgIH1cblx0ICByZXR1cm4gdG9rZW5zO1xuXHR9IFxufSAodG9rZW5pemUpKTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblx0dmFyIF9yb290ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyb290RXhwb3J0cyk7XG5cdHZhciBfc2VsZWN0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHNlbGVjdG9yRXhwb3J0cyk7XG5cdHZhciBfY2xhc3NOYW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChjbGFzc05hbWVFeHBvcnRzKTtcblx0dmFyIF9jb21tZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChjb21tZW50RXhwb3J0cyk7XG5cdHZhciBfaWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGlkRXhwb3J0cyk7XG5cdHZhciBfdGFnID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCh0YWdFeHBvcnRzKTtcblx0dmFyIF9zdHJpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHN0cmluZ0V4cG9ydHMpO1xuXHR2YXIgX3BzZXVkbyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocHNldWRvRXhwb3J0cyk7XG5cdHZhciBfYXR0cmlidXRlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoYXR0cmlidXRlJDEpO1xuXHR2YXIgX3VuaXZlcnNhbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQodW5pdmVyc2FsRXhwb3J0cyk7XG5cdHZhciBfY29tYmluYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoY29tYmluYXRvckV4cG9ydHMpO1xuXHR2YXIgX25lc3RpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG5lc3RpbmdFeHBvcnRzKTtcblx0dmFyIF9zb3J0QXNjZW5kaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChzb3J0QXNjZW5kaW5nRXhwb3J0cyk7XG5cdHZhciBfdG9rZW5pemUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCh0b2tlbml6ZSk7XG5cdHZhciB0b2tlbnMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCh0b2tlblR5cGVzKTtcblx0dmFyIHR5cGVzJDEgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCh0eXBlcyk7XG5cdHZhciBfdXRpbCA9IHV0aWw7XG5cdHZhciBfV0hJVEVTUEFDRV9UT0tFTlMsIF9PYmplY3QkYXNzaWduO1xuXHRmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXHRmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cdGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXHR2YXIgV0hJVEVTUEFDRV9UT0tFTlMgPSAoX1dISVRFU1BBQ0VfVE9LRU5TID0ge30sIF9XSElURVNQQUNFX1RPS0VOU1t0b2tlbnMuc3BhY2VdID0gdHJ1ZSwgX1dISVRFU1BBQ0VfVE9LRU5TW3Rva2Vucy5jcl0gPSB0cnVlLCBfV0hJVEVTUEFDRV9UT0tFTlNbdG9rZW5zLmZlZWRdID0gdHJ1ZSwgX1dISVRFU1BBQ0VfVE9LRU5TW3Rva2Vucy5uZXdsaW5lXSA9IHRydWUsIF9XSElURVNQQUNFX1RPS0VOU1t0b2tlbnMudGFiXSA9IHRydWUsIF9XSElURVNQQUNFX1RPS0VOUyk7XG5cdHZhciBXSElURVNQQUNFX0VRVUlWX1RPS0VOUyA9IE9iamVjdC5hc3NpZ24oe30sIFdISVRFU1BBQ0VfVE9LRU5TLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bdG9rZW5zLmNvbW1lbnRdID0gdHJ1ZSwgX09iamVjdCRhc3NpZ24pKTtcblx0ZnVuY3Rpb24gdG9rZW5TdGFydCh0b2tlbikge1xuXHQgIHJldHVybiB7XG5cdCAgICBsaW5lOiB0b2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX0xJTkVdLFxuXHQgICAgY29sdW1uOiB0b2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX0NPTF1cblx0ICB9O1xuXHR9XG5cdGZ1bmN0aW9uIHRva2VuRW5kKHRva2VuKSB7XG5cdCAgcmV0dXJuIHtcblx0ICAgIGxpbmU6IHRva2VuW190b2tlbml6ZS5GSUVMRFMuRU5EX0xJTkVdLFxuXHQgICAgY29sdW1uOiB0b2tlbltfdG9rZW5pemUuRklFTERTLkVORF9DT0xdXG5cdCAgfTtcblx0fVxuXHRmdW5jdGlvbiBnZXRTb3VyY2Uoc3RhcnRMaW5lLCBzdGFydENvbHVtbiwgZW5kTGluZSwgZW5kQ29sdW1uKSB7XG5cdCAgcmV0dXJuIHtcblx0ICAgIHN0YXJ0OiB7XG5cdCAgICAgIGxpbmU6IHN0YXJ0TGluZSxcblx0ICAgICAgY29sdW1uOiBzdGFydENvbHVtblxuXHQgICAgfSxcblx0ICAgIGVuZDoge1xuXHQgICAgICBsaW5lOiBlbmRMaW5lLFxuXHQgICAgICBjb2x1bW46IGVuZENvbHVtblxuXHQgICAgfVxuXHQgIH07XG5cdH1cblx0ZnVuY3Rpb24gZ2V0VG9rZW5Tb3VyY2UodG9rZW4pIHtcblx0ICByZXR1cm4gZ2V0U291cmNlKHRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfTElORV0sIHRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfQ09MXSwgdG9rZW5bX3Rva2VuaXplLkZJRUxEUy5FTkRfTElORV0sIHRva2VuW190b2tlbml6ZS5GSUVMRFMuRU5EX0NPTF0pO1xuXHR9XG5cdGZ1bmN0aW9uIGdldFRva2VuU291cmNlU3BhbihzdGFydFRva2VuLCBlbmRUb2tlbikge1xuXHQgIGlmICghc3RhcnRUb2tlbikge1xuXHQgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICB9XG5cdCAgcmV0dXJuIGdldFNvdXJjZShzdGFydFRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfTElORV0sIHN0YXJ0VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9DT0xdLCBlbmRUb2tlbltfdG9rZW5pemUuRklFTERTLkVORF9MSU5FXSwgZW5kVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5FTkRfQ09MXSk7XG5cdH1cblx0ZnVuY3Rpb24gdW5lc2NhcGVQcm9wKG5vZGUsIHByb3ApIHtcblx0ICB2YXIgdmFsdWUgPSBub2RlW3Byb3BdO1xuXHQgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgaWYgKHZhbHVlLmluZGV4T2YoXCJcXFxcXCIpICE9PSAtMSkge1xuXHQgICAgKDAsIF91dGlsLmVuc3VyZU9iamVjdCkobm9kZSwgJ3Jhd3MnKTtcblx0ICAgIG5vZGVbcHJvcF0gPSAoMCwgX3V0aWwudW5lc2MpKHZhbHVlKTtcblx0ICAgIGlmIChub2RlLnJhd3NbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBub2RlLnJhd3NbcHJvcF0gPSB2YWx1ZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIG5vZGU7XG5cdH1cblx0ZnVuY3Rpb24gaW5kZXhlc09mKGFycmF5LCBpdGVtKSB7XG5cdCAgdmFyIGkgPSAtMTtcblx0ICB2YXIgaW5kZXhlcyA9IFtdO1xuXHQgIHdoaWxlICgoaSA9IGFycmF5LmluZGV4T2YoaXRlbSwgaSArIDEpKSAhPT0gLTEpIHtcblx0ICAgIGluZGV4ZXMucHVzaChpKTtcblx0ICB9XG5cdCAgcmV0dXJuIGluZGV4ZXM7XG5cdH1cblx0ZnVuY3Rpb24gdW5pcXMoKSB7XG5cdCAgdmFyIGxpc3QgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcmd1bWVudHMpO1xuXHQgIHJldHVybiBsaXN0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSwgaSkge1xuXHQgICAgcmV0dXJuIGkgPT09IGxpc3QuaW5kZXhPZihpdGVtKTtcblx0ICB9KTtcblx0fVxuXHR2YXIgUGFyc2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBQYXJzZXIocnVsZSwgb3B0aW9ucykge1xuXHQgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuXHQgICAgICBvcHRpb25zID0ge307XG5cdCAgICB9XG5cdCAgICB0aGlzLnJ1bGUgPSBydWxlO1xuXHQgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdCAgICAgIGxvc3N5OiBmYWxzZSxcblx0ICAgICAgc2FmZTogZmFsc2Vcblx0ICAgIH0sIG9wdGlvbnMpO1xuXHQgICAgdGhpcy5wb3NpdGlvbiA9IDA7XG5cdCAgICB0aGlzLmNzcyA9IHR5cGVvZiB0aGlzLnJ1bGUgPT09ICdzdHJpbmcnID8gdGhpcy5ydWxlIDogdGhpcy5ydWxlLnNlbGVjdG9yO1xuXHQgICAgdGhpcy50b2tlbnMgPSAoMCwgX3Rva2VuaXplW1wiZGVmYXVsdFwiXSkoe1xuXHQgICAgICBjc3M6IHRoaXMuY3NzLFxuXHQgICAgICBlcnJvcjogdGhpcy5fZXJyb3JHZW5lcmF0b3IoKSxcblx0ICAgICAgc2FmZTogdGhpcy5vcHRpb25zLnNhZmVcblx0ICAgIH0pO1xuXHQgICAgdmFyIHJvb3RTb3VyY2UgPSBnZXRUb2tlblNvdXJjZVNwYW4odGhpcy50b2tlbnNbMF0sIHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdKTtcblx0ICAgIHRoaXMucm9vdCA9IG5ldyBfcm9vdFtcImRlZmF1bHRcIl0oe1xuXHQgICAgICBzb3VyY2U6IHJvb3RTb3VyY2Vcblx0ICAgIH0pO1xuXHQgICAgdGhpcy5yb290LmVycm9yR2VuZXJhdG9yID0gdGhpcy5fZXJyb3JHZW5lcmF0b3IoKTtcblx0ICAgIHZhciBzZWxlY3RvciA9IG5ldyBfc2VsZWN0b3JbXCJkZWZhdWx0XCJdKHtcblx0ICAgICAgc291cmNlOiB7XG5cdCAgICAgICAgc3RhcnQ6IHtcblx0ICAgICAgICAgIGxpbmU6IDEsXG5cdCAgICAgICAgICBjb2x1bW46IDFcblx0ICAgICAgICB9XG5cdCAgICAgIH0sXG5cdCAgICAgIHNvdXJjZUluZGV4OiAwXG5cdCAgICB9KTtcblx0ICAgIHRoaXMucm9vdC5hcHBlbmQoc2VsZWN0b3IpO1xuXHQgICAgdGhpcy5jdXJyZW50ID0gc2VsZWN0b3I7XG5cdCAgICB0aGlzLmxvb3AoKTtcblx0ICB9XG5cdCAgdmFyIF9wcm90byA9IFBhcnNlci5wcm90b3R5cGU7XG5cdCAgX3Byb3RvLl9lcnJvckdlbmVyYXRvciA9IGZ1bmN0aW9uIF9lcnJvckdlbmVyYXRvcigpIHtcblx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGVycm9yT3B0aW9ucykge1xuXHQgICAgICBpZiAodHlwZW9mIF90aGlzLnJ1bGUgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gX3RoaXMucnVsZS5lcnJvcihtZXNzYWdlLCBlcnJvck9wdGlvbnMpO1xuXHQgICAgfTtcblx0ICB9O1xuXHQgIF9wcm90by5hdHRyaWJ1dGUgPSBmdW5jdGlvbiBhdHRyaWJ1dGUoKSB7XG5cdCAgICB2YXIgYXR0ciA9IFtdO1xuXHQgICAgdmFyIHN0YXJ0aW5nVG9rZW4gPSB0aGlzLmN1cnJUb2tlbjtcblx0ICAgIHRoaXMucG9zaXRpb24rKztcblx0ICAgIHdoaWxlICh0aGlzLnBvc2l0aW9uIDwgdGhpcy50b2tlbnMubGVuZ3RoICYmIHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gIT09IHRva2Vucy5jbG9zZVNxdWFyZSkge1xuXHQgICAgICBhdHRyLnB1c2godGhpcy5jdXJyVG9rZW4pO1xuXHQgICAgICB0aGlzLnBvc2l0aW9uKys7XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSAhPT0gdG9rZW5zLmNsb3NlU3F1YXJlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmV4cGVjdGVkKCdjbG9zaW5nIHNxdWFyZSBicmFja2V0JywgdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdKTtcblx0ICAgIH1cblx0ICAgIHZhciBsZW4gPSBhdHRyLmxlbmd0aDtcblx0ICAgIHZhciBub2RlID0ge1xuXHQgICAgICBzb3VyY2U6IGdldFNvdXJjZShzdGFydGluZ1Rva2VuWzFdLCBzdGFydGluZ1Rva2VuWzJdLCB0aGlzLmN1cnJUb2tlblszXSwgdGhpcy5jdXJyVG9rZW5bNF0pLFxuXHQgICAgICBzb3VyY2VJbmRleDogc3RhcnRpbmdUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU11cblx0ICAgIH07XG5cdCAgICBpZiAobGVuID09PSAxICYmICF+W3Rva2Vucy53b3JkXS5pbmRleE9mKGF0dHJbMF1bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSkpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0ZWQoJ2F0dHJpYnV0ZScsIGF0dHJbMF1bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdKTtcblx0ICAgIH1cblx0ICAgIHZhciBwb3MgPSAwO1xuXHQgICAgdmFyIHNwYWNlQmVmb3JlID0gJyc7XG5cdCAgICB2YXIgY29tbWVudEJlZm9yZSA9ICcnO1xuXHQgICAgdmFyIGxhc3RBZGRlZCA9IG51bGw7XG5cdCAgICB2YXIgc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbiA9IGZhbHNlO1xuXHQgICAgd2hpbGUgKHBvcyA8IGxlbikge1xuXHQgICAgICB2YXIgdG9rZW4gPSBhdHRyW3Bvc107XG5cdCAgICAgIHZhciBjb250ZW50ID0gdGhpcy5jb250ZW50KHRva2VuKTtcblx0ICAgICAgdmFyIG5leHQgPSBhdHRyW3BvcyArIDFdO1xuXHQgICAgICBzd2l0Y2ggKHRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0pIHtcblx0ICAgICAgICBjYXNlIHRva2Vucy5zcGFjZTpcblx0ICAgICAgICAgIC8vIGlmIChcblx0ICAgICAgICAgIC8vICAgICBsZW4gPT09IDEgfHxcblx0ICAgICAgICAgIC8vICAgICBwb3MgPT09IDAgJiYgdGhpcy5jb250ZW50KG5leHQpID09PSAnfCdcblx0ICAgICAgICAgIC8vICkge1xuXHQgICAgICAgICAgLy8gICAgIHJldHVybiB0aGlzLmV4cGVjdGVkKCdhdHRyaWJ1dGUnLCB0b2tlbltUT0tFTi5TVEFSVF9QT1NdLCBjb250ZW50KTtcblx0ICAgICAgICAgIC8vIH1cblx0ICAgICAgICAgIHNwYWNlQWZ0ZXJNZWFuaW5nZnVsVG9rZW4gPSB0cnVlO1xuXHQgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb3NzeSkge1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGlmIChsYXN0QWRkZWQpIHtcblx0ICAgICAgICAgICAgKDAsIF91dGlsLmVuc3VyZU9iamVjdCkobm9kZSwgJ3NwYWNlcycsIGxhc3RBZGRlZCk7XG5cdCAgICAgICAgICAgIHZhciBwcmV2Q29udGVudCA9IG5vZGUuc3BhY2VzW2xhc3RBZGRlZF0uYWZ0ZXIgfHwgJyc7XG5cdCAgICAgICAgICAgIG5vZGUuc3BhY2VzW2xhc3RBZGRlZF0uYWZ0ZXIgPSBwcmV2Q29udGVudCArIGNvbnRlbnQ7XG5cdCAgICAgICAgICAgIHZhciBleGlzdGluZ0NvbW1lbnQgPSAoMCwgX3V0aWwuZ2V0UHJvcCkobm9kZSwgJ3Jhd3MnLCAnc3BhY2VzJywgbGFzdEFkZGVkLCAnYWZ0ZXInKSB8fCBudWxsO1xuXHQgICAgICAgICAgICBpZiAoZXhpc3RpbmdDb21tZW50KSB7XG5cdCAgICAgICAgICAgICAgbm9kZS5yYXdzLnNwYWNlc1tsYXN0QWRkZWRdLmFmdGVyID0gZXhpc3RpbmdDb21tZW50ICsgY29udGVudDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgc3BhY2VCZWZvcmUgPSBzcGFjZUJlZm9yZSArIGNvbnRlbnQ7XG5cdCAgICAgICAgICAgIGNvbW1lbnRCZWZvcmUgPSBjb21tZW50QmVmb3JlICsgY29udGVudDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgdG9rZW5zLmFzdGVyaXNrOlxuXHQgICAgICAgICAgaWYgKG5leHRbX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLmVxdWFscykge1xuXHQgICAgICAgICAgICBub2RlLm9wZXJhdG9yID0gY29udGVudDtcblx0ICAgICAgICAgICAgbGFzdEFkZGVkID0gJ29wZXJhdG9yJztcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoKCFub2RlLm5hbWVzcGFjZSB8fCBsYXN0QWRkZWQgPT09IFwibmFtZXNwYWNlXCIgJiYgIXNwYWNlQWZ0ZXJNZWFuaW5nZnVsVG9rZW4pICYmIG5leHQpIHtcblx0ICAgICAgICAgICAgaWYgKHNwYWNlQmVmb3JlKSB7XG5cdCAgICAgICAgICAgICAgKDAsIF91dGlsLmVuc3VyZU9iamVjdCkobm9kZSwgJ3NwYWNlcycsICdhdHRyaWJ1dGUnKTtcblx0ICAgICAgICAgICAgICBub2RlLnNwYWNlcy5hdHRyaWJ1dGUuYmVmb3JlID0gc3BhY2VCZWZvcmU7XG5cdCAgICAgICAgICAgICAgc3BhY2VCZWZvcmUgPSAnJztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoY29tbWVudEJlZm9yZSkge1xuXHQgICAgICAgICAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKG5vZGUsICdyYXdzJywgJ3NwYWNlcycsICdhdHRyaWJ1dGUnKTtcblx0ICAgICAgICAgICAgICBub2RlLnJhd3Muc3BhY2VzLmF0dHJpYnV0ZS5iZWZvcmUgPSBzcGFjZUJlZm9yZTtcblx0ICAgICAgICAgICAgICBjb21tZW50QmVmb3JlID0gJyc7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbm9kZS5uYW1lc3BhY2UgPSAobm9kZS5uYW1lc3BhY2UgfHwgXCJcIikgKyBjb250ZW50O1xuXHQgICAgICAgICAgICB2YXIgcmF3VmFsdWUgPSAoMCwgX3V0aWwuZ2V0UHJvcCkobm9kZSwgJ3Jhd3MnLCAnbmFtZXNwYWNlJykgfHwgbnVsbDtcblx0ICAgICAgICAgICAgaWYgKHJhd1ZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgbm9kZS5yYXdzLm5hbWVzcGFjZSArPSBjb250ZW50O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGxhc3RBZGRlZCA9ICduYW1lc3BhY2UnO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbiA9IGZhbHNlO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSB0b2tlbnMuZG9sbGFyOlxuXHQgICAgICAgICAgaWYgKGxhc3RBZGRlZCA9PT0gXCJ2YWx1ZVwiKSB7XG5cdCAgICAgICAgICAgIHZhciBvbGRSYXdWYWx1ZSA9ICgwLCBfdXRpbC5nZXRQcm9wKShub2RlLCAncmF3cycsICd2YWx1ZScpO1xuXHQgICAgICAgICAgICBub2RlLnZhbHVlICs9IFwiJFwiO1xuXHQgICAgICAgICAgICBpZiAob2xkUmF3VmFsdWUpIHtcblx0ICAgICAgICAgICAgICBub2RlLnJhd3MudmFsdWUgPSBvbGRSYXdWYWx1ZSArIFwiJFwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIC8vIEZhbGxzIHRocm91Z2hcblx0ICAgICAgICBjYXNlIHRva2Vucy5jYXJldDpcblx0ICAgICAgICAgIGlmIChuZXh0W190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5lcXVhbHMpIHtcblx0ICAgICAgICAgICAgbm9kZS5vcGVyYXRvciA9IGNvbnRlbnQ7XG5cdCAgICAgICAgICAgIGxhc3RBZGRlZCA9ICdvcGVyYXRvcic7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuID0gZmFsc2U7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIHRva2Vucy5jb21iaW5hdG9yOlxuXHQgICAgICAgICAgaWYgKGNvbnRlbnQgPT09ICd+JyAmJiBuZXh0W190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5lcXVhbHMpIHtcblx0ICAgICAgICAgICAgbm9kZS5vcGVyYXRvciA9IGNvbnRlbnQ7XG5cdCAgICAgICAgICAgIGxhc3RBZGRlZCA9ICdvcGVyYXRvcic7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBpZiAoY29udGVudCAhPT0gJ3wnKSB7XG5cdCAgICAgICAgICAgIHNwYWNlQWZ0ZXJNZWFuaW5nZnVsVG9rZW4gPSBmYWxzZTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBpZiAobmV4dFtfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuZXF1YWxzKSB7XG5cdCAgICAgICAgICAgIG5vZGUub3BlcmF0b3IgPSBjb250ZW50O1xuXHQgICAgICAgICAgICBsYXN0QWRkZWQgPSAnb3BlcmF0b3InO1xuXHQgICAgICAgICAgfSBlbHNlIGlmICghbm9kZS5uYW1lc3BhY2UgJiYgIW5vZGUuYXR0cmlidXRlKSB7XG5cdCAgICAgICAgICAgIG5vZGUubmFtZXNwYWNlID0gdHJ1ZTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHNwYWNlQWZ0ZXJNZWFuaW5nZnVsVG9rZW4gPSBmYWxzZTtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgdG9rZW5zLndvcmQ6XG5cdCAgICAgICAgICBpZiAobmV4dCAmJiB0aGlzLmNvbnRlbnQobmV4dCkgPT09ICd8JyAmJiBhdHRyW3BvcyArIDJdICYmIGF0dHJbcG9zICsgMl1bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSAhPT0gdG9rZW5zLmVxdWFscyAmJlxuXHQgICAgICAgICAgLy8gdGhpcyBsb29rLWFoZWFkIHByb2JhYmx5IGZhaWxzIHdpdGggY29tbWVudCBub2RlcyBpbnZvbHZlZC5cblx0ICAgICAgICAgICFub2RlLm9wZXJhdG9yICYmICFub2RlLm5hbWVzcGFjZSkge1xuXHQgICAgICAgICAgICBub2RlLm5hbWVzcGFjZSA9IGNvbnRlbnQ7XG5cdCAgICAgICAgICAgIGxhc3RBZGRlZCA9ICduYW1lc3BhY2UnO1xuXHQgICAgICAgICAgfSBlbHNlIGlmICghbm9kZS5hdHRyaWJ1dGUgfHwgbGFzdEFkZGVkID09PSBcImF0dHJpYnV0ZVwiICYmICFzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuKSB7XG5cdCAgICAgICAgICAgIGlmIChzcGFjZUJlZm9yZSkge1xuXHQgICAgICAgICAgICAgICgwLCBfdXRpbC5lbnN1cmVPYmplY3QpKG5vZGUsICdzcGFjZXMnLCAnYXR0cmlidXRlJyk7XG5cdCAgICAgICAgICAgICAgbm9kZS5zcGFjZXMuYXR0cmlidXRlLmJlZm9yZSA9IHNwYWNlQmVmb3JlO1xuXHQgICAgICAgICAgICAgIHNwYWNlQmVmb3JlID0gJyc7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGNvbW1lbnRCZWZvcmUpIHtcblx0ICAgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAncmF3cycsICdzcGFjZXMnLCAnYXR0cmlidXRlJyk7XG5cdCAgICAgICAgICAgICAgbm9kZS5yYXdzLnNwYWNlcy5hdHRyaWJ1dGUuYmVmb3JlID0gY29tbWVudEJlZm9yZTtcblx0ICAgICAgICAgICAgICBjb21tZW50QmVmb3JlID0gJyc7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbm9kZS5hdHRyaWJ1dGUgPSAobm9kZS5hdHRyaWJ1dGUgfHwgXCJcIikgKyBjb250ZW50O1xuXHQgICAgICAgICAgICB2YXIgX3Jhd1ZhbHVlID0gKDAsIF91dGlsLmdldFByb3ApKG5vZGUsICdyYXdzJywgJ2F0dHJpYnV0ZScpIHx8IG51bGw7XG5cdCAgICAgICAgICAgIGlmIChfcmF3VmFsdWUpIHtcblx0ICAgICAgICAgICAgICBub2RlLnJhd3MuYXR0cmlidXRlICs9IGNvbnRlbnQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbGFzdEFkZGVkID0gJ2F0dHJpYnV0ZSc7XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKCFub2RlLnZhbHVlICYmIG5vZGUudmFsdWUgIT09IFwiXCIgfHwgbGFzdEFkZGVkID09PSBcInZhbHVlXCIgJiYgIShzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuIHx8IG5vZGUucXVvdGVNYXJrKSkge1xuXHQgICAgICAgICAgICB2YXIgX3VuZXNjYXBlZCA9ICgwLCBfdXRpbC51bmVzYykoY29udGVudCk7XG5cdCAgICAgICAgICAgIHZhciBfb2xkUmF3VmFsdWUgPSAoMCwgX3V0aWwuZ2V0UHJvcCkobm9kZSwgJ3Jhd3MnLCAndmFsdWUnKSB8fCAnJztcblx0ICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gbm9kZS52YWx1ZSB8fCAnJztcblx0ICAgICAgICAgICAgbm9kZS52YWx1ZSA9IG9sZFZhbHVlICsgX3VuZXNjYXBlZDtcblx0ICAgICAgICAgICAgbm9kZS5xdW90ZU1hcmsgPSBudWxsO1xuXHQgICAgICAgICAgICBpZiAoX3VuZXNjYXBlZCAhPT0gY29udGVudCB8fCBfb2xkUmF3VmFsdWUpIHtcblx0ICAgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAncmF3cycpO1xuXHQgICAgICAgICAgICAgIG5vZGUucmF3cy52YWx1ZSA9IChfb2xkUmF3VmFsdWUgfHwgb2xkVmFsdWUpICsgY29udGVudDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBsYXN0QWRkZWQgPSAndmFsdWUnO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIGluc2Vuc2l0aXZlID0gY29udGVudCA9PT0gJ2knIHx8IGNvbnRlbnQgPT09IFwiSVwiO1xuXHQgICAgICAgICAgICBpZiAoKG5vZGUudmFsdWUgfHwgbm9kZS52YWx1ZSA9PT0gJycpICYmIChub2RlLnF1b3RlTWFyayB8fCBzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuKSkge1xuXHQgICAgICAgICAgICAgIG5vZGUuaW5zZW5zaXRpdmUgPSBpbnNlbnNpdGl2ZTtcblx0ICAgICAgICAgICAgICBpZiAoIWluc2Vuc2l0aXZlIHx8IGNvbnRlbnQgPT09IFwiSVwiKSB7XG5cdCAgICAgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAncmF3cycpO1xuXHQgICAgICAgICAgICAgICAgbm9kZS5yYXdzLmluc2Vuc2l0aXZlRmxhZyA9IGNvbnRlbnQ7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIGxhc3RBZGRlZCA9ICdpbnNlbnNpdGl2ZSc7XG5cdCAgICAgICAgICAgICAgaWYgKHNwYWNlQmVmb3JlKSB7XG5cdCAgICAgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAnc3BhY2VzJywgJ2luc2Vuc2l0aXZlJyk7XG5cdCAgICAgICAgICAgICAgICBub2RlLnNwYWNlcy5pbnNlbnNpdGl2ZS5iZWZvcmUgPSBzcGFjZUJlZm9yZTtcblx0ICAgICAgICAgICAgICAgIHNwYWNlQmVmb3JlID0gJyc7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIGlmIChjb21tZW50QmVmb3JlKSB7XG5cdCAgICAgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAncmF3cycsICdzcGFjZXMnLCAnaW5zZW5zaXRpdmUnKTtcblx0ICAgICAgICAgICAgICAgIG5vZGUucmF3cy5zcGFjZXMuaW5zZW5zaXRpdmUuYmVmb3JlID0gY29tbWVudEJlZm9yZTtcblx0ICAgICAgICAgICAgICAgIGNvbW1lbnRCZWZvcmUgPSAnJztcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSB8fCBub2RlLnZhbHVlID09PSAnJykge1xuXHQgICAgICAgICAgICAgIGxhc3RBZGRlZCA9ICd2YWx1ZSc7XG5cdCAgICAgICAgICAgICAgbm9kZS52YWx1ZSArPSBjb250ZW50O1xuXHQgICAgICAgICAgICAgIGlmIChub2RlLnJhd3MudmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIG5vZGUucmF3cy52YWx1ZSArPSBjb250ZW50O1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbiA9IGZhbHNlO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSB0b2tlbnMuc3RyOlxuXHQgICAgICAgICAgaWYgKCFub2RlLmF0dHJpYnV0ZSB8fCAhbm9kZS5vcGVyYXRvcikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihcIkV4cGVjdGVkIGFuIGF0dHJpYnV0ZSBmb2xsb3dlZCBieSBhbiBvcGVyYXRvciBwcmVjZWRpbmcgdGhlIHN0cmluZy5cIiwge1xuXHQgICAgICAgICAgICAgIGluZGV4OiB0b2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU11cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICB2YXIgX3VuZXNjYXBlVmFsdWUgPSAoMCwgX2F0dHJpYnV0ZS51bmVzY2FwZVZhbHVlKShjb250ZW50KSxcblx0ICAgICAgICAgICAgdW5lc2NhcGVkID0gX3VuZXNjYXBlVmFsdWUudW5lc2NhcGVkLFxuXHQgICAgICAgICAgICBxdW90ZU1hcmsgPSBfdW5lc2NhcGVWYWx1ZS5xdW90ZU1hcms7XG5cdCAgICAgICAgICBub2RlLnZhbHVlID0gdW5lc2NhcGVkO1xuXHQgICAgICAgICAgbm9kZS5xdW90ZU1hcmsgPSBxdW90ZU1hcms7XG5cdCAgICAgICAgICBsYXN0QWRkZWQgPSAndmFsdWUnO1xuXHQgICAgICAgICAgKDAsIF91dGlsLmVuc3VyZU9iamVjdCkobm9kZSwgJ3Jhd3MnKTtcblx0ICAgICAgICAgIG5vZGUucmF3cy52YWx1ZSA9IGNvbnRlbnQ7XG5cdCAgICAgICAgICBzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuID0gZmFsc2U7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIHRva2Vucy5lcXVhbHM6XG5cdCAgICAgICAgICBpZiAoIW5vZGUuYXR0cmlidXRlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGVjdGVkKCdhdHRyaWJ1dGUnLCB0b2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU10sIGNvbnRlbnQpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgaWYgKG5vZGUudmFsdWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ1VuZXhwZWN0ZWQgXCI9XCIgZm91bmQ7IGFuIG9wZXJhdG9yIHdhcyBhbHJlYWR5IGRlZmluZWQuJywge1xuXHQgICAgICAgICAgICAgIGluZGV4OiB0b2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU11cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBub2RlLm9wZXJhdG9yID0gbm9kZS5vcGVyYXRvciA/IG5vZGUub3BlcmF0b3IgKyBjb250ZW50IDogY29udGVudDtcblx0ICAgICAgICAgIGxhc3RBZGRlZCA9ICdvcGVyYXRvcic7XG5cdCAgICAgICAgICBzcGFjZUFmdGVyTWVhbmluZ2Z1bFRva2VuID0gZmFsc2U7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIHRva2Vucy5jb21tZW50OlxuXHQgICAgICAgICAgaWYgKGxhc3RBZGRlZCkge1xuXHQgICAgICAgICAgICBpZiAoc3BhY2VBZnRlck1lYW5pbmdmdWxUb2tlbiB8fCBuZXh0ICYmIG5leHRbX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLnNwYWNlIHx8IGxhc3RBZGRlZCA9PT0gJ2luc2Vuc2l0aXZlJykge1xuXHQgICAgICAgICAgICAgIHZhciBsYXN0Q29tbWVudCA9ICgwLCBfdXRpbC5nZXRQcm9wKShub2RlLCAnc3BhY2VzJywgbGFzdEFkZGVkLCAnYWZ0ZXInKSB8fCAnJztcblx0ICAgICAgICAgICAgICB2YXIgcmF3TGFzdENvbW1lbnQgPSAoMCwgX3V0aWwuZ2V0UHJvcCkobm9kZSwgJ3Jhd3MnLCAnc3BhY2VzJywgbGFzdEFkZGVkLCAnYWZ0ZXInKSB8fCBsYXN0Q29tbWVudDtcblx0ICAgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAncmF3cycsICdzcGFjZXMnLCBsYXN0QWRkZWQpO1xuXHQgICAgICAgICAgICAgIG5vZGUucmF3cy5zcGFjZXNbbGFzdEFkZGVkXS5hZnRlciA9IHJhd0xhc3RDb21tZW50ICsgY29udGVudDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICB2YXIgbGFzdFZhbHVlID0gbm9kZVtsYXN0QWRkZWRdIHx8ICcnO1xuXHQgICAgICAgICAgICAgIHZhciByYXdMYXN0VmFsdWUgPSAoMCwgX3V0aWwuZ2V0UHJvcCkobm9kZSwgJ3Jhd3MnLCBsYXN0QWRkZWQpIHx8IGxhc3RWYWx1ZTtcblx0ICAgICAgICAgICAgICAoMCwgX3V0aWwuZW5zdXJlT2JqZWN0KShub2RlLCAncmF3cycpO1xuXHQgICAgICAgICAgICAgIG5vZGUucmF3c1tsYXN0QWRkZWRdID0gcmF3TGFzdFZhbHVlICsgY29udGVudDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgY29tbWVudEJlZm9yZSA9IGNvbW1lbnRCZWZvcmUgKyBjb250ZW50O1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCBcXFwiXCIgKyBjb250ZW50ICsgXCJcXFwiIGZvdW5kLlwiLCB7XG5cdCAgICAgICAgICAgIGluZGV4OiB0b2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU11cblx0ICAgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICAgIHBvcysrO1xuXHQgICAgfVxuXHQgICAgdW5lc2NhcGVQcm9wKG5vZGUsIFwiYXR0cmlidXRlXCIpO1xuXHQgICAgdW5lc2NhcGVQcm9wKG5vZGUsIFwibmFtZXNwYWNlXCIpO1xuXHQgICAgdGhpcy5uZXdOb2RlKG5ldyBfYXR0cmlidXRlW1wiZGVmYXVsdFwiXShub2RlKSk7XG5cdCAgICB0aGlzLnBvc2l0aW9uKys7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogcmV0dXJuIGEgbm9kZSBjb250YWluaW5nIG1lYW5pbmdsZXNzIGdhcmJhZ2UgdXAgdG8gKGJ1dCBub3QgaW5jbHVkaW5nKSB0aGUgc3BlY2lmaWVkIHRva2VuIHBvc2l0aW9uLlxuXHQgICAqIGlmIHRoZSB0b2tlbiBwb3NpdGlvbiBpcyBuZWdhdGl2ZSwgYWxsIHJlbWFpbmluZyB0b2tlbnMgYXJlIGNvbnN1bWVkLlxuXHQgICAqXG5cdCAgICogVGhpcyByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgYSBzaW5nbGUgc3RyaW5nIG5vZGUgaWYgYWxsIHdoaXRlc3BhY2UsXG5cdCAgICogb3RoZXJ3aXNlIGFuIGFycmF5IG9mIGNvbW1lbnQgbm9kZXMgd2l0aCBzcGFjZSBiZWZvcmUgYW5kIGFmdGVyLlxuXHQgICAqXG5cdCAgICogVGhlc2UgdG9rZW5zIGFyZSBub3QgYWRkZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0b3IsIHRoZSBjYWxsZXIgY2FuIGFkZCB0aGVtIG9yIHVzZSB0aGVtIHRvIGFtZW5kXG5cdCAgICogYSBwcmV2aW91cyBub2RlJ3Mgc3BhY2UgbWV0YWRhdGEuXG5cdCAgICpcblx0ICAgKiBJbiBsb3NzeSBtb2RlLCB0aGlzIHJldHVybnMgb25seSBjb21tZW50cy5cblx0ICAgKi87XG5cdCAgX3Byb3RvLnBhcnNlV2hpdGVzcGFjZUVxdWl2YWxlbnRUb2tlbnMgPSBmdW5jdGlvbiBwYXJzZVdoaXRlc3BhY2VFcXVpdmFsZW50VG9rZW5zKHN0b3BQb3NpdGlvbikge1xuXHQgICAgaWYgKHN0b3BQb3NpdGlvbiA8IDApIHtcblx0ICAgICAgc3RvcFBvc2l0aW9uID0gdGhpcy50b2tlbnMubGVuZ3RoO1xuXHQgICAgfVxuXHQgICAgdmFyIHN0YXJ0UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuXHQgICAgdmFyIG5vZGVzID0gW107XG5cdCAgICB2YXIgc3BhY2UgPSBcIlwiO1xuXHQgICAgdmFyIGxhc3RDb21tZW50ID0gdW5kZWZpbmVkO1xuXHQgICAgZG8ge1xuXHQgICAgICBpZiAoV0hJVEVTUEFDRV9UT0tFTlNbdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXV0pIHtcblx0ICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5sb3NzeSkge1xuXHQgICAgICAgICAgc3BhY2UgKz0gdGhpcy5jb250ZW50KCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2UgaWYgKHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5jb21tZW50KSB7XG5cdCAgICAgICAgdmFyIHNwYWNlcyA9IHt9O1xuXHQgICAgICAgIGlmIChzcGFjZSkge1xuXHQgICAgICAgICAgc3BhY2VzLmJlZm9yZSA9IHNwYWNlO1xuXHQgICAgICAgICAgc3BhY2UgPSBcIlwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBsYXN0Q29tbWVudCA9IG5ldyBfY29tbWVudFtcImRlZmF1bHRcIl0oe1xuXHQgICAgICAgICAgdmFsdWU6IHRoaXMuY29udGVudCgpLFxuXHQgICAgICAgICAgc291cmNlOiBnZXRUb2tlblNvdXJjZSh0aGlzLmN1cnJUb2tlbiksXG5cdCAgICAgICAgICBzb3VyY2VJbmRleDogdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdLFxuXHQgICAgICAgICAgc3BhY2VzOiBzcGFjZXNcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBub2Rlcy5wdXNoKGxhc3RDb21tZW50KTtcblx0ICAgICAgfVxuXHQgICAgfSB3aGlsZSAoKyt0aGlzLnBvc2l0aW9uIDwgc3RvcFBvc2l0aW9uKTtcblx0ICAgIGlmIChzcGFjZSkge1xuXHQgICAgICBpZiAobGFzdENvbW1lbnQpIHtcblx0ICAgICAgICBsYXN0Q29tbWVudC5zcGFjZXMuYWZ0ZXIgPSBzcGFjZTtcblx0ICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmxvc3N5KSB7XG5cdCAgICAgICAgdmFyIGZpcnN0VG9rZW4gPSB0aGlzLnRva2Vuc1tzdGFydFBvc2l0aW9uXTtcblx0ICAgICAgICB2YXIgbGFzdFRva2VuID0gdGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbiAtIDFdO1xuXHQgICAgICAgIG5vZGVzLnB1c2gobmV3IF9zdHJpbmdbXCJkZWZhdWx0XCJdKHtcblx0ICAgICAgICAgIHZhbHVlOiAnJyxcblx0ICAgICAgICAgIHNvdXJjZTogZ2V0U291cmNlKGZpcnN0VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9MSU5FXSwgZmlyc3RUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX0NPTF0sIGxhc3RUb2tlbltfdG9rZW5pemUuRklFTERTLkVORF9MSU5FXSwgbGFzdFRva2VuW190b2tlbml6ZS5GSUVMRFMuRU5EX0NPTF0pLFxuXHQgICAgICAgICAgc291cmNlSW5kZXg6IGZpcnN0VG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdLFxuXHQgICAgICAgICAgc3BhY2VzOiB7XG5cdCAgICAgICAgICAgIGJlZm9yZTogc3BhY2UsXG5cdCAgICAgICAgICAgIGFmdGVyOiAnJ1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5vZGVzO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHsqfSBub2Rlc1xuXHQgICAqLztcblx0ICBfcHJvdG8uY29udmVydFdoaXRlc3BhY2VOb2Rlc1RvU3BhY2UgPSBmdW5jdGlvbiBjb252ZXJ0V2hpdGVzcGFjZU5vZGVzVG9TcGFjZShub2RlcywgcmVxdWlyZWRTcGFjZSkge1xuXHQgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cdCAgICBpZiAocmVxdWlyZWRTcGFjZSA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIHJlcXVpcmVkU3BhY2UgPSBmYWxzZTtcblx0ICAgIH1cblx0ICAgIHZhciBzcGFjZSA9IFwiXCI7XG5cdCAgICB2YXIgcmF3U3BhY2UgPSBcIlwiO1xuXHQgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuXHQgICAgICB2YXIgc3BhY2VCZWZvcmUgPSBfdGhpczIubG9zc3lTcGFjZShuLnNwYWNlcy5iZWZvcmUsIHJlcXVpcmVkU3BhY2UpO1xuXHQgICAgICB2YXIgcmF3U3BhY2VCZWZvcmUgPSBfdGhpczIubG9zc3lTcGFjZShuLnJhd1NwYWNlQmVmb3JlLCByZXF1aXJlZFNwYWNlKTtcblx0ICAgICAgc3BhY2UgKz0gc3BhY2VCZWZvcmUgKyBfdGhpczIubG9zc3lTcGFjZShuLnNwYWNlcy5hZnRlciwgcmVxdWlyZWRTcGFjZSAmJiBzcGFjZUJlZm9yZS5sZW5ndGggPT09IDApO1xuXHQgICAgICByYXdTcGFjZSArPSBzcGFjZUJlZm9yZSArIG4udmFsdWUgKyBfdGhpczIubG9zc3lTcGFjZShuLnJhd1NwYWNlQWZ0ZXIsIHJlcXVpcmVkU3BhY2UgJiYgcmF3U3BhY2VCZWZvcmUubGVuZ3RoID09PSAwKTtcblx0ICAgIH0pO1xuXHQgICAgaWYgKHJhd1NwYWNlID09PSBzcGFjZSkge1xuXHQgICAgICByYXdTcGFjZSA9IHVuZGVmaW5lZDtcblx0ICAgIH1cblx0ICAgIHZhciByZXN1bHQgPSB7XG5cdCAgICAgIHNwYWNlOiBzcGFjZSxcblx0ICAgICAgcmF3U3BhY2U6IHJhd1NwYWNlXG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXHQgIF9wcm90by5pc05hbWVkQ29tYmluYXRvciA9IGZ1bmN0aW9uIGlzTmFtZWRDb21iaW5hdG9yKHBvc2l0aW9uKSB7XG5cdCAgICBpZiAocG9zaXRpb24gPT09IHZvaWQgMCkge1xuXHQgICAgICBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy50b2tlbnNbcG9zaXRpb24gKyAwXSAmJiB0aGlzLnRva2Vuc1twb3NpdGlvbiArIDBdW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5zbGFzaCAmJiB0aGlzLnRva2Vuc1twb3NpdGlvbiArIDFdICYmIHRoaXMudG9rZW5zW3Bvc2l0aW9uICsgMV1bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLndvcmQgJiYgdGhpcy50b2tlbnNbcG9zaXRpb24gKyAyXSAmJiB0aGlzLnRva2Vuc1twb3NpdGlvbiArIDJdW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5zbGFzaDtcblx0ICB9O1xuXHQgIF9wcm90by5uYW1lZENvbWJpbmF0b3IgPSBmdW5jdGlvbiBuYW1lZENvbWJpbmF0b3IoKSB7XG5cdCAgICBpZiAodGhpcy5pc05hbWVkQ29tYmluYXRvcigpKSB7XG5cdCAgICAgIHZhciBuYW1lUmF3ID0gdGhpcy5jb250ZW50KHRoaXMudG9rZW5zW3RoaXMucG9zaXRpb24gKyAxXSk7XG5cdCAgICAgIHZhciBuYW1lID0gKDAsIF91dGlsLnVuZXNjKShuYW1lUmF3KS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICB2YXIgcmF3cyA9IHt9O1xuXHQgICAgICBpZiAobmFtZSAhPT0gbmFtZVJhdykge1xuXHQgICAgICAgIHJhd3MudmFsdWUgPSBcIi9cIiArIG5hbWVSYXcgKyBcIi9cIjtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgbm9kZSA9IG5ldyBfY29tYmluYXRvcltcImRlZmF1bHRcIl0oe1xuXHQgICAgICAgIHZhbHVlOiBcIi9cIiArIG5hbWUgKyBcIi9cIixcblx0ICAgICAgICBzb3VyY2U6IGdldFNvdXJjZSh0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX0xJTkVdLCB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX0NPTF0sIHRoaXMudG9rZW5zW3RoaXMucG9zaXRpb24gKyAyXVtfdG9rZW5pemUuRklFTERTLkVORF9MSU5FXSwgdGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbiArIDJdW190b2tlbml6ZS5GSUVMRFMuRU5EX0NPTF0pLFxuXHQgICAgICAgIHNvdXJjZUluZGV4OiB0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU10sXG5cdCAgICAgICAgcmF3czogcmF3c1xuXHQgICAgICB9KTtcblx0ICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gKyAzO1xuXHQgICAgICByZXR1cm4gbm9kZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgX3Byb3RvLmNvbWJpbmF0b3IgPSBmdW5jdGlvbiBjb21iaW5hdG9yKCkge1xuXHQgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cdCAgICBpZiAodGhpcy5jb250ZW50KCkgPT09ICd8Jykge1xuXHQgICAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2UoKTtcblx0ICAgIH1cblx0ICAgIC8vIFdlIG5lZWQgdG8gZGVjaWRlIGJldHdlZW4gYSBzcGFjZSB0aGF0J3MgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IgYW5kIG1lYW5pbmdsZXNzIHdoaXRlc3BhY2UgYXQgdGhlIGVuZCBvZiBhIHNlbGVjdG9yLlxuXHQgICAgdmFyIG5leHRTaWdUb2tlblBvcyA9IHRoaXMubG9jYXRlTmV4dE1lYW5pbmdmdWxUb2tlbih0aGlzLnBvc2l0aW9uKTtcblx0ICAgIGlmIChuZXh0U2lnVG9rZW5Qb3MgPCAwIHx8IHRoaXMudG9rZW5zW25leHRTaWdUb2tlblBvc11bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLmNvbW1hKSB7XG5cdCAgICAgIHZhciBub2RlcyA9IHRoaXMucGFyc2VXaGl0ZXNwYWNlRXF1aXZhbGVudFRva2VucyhuZXh0U2lnVG9rZW5Qb3MpO1xuXHQgICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkge1xuXHQgICAgICAgIHZhciBsYXN0ID0gdGhpcy5jdXJyZW50Lmxhc3Q7XG5cdCAgICAgICAgaWYgKGxhc3QpIHtcblx0ICAgICAgICAgIHZhciBfdGhpcyRjb252ZXJ0V2hpdGVzcGEgPSB0aGlzLmNvbnZlcnRXaGl0ZXNwYWNlTm9kZXNUb1NwYWNlKG5vZGVzKSxcblx0ICAgICAgICAgICAgc3BhY2UgPSBfdGhpcyRjb252ZXJ0V2hpdGVzcGEuc3BhY2UsXG5cdCAgICAgICAgICAgIHJhd1NwYWNlID0gX3RoaXMkY29udmVydFdoaXRlc3BhLnJhd1NwYWNlO1xuXHQgICAgICAgICAgaWYgKHJhd1NwYWNlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgbGFzdC5yYXdTcGFjZUFmdGVyICs9IHJhd1NwYWNlO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgbGFzdC5zcGFjZXMuYWZ0ZXIgKz0gc3BhY2U7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5uZXdOb2RlKG4pO1xuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHZhciBmaXJzdFRva2VuID0gdGhpcy5jdXJyVG9rZW47XG5cdCAgICB2YXIgc3BhY2VPckRlc2NlbmRhbnRTZWxlY3Rvck5vZGVzID0gdW5kZWZpbmVkO1xuXHQgICAgaWYgKG5leHRTaWdUb2tlblBvcyA+IHRoaXMucG9zaXRpb24pIHtcblx0ICAgICAgc3BhY2VPckRlc2NlbmRhbnRTZWxlY3Rvck5vZGVzID0gdGhpcy5wYXJzZVdoaXRlc3BhY2VFcXVpdmFsZW50VG9rZW5zKG5leHRTaWdUb2tlblBvcyk7XG5cdCAgICB9XG5cdCAgICB2YXIgbm9kZTtcblx0ICAgIGlmICh0aGlzLmlzTmFtZWRDb21iaW5hdG9yKCkpIHtcblx0ICAgICAgbm9kZSA9IHRoaXMubmFtZWRDb21iaW5hdG9yKCk7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5jb21iaW5hdG9yKSB7XG5cdCAgICAgIG5vZGUgPSBuZXcgX2NvbWJpbmF0b3JbXCJkZWZhdWx0XCJdKHtcblx0ICAgICAgICB2YWx1ZTogdGhpcy5jb250ZW50KCksXG5cdCAgICAgICAgc291cmNlOiBnZXRUb2tlblNvdXJjZSh0aGlzLmN1cnJUb2tlbiksXG5cdCAgICAgICAgc291cmNlSW5kZXg6IHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXVxuXHQgICAgICB9KTtcblx0ICAgICAgdGhpcy5wb3NpdGlvbisrO1xuXHQgICAgfSBlbHNlIGlmIChXSElURVNQQUNFX1RPS0VOU1t0aGlzLmN1cnJUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdXSkgOyBlbHNlIGlmICghc3BhY2VPckRlc2NlbmRhbnRTZWxlY3Rvck5vZGVzKSB7XG5cdCAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuXHQgICAgfVxuXHQgICAgaWYgKG5vZGUpIHtcblx0ICAgICAgaWYgKHNwYWNlT3JEZXNjZW5kYW50U2VsZWN0b3JOb2Rlcykge1xuXHQgICAgICAgIHZhciBfdGhpcyRjb252ZXJ0V2hpdGVzcGEyID0gdGhpcy5jb252ZXJ0V2hpdGVzcGFjZU5vZGVzVG9TcGFjZShzcGFjZU9yRGVzY2VuZGFudFNlbGVjdG9yTm9kZXMpLFxuXHQgICAgICAgICAgX3NwYWNlID0gX3RoaXMkY29udmVydFdoaXRlc3BhMi5zcGFjZSxcblx0ICAgICAgICAgIF9yYXdTcGFjZSA9IF90aGlzJGNvbnZlcnRXaGl0ZXNwYTIucmF3U3BhY2U7XG5cdCAgICAgICAgbm9kZS5zcGFjZXMuYmVmb3JlID0gX3NwYWNlO1xuXHQgICAgICAgIG5vZGUucmF3U3BhY2VCZWZvcmUgPSBfcmF3U3BhY2U7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIGRlc2NlbmRhbnQgY29tYmluYXRvclxuXHQgICAgICB2YXIgX3RoaXMkY29udmVydFdoaXRlc3BhMyA9IHRoaXMuY29udmVydFdoaXRlc3BhY2VOb2Rlc1RvU3BhY2Uoc3BhY2VPckRlc2NlbmRhbnRTZWxlY3Rvck5vZGVzLCB0cnVlKSxcblx0ICAgICAgICBfc3BhY2UyID0gX3RoaXMkY29udmVydFdoaXRlc3BhMy5zcGFjZSxcblx0ICAgICAgICBfcmF3U3BhY2UyID0gX3RoaXMkY29udmVydFdoaXRlc3BhMy5yYXdTcGFjZTtcblx0ICAgICAgaWYgKCFfcmF3U3BhY2UyKSB7XG5cdCAgICAgICAgX3Jhd1NwYWNlMiA9IF9zcGFjZTI7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIHNwYWNlcyA9IHt9O1xuXHQgICAgICB2YXIgcmF3cyA9IHtcblx0ICAgICAgICBzcGFjZXM6IHt9XG5cdCAgICAgIH07XG5cdCAgICAgIGlmIChfc3BhY2UyLmVuZHNXaXRoKCcgJykgJiYgX3Jhd1NwYWNlMi5lbmRzV2l0aCgnICcpKSB7XG5cdCAgICAgICAgc3BhY2VzLmJlZm9yZSA9IF9zcGFjZTIuc2xpY2UoMCwgX3NwYWNlMi5sZW5ndGggLSAxKTtcblx0ICAgICAgICByYXdzLnNwYWNlcy5iZWZvcmUgPSBfcmF3U3BhY2UyLnNsaWNlKDAsIF9yYXdTcGFjZTIubGVuZ3RoIC0gMSk7XG5cdCAgICAgIH0gZWxzZSBpZiAoX3NwYWNlMi5zdGFydHNXaXRoKCcgJykgJiYgX3Jhd1NwYWNlMi5zdGFydHNXaXRoKCcgJykpIHtcblx0ICAgICAgICBzcGFjZXMuYWZ0ZXIgPSBfc3BhY2UyLnNsaWNlKDEpO1xuXHQgICAgICAgIHJhd3Muc3BhY2VzLmFmdGVyID0gX3Jhd1NwYWNlMi5zbGljZSgxKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByYXdzLnZhbHVlID0gX3Jhd1NwYWNlMjtcblx0ICAgICAgfVxuXHQgICAgICBub2RlID0gbmV3IF9jb21iaW5hdG9yW1wiZGVmYXVsdFwiXSh7XG5cdCAgICAgICAgdmFsdWU6ICcgJyxcblx0ICAgICAgICBzb3VyY2U6IGdldFRva2VuU291cmNlU3BhbihmaXJzdFRva2VuLCB0aGlzLnRva2Vuc1t0aGlzLnBvc2l0aW9uIC0gMV0pLFxuXHQgICAgICAgIHNvdXJjZUluZGV4OiBmaXJzdFRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXSxcblx0ICAgICAgICBzcGFjZXM6IHNwYWNlcyxcblx0ICAgICAgICByYXdzOiByYXdzXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuY3VyclRva2VuICYmIHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5zcGFjZSkge1xuXHQgICAgICBub2RlLnNwYWNlcy5hZnRlciA9IHRoaXMub3B0aW9uYWxTcGFjZSh0aGlzLmNvbnRlbnQoKSk7XG5cdCAgICAgIHRoaXMucG9zaXRpb24rKztcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLm5ld05vZGUobm9kZSk7XG5cdCAgfTtcblx0ICBfcHJvdG8uY29tbWEgPSBmdW5jdGlvbiBjb21tYSgpIHtcblx0ICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSB0aGlzLnRva2Vucy5sZW5ndGggLSAxKSB7XG5cdCAgICAgIHRoaXMucm9vdC50cmFpbGluZ0NvbW1hID0gdHJ1ZTtcblx0ICAgICAgdGhpcy5wb3NpdGlvbisrO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB0aGlzLmN1cnJlbnQuX2luZmVyRW5kUG9zaXRpb24oKTtcblx0ICAgIHZhciBzZWxlY3RvciA9IG5ldyBfc2VsZWN0b3JbXCJkZWZhdWx0XCJdKHtcblx0ICAgICAgc291cmNlOiB7XG5cdCAgICAgICAgc3RhcnQ6IHRva2VuU3RhcnQodGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbiArIDFdKVxuXHQgICAgICB9LFxuXHQgICAgICBzb3VyY2VJbmRleDogdGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbiArIDFdW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXVxuXHQgICAgfSk7XG5cdCAgICB0aGlzLmN1cnJlbnQucGFyZW50LmFwcGVuZChzZWxlY3Rvcik7XG5cdCAgICB0aGlzLmN1cnJlbnQgPSBzZWxlY3Rvcjtcblx0ICAgIHRoaXMucG9zaXRpb24rKztcblx0ICB9O1xuXHQgIF9wcm90by5jb21tZW50ID0gZnVuY3Rpb24gY29tbWVudCgpIHtcblx0ICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyVG9rZW47XG5cdCAgICB0aGlzLm5ld05vZGUobmV3IF9jb21tZW50W1wiZGVmYXVsdFwiXSh7XG5cdCAgICAgIHZhbHVlOiB0aGlzLmNvbnRlbnQoKSxcblx0ICAgICAgc291cmNlOiBnZXRUb2tlblNvdXJjZShjdXJyZW50KSxcblx0ICAgICAgc291cmNlSW5kZXg6IGN1cnJlbnRbX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG5cdCAgICB9KSk7XG5cdCAgICB0aGlzLnBvc2l0aW9uKys7XG5cdCAgfTtcblx0ICBfcHJvdG8uZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtZXNzYWdlLCBvcHRzKSB7XG5cdCAgICB0aHJvdyB0aGlzLnJvb3QuZXJyb3IobWVzc2FnZSwgb3B0cyk7XG5cdCAgfTtcblx0ICBfcHJvdG8ubWlzc2luZ0JhY2tzbGFzaCA9IGZ1bmN0aW9uIG1pc3NpbmdCYWNrc2xhc2goKSB7XG5cdCAgICByZXR1cm4gdGhpcy5lcnJvcignRXhwZWN0ZWQgYSBiYWNrc2xhc2ggcHJlY2VkaW5nIHRoZSBzZW1pY29sb24uJywge1xuXHQgICAgICBpbmRleDogdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG5cdCAgICB9KTtcblx0ICB9O1xuXHQgIF9wcm90by5taXNzaW5nUGFyZW50aGVzaXMgPSBmdW5jdGlvbiBtaXNzaW5nUGFyZW50aGVzaXMoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5leHBlY3RlZCgnb3BlbmluZyBwYXJlbnRoZXNpcycsIHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXSk7XG5cdCAgfTtcblx0ICBfcHJvdG8ubWlzc2luZ1NxdWFyZUJyYWNrZXQgPSBmdW5jdGlvbiBtaXNzaW5nU3F1YXJlQnJhY2tldCgpIHtcblx0ICAgIHJldHVybiB0aGlzLmV4cGVjdGVkKCdvcGVuaW5nIHNxdWFyZSBicmFja2V0JywgdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdKTtcblx0ICB9O1xuXHQgIF9wcm90by51bmV4cGVjdGVkID0gZnVuY3Rpb24gdW5leHBlY3RlZCgpIHtcblx0ICAgIHJldHVybiB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCAnXCIgKyB0aGlzLmNvbnRlbnQoKSArIFwiJy4gRXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIHdpdGggXFxcXCBtYXkgaGVscC5cIiwgdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdKTtcblx0ICB9O1xuXHQgIF9wcm90by51bmV4cGVjdGVkUGlwZSA9IGZ1bmN0aW9uIHVuZXhwZWN0ZWRQaXBlKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkICd8Jy5cIiwgdGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdKTtcblx0ICB9O1xuXHQgIF9wcm90by5uYW1lc3BhY2UgPSBmdW5jdGlvbiBuYW1lc3BhY2UoKSB7XG5cdCAgICB2YXIgYmVmb3JlID0gdGhpcy5wcmV2VG9rZW4gJiYgdGhpcy5jb250ZW50KHRoaXMucHJldlRva2VuKSB8fCB0cnVlO1xuXHQgICAgaWYgKHRoaXMubmV4dFRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy53b3JkKSB7XG5cdCAgICAgIHRoaXMucG9zaXRpb24rKztcblx0ICAgICAgcmV0dXJuIHRoaXMud29yZChiZWZvcmUpO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLm5leHRUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuYXN0ZXJpc2spIHtcblx0ICAgICAgdGhpcy5wb3NpdGlvbisrO1xuXHQgICAgICByZXR1cm4gdGhpcy51bml2ZXJzYWwoYmVmb3JlKTtcblx0ICAgIH1cblx0ICAgIHRoaXMudW5leHBlY3RlZFBpcGUoKTtcblx0ICB9O1xuXHQgIF9wcm90by5uZXN0aW5nID0gZnVuY3Rpb24gbmVzdGluZygpIHtcblx0ICAgIGlmICh0aGlzLm5leHRUb2tlbikge1xuXHQgICAgICB2YXIgbmV4dENvbnRlbnQgPSB0aGlzLmNvbnRlbnQodGhpcy5uZXh0VG9rZW4pO1xuXHQgICAgICBpZiAobmV4dENvbnRlbnQgPT09IFwifFwiKSB7XG5cdCAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJUb2tlbjtcblx0ICAgIHRoaXMubmV3Tm9kZShuZXcgX25lc3RpbmdbXCJkZWZhdWx0XCJdKHtcblx0ICAgICAgdmFsdWU6IHRoaXMuY29udGVudCgpLFxuXHQgICAgICBzb3VyY2U6IGdldFRva2VuU291cmNlKGN1cnJlbnQpLFxuXHQgICAgICBzb3VyY2VJbmRleDogY3VycmVudFtfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU11cblx0ICAgIH0pKTtcblx0ICAgIHRoaXMucG9zaXRpb24rKztcblx0ICB9O1xuXHQgIF9wcm90by5wYXJlbnRoZXNlcyA9IGZ1bmN0aW9uIHBhcmVudGhlc2VzKCkge1xuXHQgICAgdmFyIGxhc3QgPSB0aGlzLmN1cnJlbnQubGFzdDtcblx0ICAgIHZhciB1bmJhbGFuY2VkID0gMTtcblx0ICAgIHRoaXMucG9zaXRpb24rKztcblx0ICAgIGlmIChsYXN0ICYmIGxhc3QudHlwZSA9PT0gdHlwZXMkMS5QU0VVRE8pIHtcblx0ICAgICAgdmFyIHNlbGVjdG9yID0gbmV3IF9zZWxlY3RvcltcImRlZmF1bHRcIl0oe1xuXHQgICAgICAgIHNvdXJjZToge1xuXHQgICAgICAgICAgc3RhcnQ6IHRva2VuU3RhcnQodGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbl0pXG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzb3VyY2VJbmRleDogdGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbl1bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG5cdCAgICAgIH0pO1xuXHQgICAgICB2YXIgY2FjaGUgPSB0aGlzLmN1cnJlbnQ7XG5cdCAgICAgIGxhc3QuYXBwZW5kKHNlbGVjdG9yKTtcblx0ICAgICAgdGhpcy5jdXJyZW50ID0gc2VsZWN0b3I7XG5cdCAgICAgIHdoaWxlICh0aGlzLnBvc2l0aW9uIDwgdGhpcy50b2tlbnMubGVuZ3RoICYmIHVuYmFsYW5jZWQpIHtcblx0ICAgICAgICBpZiAodGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLm9wZW5QYXJlbnRoZXNpcykge1xuXHQgICAgICAgICAgdW5iYWxhbmNlZCsrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLmNsb3NlUGFyZW50aGVzaXMpIHtcblx0ICAgICAgICAgIHVuYmFsYW5jZWQtLTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHVuYmFsYW5jZWQpIHtcblx0ICAgICAgICAgIHRoaXMucGFyc2UoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdGhpcy5jdXJyZW50LnNvdXJjZS5lbmQgPSB0b2tlbkVuZCh0aGlzLmN1cnJUb2tlbik7XG5cdCAgICAgICAgICB0aGlzLmN1cnJlbnQucGFyZW50LnNvdXJjZS5lbmQgPSB0b2tlbkVuZCh0aGlzLmN1cnJUb2tlbik7XG5cdCAgICAgICAgICB0aGlzLnBvc2l0aW9uKys7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHRoaXMuY3VycmVudCA9IGNhY2hlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gSSB0aGluayB0aGlzIGNhc2Ugc2hvdWxkIGJlIGFuIGVycm9yLiBJdCdzIHVzZWQgdG8gaW1wbGVtZW50IGEgYmFzaWMgcGFyc2Ugb2YgbWVkaWEgcXVlcmllc1xuXHQgICAgICAvLyBidXQgSSBkb24ndCB0aGluayBpdCdzIGEgZ29vZCBpZGVhLlxuXHQgICAgICB2YXIgcGFyZW5TdGFydCA9IHRoaXMuY3VyclRva2VuO1xuXHQgICAgICB2YXIgcGFyZW5WYWx1ZSA9IFwiKFwiO1xuXHQgICAgICB2YXIgcGFyZW5FbmQ7XG5cdCAgICAgIHdoaWxlICh0aGlzLnBvc2l0aW9uIDwgdGhpcy50b2tlbnMubGVuZ3RoICYmIHVuYmFsYW5jZWQpIHtcblx0ICAgICAgICBpZiAodGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLm9wZW5QYXJlbnRoZXNpcykge1xuXHQgICAgICAgICAgdW5iYWxhbmNlZCsrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSA9PT0gdG9rZW5zLmNsb3NlUGFyZW50aGVzaXMpIHtcblx0ICAgICAgICAgIHVuYmFsYW5jZWQtLTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcGFyZW5FbmQgPSB0aGlzLmN1cnJUb2tlbjtcblx0ICAgICAgICBwYXJlblZhbHVlICs9IHRoaXMucGFyc2VQYXJlbnRoZXNpc1Rva2VuKHRoaXMuY3VyclRva2VuKTtcblx0ICAgICAgICB0aGlzLnBvc2l0aW9uKys7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGxhc3QpIHtcblx0ICAgICAgICBsYXN0LmFwcGVuZFRvUHJvcGVydHlBbmRFc2NhcGUoXCJ2YWx1ZVwiLCBwYXJlblZhbHVlLCBwYXJlblZhbHVlKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLm5ld05vZGUobmV3IF9zdHJpbmdbXCJkZWZhdWx0XCJdKHtcblx0ICAgICAgICAgIHZhbHVlOiBwYXJlblZhbHVlLFxuXHQgICAgICAgICAgc291cmNlOiBnZXRTb3VyY2UocGFyZW5TdGFydFtfdG9rZW5pemUuRklFTERTLlNUQVJUX0xJTkVdLCBwYXJlblN0YXJ0W190b2tlbml6ZS5GSUVMRFMuU1RBUlRfQ09MXSwgcGFyZW5FbmRbX3Rva2VuaXplLkZJRUxEUy5FTkRfTElORV0sIHBhcmVuRW5kW190b2tlbml6ZS5GSUVMRFMuRU5EX0NPTF0pLFxuXHQgICAgICAgICAgc291cmNlSW5kZXg6IHBhcmVuU3RhcnRbX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG5cdCAgICAgICAgfSkpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAodW5iYWxhbmNlZCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5leHBlY3RlZCgnY2xvc2luZyBwYXJlbnRoZXNpcycsIHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXSk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICBfcHJvdG8ucHNldWRvID0gZnVuY3Rpb24gcHNldWRvKCkge1xuXHQgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cdCAgICB2YXIgcHNldWRvU3RyID0gJyc7XG5cdCAgICB2YXIgc3RhcnRpbmdUb2tlbiA9IHRoaXMuY3VyclRva2VuO1xuXHQgICAgd2hpbGUgKHRoaXMuY3VyclRva2VuICYmIHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5jb2xvbikge1xuXHQgICAgICBwc2V1ZG9TdHIgKz0gdGhpcy5jb250ZW50KCk7XG5cdCAgICAgIHRoaXMucG9zaXRpb24rKztcblx0ICAgIH1cblx0ICAgIGlmICghdGhpcy5jdXJyVG9rZW4pIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZXhwZWN0ZWQoWydwc2V1ZG8tY2xhc3MnLCAncHNldWRvLWVsZW1lbnQnXSwgdGhpcy5wb3NpdGlvbiAtIDEpO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy53b3JkKSB7XG5cdCAgICAgIHRoaXMuc3BsaXRXb3JkKGZhbHNlLCBmdW5jdGlvbiAoZmlyc3QsIGxlbmd0aCkge1xuXHQgICAgICAgIHBzZXVkb1N0ciArPSBmaXJzdDtcblx0ICAgICAgICBfdGhpczQubmV3Tm9kZShuZXcgX3BzZXVkb1tcImRlZmF1bHRcIl0oe1xuXHQgICAgICAgICAgdmFsdWU6IHBzZXVkb1N0cixcblx0ICAgICAgICAgIHNvdXJjZTogZ2V0VG9rZW5Tb3VyY2VTcGFuKHN0YXJ0aW5nVG9rZW4sIF90aGlzNC5jdXJyVG9rZW4pLFxuXHQgICAgICAgICAgc291cmNlSW5kZXg6IHN0YXJ0aW5nVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdXG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIGlmIChsZW5ndGggPiAxICYmIF90aGlzNC5uZXh0VG9rZW4gJiYgX3RoaXM0Lm5leHRUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMub3BlblBhcmVudGhlc2lzKSB7XG5cdCAgICAgICAgICBfdGhpczQuZXJyb3IoJ01pc3BsYWNlZCBwYXJlbnRoZXNpcy4nLCB7XG5cdCAgICAgICAgICAgIGluZGV4OiBfdGhpczQubmV4dFRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXVxuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmV4cGVjdGVkKFsncHNldWRvLWNsYXNzJywgJ3BzZXVkby1lbGVtZW50J10sIHRoaXMuY3VyclRva2VuW190b2tlbml6ZS5GSUVMRFMuU1RBUlRfUE9TXSk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICBfcHJvdG8uc3BhY2UgPSBmdW5jdGlvbiBzcGFjZSgpIHtcblx0ICAgIHZhciBjb250ZW50ID0gdGhpcy5jb250ZW50KCk7XG5cdCAgICAvLyBIYW5kbGUgc3BhY2UgYmVmb3JlIGFuZCBhZnRlciB0aGUgc2VsZWN0b3Jcblx0ICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSAwIHx8IHRoaXMucHJldlRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5jb21tYSB8fCB0aGlzLnByZXZUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMub3BlblBhcmVudGhlc2lzIHx8IHRoaXMuY3VycmVudC5ub2Rlcy5ldmVyeShmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICByZXR1cm4gbm9kZS50eXBlID09PSAnY29tbWVudCc7XG5cdCAgICB9KSkge1xuXHQgICAgICB0aGlzLnNwYWNlcyA9IHRoaXMub3B0aW9uYWxTcGFjZShjb250ZW50KTtcblx0ICAgICAgdGhpcy5wb3NpdGlvbisrO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLnBvc2l0aW9uID09PSB0aGlzLnRva2Vucy5sZW5ndGggLSAxIHx8IHRoaXMubmV4dFRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5jb21tYSB8fCB0aGlzLm5leHRUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdID09PSB0b2tlbnMuY2xvc2VQYXJlbnRoZXNpcykge1xuXHQgICAgICB0aGlzLmN1cnJlbnQubGFzdC5zcGFjZXMuYWZ0ZXIgPSB0aGlzLm9wdGlvbmFsU3BhY2UoY29udGVudCk7XG5cdCAgICAgIHRoaXMucG9zaXRpb24rKztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuY29tYmluYXRvcigpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgX3Byb3RvLnN0cmluZyA9IGZ1bmN0aW9uIHN0cmluZygpIHtcblx0ICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyVG9rZW47XG5cdCAgICB0aGlzLm5ld05vZGUobmV3IF9zdHJpbmdbXCJkZWZhdWx0XCJdKHtcblx0ICAgICAgdmFsdWU6IHRoaXMuY29udGVudCgpLFxuXHQgICAgICBzb3VyY2U6IGdldFRva2VuU291cmNlKGN1cnJlbnQpLFxuXHQgICAgICBzb3VyY2VJbmRleDogY3VycmVudFtfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU11cblx0ICAgIH0pKTtcblx0ICAgIHRoaXMucG9zaXRpb24rKztcblx0ICB9O1xuXHQgIF9wcm90by51bml2ZXJzYWwgPSBmdW5jdGlvbiB1bml2ZXJzYWwobmFtZXNwYWNlKSB7XG5cdCAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5uZXh0VG9rZW47XG5cdCAgICBpZiAobmV4dFRva2VuICYmIHRoaXMuY29udGVudChuZXh0VG9rZW4pID09PSAnfCcpIHtcblx0ICAgICAgdGhpcy5wb3NpdGlvbisrO1xuXHQgICAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2UoKTtcblx0ICAgIH1cblx0ICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyVG9rZW47XG5cdCAgICB0aGlzLm5ld05vZGUobmV3IF91bml2ZXJzYWxbXCJkZWZhdWx0XCJdKHtcblx0ICAgICAgdmFsdWU6IHRoaXMuY29udGVudCgpLFxuXHQgICAgICBzb3VyY2U6IGdldFRva2VuU291cmNlKGN1cnJlbnQpLFxuXHQgICAgICBzb3VyY2VJbmRleDogY3VycmVudFtfdG9rZW5pemUuRklFTERTLlNUQVJUX1BPU11cblx0ICAgIH0pLCBuYW1lc3BhY2UpO1xuXHQgICAgdGhpcy5wb3NpdGlvbisrO1xuXHQgIH07XG5cdCAgX3Byb3RvLnNwbGl0V29yZCA9IGZ1bmN0aW9uIHNwbGl0V29yZChuYW1lc3BhY2UsIGZpcnN0Q2FsbGJhY2spIHtcblx0ICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXHQgICAgdmFyIG5leHRUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuXHQgICAgdmFyIHdvcmQgPSB0aGlzLmNvbnRlbnQoKTtcblx0ICAgIHdoaWxlIChuZXh0VG9rZW4gJiYgflt0b2tlbnMuZG9sbGFyLCB0b2tlbnMuY2FyZXQsIHRva2Vucy5lcXVhbHMsIHRva2Vucy53b3JkXS5pbmRleE9mKG5leHRUb2tlbltfdG9rZW5pemUuRklFTERTLlRZUEVdKSkge1xuXHQgICAgICB0aGlzLnBvc2l0aW9uKys7XG5cdCAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jb250ZW50KCk7XG5cdCAgICAgIHdvcmQgKz0gY3VycmVudDtcblx0ICAgICAgaWYgKGN1cnJlbnQubGFzdEluZGV4T2YoJ1xcXFwnKSA9PT0gY3VycmVudC5sZW5ndGggLSAxKSB7XG5cdCAgICAgICAgdmFyIG5leHQgPSB0aGlzLm5leHRUb2tlbjtcblx0ICAgICAgICBpZiAobmV4dCAmJiBuZXh0W190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5zcGFjZSkge1xuXHQgICAgICAgICAgd29yZCArPSB0aGlzLnJlcXVpcmVkU3BhY2UodGhpcy5jb250ZW50KG5leHQpKTtcblx0ICAgICAgICAgIHRoaXMucG9zaXRpb24rKztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgbmV4dFRva2VuID0gdGhpcy5uZXh0VG9rZW47XG5cdCAgICB9XG5cdCAgICB2YXIgaGFzQ2xhc3MgPSBpbmRleGVzT2Yod29yZCwgJy4nKS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcblx0ICAgICAgLy8gQWxsb3cgZXNjYXBlZCBkb3Qgd2l0aGluIGNsYXNzIG5hbWVcblx0ICAgICAgdmFyIGVzY2FwZWREb3QgPSB3b3JkW2kgLSAxXSA9PT0gJ1xcXFwnO1xuXHQgICAgICAvLyBBbGxvdyBkZWNpbWFsIG51bWJlcnMgcGVyY2VudCBpbiBAa2V5ZnJhbWVzXG5cdCAgICAgIHZhciBpc0tleWZyYW1lc1BlcmNlbnQgPSAvXlxcZCtcXC5cXGQrJSQvLnRlc3Qod29yZCk7XG5cdCAgICAgIHJldHVybiAhZXNjYXBlZERvdCAmJiAhaXNLZXlmcmFtZXNQZXJjZW50O1xuXHQgICAgfSk7XG5cdCAgICB2YXIgaGFzSWQgPSBpbmRleGVzT2Yod29yZCwgJyMnKS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcblx0ICAgICAgcmV0dXJuIHdvcmRbaSAtIDFdICE9PSAnXFxcXCc7XG5cdCAgICB9KTtcblx0ICAgIC8vIEVsaW1pbmF0ZSBTYXNzIGludGVycG9sYXRpb25zIGZyb20gdGhlIGxpc3Qgb2YgaWQgaW5kZXhlc1xuXHQgICAgdmFyIGludGVycG9sYXRpb25zID0gaW5kZXhlc09mKHdvcmQsICcjeycpO1xuXHQgICAgaWYgKGludGVycG9sYXRpb25zLmxlbmd0aCkge1xuXHQgICAgICBoYXNJZCA9IGhhc0lkLmZpbHRlcihmdW5jdGlvbiAoaGFzaEluZGV4KSB7XG5cdCAgICAgICAgcmV0dXJuICF+aW50ZXJwb2xhdGlvbnMuaW5kZXhPZihoYXNoSW5kZXgpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIHZhciBpbmRpY2VzID0gKDAsIF9zb3J0QXNjZW5kaW5nW1wiZGVmYXVsdFwiXSkodW5pcXMoWzBdLmNvbmNhdChoYXNDbGFzcywgaGFzSWQpKSk7XG5cdCAgICBpbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKGluZCwgaSkge1xuXHQgICAgICB2YXIgaW5kZXggPSBpbmRpY2VzW2kgKyAxXSB8fCB3b3JkLmxlbmd0aDtcblx0ICAgICAgdmFyIHZhbHVlID0gd29yZC5zbGljZShpbmQsIGluZGV4KTtcblx0ICAgICAgaWYgKGkgPT09IDAgJiYgZmlyc3RDYWxsYmFjaykge1xuXHQgICAgICAgIHJldHVybiBmaXJzdENhbGxiYWNrLmNhbGwoX3RoaXM1LCB2YWx1ZSwgaW5kaWNlcy5sZW5ndGgpO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBub2RlO1xuXHQgICAgICB2YXIgY3VycmVudCA9IF90aGlzNS5jdXJyVG9rZW47XG5cdCAgICAgIHZhciBzb3VyY2VJbmRleCA9IGN1cnJlbnRbX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdICsgaW5kaWNlc1tpXTtcblx0ICAgICAgdmFyIHNvdXJjZSA9IGdldFNvdXJjZShjdXJyZW50WzFdLCBjdXJyZW50WzJdICsgaW5kLCBjdXJyZW50WzNdLCBjdXJyZW50WzJdICsgKGluZGV4IC0gMSkpO1xuXHQgICAgICBpZiAofmhhc0NsYXNzLmluZGV4T2YoaW5kKSkge1xuXHQgICAgICAgIHZhciBjbGFzc05hbWVPcHRzID0ge1xuXHQgICAgICAgICAgdmFsdWU6IHZhbHVlLnNsaWNlKDEpLFxuXHQgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG5cdCAgICAgICAgICBzb3VyY2VJbmRleDogc291cmNlSW5kZXhcblx0ICAgICAgICB9O1xuXHQgICAgICAgIG5vZGUgPSBuZXcgX2NsYXNzTmFtZVtcImRlZmF1bHRcIl0odW5lc2NhcGVQcm9wKGNsYXNzTmFtZU9wdHMsIFwidmFsdWVcIikpO1xuXHQgICAgICB9IGVsc2UgaWYgKH5oYXNJZC5pbmRleE9mKGluZCkpIHtcblx0ICAgICAgICB2YXIgaWRPcHRzID0ge1xuXHQgICAgICAgICAgdmFsdWU6IHZhbHVlLnNsaWNlKDEpLFxuXHQgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG5cdCAgICAgICAgICBzb3VyY2VJbmRleDogc291cmNlSW5kZXhcblx0ICAgICAgICB9O1xuXHQgICAgICAgIG5vZGUgPSBuZXcgX2lkW1wiZGVmYXVsdFwiXSh1bmVzY2FwZVByb3AoaWRPcHRzLCBcInZhbHVlXCIpKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB2YXIgdGFnT3B0cyA9IHtcblx0ICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcblx0ICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuXHQgICAgICAgICAgc291cmNlSW5kZXg6IHNvdXJjZUluZGV4XG5cdCAgICAgICAgfTtcblx0ICAgICAgICB1bmVzY2FwZVByb3AodGFnT3B0cywgXCJ2YWx1ZVwiKTtcblx0ICAgICAgICBub2RlID0gbmV3IF90YWdbXCJkZWZhdWx0XCJdKHRhZ09wdHMpO1xuXHQgICAgICB9XG5cdCAgICAgIF90aGlzNS5uZXdOb2RlKG5vZGUsIG5hbWVzcGFjZSk7XG5cdCAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBuYW1lc3BhY2UgaXMgdXNlZCBvbmx5IG9uY2Vcblx0ICAgICAgbmFtZXNwYWNlID0gbnVsbDtcblx0ICAgIH0pO1xuXHQgICAgdGhpcy5wb3NpdGlvbisrO1xuXHQgIH07XG5cdCAgX3Byb3RvLndvcmQgPSBmdW5jdGlvbiB3b3JkKG5hbWVzcGFjZSkge1xuXHQgICAgdmFyIG5leHRUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuXHQgICAgaWYgKG5leHRUb2tlbiAmJiB0aGlzLmNvbnRlbnQobmV4dFRva2VuKSA9PT0gJ3wnKSB7XG5cdCAgICAgIHRoaXMucG9zaXRpb24rKztcblx0ICAgICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5zcGxpdFdvcmQobmFtZXNwYWNlKTtcblx0ICB9O1xuXHQgIF9wcm90by5sb29wID0gZnVuY3Rpb24gbG9vcCgpIHtcblx0ICAgIHdoaWxlICh0aGlzLnBvc2l0aW9uIDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XG5cdCAgICAgIHRoaXMucGFyc2UodHJ1ZSk7XG5cdCAgICB9XG5cdCAgICB0aGlzLmN1cnJlbnQuX2luZmVyRW5kUG9zaXRpb24oKTtcblx0ICAgIHJldHVybiB0aGlzLnJvb3Q7XG5cdCAgfTtcblx0ICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0aHJvd09uUGFyZW50aGVzaXMpIHtcblx0ICAgIHN3aXRjaCAodGhpcy5jdXJyVG9rZW5bX3Rva2VuaXplLkZJRUxEUy5UWVBFXSkge1xuXHQgICAgICBjYXNlIHRva2Vucy5zcGFjZTpcblx0ICAgICAgICB0aGlzLnNwYWNlKCk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGNhc2UgdG9rZW5zLmNvbW1lbnQ6XG5cdCAgICAgICAgdGhpcy5jb21tZW50KCk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGNhc2UgdG9rZW5zLm9wZW5QYXJlbnRoZXNpczpcblx0ICAgICAgICB0aGlzLnBhcmVudGhlc2VzKCk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGNhc2UgdG9rZW5zLmNsb3NlUGFyZW50aGVzaXM6XG5cdCAgICAgICAgaWYgKHRocm93T25QYXJlbnRoZXNpcykge1xuXHQgICAgICAgICAgdGhpcy5taXNzaW5nUGFyZW50aGVzaXMoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGNhc2UgdG9rZW5zLm9wZW5TcXVhcmU6XG5cdCAgICAgICAgdGhpcy5hdHRyaWJ1dGUoKTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgY2FzZSB0b2tlbnMuZG9sbGFyOlxuXHQgICAgICBjYXNlIHRva2Vucy5jYXJldDpcblx0ICAgICAgY2FzZSB0b2tlbnMuZXF1YWxzOlxuXHQgICAgICBjYXNlIHRva2Vucy53b3JkOlxuXHQgICAgICAgIHRoaXMud29yZCgpO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBjYXNlIHRva2Vucy5jb2xvbjpcblx0ICAgICAgICB0aGlzLnBzZXVkbygpO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBjYXNlIHRva2Vucy5jb21tYTpcblx0ICAgICAgICB0aGlzLmNvbW1hKCk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGNhc2UgdG9rZW5zLmFzdGVyaXNrOlxuXHQgICAgICAgIHRoaXMudW5pdmVyc2FsKCk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGNhc2UgdG9rZW5zLmFtcGVyc2FuZDpcblx0ICAgICAgICB0aGlzLm5lc3RpbmcoKTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgY2FzZSB0b2tlbnMuc2xhc2g6XG5cdCAgICAgIGNhc2UgdG9rZW5zLmNvbWJpbmF0b3I6XG5cdCAgICAgICAgdGhpcy5jb21iaW5hdG9yKCk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGNhc2UgdG9rZW5zLnN0cjpcblx0ICAgICAgICB0aGlzLnN0cmluZygpO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICAvLyBUaGVzZSBjYXNlcyB0aHJvdzsgbm8gYnJlYWsgbmVlZGVkLlxuXHQgICAgICBjYXNlIHRva2Vucy5jbG9zZVNxdWFyZTpcblx0ICAgICAgICB0aGlzLm1pc3NpbmdTcXVhcmVCcmFja2V0KCk7XG5cdCAgICAgIGNhc2UgdG9rZW5zLnNlbWljb2xvbjpcblx0ICAgICAgICB0aGlzLm1pc3NpbmdCYWNrc2xhc2goKTtcblx0ICAgICAgZGVmYXVsdDpcblx0ICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBIZWxwZXJzXG5cdCAgICovO1xuXHQgIF9wcm90by5leHBlY3RlZCA9IGZ1bmN0aW9uIGV4cGVjdGVkKGRlc2NyaXB0aW9uLCBpbmRleCwgZm91bmQpIHtcblx0ICAgIGlmIChBcnJheS5pc0FycmF5KGRlc2NyaXB0aW9uKSkge1xuXHQgICAgICB2YXIgbGFzdCA9IGRlc2NyaXB0aW9uLnBvcCgpO1xuXHQgICAgICBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uLmpvaW4oJywgJykgKyBcIiBvciBcIiArIGxhc3Q7XG5cdCAgICB9XG5cdCAgICB2YXIgYW4gPSAvXlthZWlvdV0vLnRlc3QoZGVzY3JpcHRpb25bMF0pID8gJ2FuJyA6ICdhJztcblx0ICAgIGlmICghZm91bmQpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCJFeHBlY3RlZCBcIiArIGFuICsgXCIgXCIgKyBkZXNjcmlwdGlvbiArIFwiLlwiLCB7XG5cdCAgICAgICAgaW5kZXg6IGluZGV4XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCJFeHBlY3RlZCBcIiArIGFuICsgXCIgXCIgKyBkZXNjcmlwdGlvbiArIFwiLCBmb3VuZCBcXFwiXCIgKyBmb3VuZCArIFwiXFxcIiBpbnN0ZWFkLlwiLCB7XG5cdCAgICAgIGluZGV4OiBpbmRleFxuXHQgICAgfSk7XG5cdCAgfTtcblx0ICBfcHJvdG8ucmVxdWlyZWRTcGFjZSA9IGZ1bmN0aW9uIHJlcXVpcmVkU3BhY2Uoc3BhY2UpIHtcblx0ICAgIHJldHVybiB0aGlzLm9wdGlvbnMubG9zc3kgPyAnICcgOiBzcGFjZTtcblx0ICB9O1xuXHQgIF9wcm90by5vcHRpb25hbFNwYWNlID0gZnVuY3Rpb24gb3B0aW9uYWxTcGFjZShzcGFjZSkge1xuXHQgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sb3NzeSA/ICcnIDogc3BhY2U7XG5cdCAgfTtcblx0ICBfcHJvdG8ubG9zc3lTcGFjZSA9IGZ1bmN0aW9uIGxvc3N5U3BhY2Uoc3BhY2UsIHJlcXVpcmVkKSB7XG5cdCAgICBpZiAodGhpcy5vcHRpb25zLmxvc3N5KSB7XG5cdCAgICAgIHJldHVybiByZXF1aXJlZCA/ICcgJyA6ICcnO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHNwYWNlO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgX3Byb3RvLnBhcnNlUGFyZW50aGVzaXNUb2tlbiA9IGZ1bmN0aW9uIHBhcnNlUGFyZW50aGVzaXNUb2tlbih0b2tlbikge1xuXHQgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQodG9rZW4pO1xuXHQgICAgaWYgKHRva2VuW190b2tlbml6ZS5GSUVMRFMuVFlQRV0gPT09IHRva2Vucy5zcGFjZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlZFNwYWNlKGNvbnRlbnQpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIGNvbnRlbnQ7XG5cdCAgICB9XG5cdCAgfTtcblx0ICBfcHJvdG8ubmV3Tm9kZSA9IGZ1bmN0aW9uIG5ld05vZGUobm9kZSwgbmFtZXNwYWNlKSB7XG5cdCAgICBpZiAobmFtZXNwYWNlKSB7XG5cdCAgICAgIGlmICgvXiArJC8udGVzdChuYW1lc3BhY2UpKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubG9zc3kpIHtcblx0ICAgICAgICAgIHRoaXMuc3BhY2VzID0gKHRoaXMuc3BhY2VzIHx8ICcnKSArIG5hbWVzcGFjZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbmFtZXNwYWNlID0gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgICBub2RlLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0ICAgICAgdW5lc2NhcGVQcm9wKG5vZGUsIFwibmFtZXNwYWNlXCIpO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuc3BhY2VzKSB7XG5cdCAgICAgIG5vZGUuc3BhY2VzLmJlZm9yZSA9IHRoaXMuc3BhY2VzO1xuXHQgICAgICB0aGlzLnNwYWNlcyA9ICcnO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuY3VycmVudC5hcHBlbmQobm9kZSk7XG5cdCAgfTtcblx0ICBfcHJvdG8uY29udGVudCA9IGZ1bmN0aW9uIGNvbnRlbnQodG9rZW4pIHtcblx0ICAgIGlmICh0b2tlbiA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIHRva2VuID0gdGhpcy5jdXJyVG9rZW47XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5jc3Muc2xpY2UodG9rZW5bX3Rva2VuaXplLkZJRUxEUy5TVEFSVF9QT1NdLCB0b2tlbltfdG9rZW5pemUuRklFTERTLkVORF9QT1NdKTtcblx0ICB9O1xuXHQgIC8qKlxuXHQgICAqIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IG5vbi13aGl0ZXNwYWNlLCBub24tY29tbWVudCB0b2tlbi5cblx0ICAgKiByZXR1cm5zIC0xIGlmIG5vIG1lYW5pbmdmdWwgdG9rZW4gaXMgZm91bmQuXG5cdCAgICovXG5cdCAgX3Byb3RvLmxvY2F0ZU5leHRNZWFuaW5nZnVsVG9rZW4gPSBmdW5jdGlvbiBsb2NhdGVOZXh0TWVhbmluZ2Z1bFRva2VuKHN0YXJ0UG9zaXRpb24pIHtcblx0ICAgIGlmIChzdGFydFBvc2l0aW9uID09PSB2b2lkIDApIHtcblx0ICAgICAgc3RhcnRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gKyAxO1xuXHQgICAgfVxuXHQgICAgdmFyIHNlYXJjaFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcblx0ICAgIHdoaWxlIChzZWFyY2hQb3NpdGlvbiA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuXHQgICAgICBpZiAoV0hJVEVTUEFDRV9FUVVJVl9UT0tFTlNbdGhpcy50b2tlbnNbc2VhcmNoUG9zaXRpb25dW190b2tlbml6ZS5GSUVMRFMuVFlQRV1dKSB7XG5cdCAgICAgICAgc2VhcmNoUG9zaXRpb24rKztcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gc2VhcmNoUG9zaXRpb247XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiAtMTtcblx0ICB9O1xuXHQgIF9jcmVhdGVDbGFzcyhQYXJzZXIsIFt7XG5cdCAgICBrZXk6IFwiY3VyclRva2VuXCIsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMucG9zaXRpb25dO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJuZXh0VG9rZW5cIixcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbiArIDFdO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJwcmV2VG9rZW5cIixcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5wb3NpdGlvbiAtIDFdO1xuXHQgICAgfVxuXHQgIH1dKTtcblx0ICByZXR1cm4gUGFyc2VyO1xuXHR9KCk7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUGFyc2VyO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDsgXG59IChwYXJzZXIsIHBhcnNlci5leHBvcnRzKSk7XG5cbnZhciBwYXJzZXJFeHBvcnRzID0gcGFyc2VyLmV4cG9ydHM7XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cdHZhciBfcGFyc2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChwYXJzZXJFeHBvcnRzKTtcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cdHZhciBQcm9jZXNzb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIFByb2Nlc3NvcihmdW5jLCBvcHRpb25zKSB7XG5cdCAgICB0aGlzLmZ1bmMgPSBmdW5jIHx8IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblx0ICAgIHRoaXMuZnVuY1JlcyA9IG51bGw7XG5cdCAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHQgIH1cblx0ICB2YXIgX3Byb3RvID0gUHJvY2Vzc29yLnByb3RvdHlwZTtcblx0ICBfcHJvdG8uX3Nob3VsZFVwZGF0ZVNlbGVjdG9yID0gZnVuY3Rpb24gX3Nob3VsZFVwZGF0ZVNlbGVjdG9yKHJ1bGUsIG9wdGlvbnMpIHtcblx0ICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcblx0ICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgfVxuXHQgICAgdmFyIG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cdCAgICBpZiAobWVyZ2VkLnVwZGF0ZVNlbGVjdG9yID09PSBmYWxzZSkge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gdHlwZW9mIHJ1bGUgIT09IFwic3RyaW5nXCI7XG5cdCAgICB9XG5cdCAgfTtcblx0ICBfcHJvdG8uX2lzTG9zc3kgPSBmdW5jdGlvbiBfaXNMb3NzeShvcHRpb25zKSB7XG5cdCAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgIH1cblx0ICAgIHZhciBtZXJnZWQgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXHQgICAgaWYgKG1lcmdlZC5sb3NzbGVzcyA9PT0gZmFsc2UpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfTtcblx0ICBfcHJvdG8uX3Jvb3QgPSBmdW5jdGlvbiBfcm9vdChydWxlLCBvcHRpb25zKSB7XG5cdCAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgIH1cblx0ICAgIHZhciBwYXJzZXIgPSBuZXcgX3BhcnNlcltcImRlZmF1bHRcIl0ocnVsZSwgdGhpcy5fcGFyc2VPcHRpb25zKG9wdGlvbnMpKTtcblx0ICAgIHJldHVybiBwYXJzZXIucm9vdDtcblx0ICB9O1xuXHQgIF9wcm90by5fcGFyc2VPcHRpb25zID0gZnVuY3Rpb24gX3BhcnNlT3B0aW9ucyhvcHRpb25zKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBsb3NzeTogdGhpcy5faXNMb3NzeShvcHRpb25zKVxuXHQgICAgfTtcblx0ICB9O1xuXHQgIF9wcm90by5fcnVuID0gZnVuY3Rpb24gX3J1bihydWxlLCBvcHRpb25zKSB7XG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuXHQgICAgICBvcHRpb25zID0ge307XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHZhciByb290ID0gX3RoaXMuX3Jvb3QocnVsZSwgb3B0aW9ucyk7XG5cdCAgICAgICAgUHJvbWlzZS5yZXNvbHZlKF90aGlzLmZ1bmMocm9vdCkpLnRoZW4oZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuXHQgICAgICAgICAgdmFyIHN0cmluZyA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgIGlmIChfdGhpcy5fc2hvdWxkVXBkYXRlU2VsZWN0b3IocnVsZSwgb3B0aW9ucykpIHtcblx0ICAgICAgICAgICAgc3RyaW5nID0gcm9vdC50b1N0cmluZygpO1xuXHQgICAgICAgICAgICBydWxlLnNlbGVjdG9yID0gc3RyaW5nO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG5cdCAgICAgICAgICAgIHJvb3Q6IHJvb3QsXG5cdCAgICAgICAgICAgIHN0cmluZzogc3RyaW5nXG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIHJlamVjdChlKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cdCAgX3Byb3RvLl9ydW5TeW5jID0gZnVuY3Rpb24gX3J1blN5bmMocnVsZSwgb3B0aW9ucykge1xuXHQgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuXHQgICAgICBvcHRpb25zID0ge307XG5cdCAgICB9XG5cdCAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3QocnVsZSwgb3B0aW9ucyk7XG5cdCAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5mdW5jKHJvb3QpO1xuXHQgICAgaWYgKHRyYW5zZm9ybSAmJiB0eXBlb2YgdHJhbnNmb3JtLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWxlY3RvciBwcm9jZXNzb3IgcmV0dXJuZWQgYSBwcm9taXNlIHRvIGEgc3luY2hyb25vdXMgY2FsbC5cIik7XG5cdCAgICB9XG5cdCAgICB2YXIgc3RyaW5nID0gdW5kZWZpbmVkO1xuXHQgICAgaWYgKG9wdGlvbnMudXBkYXRlU2VsZWN0b3IgJiYgdHlwZW9mIHJ1bGUgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgc3RyaW5nID0gcm9vdC50b1N0cmluZygpO1xuXHQgICAgICBydWxlLnNlbGVjdG9yID0gc3RyaW5nO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG5cdCAgICAgIHJvb3Q6IHJvb3QsXG5cdCAgICAgIHN0cmluZzogc3RyaW5nXG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFByb2Nlc3MgcnVsZSBpbnRvIGEgc2VsZWN0b3IgQVNULlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHJ1bGUge3Bvc3Rjc3MuUnVsZSB8IHN0cmluZ30gVGhlIGNzcyBzZWxlY3RvciB0byBiZSBwcm9jZXNzZWRcblx0ICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgcHJvY2Vzc2luZ1xuXHQgICAqIEByZXR1cm5zIHtQcm9taXNlPHBhcnNlci5Sb290Pn0gVGhlIEFTVCBvZiB0aGUgc2VsZWN0b3IgYWZ0ZXIgcHJvY2Vzc2luZyBpdC5cblx0ICAgKi87XG5cdCAgX3Byb3RvLmFzdCA9IGZ1bmN0aW9uIGFzdChydWxlLCBvcHRpb25zKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fcnVuKHJ1bGUsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXHQgICAgICByZXR1cm4gcmVzdWx0LnJvb3Q7XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBQcm9jZXNzIHJ1bGUgaW50byBhIHNlbGVjdG9yIEFTVCBzeW5jaHJvbm91c2x5LlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHJ1bGUge3Bvc3Rjc3MuUnVsZSB8IHN0cmluZ30gVGhlIGNzcyBzZWxlY3RvciB0byBiZSBwcm9jZXNzZWRcblx0ICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgcHJvY2Vzc2luZ1xuXHQgICAqIEByZXR1cm5zIHtwYXJzZXIuUm9vdH0gVGhlIEFTVCBvZiB0aGUgc2VsZWN0b3IgYWZ0ZXIgcHJvY2Vzc2luZyBpdC5cblx0ICAgKi87XG5cdCAgX3Byb3RvLmFzdFN5bmMgPSBmdW5jdGlvbiBhc3RTeW5jKHJ1bGUsIG9wdGlvbnMpIHtcblx0ICAgIHJldHVybiB0aGlzLl9ydW5TeW5jKHJ1bGUsIG9wdGlvbnMpLnJvb3Q7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogUHJvY2VzcyBhIHNlbGVjdG9yIGludG8gYSB0cmFuc2Zvcm1lZCB2YWx1ZSBhc3luY2hyb25vdXNseVxuXHQgICAqXG5cdCAgICogQHBhcmFtIHJ1bGUge3Bvc3Rjc3MuUnVsZSB8IHN0cmluZ30gVGhlIGNzcyBzZWxlY3RvciB0byBiZSBwcm9jZXNzZWRcblx0ICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgcHJvY2Vzc2luZ1xuXHQgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgcHJvY2Vzc29yLlxuXHQgICAqLztcblx0ICBfcHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtKHJ1bGUsIG9wdGlvbnMpIHtcblx0ICAgIHJldHVybiB0aGlzLl9ydW4ocnVsZSwgb3B0aW9ucykudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdCAgICAgIHJldHVybiByZXN1bHQudHJhbnNmb3JtO1xuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogUHJvY2VzcyBhIHNlbGVjdG9yIGludG8gYSB0cmFuc2Zvcm1lZCB2YWx1ZSBzeW5jaHJvbm91c2x5LlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHJ1bGUge3Bvc3Rjc3MuUnVsZSB8IHN0cmluZ30gVGhlIGNzcyBzZWxlY3RvciB0byBiZSBwcm9jZXNzZWRcblx0ICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgcHJvY2Vzc2luZ1xuXHQgICAqIEByZXR1cm5zIHthbnl9IFRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgcHJvY2Vzc29yLlxuXHQgICAqLztcblx0ICBfcHJvdG8udHJhbnNmb3JtU3luYyA9IGZ1bmN0aW9uIHRyYW5zZm9ybVN5bmMocnVsZSwgb3B0aW9ucykge1xuXHQgICAgcmV0dXJuIHRoaXMuX3J1blN5bmMocnVsZSwgb3B0aW9ucykudHJhbnNmb3JtO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFByb2Nlc3MgYSBzZWxlY3RvciBpbnRvIGEgbmV3IHNlbGVjdG9yIHN0cmluZyBhc3luY2hyb25vdXNseS5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSBydWxlIHtwb3N0Y3NzLlJ1bGUgfCBzdHJpbmd9IFRoZSBjc3Mgc2VsZWN0b3IgdG8gYmUgcHJvY2Vzc2VkXG5cdCAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHByb2Nlc3Npbmdcblx0ICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgc2VsZWN0b3IgYWZ0ZXIgcHJvY2Vzc2luZy5cblx0ICAgKi87XG5cdCAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKHJ1bGUsIG9wdGlvbnMpIHtcblx0ICAgIHJldHVybiB0aGlzLl9ydW4ocnVsZSwgb3B0aW9ucykudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdCAgICAgIHJldHVybiByZXN1bHQuc3RyaW5nIHx8IHJlc3VsdC5yb290LnRvU3RyaW5nKCk7XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBQcm9jZXNzIGEgc2VsZWN0b3IgaW50byBhIG5ldyBzZWxlY3RvciBzdHJpbmcgc3luY2hyb25vdXNseS5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSBydWxlIHtwb3N0Y3NzLlJ1bGUgfCBzdHJpbmd9IFRoZSBjc3Mgc2VsZWN0b3IgdG8gYmUgcHJvY2Vzc2VkXG5cdCAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHByb2Nlc3Npbmdcblx0ICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgc2VsZWN0b3IgYWZ0ZXIgcHJvY2Vzc2luZy5cblx0ICAgKi87XG5cdCAgX3Byb3RvLnByb2Nlc3NTeW5jID0gZnVuY3Rpb24gcHJvY2Vzc1N5bmMocnVsZSwgb3B0aW9ucykge1xuXHQgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3J1blN5bmMocnVsZSwgb3B0aW9ucyk7XG5cdCAgICByZXR1cm4gcmVzdWx0LnN0cmluZyB8fCByZXN1bHQucm9vdC50b1N0cmluZygpO1xuXHQgIH07XG5cdCAgcmV0dXJuIFByb2Nlc3Nvcjtcblx0fSgpO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IFByb2Nlc3Nvcjtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7IFxufSAocHJvY2Vzc29yLCBwcm9jZXNzb3IuZXhwb3J0cykpO1xuXG52YXIgcHJvY2Vzc29yRXhwb3J0cyA9IHByb2Nlc3Nvci5leHBvcnRzO1xuXG52YXIgc2VsZWN0b3JzID0ge307XG5cbnZhciBjb25zdHJ1Y3RvcnMgPSB7fTtcblxuY29uc3RydWN0b3JzLl9fZXNNb2R1bGUgPSB0cnVlO1xuY29uc3RydWN0b3JzLnVuaXZlcnNhbCA9IGNvbnN0cnVjdG9ycy50YWcgPSBjb25zdHJ1Y3RvcnMuc3RyaW5nID0gY29uc3RydWN0b3JzLnNlbGVjdG9yID0gY29uc3RydWN0b3JzLnJvb3QgPSBjb25zdHJ1Y3RvcnMucHNldWRvID0gY29uc3RydWN0b3JzLm5lc3RpbmcgPSBjb25zdHJ1Y3RvcnMuaWQgPSBjb25zdHJ1Y3RvcnMuY29tbWVudCA9IGNvbnN0cnVjdG9ycy5jb21iaW5hdG9yID0gY29uc3RydWN0b3JzLmNsYXNzTmFtZSA9IGNvbnN0cnVjdG9ycy5hdHRyaWJ1dGUgPSB2b2lkIDA7XG52YXIgX2F0dHJpYnV0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkMihhdHRyaWJ1dGUkMSk7XG52YXIgX2NsYXNzTmFtZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkMihjbGFzc05hbWVFeHBvcnRzKTtcbnZhciBfY29tYmluYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkMihjb21iaW5hdG9yRXhwb3J0cyk7XG52YXIgX2NvbW1lbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0JDIoY29tbWVudEV4cG9ydHMpO1xudmFyIF9pZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkMihpZEV4cG9ydHMpO1xudmFyIF9uZXN0aW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQyKG5lc3RpbmdFeHBvcnRzKTtcbnZhciBfcHNldWRvID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQyKHBzZXVkb0V4cG9ydHMpO1xudmFyIF9yb290ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQyKHJvb3RFeHBvcnRzKTtcbnZhciBfc2VsZWN0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0JDIoc2VsZWN0b3JFeHBvcnRzKTtcbnZhciBfc3RyaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQyKHN0cmluZ0V4cG9ydHMpO1xudmFyIF90YWcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0JDIodGFnRXhwb3J0cyk7XG52YXIgX3VuaXZlcnNhbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkMih1bml2ZXJzYWxFeHBvcnRzKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkMihvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG52YXIgYXR0cmlidXRlID0gZnVuY3Rpb24gYXR0cmlidXRlKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBfYXR0cmlidXRlW1wiZGVmYXVsdFwiXShvcHRzKTtcbn07XG5jb25zdHJ1Y3RvcnMuYXR0cmlidXRlID0gYXR0cmlidXRlO1xudmFyIGNsYXNzTmFtZSA9IGZ1bmN0aW9uIGNsYXNzTmFtZShvcHRzKSB7XG4gIHJldHVybiBuZXcgX2NsYXNzTmFtZVtcImRlZmF1bHRcIl0ob3B0cyk7XG59O1xuY29uc3RydWN0b3JzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbnZhciBjb21iaW5hdG9yID0gZnVuY3Rpb24gY29tYmluYXRvcihvcHRzKSB7XG4gIHJldHVybiBuZXcgX2NvbWJpbmF0b3JbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcbmNvbnN0cnVjdG9ycy5jb21iaW5hdG9yID0gY29tYmluYXRvcjtcbnZhciBjb21tZW50ID0gZnVuY3Rpb24gY29tbWVudChvcHRzKSB7XG4gIHJldHVybiBuZXcgX2NvbW1lbnRbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcbmNvbnN0cnVjdG9ycy5jb21tZW50ID0gY29tbWVudDtcbnZhciBpZCA9IGZ1bmN0aW9uIGlkKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBfaWRbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcbmNvbnN0cnVjdG9ycy5pZCA9IGlkO1xudmFyIG5lc3RpbmcgPSBmdW5jdGlvbiBuZXN0aW5nKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBfbmVzdGluZ1tcImRlZmF1bHRcIl0ob3B0cyk7XG59O1xuY29uc3RydWN0b3JzLm5lc3RpbmcgPSBuZXN0aW5nO1xudmFyIHBzZXVkbyA9IGZ1bmN0aW9uIHBzZXVkbyhvcHRzKSB7XG4gIHJldHVybiBuZXcgX3BzZXVkb1tcImRlZmF1bHRcIl0ob3B0cyk7XG59O1xuY29uc3RydWN0b3JzLnBzZXVkbyA9IHBzZXVkbztcbnZhciByb290ID0gZnVuY3Rpb24gcm9vdChvcHRzKSB7XG4gIHJldHVybiBuZXcgX3Jvb3RbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcbmNvbnN0cnVjdG9ycy5yb290ID0gcm9vdDtcbnZhciBzZWxlY3RvciA9IGZ1bmN0aW9uIHNlbGVjdG9yKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBfc2VsZWN0b3JbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcbmNvbnN0cnVjdG9ycy5zZWxlY3RvciA9IHNlbGVjdG9yO1xudmFyIHN0cmluZyA9IGZ1bmN0aW9uIHN0cmluZyhvcHRzKSB7XG4gIHJldHVybiBuZXcgX3N0cmluZ1tcImRlZmF1bHRcIl0ob3B0cyk7XG59O1xuY29uc3RydWN0b3JzLnN0cmluZyA9IHN0cmluZztcbnZhciB0YWcgPSBmdW5jdGlvbiB0YWcob3B0cykge1xuICByZXR1cm4gbmV3IF90YWdbXCJkZWZhdWx0XCJdKG9wdHMpO1xufTtcbmNvbnN0cnVjdG9ycy50YWcgPSB0YWc7XG52YXIgdW5pdmVyc2FsID0gZnVuY3Rpb24gdW5pdmVyc2FsKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBfdW5pdmVyc2FsW1wiZGVmYXVsdFwiXShvcHRzKTtcbn07XG5jb25zdHJ1Y3RvcnMudW5pdmVyc2FsID0gdW5pdmVyc2FsO1xuXG52YXIgZ3VhcmRzID0ge307XG5cbmd1YXJkcy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmd1YXJkcy5pc0NvbW1lbnQgPSBndWFyZHMuaXNDb21iaW5hdG9yID0gZ3VhcmRzLmlzQ2xhc3NOYW1lID0gZ3VhcmRzLmlzQXR0cmlidXRlID0gdm9pZCAwO1xuZ3VhcmRzLmlzQ29udGFpbmVyID0gaXNDb250YWluZXI7XG5ndWFyZHMuaXNJZGVudGlmaWVyID0gdm9pZCAwO1xuZ3VhcmRzLmlzTmFtZXNwYWNlID0gaXNOYW1lc3BhY2U7XG5ndWFyZHMuaXNOZXN0aW5nID0gdm9pZCAwO1xuZ3VhcmRzLmlzTm9kZSA9IGlzTm9kZTtcbmd1YXJkcy5pc1BzZXVkbyA9IHZvaWQgMDtcbmd1YXJkcy5pc1BzZXVkb0NsYXNzID0gaXNQc2V1ZG9DbGFzcztcbmd1YXJkcy5pc1BzZXVkb0VsZW1lbnQgPSBpc1BzZXVkb0VsZW1lbnQ7XG5ndWFyZHMuaXNVbml2ZXJzYWwgPSBndWFyZHMuaXNUYWcgPSBndWFyZHMuaXNTdHJpbmcgPSBndWFyZHMuaXNTZWxlY3RvciA9IGd1YXJkcy5pc1Jvb3QgPSB2b2lkIDA7XG52YXIgX3R5cGVzID0gdHlwZXM7XG52YXIgX0lTX1RZUEU7XG52YXIgSVNfVFlQRSA9IChfSVNfVFlQRSA9IHt9LCBfSVNfVFlQRVtfdHlwZXMuQVRUUklCVVRFXSA9IHRydWUsIF9JU19UWVBFW190eXBlcy5DTEFTU10gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuQ09NQklOQVRPUl0gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuQ09NTUVOVF0gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuSURdID0gdHJ1ZSwgX0lTX1RZUEVbX3R5cGVzLk5FU1RJTkddID0gdHJ1ZSwgX0lTX1RZUEVbX3R5cGVzLlBTRVVET10gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuUk9PVF0gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuU0VMRUNUT1JdID0gdHJ1ZSwgX0lTX1RZUEVbX3R5cGVzLlNUUklOR10gPSB0cnVlLCBfSVNfVFlQRVtfdHlwZXMuVEFHXSA9IHRydWUsIF9JU19UWVBFW190eXBlcy5VTklWRVJTQUxdID0gdHJ1ZSwgX0lTX1RZUEUpO1xuZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBub2RlID09PSBcIm9iamVjdFwiICYmIElTX1RZUEVbbm9kZS50eXBlXTtcbn1cbmZ1bmN0aW9uIGlzTm9kZVR5cGUodHlwZSwgbm9kZSkge1xuICByZXR1cm4gaXNOb2RlKG5vZGUpICYmIG5vZGUudHlwZSA9PT0gdHlwZTtcbn1cbnZhciBpc0F0dHJpYnV0ZSA9IGlzTm9kZVR5cGUuYmluZChudWxsLCBfdHlwZXMuQVRUUklCVVRFKTtcbmd1YXJkcy5pc0F0dHJpYnV0ZSA9IGlzQXR0cmlidXRlO1xudmFyIGlzQ2xhc3NOYW1lID0gaXNOb2RlVHlwZS5iaW5kKG51bGwsIF90eXBlcy5DTEFTUyk7XG5ndWFyZHMuaXNDbGFzc05hbWUgPSBpc0NsYXNzTmFtZTtcbnZhciBpc0NvbWJpbmF0b3IgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLkNPTUJJTkFUT1IpO1xuZ3VhcmRzLmlzQ29tYmluYXRvciA9IGlzQ29tYmluYXRvcjtcbnZhciBpc0NvbW1lbnQgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLkNPTU1FTlQpO1xuZ3VhcmRzLmlzQ29tbWVudCA9IGlzQ29tbWVudDtcbnZhciBpc0lkZW50aWZpZXIgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLklEKTtcbmd1YXJkcy5pc0lkZW50aWZpZXIgPSBpc0lkZW50aWZpZXI7XG52YXIgaXNOZXN0aW5nID0gaXNOb2RlVHlwZS5iaW5kKG51bGwsIF90eXBlcy5ORVNUSU5HKTtcbmd1YXJkcy5pc05lc3RpbmcgPSBpc05lc3Rpbmc7XG52YXIgaXNQc2V1ZG8gPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLlBTRVVETyk7XG5ndWFyZHMuaXNQc2V1ZG8gPSBpc1BzZXVkbztcbnZhciBpc1Jvb3QgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLlJPT1QpO1xuZ3VhcmRzLmlzUm9vdCA9IGlzUm9vdDtcbnZhciBpc1NlbGVjdG9yID0gaXNOb2RlVHlwZS5iaW5kKG51bGwsIF90eXBlcy5TRUxFQ1RPUik7XG5ndWFyZHMuaXNTZWxlY3RvciA9IGlzU2VsZWN0b3I7XG52YXIgaXNTdHJpbmcgPSBpc05vZGVUeXBlLmJpbmQobnVsbCwgX3R5cGVzLlNUUklORyk7XG5ndWFyZHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbnZhciBpc1RhZyA9IGlzTm9kZVR5cGUuYmluZChudWxsLCBfdHlwZXMuVEFHKTtcbmd1YXJkcy5pc1RhZyA9IGlzVGFnO1xudmFyIGlzVW5pdmVyc2FsID0gaXNOb2RlVHlwZS5iaW5kKG51bGwsIF90eXBlcy5VTklWRVJTQUwpO1xuZ3VhcmRzLmlzVW5pdmVyc2FsID0gaXNVbml2ZXJzYWw7XG5mdW5jdGlvbiBpc1BzZXVkb0VsZW1lbnQobm9kZSkge1xuICByZXR1cm4gaXNQc2V1ZG8obm9kZSkgJiYgbm9kZS52YWx1ZSAmJiAobm9kZS52YWx1ZS5zdGFydHNXaXRoKFwiOjpcIikgfHwgbm9kZS52YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBcIjpiZWZvcmVcIiB8fCBub2RlLnZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwiOmFmdGVyXCIgfHwgbm9kZS52YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBcIjpmaXJzdC1sZXR0ZXJcIiB8fCBub2RlLnZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwiOmZpcnN0LWxpbmVcIik7XG59XG5mdW5jdGlvbiBpc1BzZXVkb0NsYXNzKG5vZGUpIHtcbiAgcmV0dXJuIGlzUHNldWRvKG5vZGUpICYmICFpc1BzZXVkb0VsZW1lbnQobm9kZSk7XG59XG5mdW5jdGlvbiBpc0NvbnRhaW5lcihub2RlKSB7XG4gIHJldHVybiAhIShpc05vZGUobm9kZSkgJiYgbm9kZS53YWxrKTtcbn1cbmZ1bmN0aW9uIGlzTmFtZXNwYWNlKG5vZGUpIHtcbiAgcmV0dXJuIGlzQXR0cmlidXRlKG5vZGUpIHx8IGlzVGFnKG5vZGUpO1xufVxuXG4oZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHR2YXIgX3R5cGVzID0gdHlwZXM7XG5cdE9iamVjdC5rZXlzKF90eXBlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuXHQgIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF90eXBlc1trZXldKSByZXR1cm47XG5cdCAgZXhwb3J0c1trZXldID0gX3R5cGVzW2tleV07XG5cdH0pO1xuXHR2YXIgX2NvbnN0cnVjdG9ycyA9IGNvbnN0cnVjdG9ycztcblx0T2JqZWN0LmtleXMoX2NvbnN0cnVjdG9ycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuXHQgIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9jb25zdHJ1Y3RvcnNba2V5XSkgcmV0dXJuO1xuXHQgIGV4cG9ydHNba2V5XSA9IF9jb25zdHJ1Y3RvcnNba2V5XTtcblx0fSk7XG5cdHZhciBfZ3VhcmRzID0gZ3VhcmRzO1xuXHRPYmplY3Qua2V5cyhfZ3VhcmRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG5cdCAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2d1YXJkc1trZXldKSByZXR1cm47XG5cdCAgZXhwb3J0c1trZXldID0gX2d1YXJkc1trZXldO1xuXHR9KTsgXG59IChzZWxlY3RvcnMpKTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblx0dmFyIF9wcm9jZXNzb3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHByb2Nlc3NvckV4cG9ydHMpO1xuXHR2YXIgc2VsZWN0b3JzJDEgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChzZWxlY3RvcnMpO1xuXHRmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXHR2YXIgcGFyc2VyID0gZnVuY3Rpb24gcGFyc2VyKHByb2Nlc3Nvcikge1xuXHQgIHJldHVybiBuZXcgX3Byb2Nlc3NvcltcImRlZmF1bHRcIl0ocHJvY2Vzc29yKTtcblx0fTtcblx0T2JqZWN0LmFzc2lnbihwYXJzZXIsIHNlbGVjdG9ycyQxKTtcblx0ZGVsZXRlIHBhcnNlci5fX2VzTW9kdWxlO1xuXHR2YXIgX2RlZmF1bHQgPSBwYXJzZXI7XG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0OyBcbn0gKGRpc3QsIGRpc3QuZXhwb3J0cykpO1xuXG52YXIgZGlzdEV4cG9ydHMgPSBkaXN0LmV4cG9ydHM7XG5cbmNvbnN0IHNlbGVjdG9yUGFyc2VyJDEgPSBkaXN0RXhwb3J0cztcbmNvbnN0IHZhbHVlUGFyc2VyID0gbGliO1xuY29uc3QgeyBleHRyYWN0SUNTUyB9ID0gc3JjJDQ7XG5cbmNvbnN0IGlzU3BhY2luZyA9IChub2RlKSA9PiBub2RlLnR5cGUgPT09IFwiY29tYmluYXRvclwiICYmIG5vZGUudmFsdWUgPT09IFwiIFwiO1xuXG5mdW5jdGlvbiBub3JtYWxpemVOb2RlQXJyYXkobm9kZXMpIHtcbiAgY29uc3QgYXJyYXkgPSBbXTtcblxuICBub2Rlcy5mb3JFYWNoKCh4KSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgIG5vcm1hbGl6ZU5vZGVBcnJheSh4KS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGFycmF5LnB1c2goaXRlbSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHgpIHtcbiAgICAgIGFycmF5LnB1c2goeCk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoYXJyYXkubGVuZ3RoID4gMCAmJiBpc1NwYWNpbmcoYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV0pKSB7XG4gICAgYXJyYXkucG9wKCk7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiBsb2NhbGl6ZU5vZGUocnVsZSwgbW9kZSwgbG9jYWxBbGlhc01hcCkge1xuICBjb25zdCB0cmFuc2Zvcm0gPSAobm9kZSwgY29udGV4dCkgPT4ge1xuICAgIGlmIChjb250ZXh0Lmlnbm9yZU5leHRTcGFjaW5nICYmICFpc1NwYWNpbmcobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgd2hpdGVzcGFjZSBhZnRlciBcIiArIGNvbnRleHQuaWdub3JlTmV4dFNwYWNpbmcpO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0LmVuZm9yY2VOb1NwYWNpbmcgJiYgaXNTcGFjaW5nKG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHdoaXRlc3BhY2UgYmVmb3JlIFwiICsgY29udGV4dC5lbmZvcmNlTm9TcGFjaW5nKTtcbiAgICB9XG5cbiAgICBsZXQgbmV3Tm9kZXM7XG5cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcInJvb3RcIjoge1xuICAgICAgICBsZXQgcmVzdWx0aW5nR2xvYmFsO1xuXG4gICAgICAgIGNvbnRleHQuaGFzUHVyZUdsb2JhbHMgPSBmYWxzZTtcblxuICAgICAgICBuZXdOb2RlcyA9IG5vZGUubm9kZXMubWFwKChuKSA9PiB7XG4gICAgICAgICAgY29uc3QgbkNvbnRleHQgPSB7XG4gICAgICAgICAgICBnbG9iYWw6IGNvbnRleHQuZ2xvYmFsLFxuICAgICAgICAgICAgbGFzdFdhc1NwYWNpbmc6IHRydWUsXG4gICAgICAgICAgICBoYXNMb2NhbHM6IGZhbHNlLFxuICAgICAgICAgICAgZXhwbGljaXQ6IGZhbHNlLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBuID0gdHJhbnNmb3JtKG4sIG5Db250ZXh0KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0aW5nR2xvYmFsID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXN1bHRpbmdHbG9iYWwgPSBuQ29udGV4dC5nbG9iYWw7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHRpbmdHbG9iYWwgIT09IG5Db250ZXh0Lmdsb2JhbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnSW5jb25zaXN0ZW50IHJ1bGUgZ2xvYmFsL2xvY2FsIHJlc3VsdCBpbiBydWxlIFwiJyArXG4gICAgICAgICAgICAgICAgbm9kZSArXG4gICAgICAgICAgICAgICAgJ1wiIChtdWx0aXBsZSBzZWxlY3RvcnMgbXVzdCByZXN1bHQgaW4gdGhlIHNhbWUgbW9kZSBmb3IgdGhlIHJ1bGUpJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIW5Db250ZXh0Lmhhc0xvY2Fscykge1xuICAgICAgICAgICAgY29udGV4dC5oYXNQdXJlR2xvYmFscyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsID0gcmVzdWx0aW5nR2xvYmFsO1xuXG4gICAgICAgIG5vZGUubm9kZXMgPSBub3JtYWxpemVOb2RlQXJyYXkobmV3Tm9kZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJzZWxlY3RvclwiOiB7XG4gICAgICAgIG5ld05vZGVzID0gbm9kZS5tYXAoKGNoaWxkTm9kZSkgPT4gdHJhbnNmb3JtKGNoaWxkTm9kZSwgY29udGV4dCkpO1xuXG4gICAgICAgIG5vZGUgPSBub2RlLmNsb25lKCk7XG4gICAgICAgIG5vZGUubm9kZXMgPSBub3JtYWxpemVOb2RlQXJyYXkobmV3Tm9kZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJjb21iaW5hdG9yXCI6IHtcbiAgICAgICAgaWYgKGlzU3BhY2luZyhub2RlKSkge1xuICAgICAgICAgIGlmIChjb250ZXh0Lmlnbm9yZU5leHRTcGFjaW5nKSB7XG4gICAgICAgICAgICBjb250ZXh0Lmlnbm9yZU5leHRTcGFjaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBjb250ZXh0Lmxhc3RXYXNTcGFjaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBjb250ZXh0LmVuZm9yY2VOb1NwYWNpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250ZXh0Lmxhc3RXYXNTcGFjaW5nID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJwc2V1ZG9cIjoge1xuICAgICAgICBsZXQgY2hpbGRDb250ZXh0O1xuICAgICAgICBjb25zdCBpc05lc3RlZCA9ICEhbm9kZS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGlzU2NvcGVkID0gbm9kZS52YWx1ZSA9PT0gXCI6bG9jYWxcIiB8fCBub2RlLnZhbHVlID09PSBcIjpnbG9iYWxcIjtcbiAgICAgICAgY29uc3QgaXNJbXBvcnRFeHBvcnQgPVxuICAgICAgICAgIG5vZGUudmFsdWUgPT09IFwiOmltcG9ydFwiIHx8IG5vZGUudmFsdWUgPT09IFwiOmV4cG9ydFwiO1xuXG4gICAgICAgIGlmIChpc0ltcG9ydEV4cG9ydCkge1xuICAgICAgICAgIGNvbnRleHQuaGFzTG9jYWxzID0gdHJ1ZTtcbiAgICAgICAgICAvLyA6bG9jYWwoLmZvbylcbiAgICAgICAgfSBlbHNlIGlmIChpc05lc3RlZCkge1xuICAgICAgICAgIGlmIChpc1Njb3BlZCkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtub2RlLnZhbHVlfSgpIGNhbid0IGJlIGVtcHR5YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb250ZXh0Lmluc2lkZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYEEgJHtub2RlLnZhbHVlfSBpcyBub3QgYWxsb3dlZCBpbnNpZGUgb2YgYSAke2NvbnRleHQuaW5zaWRlfSguLi4pYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZENvbnRleHQgPSB7XG4gICAgICAgICAgICAgIGdsb2JhbDogbm9kZS52YWx1ZSA9PT0gXCI6Z2xvYmFsXCIsXG4gICAgICAgICAgICAgIGluc2lkZTogbm9kZS52YWx1ZSxcbiAgICAgICAgICAgICAgaGFzTG9jYWxzOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXhwbGljaXQ6IHRydWUsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBuZXdOb2RlcyA9IG5vZGVcbiAgICAgICAgICAgICAgLm1hcCgoY2hpbGROb2RlKSA9PiB0cmFuc2Zvcm0oY2hpbGROb2RlLCBjaGlsZENvbnRleHQpKVxuICAgICAgICAgICAgICAucmVkdWNlKChhY2MsIG5leHQpID0+IGFjYy5jb25jYXQobmV4dC5ub2RlcyksIFtdKTtcblxuICAgICAgICAgICAgaWYgKG5ld05vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zdCB7IGJlZm9yZSwgYWZ0ZXIgfSA9IG5vZGUuc3BhY2VzO1xuXG4gICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gbmV3Tm9kZXNbMF07XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBuZXdOb2Rlc1tuZXdOb2Rlcy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICBmaXJzdC5zcGFjZXMgPSB7IGJlZm9yZSwgYWZ0ZXI6IGZpcnN0LnNwYWNlcy5hZnRlciB9O1xuICAgICAgICAgICAgICBsYXN0LnNwYWNlcyA9IHsgYmVmb3JlOiBsYXN0LnNwYWNlcy5iZWZvcmUsIGFmdGVyIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSBuZXdOb2RlcztcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkQ29udGV4dCA9IHtcbiAgICAgICAgICAgICAgZ2xvYmFsOiBjb250ZXh0Lmdsb2JhbCxcbiAgICAgICAgICAgICAgaW5zaWRlOiBjb250ZXh0Lmluc2lkZSxcbiAgICAgICAgICAgICAgbGFzdFdhc1NwYWNpbmc6IHRydWUsXG4gICAgICAgICAgICAgIGhhc0xvY2FsczogZmFsc2UsXG4gICAgICAgICAgICAgIGV4cGxpY2l0OiBjb250ZXh0LmV4cGxpY2l0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5ld05vZGVzID0gbm9kZS5tYXAoKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBuZXdDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIC4uLmNoaWxkQ29udGV4dCxcbiAgICAgICAgICAgICAgICBlbmZvcmNlTm9TcGFjaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0cmFuc2Zvcm0oY2hpbGROb2RlLCBuZXdDb250ZXh0KTtcblxuICAgICAgICAgICAgICBjaGlsZENvbnRleHQuZ2xvYmFsID0gbmV3Q29udGV4dC5nbG9iYWw7XG4gICAgICAgICAgICAgIGNoaWxkQ29udGV4dC5oYXNMb2NhbHMgPSBuZXdDb250ZXh0Lmhhc0xvY2FscztcblxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNsb25lKCk7XG4gICAgICAgICAgICBub2RlLm5vZGVzID0gbm9ybWFsaXplTm9kZUFycmF5KG5ld05vZGVzKTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkQ29udGV4dC5oYXNMb2NhbHMpIHtcbiAgICAgICAgICAgICAgY29udGV4dC5oYXNMb2NhbHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vOmxvY2FsIC5mb28gLmJhclxuICAgICAgICB9IGVsc2UgaWYgKGlzU2NvcGVkKSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQuaW5zaWRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBBICR7bm9kZS52YWx1ZX0gaXMgbm90IGFsbG93ZWQgaW5zaWRlIG9mIGEgJHtjb250ZXh0Lmluc2lkZX0oLi4uKWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYWRkQmFja1NwYWNpbmcgPSAhIW5vZGUuc3BhY2VzLmJlZm9yZTtcblxuICAgICAgICAgIGNvbnRleHQuaWdub3JlTmV4dFNwYWNpbmcgPSBjb250ZXh0Lmxhc3RXYXNTcGFjaW5nXG4gICAgICAgICAgICA/IG5vZGUudmFsdWVcbiAgICAgICAgICAgIDogZmFsc2U7XG5cbiAgICAgICAgICBjb250ZXh0LmVuZm9yY2VOb1NwYWNpbmcgPSBjb250ZXh0Lmxhc3RXYXNTcGFjaW5nXG4gICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICA6IG5vZGUudmFsdWU7XG5cbiAgICAgICAgICBjb250ZXh0Lmdsb2JhbCA9IG5vZGUudmFsdWUgPT09IFwiOmdsb2JhbFwiO1xuICAgICAgICAgIGNvbnRleHQuZXhwbGljaXQgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGlzIG5vZGUgaGFzIHNwYWNpbmcgdGhhdCBpcyBsb3N0IHdoZW4gd2UgcmVtb3ZlIGl0XG4gICAgICAgICAgLy8gd2UgbWFrZSB1cCBmb3IgaXQgYnkgYWRkaW5nIGFuIGV4dHJhIGNvbWJpbmF0b3IgaW4gc2luY2UgYWRkaW5nXG4gICAgICAgICAgLy8gc3BhY2luZyBvbiB0aGUgcGFyZW50IHNlbGVjdG9yIGRvZXNuJ3Qgd29ya1xuICAgICAgICAgIHJldHVybiBhZGRCYWNrU3BhY2luZ1xuICAgICAgICAgICAgPyBzZWxlY3RvclBhcnNlciQxLmNvbWJpbmF0b3IoeyB2YWx1ZTogXCIgXCIgfSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgY2FzZSBcImNsYXNzXCI6IHtcbiAgICAgICAgaWYgKCFub2RlLnZhbHVlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjbGFzcyBvciBpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5nbG9iYWwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzSW1wb3J0ZWRWYWx1ZSA9IGxvY2FsQWxpYXNNYXAuaGFzKG5vZGUudmFsdWUpO1xuICAgICAgICBjb25zdCBpc0ltcG9ydGVkV2l0aEV4cGxpY2l0U2NvcGUgPSBpc0ltcG9ydGVkVmFsdWUgJiYgY29udGV4dC5leHBsaWNpdDtcblxuICAgICAgICBpZiAoIWlzSW1wb3J0ZWRWYWx1ZSB8fCBpc0ltcG9ydGVkV2l0aEV4cGxpY2l0U2NvcGUpIHtcbiAgICAgICAgICBjb25zdCBpbm5lck5vZGUgPSBub2RlLmNsb25lKCk7XG4gICAgICAgICAgaW5uZXJOb2RlLnNwYWNlcyA9IHsgYmVmb3JlOiBcIlwiLCBhZnRlcjogXCJcIiB9O1xuXG4gICAgICAgICAgbm9kZSA9IHNlbGVjdG9yUGFyc2VyJDEucHNldWRvKHtcbiAgICAgICAgICAgIHZhbHVlOiBcIjpsb2NhbFwiLFxuICAgICAgICAgICAgbm9kZXM6IFtpbm5lck5vZGVdLFxuICAgICAgICAgICAgc3BhY2VzOiBub2RlLnNwYWNlcyxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnRleHQuaGFzTG9jYWxzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm5lc3RpbmdcIjoge1xuICAgICAgICBpZiAobm9kZS52YWx1ZSA9PT0gXCImXCIpIHtcbiAgICAgICAgICBjb250ZXh0Lmhhc0xvY2FscyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb250ZXh0Lmxhc3RXYXNTcGFjaW5nID0gZmFsc2U7XG4gICAgY29udGV4dC5pZ25vcmVOZXh0U3BhY2luZyA9IGZhbHNlO1xuICAgIGNvbnRleHQuZW5mb3JjZU5vU3BhY2luZyA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgY29uc3Qgcm9vdENvbnRleHQgPSB7XG4gICAgZ2xvYmFsOiBtb2RlID09PSBcImdsb2JhbFwiLFxuICAgIGhhc1B1cmVHbG9iYWxzOiBmYWxzZSxcbiAgfTtcblxuICByb290Q29udGV4dC5zZWxlY3RvciA9IHNlbGVjdG9yUGFyc2VyJDEoKHJvb3QpID0+IHtcbiAgICB0cmFuc2Zvcm0ocm9vdCwgcm9vdENvbnRleHQpO1xuICB9KS5wcm9jZXNzU3luYyhydWxlLCB7IHVwZGF0ZVNlbGVjdG9yOiBmYWxzZSwgbG9zc2xlc3M6IHRydWUgfSk7XG5cbiAgcmV0dXJuIHJvb3RDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBsb2NhbGl6ZURlY2xOb2RlKG5vZGUsIGNvbnRleHQpIHtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwid29yZFwiOlxuICAgICAgaWYgKGNvbnRleHQubG9jYWxpemVOZXh0SXRlbSkge1xuICAgICAgICBpZiAoIWNvbnRleHQubG9jYWxBbGlhc01hcC5oYXMobm9kZS52YWx1ZSkpIHtcbiAgICAgICAgICBub2RlLnZhbHVlID0gXCI6bG9jYWwoXCIgKyBub2RlLnZhbHVlICsgXCIpXCI7XG4gICAgICAgICAgY29udGV4dC5sb2NhbGl6ZU5leHRJdGVtID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICBpZiAoXG4gICAgICAgIGNvbnRleHQub3B0aW9ucyAmJlxuICAgICAgICBjb250ZXh0Lm9wdGlvbnMucmV3cml0ZVVybCAmJlxuICAgICAgICBub2RlLnZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwidXJsXCJcbiAgICAgICkge1xuICAgICAgICBub2RlLm5vZGVzLm1hcCgobmVzdGVkTm9kZSkgPT4ge1xuICAgICAgICAgIGlmIChuZXN0ZWROb2RlLnR5cGUgIT09IFwic3RyaW5nXCIgJiYgbmVzdGVkTm9kZS50eXBlICE9PSBcIndvcmRcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBuZXdVcmwgPSBjb250ZXh0Lm9wdGlvbnMucmV3cml0ZVVybChcbiAgICAgICAgICAgIGNvbnRleHQuZ2xvYmFsLFxuICAgICAgICAgICAgbmVzdGVkTm9kZS52YWx1ZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBzd2l0Y2ggKG5lc3RlZE5vZGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICBpZiAobmVzdGVkTm9kZS5xdW90ZSA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgICAgICBuZXdVcmwgPSBuZXdVcmwucmVwbGFjZSgvKFxcXFwpL2csIFwiXFxcXCQxXCIpLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChuZXN0ZWROb2RlLnF1b3RlID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgbmV3VXJsID0gbmV3VXJsLnJlcGxhY2UoLyhcXFxcKS9nLCBcIlxcXFwkMVwiKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ3b3JkXCI6XG4gICAgICAgICAgICAgIG5ld1VybCA9IG5ld1VybC5yZXBsYWNlKC8oXCJ8J3xcXCl8XFxcXCkvZywgXCJcXFxcJDFcIik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5lc3RlZE5vZGUudmFsdWUgPSBuZXdVcmw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8vIGBub25lYCBpcyBzcGVjaWFsIHZhbHVlLCBvdGhlciBpcyBnbG9iYWwgdmFsdWVzXG5jb25zdCBzcGVjaWFsS2V5d29yZHMgPSBbXG4gIFwibm9uZVwiLFxuICBcImluaGVyaXRcIixcbiAgXCJpbml0aWFsXCIsXG4gIFwicmV2ZXJ0XCIsXG4gIFwicmV2ZXJ0LWxheWVyXCIsXG4gIFwidW5zZXRcIixcbl07XG5cbmZ1bmN0aW9uIGxvY2FsaXplRGVjbGFyYXRpb25WYWx1ZXMobG9jYWxpemUsIGRlY2xhcmF0aW9uLCBjb250ZXh0KSB7XG4gIGNvbnN0IHZhbHVlTm9kZXMgPSB2YWx1ZVBhcnNlcihkZWNsYXJhdGlvbi52YWx1ZSk7XG5cbiAgdmFsdWVOb2Rlcy53YWxrKChub2RlLCBpbmRleCwgbm9kZXMpID0+IHtcbiAgICBpZiAoXG4gICAgICBub2RlLnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgKG5vZGUudmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ2YXJcIiB8fCBub2RlLnZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwiZW52XCIpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgbm9kZS50eXBlID09PSBcIndvcmRcIiAmJlxuICAgICAgc3BlY2lhbEtleXdvcmRzLmluY2x1ZGVzKG5vZGUudmFsdWUudG9Mb3dlckNhc2UoKSlcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdWJDb250ZXh0ID0ge1xuICAgICAgb3B0aW9uczogY29udGV4dC5vcHRpb25zLFxuICAgICAgZ2xvYmFsOiBjb250ZXh0Lmdsb2JhbCxcbiAgICAgIGxvY2FsaXplTmV4dEl0ZW06IGxvY2FsaXplICYmICFjb250ZXh0Lmdsb2JhbCxcbiAgICAgIGxvY2FsQWxpYXNNYXA6IGNvbnRleHQubG9jYWxBbGlhc01hcCxcbiAgICB9O1xuICAgIG5vZGVzW2luZGV4XSA9IGxvY2FsaXplRGVjbE5vZGUobm9kZSwgc3ViQ29udGV4dCk7XG4gIH0pO1xuXG4gIGRlY2xhcmF0aW9uLnZhbHVlID0gdmFsdWVOb2Rlcy50b1N0cmluZygpO1xufVxuXG5mdW5jdGlvbiBsb2NhbGl6ZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLCBjb250ZXh0KSB7XG4gIGNvbnN0IGlzQW5pbWF0aW9uID0gL2FuaW1hdGlvbiQvaS50ZXN0KGRlY2xhcmF0aW9uLnByb3ApO1xuXG4gIGlmIChpc0FuaW1hdGlvbikge1xuICAgIC8vIGxldHRlclxuICAgIC8vIEFuIHVwcGVyY2FzZSBsZXR0ZXIgb3IgYSBsb3dlcmNhc2UgbGV0dGVyLlxuICAgIC8vXG4gICAgLy8gaWRlbnQtc3RhcnQgY29kZSBwb2ludFxuICAgIC8vIEEgbGV0dGVyLCBhIG5vbi1BU0NJSSBjb2RlIHBvaW50LCBvciBVKzAwNUYgTE9XIExJTkUgKF8pLlxuICAgIC8vXG4gICAgLy8gaWRlbnQgY29kZSBwb2ludFxuICAgIC8vIEFuIGlkZW50LXN0YXJ0IGNvZGUgcG9pbnQsIGEgZGlnaXQsIG9yIFUrMDAyRCBIWVBIRU4tTUlOVVMgKC0pLlxuXG4gICAgLy8gV2UgZG9uJ3QgdmFsaWRhdGUgYGhleCBkaWdpdHNgLCBiZWNhdXNlIHdlIGRvbid0IG5lZWQgaXQsIGl0IGlzIHdvcmsgb2YgbGludGVycy5cbiAgICBjb25zdCB2YWxpZElkZW50ID1cbiAgICAgIC9eLT8oW2EtelxcdTAwODAtXFx1RkZGRl9dfChcXFxcW15cXHJcXG5cXGZdKXwtKD8hWzAtOV0pKSgoXFxcXFteXFxyXFxuXFxmXSl8W2EtelxcdTAwODAtXFx1RkZGRl8wLTktXSkqJC9pO1xuXG4gICAgLypcbiAgICBUaGUgc3BlYyBkZWZpbmVzIHNvbWUga2V5d29yZHMgdGhhdCB5b3UgY2FuIHVzZSB0byBkZXNjcmliZSBwcm9wZXJ0aWVzIHN1Y2ggYXMgdGhlIHRpbWluZ1xuICAgIGZ1bmN0aW9uLiBUaGVzZSBhcmUgc3RpbGwgdmFsaWQgYW5pbWF0aW9uIG5hbWVzLCBzbyBhcyBsb25nIGFzIHRoZXJlIGlzIGEgcHJvcGVydHkgdGhhdCBhY2NlcHRzXG4gICAgYSBrZXl3b3JkLCBpdCBpcyBnaXZlbiBwcmlvcml0eS4gT25seSB3aGVuIGFsbCB0aGUgcHJvcGVydGllcyB0aGF0IGNhbiB0YWtlIGEga2V5d29yZCBhcmVcbiAgICBleGhhdXN0ZWQgY2FuIHRoZSBhbmltYXRpb24gbmFtZSBiZSBzZXQgdG8gdGhlIGtleXdvcmQuIEkuZS5cblxuICAgIGFuaW1hdGlvbjogaW5maW5pdGUgaW5maW5pdGU7XG5cbiAgICBUaGUgYW5pbWF0aW9uIHdpbGwgcmVwZWF0IGFuIGluZmluaXRlIG51bWJlciBvZiB0aW1lcyBmcm9tIHRoZSBmaXJzdCBhcmd1bWVudCwgYW5kIHdpbGwgaGF2ZSBhblxuICAgIGFuaW1hdGlvbiBuYW1lIG9mIGluZmluaXRlIGZyb20gdGhlIHNlY29uZC5cbiAgICAqL1xuICAgIGNvbnN0IGFuaW1hdGlvbktleXdvcmRzID0ge1xuICAgICAgLy8gYW5pbWF0aW9uLWRpcmVjdGlvblxuICAgICAgJG5vcm1hbDogMSxcbiAgICAgICRyZXZlcnNlOiAxLFxuICAgICAgJGFsdGVybmF0ZTogMSxcbiAgICAgIFwiJGFsdGVybmF0ZS1yZXZlcnNlXCI6IDEsXG4gICAgICAvLyBhbmltYXRpb24tZmlsbC1tb2RlXG4gICAgICAkZm9yd2FyZHM6IDEsXG4gICAgICAkYmFja3dhcmRzOiAxLFxuICAgICAgJGJvdGg6IDEsXG4gICAgICAvLyBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50XG4gICAgICAkaW5maW5pdGU6IDEsXG4gICAgICAvLyBhbmltYXRpb24tcGxheS1zdGF0ZVxuICAgICAgJHBhdXNlZDogMSxcbiAgICAgICRydW5uaW5nOiAxLFxuICAgICAgLy8gYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvblxuICAgICAgJGVhc2U6IDEsXG4gICAgICBcIiRlYXNlLWluXCI6IDEsXG4gICAgICBcIiRlYXNlLW91dFwiOiAxLFxuICAgICAgXCIkZWFzZS1pbi1vdXRcIjogMSxcbiAgICAgICRsaW5lYXI6IDEsXG4gICAgICBcIiRzdGVwLWVuZFwiOiAxLFxuICAgICAgXCIkc3RlcC1zdGFydFwiOiAxLFxuICAgICAgLy8gU3BlY2lhbFxuICAgICAgJG5vbmU6IEluZmluaXR5LCAvLyBObyBtYXR0ZXIgaG93IG1hbnkgdGltZXMgeW91IHdyaXRlIG5vbmUsIGl0IHdpbGwgbmV2ZXIgYmUgYW4gYW5pbWF0aW9uIG5hbWVcbiAgICAgIC8vIEdsb2JhbCB2YWx1ZXNcbiAgICAgICRpbml0aWFsOiBJbmZpbml0eSxcbiAgICAgICRpbmhlcml0OiBJbmZpbml0eSxcbiAgICAgICR1bnNldDogSW5maW5pdHksXG4gICAgICAkcmV2ZXJ0OiBJbmZpbml0eSxcbiAgICAgIFwiJHJldmVydC1sYXllclwiOiBJbmZpbml0eSxcbiAgICB9O1xuICAgIGxldCBwYXJzZWRBbmltYXRpb25LZXl3b3JkcyA9IHt9O1xuICAgIGNvbnN0IHZhbHVlTm9kZXMgPSB2YWx1ZVBhcnNlcihkZWNsYXJhdGlvbi52YWx1ZSkud2Fsaygobm9kZSkgPT4ge1xuICAgICAgLy8gSWYgZGl2LXRva2VuIGFwcGVhcmVkIChyZXByZXNlbnRzIGFzIGNvbW1hICcsJyksIGEgcG9zc2liaWxpdHkgb2YgYW4gYW5pbWF0aW9uLWtleXdvcmRzIHNob3VsZCBiZSByZWZsZXNoLlxuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJkaXZcIikge1xuICAgICAgICBwYXJzZWRBbmltYXRpb25LZXl3b3JkcyA9IHt9O1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIERvIG5vdCBoYW5kbGUgbmVzdGVkIGZ1bmN0aW9uc1xuICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gSWdub3JlIGFsbCBleGNlcHQgd29yZFxuICAgICAgZWxzZSBpZiAobm9kZS50eXBlICE9PSBcIndvcmRcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gbm9kZS50eXBlID09PSBcIndvcmRcIiA/IG5vZGUudmFsdWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XG5cbiAgICAgIGxldCBzaG91bGRQYXJzZUFuaW1hdGlvbk5hbWUgPSBmYWxzZTtcblxuICAgICAgaWYgKHZhbHVlICYmIHZhbGlkSWRlbnQudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKFwiJFwiICsgdmFsdWUgaW4gYW5pbWF0aW9uS2V5d29yZHMpIHtcbiAgICAgICAgICBwYXJzZWRBbmltYXRpb25LZXl3b3Jkc1tcIiRcIiArIHZhbHVlXSA9XG4gICAgICAgICAgICBcIiRcIiArIHZhbHVlIGluIHBhcnNlZEFuaW1hdGlvbktleXdvcmRzXG4gICAgICAgICAgICAgID8gcGFyc2VkQW5pbWF0aW9uS2V5d29yZHNbXCIkXCIgKyB2YWx1ZV0gKyAxXG4gICAgICAgICAgICAgIDogMDtcblxuICAgICAgICAgIHNob3VsZFBhcnNlQW5pbWF0aW9uTmFtZSA9XG4gICAgICAgICAgICBwYXJzZWRBbmltYXRpb25LZXl3b3Jkc1tcIiRcIiArIHZhbHVlXSA+PVxuICAgICAgICAgICAgYW5pbWF0aW9uS2V5d29yZHNbXCIkXCIgKyB2YWx1ZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hvdWxkUGFyc2VBbmltYXRpb25OYW1lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzdWJDb250ZXh0ID0ge1xuICAgICAgICBvcHRpb25zOiBjb250ZXh0Lm9wdGlvbnMsXG4gICAgICAgIGdsb2JhbDogY29udGV4dC5nbG9iYWwsXG4gICAgICAgIGxvY2FsaXplTmV4dEl0ZW06IHNob3VsZFBhcnNlQW5pbWF0aW9uTmFtZSAmJiAhY29udGV4dC5nbG9iYWwsXG4gICAgICAgIGxvY2FsQWxpYXNNYXA6IGNvbnRleHQubG9jYWxBbGlhc01hcCxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBsb2NhbGl6ZURlY2xOb2RlKG5vZGUsIHN1YkNvbnRleHQpO1xuICAgIH0pO1xuXG4gICAgZGVjbGFyYXRpb24udmFsdWUgPSB2YWx1ZU5vZGVzLnRvU3RyaW5nKCk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBpc0FuaW1hdGlvbk5hbWUgPSAvYW5pbWF0aW9uKC1uYW1lKT8kL2kudGVzdChkZWNsYXJhdGlvbi5wcm9wKTtcblxuICBpZiAoaXNBbmltYXRpb25OYW1lKSB7XG4gICAgcmV0dXJuIGxvY2FsaXplRGVjbGFyYXRpb25WYWx1ZXModHJ1ZSwgZGVjbGFyYXRpb24sIGNvbnRleHQpO1xuICB9XG5cbiAgY29uc3QgaGFzVXJsID0gL3VybFxcKC9pLnRlc3QoZGVjbGFyYXRpb24udmFsdWUpO1xuXG4gIGlmIChoYXNVcmwpIHtcbiAgICByZXR1cm4gbG9jYWxpemVEZWNsYXJhdGlvblZhbHVlcyhmYWxzZSwgZGVjbGFyYXRpb24sIGNvbnRleHQpO1xuICB9XG59XG5cbnNyYyQyLmV4cG9ydHMgPSAob3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmIChcbiAgICBvcHRpb25zICYmXG4gICAgb3B0aW9ucy5tb2RlICYmXG4gICAgb3B0aW9ucy5tb2RlICE9PSBcImdsb2JhbFwiICYmXG4gICAgb3B0aW9ucy5tb2RlICE9PSBcImxvY2FsXCIgJiZcbiAgICBvcHRpb25zLm1vZGUgIT09IFwicHVyZVwiXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdvcHRpb25zLm1vZGUgbXVzdCBiZSBlaXRoZXIgXCJnbG9iYWxcIiwgXCJsb2NhbFwiIG9yIFwicHVyZVwiIChkZWZhdWx0IFwibG9jYWxcIiknXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IHB1cmVNb2RlID0gb3B0aW9ucyAmJiBvcHRpb25zLm1vZGUgPT09IFwicHVyZVwiO1xuICBjb25zdCBnbG9iYWxNb2RlID0gb3B0aW9ucyAmJiBvcHRpb25zLm1vZGUgPT09IFwiZ2xvYmFsXCI7XG5cbiAgcmV0dXJuIHtcbiAgICBwb3N0Y3NzUGx1Z2luOiBcInBvc3Rjc3MtbW9kdWxlcy1sb2NhbC1ieS1kZWZhdWx0XCIsXG4gICAgcHJlcGFyZSgpIHtcbiAgICAgIGNvbnN0IGxvY2FsQWxpYXNNYXAgPSBuZXcgTWFwKCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIE9uY2Uocm9vdCkge1xuICAgICAgICAgIGNvbnN0IHsgaWNzc0ltcG9ydHMgfSA9IGV4dHJhY3RJQ1NTKHJvb3QsIGZhbHNlKTtcblxuICAgICAgICAgIE9iamVjdC5rZXlzKGljc3NJbXBvcnRzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGljc3NJbXBvcnRzW2tleV0pLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgICAgICAgbG9jYWxBbGlhc01hcC5zZXQocHJvcCwgaWNzc0ltcG9ydHNba2V5XVtwcm9wXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJvb3Qud2Fsa0F0UnVsZXMoKGF0UnVsZSkgPT4ge1xuICAgICAgICAgICAgaWYgKC9rZXlmcmFtZXMkL2kudGVzdChhdFJ1bGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgZ2xvYmFsTWF0Y2ggPSAvXlxccyo6Z2xvYmFsXFxzKlxcKCguKylcXClcXHMqJC8uZXhlYyhcbiAgICAgICAgICAgICAgICBhdFJ1bGUucGFyYW1zXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGNvbnN0IGxvY2FsTWF0Y2ggPSAvXlxccyo6bG9jYWxcXHMqXFwoKC4rKVxcKVxccyokLy5leGVjKFxuICAgICAgICAgICAgICAgIGF0UnVsZS5wYXJhbXNcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBsZXQgZ2xvYmFsS2V5ZnJhbWVzID0gZ2xvYmFsTW9kZTtcblxuICAgICAgICAgICAgICBpZiAoZ2xvYmFsTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBpZiAocHVyZU1vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IGF0UnVsZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJAa2V5ZnJhbWVzIDpnbG9iYWwoLi4uKSBpcyBub3QgYWxsb3dlZCBpbiBwdXJlIG1vZGVcIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXRSdWxlLnBhcmFtcyA9IGdsb2JhbE1hdGNoWzFdO1xuICAgICAgICAgICAgICAgIGdsb2JhbEtleWZyYW1lcyA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxNYXRjaCkge1xuICAgICAgICAgICAgICAgIGF0UnVsZS5wYXJhbXMgPSBsb2NhbE1hdGNoWzBdO1xuICAgICAgICAgICAgICAgIGdsb2JhbEtleWZyYW1lcyA9IGZhbHNlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIGF0UnVsZS5wYXJhbXMgJiZcbiAgICAgICAgICAgICAgICAhZ2xvYmFsTW9kZSAmJlxuICAgICAgICAgICAgICAgICFsb2NhbEFsaWFzTWFwLmhhcyhhdFJ1bGUucGFyYW1zKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBhdFJ1bGUucGFyYW1zID0gXCI6bG9jYWwoXCIgKyBhdFJ1bGUucGFyYW1zICsgXCIpXCI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhdFJ1bGUud2Fsa0RlY2xzKChkZWNsYXJhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGxvY2FsaXplRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgIGxvY2FsQWxpYXNNYXAsXG4gICAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgZ2xvYmFsOiBnbG9iYWxLZXlmcmFtZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvc2NvcGUkL2kudGVzdChhdFJ1bGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgaWYgKGF0UnVsZS5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBhdFJ1bGUucGFyYW1zID0gYXRSdWxlLnBhcmFtc1xuICAgICAgICAgICAgICAgICAgLnNwbGl0KFwidG9cIilcbiAgICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBpdGVtLnRyaW0oKS5zbGljZSgxLCAtMSkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gbG9jYWxpemVOb2RlKFxuICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBsb2NhbEFsaWFzTWFwXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5sb2NhbEFsaWFzTWFwID0gbG9jYWxBbGlhc01hcDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocHVyZU1vZGUgJiYgY29udGV4dC5oYXNQdXJlR2xvYmFscykge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IGF0UnVsZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWxlY3RvciBpbiBhdC1ydWxlXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnXCIgaXMgbm90IHB1cmUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiKHB1cmUgc2VsZWN0b3JzIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgbG9jYWwgY2xhc3Mgb3IgaWQpXCJcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAoJHtjb250ZXh0LnNlbGVjdG9yfSlgO1xuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIC5qb2luKFwiIHRvIFwiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGF0UnVsZS5ub2Rlcy5mb3JFYWNoKChkZWNsYXJhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbi50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICAgICAgICAgICAgbG9jYWxpemVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbEFsaWFzTWFwLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBnbG9iYWw6IGdsb2JhbE1vZGUsXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhdFJ1bGUubm9kZXMpIHtcbiAgICAgICAgICAgICAgYXRSdWxlLm5vZGVzLmZvckVhY2goKGRlY2xhcmF0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9uLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgICAgICAgICAgICBsb2NhbGl6ZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsQWxpYXNNYXAsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbDogZ2xvYmFsTW9kZSxcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByb290LndhbGtSdWxlcygocnVsZSkgPT4ge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBydWxlLnBhcmVudCAmJlxuICAgICAgICAgICAgICBydWxlLnBhcmVudC50eXBlID09PSBcImF0cnVsZVwiICYmXG4gICAgICAgICAgICAgIC9rZXlmcmFtZXMkL2kudGVzdChydWxlLnBhcmVudC5uYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIGlnbm9yZSBrZXlmcmFtZSBydWxlc1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBsb2NhbGl6ZU5vZGUocnVsZSwgb3B0aW9ucy5tb2RlLCBsb2NhbEFsaWFzTWFwKTtcblxuICAgICAgICAgICAgY29udGV4dC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnRleHQubG9jYWxBbGlhc01hcCA9IGxvY2FsQWxpYXNNYXA7XG5cbiAgICAgICAgICAgIGlmIChwdXJlTW9kZSAmJiBjb250ZXh0Lmhhc1B1cmVHbG9iYWxzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJ1bGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ1NlbGVjdG9yIFwiJyArXG4gICAgICAgICAgICAgICAgICBydWxlLnNlbGVjdG9yICtcbiAgICAgICAgICAgICAgICAgICdcIiBpcyBub3QgcHVyZSAnICtcbiAgICAgICAgICAgICAgICAgIFwiKHB1cmUgc2VsZWN0b3JzIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgbG9jYWwgY2xhc3Mgb3IgaWQpXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcnVsZS5zZWxlY3RvciA9IGNvbnRleHQuc2VsZWN0b3I7XG5cbiAgICAgICAgICAgIC8vIExlc3Mtc3ludGF4IG1peGlucyBwYXJzZSBhcyBydWxlcyB3aXRoIG5vIG5vZGVzXG4gICAgICAgICAgICBpZiAocnVsZS5ub2Rlcykge1xuICAgICAgICAgICAgICBydWxlLm5vZGVzLmZvckVhY2goKGRlY2xhcmF0aW9uKSA9PlxuICAgICAgICAgICAgICAgIGxvY2FsaXplRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIGNvbnRleHQpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0sXG4gIH07XG59O1xuc3JjJDIuZXhwb3J0cy5wb3N0Y3NzID0gdHJ1ZTtcblxudmFyIHNyY0V4cG9ydHMkMSA9IHNyYyQyLmV4cG9ydHM7XG5cbmNvbnN0IHNlbGVjdG9yUGFyc2VyID0gZGlzdEV4cG9ydHM7XG5cbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gaXNOZXN0ZWRSdWxlKHJ1bGUpIHtcbiAgaWYgKCFydWxlLnBhcmVudCB8fCBydWxlLnBhcmVudC50eXBlID09PSBcInJvb3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChydWxlLnBhcmVudC50eXBlID09PSBcInJ1bGVcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGlzTmVzdGVkUnVsZShydWxlLnBhcmVudCk7XG59XG5cbmZ1bmN0aW9uIGdldFNpbmdsZUxvY2FsTmFtZXNGb3JDb21wb3Nlcyhyb290LCBydWxlKSB7XG4gIGlmIChpc05lc3RlZFJ1bGUocnVsZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbXBvc2l0aW9uIGlzIG5vdCBhbGxvd2VkIGluIG5lc3RlZCBydWxlIFxcblxcbiR7cnVsZX1gKTtcbiAgfVxuXG4gIHJldHVybiByb290Lm5vZGVzLm1hcCgobm9kZSkgPT4ge1xuICAgIGlmIChub2RlLnR5cGUgIT09IFwic2VsZWN0b3JcIiB8fCBub2RlLm5vZGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgY29tcG9zaXRpb24gaXMgb25seSBhbGxvd2VkIHdoZW4gc2VsZWN0b3IgaXMgc2luZ2xlIDpsb2NhbCBjbGFzcyBuYW1lIG5vdCBpbiBcIiR7cm9vdH1cImBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUubm9kZXNbMF07XG5cbiAgICBpZiAoXG4gICAgICBub2RlLnR5cGUgIT09IFwicHNldWRvXCIgfHxcbiAgICAgIG5vZGUudmFsdWUgIT09IFwiOmxvY2FsXCIgfHxcbiAgICAgIG5vZGUubm9kZXMubGVuZ3RoICE9PSAxXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdjb21wb3NpdGlvbiBpcyBvbmx5IGFsbG93ZWQgd2hlbiBzZWxlY3RvciBpcyBzaW5nbGUgOmxvY2FsIGNsYXNzIG5hbWUgbm90IGluIFwiJyArXG4gICAgICAgICAgcm9vdCArXG4gICAgICAgICAgJ1wiLCBcIicgK1xuICAgICAgICAgIG5vZGUgK1xuICAgICAgICAgICdcIiBpcyB3ZWlyZCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUuZmlyc3Q7XG5cbiAgICBpZiAobm9kZS50eXBlICE9PSBcInNlbGVjdG9yXCIgfHwgbm9kZS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2NvbXBvc2l0aW9uIGlzIG9ubHkgYWxsb3dlZCB3aGVuIHNlbGVjdG9yIGlzIHNpbmdsZSA6bG9jYWwgY2xhc3MgbmFtZSBub3QgaW4gXCInICtcbiAgICAgICAgICByb290ICtcbiAgICAgICAgICAnXCIsIFwiJyArXG4gICAgICAgICAgbm9kZSArXG4gICAgICAgICAgJ1wiIGlzIHdlaXJkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5maXJzdDtcblxuICAgIGlmIChub2RlLnR5cGUgIT09IFwiY2xhc3NcIikge1xuICAgICAgLy8gJ2lkJyBpcyBub3QgcG9zc2libGUsIGJlY2F1c2UgeW91IGNhbid0IGNvbXBvc2UgaWRzXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdjb21wb3NpdGlvbiBpcyBvbmx5IGFsbG93ZWQgd2hlbiBzZWxlY3RvciBpcyBzaW5nbGUgOmxvY2FsIGNsYXNzIG5hbWUgbm90IGluIFwiJyArXG4gICAgICAgICAgcm9vdCArXG4gICAgICAgICAgJ1wiLCBcIicgK1xuICAgICAgICAgIG5vZGUgK1xuICAgICAgICAgICdcIiBpcyB3ZWlyZCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gIH0pO1xufVxuXG5jb25zdCB3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiO1xuY29uc3QgdW5lc2NhcGVSZWdFeHAgPSBuZXcgUmVnRXhwKFxuICBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsXG4gIFwiaWdcIlxuKTtcblxuZnVuY3Rpb24gdW5lc2NhcGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSh1bmVzY2FwZVJlZ0V4cCwgKF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlKSA9PiB7XG4gICAgY29uc3QgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXG4gICAgLy8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcbiAgICAvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcbiAgICByZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZVxuICAgICAgPyBlc2NhcGVkXG4gICAgICA6IGhpZ2ggPCAwXG4gICAgICA/IC8vIEJNUCBjb2RlcG9pbnRcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShoaWdoICsgMHgxMDAwMClcbiAgICAgIDogLy8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoKGhpZ2ggPj4gMTApIHwgMHhkODAwLCAoaGlnaCAmIDB4M2ZmKSB8IDB4ZGMwMCk7XG4gIH0pO1xufVxuXG5jb25zdCBwbHVnaW4gPSAob3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGdlbmVyYXRlU2NvcGVkTmFtZSA9XG4gICAgKG9wdGlvbnMgJiYgb3B0aW9ucy5nZW5lcmF0ZVNjb3BlZE5hbWUpIHx8IHBsdWdpbi5nZW5lcmF0ZVNjb3BlZE5hbWU7XG4gIGNvbnN0IGdlbmVyYXRlRXhwb3J0RW50cnkgPVxuICAgIChvcHRpb25zICYmIG9wdGlvbnMuZ2VuZXJhdGVFeHBvcnRFbnRyeSkgfHwgcGx1Z2luLmdlbmVyYXRlRXhwb3J0RW50cnk7XG4gIGNvbnN0IGV4cG9ydEdsb2JhbHMgPSBvcHRpb25zICYmIG9wdGlvbnMuZXhwb3J0R2xvYmFscztcblxuICByZXR1cm4ge1xuICAgIHBvc3Rjc3NQbHVnaW46IFwicG9zdGNzcy1tb2R1bGVzLXNjb3BlXCIsXG4gICAgT25jZShyb290LCB7IHJ1bGUgfSkge1xuICAgICAgY29uc3QgZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGZ1bmN0aW9uIGV4cG9ydFNjb3BlZE5hbWUobmFtZSwgcmF3TmFtZSwgbm9kZSkge1xuICAgICAgICBjb25zdCBzY29wZWROYW1lID0gZ2VuZXJhdGVTY29wZWROYW1lKFxuICAgICAgICAgIHJhd05hbWUgPyByYXdOYW1lIDogbmFtZSxcbiAgICAgICAgICByb290LnNvdXJjZS5pbnB1dC5mcm9tLFxuICAgICAgICAgIHJvb3Quc291cmNlLmlucHV0LmNzcyxcbiAgICAgICAgICBub2RlXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGV4cG9ydEVudHJ5ID0gZ2VuZXJhdGVFeHBvcnRFbnRyeShcbiAgICAgICAgICByYXdOYW1lID8gcmF3TmFtZSA6IG5hbWUsXG4gICAgICAgICAgc2NvcGVkTmFtZSxcbiAgICAgICAgICByb290LnNvdXJjZS5pbnB1dC5mcm9tLFxuICAgICAgICAgIHJvb3Quc291cmNlLmlucHV0LmNzcyxcbiAgICAgICAgICBub2RlXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gZXhwb3J0RW50cnk7XG5cbiAgICAgICAgZXhwb3J0c1trZXldID0gZXhwb3J0c1trZXldIHx8IFtdO1xuXG4gICAgICAgIGlmIChleHBvcnRzW2tleV0uaW5kZXhPZih2YWx1ZSkgPCAwKSB7XG4gICAgICAgICAgZXhwb3J0c1trZXldLnB1c2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjb3BlZE5hbWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxvY2FsaXplTm9kZShub2RlKSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInNlbGVjdG9yXCI6XG4gICAgICAgICAgICBub2RlLm5vZGVzID0gbm9kZS5tYXAoKGl0ZW0pID0+IGxvY2FsaXplTm9kZShpdGVtKSk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RvclBhcnNlci5jbGFzc05hbWUoe1xuICAgICAgICAgICAgICB2YWx1ZTogZXhwb3J0U2NvcGVkTmFtZShcbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlLFxuICAgICAgICAgICAgICAgIG5vZGUucmF3cyAmJiBub2RlLnJhd3MudmFsdWUgPyBub2RlLnJhd3MudmFsdWUgOiBudWxsLFxuICAgICAgICAgICAgICAgIG5vZGVcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgXCJpZFwiOiB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0b3JQYXJzZXIuaWQoe1xuICAgICAgICAgICAgICB2YWx1ZTogZXhwb3J0U2NvcGVkTmFtZShcbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlLFxuICAgICAgICAgICAgICAgIG5vZGUucmF3cyAmJiBub2RlLnJhd3MudmFsdWUgPyBub2RlLnJhd3MudmFsdWUgOiBudWxsLFxuICAgICAgICAgICAgICAgIG5vZGVcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiYXR0cmlidXRlXCI6IHtcbiAgICAgICAgICAgIGlmIChub2RlLmF0dHJpYnV0ZSA9PT0gXCJjbGFzc1wiICYmIG5vZGUub3BlcmF0b3IgPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWxlY3RvclBhcnNlci5hdHRyaWJ1dGUoe1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogbm9kZS5hdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IG5vZGUub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgcXVvdGVNYXJrOiBcIidcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXhwb3J0U2NvcGVkTmFtZShub2RlLnZhbHVlLCBudWxsLCBudWxsKSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke25vZGUudHlwZX0gKFwiJHtub2RlfVwiKSBpcyBub3QgYWxsb3dlZCBpbiBhIDpsb2NhbCBibG9ja2BcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdHJhdmVyc2VOb2RlKG5vZGUpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwicHNldWRvXCI6XG4gICAgICAgICAgICBpZiAobm9kZS52YWx1ZSA9PT0gXCI6bG9jYWxcIikge1xuICAgICAgICAgICAgICBpZiAobm9kZS5ub2Rlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgY29tbWEgKFwiLFwiKSBpbiA6bG9jYWwgYmxvY2snKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gbG9jYWxpemVOb2RlKG5vZGUuZmlyc3QpO1xuICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSBzcGFjZXMgdGhhdCB3ZXJlIGFyb3VuZCB0aGUgcHNldWRvIHNlbGVjdG9yIHRvIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAvLyBub24tY29udGFpbmVyIG5vZGVcbiAgICAgICAgICAgICAgc2VsZWN0b3IuZmlyc3Quc3BhY2VzID0gbm9kZS5zcGFjZXM7XG5cbiAgICAgICAgICAgICAgY29uc3QgbmV4dE5vZGUgPSBub2RlLm5leHQoKTtcblxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgbmV4dE5vZGUgJiZcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZS50eXBlID09PSBcImNvbWJpbmF0b3JcIiAmJlxuICAgICAgICAgICAgICAgIG5leHROb2RlLnZhbHVlID09PSBcIiBcIiAmJlxuICAgICAgICAgICAgICAgIC9cXFxcW0EtRjAtOV17MSw2fSQvLnRlc3Qoc2VsZWN0b3IubGFzdC52YWx1ZSlcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IubGFzdC5zcGFjZXMuYWZ0ZXIgPSBcIiBcIjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG5vZGUucmVwbGFjZVdpdGgoc2VsZWN0b3IpO1xuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgY2FzZSBcInJvb3RcIjpcbiAgICAgICAgICBjYXNlIFwic2VsZWN0b3JcIjoge1xuICAgICAgICAgICAgbm9kZS5lYWNoKChpdGVtKSA9PiB0cmF2ZXJzZU5vZGUoaXRlbSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgIGNhc2UgXCJjbGFzc1wiOlxuICAgICAgICAgICAgaWYgKGV4cG9ydEdsb2JhbHMpIHtcbiAgICAgICAgICAgICAgZXhwb3J0c1tub2RlLnZhbHVlXSA9IFtub2RlLnZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIGFueSA6aW1wb3J0IGFuZCByZW1lbWJlciBpbXBvcnRlZCBuYW1lc1xuICAgICAgY29uc3QgaW1wb3J0ZWROYW1lcyA9IHt9O1xuXG4gICAgICByb290LndhbGtSdWxlcygvXjppbXBvcnRcXCguK1xcKSQvLCAocnVsZSkgPT4ge1xuICAgICAgICBydWxlLndhbGtEZWNscygoZGVjbCkgPT4ge1xuICAgICAgICAgIGltcG9ydGVkTmFtZXNbZGVjbC5wcm9wXSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEZpbmQgYW55IDpsb2NhbCBzZWxlY3RvcnNcbiAgICAgIHJvb3Qud2Fsa1J1bGVzKChydWxlKSA9PiB7XG4gICAgICAgIGxldCBwYXJzZWRTZWxlY3RvciA9IHNlbGVjdG9yUGFyc2VyKCkuYXN0U3luYyhydWxlKTtcblxuICAgICAgICBydWxlLnNlbGVjdG9yID0gdHJhdmVyc2VOb2RlKHBhcnNlZFNlbGVjdG9yLmNsb25lKCkpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgcnVsZS53YWxrRGVjbHMoL14oY29tcG9zZXN8Y29tcG9zZS13aXRoKSQvaSwgKGRlY2wpID0+IHtcbiAgICAgICAgICBjb25zdCBsb2NhbE5hbWVzID0gZ2V0U2luZ2xlTG9jYWxOYW1lc0ZvckNvbXBvc2VzKFxuICAgICAgICAgICAgcGFyc2VkU2VsZWN0b3IsXG4gICAgICAgICAgICBkZWNsLnBhcmVudFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgbXVsdGlwbGUgPSBkZWNsLnZhbHVlLnNwbGl0KFwiLFwiKTtcblxuICAgICAgICAgIG11bHRpcGxlLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gdmFsdWUudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG5cbiAgICAgICAgICAgIGNsYXNzZXMuZm9yRWFjaCgoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGdsb2JhbCA9IC9eZ2xvYmFsXFwoKFteKV0rKVxcKSQvLmV4ZWMoY2xhc3NOYW1lKTtcblxuICAgICAgICAgICAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxOYW1lcy5mb3JFYWNoKChleHBvcnRlZE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgIGV4cG9ydHNbZXhwb3J0ZWROYW1lXS5wdXNoKGdsb2JhbFsxXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChpbXBvcnRlZE5hbWVzLCBjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxOYW1lcy5mb3JFYWNoKChleHBvcnRlZE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgIGV4cG9ydHNbZXhwb3J0ZWROYW1lXS5wdXNoKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxOYW1lcy5mb3JFYWNoKChleHBvcnRlZE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgIGV4cG9ydHNbY2xhc3NOYW1lXS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHNbZXhwb3J0ZWROYW1lXS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVjbC5lcnJvcihcbiAgICAgICAgICAgICAgICAgIGByZWZlcmVuY2VkIGNsYXNzIG5hbWUgXCIke2NsYXNzTmFtZX1cIiBpbiAke2RlY2wucHJvcH0gbm90IGZvdW5kYFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGVjbC5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRmluZCBhbnkgOmxvY2FsIHZhbHVlc1xuICAgICAgICBydWxlLndhbGtEZWNscygoZGVjbCkgPT4ge1xuICAgICAgICAgIGlmICghLzpsb2NhbFxccypcXCgoLis/KVxcKS8udGVzdChkZWNsLnZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCB0b2tlbnMgPSBkZWNsLnZhbHVlLnNwbGl0KC8oLHwnW14nXSonfFwiW15cIl0qXCIpLyk7XG5cbiAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMubWFwKCh0b2tlbiwgaWR4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaWR4ID09PSAwIHx8IHRva2Vuc1tpZHggLSAxXSA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRva2VuO1xuXG4gICAgICAgICAgICAgIGNvbnN0IGxvY2FsTWF0Y2ggPSAvOmxvY2FsXFxzKlxcKCguKz8pXFwpLy5leGVjKHRva2VuKTtcblxuICAgICAgICAgICAgICBpZiAobG9jYWxNYXRjaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gbG9jYWxNYXRjaC5pbnB1dDtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFBhdHRlcm4gPSBsb2NhbE1hdGNoWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoVmFsID0gbG9jYWxNYXRjaFsxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWwgPSBleHBvcnRTY29wZWROYW1lKG1hdGNoVmFsKTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0LnJlcGxhY2UobWF0Y2hQYXR0ZXJuLCBuZXdWYWwpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBkZWNsLnZhbHVlID0gdG9rZW5zLmpvaW4oXCJcIik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEZpbmQgYW55IDpsb2NhbCBrZXlmcmFtZXNcbiAgICAgIHJvb3Qud2Fsa0F0UnVsZXMoL2tleWZyYW1lcyQvaSwgKGF0UnVsZSkgPT4ge1xuICAgICAgICBjb25zdCBsb2NhbE1hdGNoID0gL15cXHMqOmxvY2FsXFxzKlxcKCguKz8pXFwpXFxzKiQvLmV4ZWMoYXRSdWxlLnBhcmFtcyk7XG5cbiAgICAgICAgaWYgKCFsb2NhbE1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXRSdWxlLnBhcmFtcyA9IGV4cG9ydFNjb3BlZE5hbWUobG9jYWxNYXRjaFsxXSk7XG4gICAgICB9KTtcblxuICAgICAgcm9vdC53YWxrQXRSdWxlcygvc2NvcGUkL2ksIChhdFJ1bGUpID0+IHtcbiAgICAgICAgaWYgKGF0UnVsZS5wYXJhbXMpIHtcbiAgICAgICAgICBhdFJ1bGUucGFyYW1zID0gYXRSdWxlLnBhcmFtc1xuICAgICAgICAgICAgLnNwbGl0KFwidG9cIilcbiAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBpdGVtLnRyaW0oKS5zbGljZSgxLCAtMSkudHJpbSgpO1xuXG4gICAgICAgICAgICAgIGNvbnN0IGxvY2FsTWF0Y2ggPSAvXlxccyo6bG9jYWxcXHMqXFwoKC4rPylcXClcXHMqJC8uZXhlYyhzZWxlY3Rvcik7XG5cbiAgICAgICAgICAgICAgaWYgKCFsb2NhbE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAoJHtzZWxlY3Rvcn0pYDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxldCBwYXJzZWRTZWxlY3RvciA9IHNlbGVjdG9yUGFyc2VyKCkuYXN0U3luYyhzZWxlY3Rvcik7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGAoJHt0cmF2ZXJzZU5vZGUocGFyc2VkU2VsZWN0b3IpLnRvU3RyaW5nKCl9KWA7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oXCIgdG8gXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgd2UgZm91bmQgYW55IDpsb2NhbHMsIGluc2VydCBhbiA6ZXhwb3J0IHJ1bGVcbiAgICAgIGNvbnN0IGV4cG9ydGVkTmFtZXMgPSBPYmplY3Qua2V5cyhleHBvcnRzKTtcblxuICAgICAgaWYgKGV4cG9ydGVkTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBleHBvcnRSdWxlID0gcnVsZSh7IHNlbGVjdG9yOiBcIjpleHBvcnRcIiB9KTtcblxuICAgICAgICBleHBvcnRlZE5hbWVzLmZvckVhY2goKGV4cG9ydGVkTmFtZSkgPT5cbiAgICAgICAgICBleHBvcnRSdWxlLmFwcGVuZCh7XG4gICAgICAgICAgICBwcm9wOiBleHBvcnRlZE5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogZXhwb3J0c1tleHBvcnRlZE5hbWVdLmpvaW4oXCIgXCIpLFxuICAgICAgICAgICAgcmF3czogeyBiZWZvcmU6IFwiXFxuICBcIiB9LFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgcm9vdC5hcHBlbmQoZXhwb3J0UnVsZSk7XG4gICAgICB9XG4gICAgfSxcbiAgfTtcbn07XG5cbnBsdWdpbi5wb3N0Y3NzID0gdHJ1ZTtcblxucGx1Z2luLmdlbmVyYXRlU2NvcGVkTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBwYXRoKSB7XG4gIGNvbnN0IHNhbml0aXNlZFBhdGggPSBwYXRoXG4gICAgLnJlcGxhY2UoL1xcLlteLi9cXFxcXSskLywgXCJcIilcbiAgICAucmVwbGFjZSgvW1xcV19dKy9nLCBcIl9cIilcbiAgICAucmVwbGFjZSgvXl98XyQvZywgXCJcIik7XG5cbiAgcmV0dXJuIGBfJHtzYW5pdGlzZWRQYXRofV9fJHtuYW1lfWAudHJpbSgpO1xufTtcblxucGx1Z2luLmdlbmVyYXRlRXhwb3J0RW50cnkgPSBmdW5jdGlvbiAobmFtZSwgc2NvcGVkTmFtZSkge1xuICByZXR1cm4ge1xuICAgIGtleTogdW5lc2NhcGUobmFtZSksXG4gICAgdmFsdWU6IHVuZXNjYXBlKHNjb3BlZE5hbWUpLFxuICB9O1xufTtcblxudmFyIHNyYyQxID0gcGx1Z2luO1xuXG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICB2YXIgaGFzaCA9IDUzODEsXG4gICAgICBpICAgID0gc3RyLmxlbmd0aDtcblxuICB3aGlsZShpKSB7XG4gICAgaGFzaCA9IChoYXNoICogMzMpIF4gc3RyLmNoYXJDb2RlQXQoLS1pKTtcbiAgfVxuXG4gIC8qIEphdmFTY3JpcHQgZG9lcyBiaXR3aXNlIG9wZXJhdGlvbnMgKGxpa2UgWE9SLCBhYm92ZSkgb24gMzItYml0IHNpZ25lZFxuICAgKiBpbnRlZ2Vycy4gU2luY2Ugd2Ugd2FudCB0aGUgcmVzdWx0cyB0byBiZSBhbHdheXMgcG9zaXRpdmUsIGNvbnZlcnQgdGhlXG4gICAqIHNpZ25lZCBpbnQgdG8gYW4gdW5zaWduZWQgYnkgZG9pbmcgYW4gdW5zaWduZWQgYml0c2hpZnQuICovXG4gIHJldHVybiBoYXNoID4+PiAwO1xufVxuXG52YXIgc3RyaW5nSGFzaCA9IGhhc2g7XG5cbnZhciBzcmMgPSB7ZXhwb3J0czoge319O1xuXG5jb25zdCBJQ1NTVXRpbHMgPSBzcmMkNDtcblxuY29uc3QgbWF0Y2hJbXBvcnRzID0gL14oLis/fFxcKFtcXHNcXFNdKz9cXCkpXFxzK2Zyb21cXHMrKFwiW15cIl0qXCJ8J1teJ10qJ3xbXFx3LV0rKSQvO1xuY29uc3QgbWF0Y2hWYWx1ZURlZmluaXRpb24gPSAvKD86XFxzK3xeKShbXFx3LV0rKTo/KC4qPykkLztcbmNvbnN0IG1hdGNoSW1wb3J0ID0gL14oW1xcdy1dKykoPzpcXHMrYXNcXHMrKFtcXHctXSspKT8vO1xuXG5zcmMuZXhwb3J0cyA9IChvcHRpb25zKSA9PiB7XG4gIGxldCBpbXBvcnRJbmRleCA9IDA7XG4gIGNvbnN0IGNyZWF0ZUltcG9ydGVkTmFtZSA9XG4gICAgKG9wdGlvbnMgJiYgb3B0aW9ucy5jcmVhdGVJbXBvcnRlZE5hbWUpIHx8XG4gICAgKChpbXBvcnROYW1lIC8qLCBwYXRoKi8pID0+XG4gICAgICBgaV9fY29uc3RfJHtpbXBvcnROYW1lLnJlcGxhY2UoL1xcVy9nLCBcIl9cIil9XyR7aW1wb3J0SW5kZXgrK31gKTtcblxuICByZXR1cm4ge1xuICAgIHBvc3Rjc3NQbHVnaW46IFwicG9zdGNzcy1tb2R1bGVzLXZhbHVlc1wiLFxuICAgIHByZXBhcmUocmVzdWx0KSB7XG4gICAgICBjb25zdCBpbXBvcnRBbGlhc2VzID0gW107XG4gICAgICBjb25zdCBkZWZpbml0aW9ucyA9IHt9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBPbmNlKHJvb3QsIHBvc3Rjc3MpIHtcbiAgICAgICAgICByb290LndhbGtBdFJ1bGVzKC92YWx1ZS9pLCAoYXRSdWxlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gYXRSdWxlLnBhcmFtcy5tYXRjaChtYXRjaEltcG9ydHMpO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICBsZXQgWywgLyptYXRjaCovIGFsaWFzZXMsIHBhdGhdID0gbWF0Y2hlcztcblxuICAgICAgICAgICAgICAvLyBXZSBjYW4gdXNlIGNvbnN0YW50cyBmb3IgcGF0aCBuYW1lc1xuICAgICAgICAgICAgICBpZiAoZGVmaW5pdGlvbnNbcGF0aF0pIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gZGVmaW5pdGlvbnNbcGF0aF07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBpbXBvcnRzID0gYWxpYXNlc1xuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eXFwoXFxzKihbXFxzXFxTXSspXFxzKlxcKSQvLCBcIiQxXCIpXG4gICAgICAgICAgICAgICAgLnNwbGl0KC9cXHMqLFxccyovKVxuICAgICAgICAgICAgICAgIC5tYXAoKGFsaWFzKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbnMgPSBtYXRjaEltcG9ydC5leGVjKGFsaWFzKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbLCAvKm1hdGNoKi8gdGhlaXJOYW1lLCBteU5hbWUgPSB0aGVpck5hbWVdID0gdG9rZW5zO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbXBvcnRlZE5hbWUgPSBjcmVhdGVJbXBvcnRlZE5hbWUobXlOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbnNbbXlOYW1lXSA9IGltcG9ydGVkTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGhlaXJOYW1lLCBpbXBvcnRlZE5hbWUgfTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQGltcG9ydCBzdGF0ZW1lbnQgXCIke2FsaWFzfVwiIGlzIGludmFsaWQhYCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaW1wb3J0QWxpYXNlcy5wdXNoKHsgcGF0aCwgaW1wb3J0cyB9KTtcblxuICAgICAgICAgICAgICBhdFJ1bGUucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXRSdWxlLnBhcmFtcy5pbmRleE9mKFwiQHZhbHVlXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICByZXN1bHQud2FybihcIkludmFsaWQgdmFsdWUgZGVmaW5pdGlvbjogXCIgKyBhdFJ1bGUucGFyYW1zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IFssIGtleSwgdmFsdWVdID0gYCR7YXRSdWxlLnBhcmFtc30ke2F0UnVsZS5yYXdzLmJldHdlZW59YC5tYXRjaChcbiAgICAgICAgICAgICAgbWF0Y2hWYWx1ZURlZmluaXRpb25cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcL1xcKigoPyFcXCpcXC8pLio/KVxcKlxcLy9nLCBcIlwiKTtcblxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRWYWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgcmVzdWx0Lndhcm4oXCJJbnZhbGlkIHZhbHVlIGRlZmluaXRpb246IFwiICsgYXRSdWxlLnBhcmFtcyk7XG4gICAgICAgICAgICAgIGF0UnVsZS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBpc09ubHlTcGFjZSA9IC9eXFxzKyQvLnRlc3Qobm9ybWFsaXplZFZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKCFpc09ubHlTcGFjZSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHRvIHRoZSBkZWZpbml0aW9ucywga25vd2luZyB0aGF0IHZhbHVlcyBjYW4gcmVmZXIgdG8gZWFjaCBvdGhlclxuICAgICAgICAgICAgZGVmaW5pdGlvbnNba2V5XSA9IElDU1NVdGlscy5yZXBsYWNlVmFsdWVTeW1ib2xzKFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgZGVmaW5pdGlvbnNcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGF0UnVsZS5yZW1vdmUoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8qIElmIHdlIGhhdmUgbm8gZGVmaW5pdGlvbnMsIGRvbid0IGNvbnRpbnVlICovXG4gICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhkZWZpbml0aW9ucykubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyogUGVyZm9ybSByZXBsYWNlbWVudHMgKi9cbiAgICAgICAgICBJQ1NTVXRpbHMucmVwbGFjZVN5bWJvbHMocm9vdCwgZGVmaW5pdGlvbnMpO1xuXG4gICAgICAgICAgLyogV2Ugd2FudCB0byBleHBvcnQgYW55dGhpbmcgZGVmaW5lZCBieSBub3csIGJ1dCBkb24ndCBhZGQgaXQgdG8gdGhlIENTUyB5ZXQgb3IgaXQgd2VsbCBnZXQgcGlja2VkIHVwIGJ5IHRoZSByZXBsYWNlbWVudCBzdHVmZiAqL1xuICAgICAgICAgIGNvbnN0IGV4cG9ydERlY2xhcmF0aW9ucyA9IE9iamVjdC5rZXlzKGRlZmluaXRpb25zKS5tYXAoKGtleSkgPT5cbiAgICAgICAgICAgIHBvc3Rjc3MuZGVjbCh7XG4gICAgICAgICAgICAgIHZhbHVlOiBkZWZpbml0aW9uc1trZXldLFxuICAgICAgICAgICAgICBwcm9wOiBrZXksXG4gICAgICAgICAgICAgIHJhd3M6IHsgYmVmb3JlOiBcIlxcbiAgXCIgfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8qIEFkZCBleHBvcnQgcnVsZXMgaWYgYW55ICovXG4gICAgICAgICAgaWYgKGV4cG9ydERlY2xhcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBleHBvcnRSdWxlID0gcG9zdGNzcy5ydWxlKHtcbiAgICAgICAgICAgICAgc2VsZWN0b3I6IFwiOmV4cG9ydFwiLFxuICAgICAgICAgICAgICByYXdzOiB7IGFmdGVyOiBcIlxcblwiIH0sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZXhwb3J0UnVsZS5hcHBlbmQoZXhwb3J0RGVjbGFyYXRpb25zKTtcblxuICAgICAgICAgICAgcm9vdC5wcmVwZW5kKGV4cG9ydFJ1bGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qIEFkZCBpbXBvcnQgcnVsZXMgKi9cbiAgICAgICAgICBpbXBvcnRBbGlhc2VzLnJldmVyc2UoKS5mb3JFYWNoKCh7IHBhdGgsIGltcG9ydHMgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW1wb3J0UnVsZSA9IHBvc3Rjc3MucnVsZSh7XG4gICAgICAgICAgICAgIHNlbGVjdG9yOiBgOmltcG9ydCgke3BhdGh9KWAsXG4gICAgICAgICAgICAgIHJhd3M6IHsgYWZ0ZXI6IFwiXFxuXCIgfSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpbXBvcnRzLmZvckVhY2goKHsgdGhlaXJOYW1lLCBpbXBvcnRlZE5hbWUgfSkgPT4ge1xuICAgICAgICAgICAgICBpbXBvcnRSdWxlLmFwcGVuZCh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoZWlyTmFtZSxcbiAgICAgICAgICAgICAgICBwcm9wOiBpbXBvcnRlZE5hbWUsXG4gICAgICAgICAgICAgICAgcmF3czogeyBiZWZvcmU6IFwiXFxuICBcIiB9LFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByb290LnByZXBlbmQoaW1wb3J0UnVsZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0sXG4gIH07XG59O1xuXG5zcmMuZXhwb3J0cy5wb3N0Y3NzID0gdHJ1ZTtcblxudmFyIHNyY0V4cG9ydHMgPSBzcmMuZXhwb3J0cztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNjb3BpbmcsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnNjb3BpbmcuYmVoYXZpb3VycyA9IHZvaWQgMDtcbnNjb3BpbmcuZ2V0RGVmYXVsdFBsdWdpbnMgPSBnZXREZWZhdWx0UGx1Z2lucztcbnNjb3BpbmcuZ2V0RGVmYXVsdFNjb3BlQmVoYXZpb3VyID0gZ2V0RGVmYXVsdFNjb3BlQmVoYXZpb3VyO1xuc2NvcGluZy5nZXRTY29wZWROYW1lR2VuZXJhdG9yID0gZ2V0U2NvcGVkTmFtZUdlbmVyYXRvcjtcblxudmFyIF9wb3N0Y3NzTW9kdWxlc0V4dHJhY3RJbXBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQxKHNyY0V4cG9ydHMkMik7XG5cbnZhciBfZ2VuZXJpY05hbWVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdCQxKGdlbmVyaWNOYW1lcyk7XG5cbnZhciBfcG9zdGNzc01vZHVsZXNMb2NhbEJ5RGVmYXVsdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkMShzcmNFeHBvcnRzJDEpO1xuXG52YXIgX3Bvc3Rjc3NNb2R1bGVzU2NvcGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0JDEoc3JjJDEpO1xuXG52YXIgX3N0cmluZ0hhc2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0JDEoc3RyaW5nSGFzaCk7XG5cbnZhciBfcG9zdGNzc01vZHVsZXNWYWx1ZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0JDEoc3JjRXhwb3J0cyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQkMShvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3QgYmVoYXZpb3VycyA9IHtcbiAgTE9DQUw6IFwibG9jYWxcIixcbiAgR0xPQkFMOiBcImdsb2JhbFwiXG59O1xuc2NvcGluZy5iZWhhdmlvdXJzID0gYmVoYXZpb3VycztcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFBsdWdpbnMoe1xuICBiZWhhdmlvdXIsXG4gIGdlbmVyYXRlU2NvcGVkTmFtZSxcbiAgZXhwb3J0R2xvYmFsc1xufSkge1xuICBjb25zdCBzY29wZSA9ICgwLCBfcG9zdGNzc01vZHVsZXNTY29wZS5kZWZhdWx0KSh7XG4gICAgZ2VuZXJhdGVTY29wZWROYW1lLFxuICAgIGV4cG9ydEdsb2JhbHNcbiAgfSk7XG4gIGNvbnN0IHBsdWdpbnMgPSB7XG4gICAgW2JlaGF2aW91cnMuTE9DQUxdOiBbX3Bvc3Rjc3NNb2R1bGVzVmFsdWVzLmRlZmF1bHQsICgwLCBfcG9zdGNzc01vZHVsZXNMb2NhbEJ5RGVmYXVsdC5kZWZhdWx0KSh7XG4gICAgICBtb2RlOiBcImxvY2FsXCJcbiAgICB9KSwgX3Bvc3Rjc3NNb2R1bGVzRXh0cmFjdEltcG9ydHMuZGVmYXVsdCwgc2NvcGVdLFxuICAgIFtiZWhhdmlvdXJzLkdMT0JBTF06IFtfcG9zdGNzc01vZHVsZXNWYWx1ZXMuZGVmYXVsdCwgKDAsIF9wb3N0Y3NzTW9kdWxlc0xvY2FsQnlEZWZhdWx0LmRlZmF1bHQpKHtcbiAgICAgIG1vZGU6IFwiZ2xvYmFsXCJcbiAgICB9KSwgX3Bvc3Rjc3NNb2R1bGVzRXh0cmFjdEltcG9ydHMuZGVmYXVsdCwgc2NvcGVdXG4gIH07XG4gIHJldHVybiBwbHVnaW5zW2JlaGF2aW91cl07XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRCZWhhdmlvdXIoYmVoYXZpb3VyKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhiZWhhdmlvdXJzKS5tYXAoa2V5ID0+IGJlaGF2aW91cnNba2V5XSkuaW5kZXhPZihiZWhhdmlvdXIpID4gLTE7XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRTY29wZUJlaGF2aW91cihzY29wZUJlaGF2aW91cikge1xuICByZXR1cm4gc2NvcGVCZWhhdmlvdXIgJiYgaXNWYWxpZEJlaGF2aW91cihzY29wZUJlaGF2aW91cikgPyBzY29wZUJlaGF2aW91ciA6IGJlaGF2aW91cnMuTE9DQUw7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU2NvcGVkTmFtZURlZmF1bHQobmFtZSwgZmlsZW5hbWUsIGNzcykge1xuICBjb25zdCBpID0gY3NzLmluZGV4T2YoYC4ke25hbWV9YCk7XG4gIGNvbnN0IGxpbmVOdW1iZXIgPSBjc3Muc3Vic3RyKDAsIGkpLnNwbGl0KC9bXFxyXFxuXS8pLmxlbmd0aDtcbiAgY29uc3QgaGFzaCA9ICgwLCBfc3RyaW5nSGFzaC5kZWZhdWx0KShjc3MpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMCwgNSk7XG4gIHJldHVybiBgXyR7bmFtZX1fJHtoYXNofV8ke2xpbmVOdW1iZXJ9YDtcbn1cblxuZnVuY3Rpb24gZ2V0U2NvcGVkTmFtZUdlbmVyYXRvcihnZW5lcmF0ZVNjb3BlZE5hbWUsIGhhc2hQcmVmaXgpIHtcbiAgY29uc3Qgc2NvcGVkTmFtZUdlbmVyYXRvciA9IGdlbmVyYXRlU2NvcGVkTmFtZSB8fCBnZW5lcmF0ZVNjb3BlZE5hbWVEZWZhdWx0O1xuXG4gIGlmICh0eXBlb2Ygc2NvcGVkTmFtZUdlbmVyYXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHNjb3BlZE5hbWVHZW5lcmF0b3I7XG4gIH1cblxuICByZXR1cm4gKDAsIF9nZW5lcmljTmFtZXMuZGVmYXVsdCkoc2NvcGVkTmFtZUdlbmVyYXRvciwge1xuICAgIGNvbnRleHQ6IHByb2Nlc3MuY3dkKCksXG4gICAgaGFzaFByZWZpeDogaGFzaFByZWZpeFxuICB9KTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHBsdWdpbkZhY3RvcnksIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnBsdWdpbkZhY3RvcnkubWFrZVBsdWdpbiA9IG1ha2VQbHVnaW47XG5cbnZhciBfcG9zdGNzcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZSQkMCk7XG5cbnZhciBfdW5xdW90ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQodW5xdW90ZSQxKTtcblxudmFyIF9QYXJzZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KFBhcnNlciQxKTtcblxudmFyIF9zYXZlSlNPTiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoc2F2ZUpTT04kMSk7XG5cbnZhciBfbG9jYWxzQ29udmVudGlvbiA9IGxvY2Fsc0NvbnZlbnRpb247XG5cbnZhciBfRmlsZVN5c3RlbUxvYWRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoRmlsZVN5c3RlbUxvYWRlciQxKTtcblxudmFyIF9zY29waW5nID0gc2NvcGluZztcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3QgUExVR0lOX05BTUUgPSBcInBvc3Rjc3MtbW9kdWxlc1wiO1xuXG5mdW5jdGlvbiBpc0dsb2JhbE1vZHVsZShnbG9iYWxNb2R1bGVzLCBpbnB1dEZpbGUpIHtcbiAgcmV0dXJuIGdsb2JhbE1vZHVsZXMuc29tZShyZWdleCA9PiBpbnB1dEZpbGUubWF0Y2gocmVnZXgpKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFBsdWdpbnNMaXN0KG9wdHMsIGlucHV0RmlsZSkge1xuICBjb25zdCBnbG9iYWxNb2R1bGVzTGlzdCA9IG9wdHMuZ2xvYmFsTW9kdWxlUGF0aHMgfHwgbnVsbDtcbiAgY29uc3QgZXhwb3J0R2xvYmFscyA9IG9wdHMuZXhwb3J0R2xvYmFscyB8fCBmYWxzZTtcbiAgY29uc3QgZGVmYXVsdEJlaGF2aW91ciA9ICgwLCBfc2NvcGluZy5nZXREZWZhdWx0U2NvcGVCZWhhdmlvdXIpKG9wdHMuc2NvcGVCZWhhdmlvdXIpO1xuICBjb25zdCBnZW5lcmF0ZVNjb3BlZE5hbWUgPSAoMCwgX3Njb3BpbmcuZ2V0U2NvcGVkTmFtZUdlbmVyYXRvcikob3B0cy5nZW5lcmF0ZVNjb3BlZE5hbWUsIG9wdHMuaGFzaFByZWZpeCk7XG5cbiAgaWYgKGdsb2JhbE1vZHVsZXNMaXN0ICYmIGlzR2xvYmFsTW9kdWxlKGdsb2JhbE1vZHVsZXNMaXN0LCBpbnB1dEZpbGUpKSB7XG4gICAgcmV0dXJuICgwLCBfc2NvcGluZy5nZXREZWZhdWx0UGx1Z2lucykoe1xuICAgICAgYmVoYXZpb3VyOiBfc2NvcGluZy5iZWhhdmlvdXJzLkdMT0JBTCxcbiAgICAgIGdlbmVyYXRlU2NvcGVkTmFtZSxcbiAgICAgIGV4cG9ydEdsb2JhbHNcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiAoMCwgX3Njb3BpbmcuZ2V0RGVmYXVsdFBsdWdpbnMpKHtcbiAgICBiZWhhdmlvdXI6IGRlZmF1bHRCZWhhdmlvdXIsXG4gICAgZ2VuZXJhdGVTY29wZWROYW1lLFxuICAgIGV4cG9ydEdsb2JhbHNcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldExvYWRlcihvcHRzLCBwbHVnaW5zKSB7XG4gIGNvbnN0IHJvb3QgPSB0eXBlb2Ygb3B0cy5yb290ID09PSBcInVuZGVmaW5lZFwiID8gXCIvXCIgOiBvcHRzLnJvb3Q7XG4gIHJldHVybiB0eXBlb2Ygb3B0cy5Mb2FkZXIgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBvcHRzLkxvYWRlcihyb290LCBwbHVnaW5zLCBvcHRzLnJlc29sdmUpIDogbmV3IF9GaWxlU3lzdGVtTG9hZGVyLmRlZmF1bHQocm9vdCwgcGx1Z2lucywgb3B0cy5yZXNvbHZlKTtcbn1cblxuZnVuY3Rpb24gaXNPdXJQbHVnaW4ocGx1Z2luKSB7XG4gIHJldHVybiBwbHVnaW4ucG9zdGNzc1BsdWdpbiA9PT0gUExVR0lOX05BTUU7XG59XG5cbmZ1bmN0aW9uIG1ha2VQbHVnaW4ob3B0cykge1xuICByZXR1cm4ge1xuICAgIHBvc3Rjc3NQbHVnaW46IFBMVUdJTl9OQU1FLFxuXG4gICAgYXN5bmMgT25jZUV4aXQoY3NzLCB7XG4gICAgICByZXN1bHRcbiAgICB9KSB7XG4gICAgICBjb25zdCBnZXRKU09OID0gb3B0cy5nZXRKU09OIHx8IF9zYXZlSlNPTi5kZWZhdWx0O1xuICAgICAgY29uc3QgaW5wdXRGaWxlID0gY3NzLnNvdXJjZS5pbnB1dC5maWxlO1xuICAgICAgY29uc3QgcGx1Z2luTGlzdCA9IGdldERlZmF1bHRQbHVnaW5zTGlzdChvcHRzLCBpbnB1dEZpbGUpO1xuICAgICAgY29uc3QgcmVzdWx0UGx1Z2luSW5kZXggPSByZXN1bHQucHJvY2Vzc29yLnBsdWdpbnMuZmluZEluZGV4KHBsdWdpbiA9PiBpc091clBsdWdpbihwbHVnaW4pKTtcblxuICAgICAgaWYgKHJlc3VsdFBsdWdpbkluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbHVnaW4gbWlzc2luZyBmcm9tIG9wdGlvbnMuXCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlYXJsaWVyUGx1Z2lucyA9IHJlc3VsdC5wcm9jZXNzb3IucGx1Z2lucy5zbGljZSgwLCByZXN1bHRQbHVnaW5JbmRleCk7XG4gICAgICBjb25zdCBsb2FkZXJQbHVnaW5zID0gWy4uLmVhcmxpZXJQbHVnaW5zLCAuLi5wbHVnaW5MaXN0XTtcbiAgICAgIGNvbnN0IGxvYWRlciA9IGdldExvYWRlcihvcHRzLCBsb2FkZXJQbHVnaW5zKTtcblxuICAgICAgY29uc3QgZmV0Y2hlciA9IGFzeW5jIChmaWxlLCByZWxhdGl2ZVRvLCBkZXBUcmFjZSkgPT4ge1xuICAgICAgICBjb25zdCB1bnF1b3RlRmlsZSA9ICgwLCBfdW5xdW90ZS5kZWZhdWx0KShmaWxlKTtcbiAgICAgICAgcmV0dXJuIGxvYWRlci5mZXRjaC5jYWxsKGxvYWRlciwgdW5xdW90ZUZpbGUsIHJlbGF0aXZlVG8sIGRlcFRyYWNlKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBfUGFyc2VyLmRlZmF1bHQoZmV0Y2hlcik7XG4gICAgICBhd2FpdCAoMCwgX3Bvc3Rjc3MuZGVmYXVsdCkoWy4uLnBsdWdpbkxpc3QsIHBhcnNlci5wbHVnaW4oKV0pLnByb2Nlc3MoY3NzLCB7XG4gICAgICAgIGZyb206IGlucHV0RmlsZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBvdXQgPSBsb2FkZXIuZmluYWxTb3VyY2U7XG4gICAgICBpZiAob3V0KSBjc3MucHJlcGVuZChvdXQpO1xuXG4gICAgICBpZiAob3B0cy5sb2NhbHNDb252ZW50aW9uKSB7XG4gICAgICAgIGNvbnN0IHJlZHVjZXIgPSAoMCwgX2xvY2Fsc0NvbnZlbnRpb24ubWFrZUxvY2Fsc0NvbnZlbnRpb25SZWR1Y2VyKShvcHRzLmxvY2Fsc0NvbnZlbnRpb24sIGlucHV0RmlsZSk7XG4gICAgICAgIHBhcnNlci5leHBvcnRUb2tlbnMgPSBPYmplY3QuZW50cmllcyhwYXJzZXIuZXhwb3J0VG9rZW5zKS5yZWR1Y2UocmVkdWNlciwge30pO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQubWVzc2FnZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiZXhwb3J0XCIsXG4gICAgICAgIHBsdWdpbjogXCJwb3N0Y3NzLW1vZHVsZXNcIixcbiAgICAgICAgZXhwb3J0VG9rZW5zOiBwYXJzZXIuZXhwb3J0VG9rZW5zXG4gICAgICB9KTsgLy8gZ2V0SlNPTiBtYXkgcmV0dXJuIGEgcHJvbWlzZVxuXG4gICAgICByZXR1cm4gZ2V0SlNPTihjc3Muc291cmNlLmlucHV0LmZpbGUsIHBhcnNlci5leHBvcnRUb2tlbnMsIHJlc3VsdC5vcHRzLnRvKTtcbiAgICB9XG5cbiAgfTtcbn1cblxudmFyIF9mcyA9IHJlcXVpcmUkJDBfX2RlZmF1bHQ7XG5cbnZhciBfZnMyID0gZnM7XG5cbnZhciBfcGx1Z2luRmFjdG9yeSA9IHBsdWdpbkZhY3Rvcnk7XG5cbigwLCBfZnMyLnNldEZpbGVTeXN0ZW0pKHtcbiAgcmVhZEZpbGU6IF9mcy5yZWFkRmlsZSxcbiAgd3JpdGVGaWxlOiBfZnMud3JpdGVGaWxlXG59KTtcblxuYnVpbGQuZXhwb3J0cyA9IChvcHRzID0ge30pID0+ICgwLCBfcGx1Z2luRmFjdG9yeS5tYWtlUGx1Z2luKShvcHRzKTtcblxudmFyIHBvc3Rjc3MgPSBidWlsZC5leHBvcnRzLnBvc3Rjc3MgPSB0cnVlO1xuXG52YXIgYnVpbGRFeHBvcnRzID0gYnVpbGQuZXhwb3J0cztcbnZhciBpbmRleCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhidWlsZEV4cG9ydHMpO1xuXG52YXIgaW5kZXgkMSA9IC8qI19fUFVSRV9fKi9fbWVyZ2VOYW1lc3BhY2VzKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBkZWZhdWx0OiBpbmRleCxcbiAgcG9zdGNzczogcG9zdGNzc1xufSwgW2J1aWxkRXhwb3J0c10pO1xuXG5leHBvcnQgeyBpbmRleCQxIGFzIGkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vite/dist/node/chunks/dep-Ba1kN6Mp.js\n");

/***/ }),

/***/ "./node_modules/vite/dist/node/chunks/dep-IQS-Za7F.js":
/*!************************************************************!*\
  !*** ./node_modules/vite/dist/node/chunks/dep-IQS-Za7F.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   l: () => (/* binding */ lib)\n/* harmony export */ });\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:module */ \"node:module\");\n\n\n\n\nconst __filename = (0,node_url__WEBPACK_IMPORTED_MODULE_0__.fileURLToPath)(\"file:///var/www/html/livewire-tall/node_modules/vite/dist/node/chunks/dep-IQS-Za7F.js\");\nconst __dirname = (0,node_path__WEBPACK_IMPORTED_MODULE_1__.dirname)(__filename);\nconst require = (0,node_module__WEBPACK_IMPORTED_MODULE_2__.createRequire)(\"file:///var/www/html/livewire-tall/node_modules/vite/dist/node/chunks/dep-IQS-Za7F.js\");\nconst __require = require;\nvar openParentheses = \"(\".charCodeAt(0);\nvar closeParentheses = \")\".charCodeAt(0);\nvar singleQuote = \"'\".charCodeAt(0);\nvar doubleQuote = '\"'.charCodeAt(0);\nvar backslash = \"\\\\\".charCodeAt(0);\nvar slash = \"/\".charCodeAt(0);\nvar comma = \",\".charCodeAt(0);\nvar colon = \":\".charCodeAt(0);\nvar star = \"*\".charCodeAt(0);\nvar uLower = \"u\".charCodeAt(0);\nvar uUpper = \"U\".charCodeAt(0);\nvar plus = \"+\".charCodeAt(0);\nvar isUnicodeRange = /^[a-f0-9?-]+$/i;\n\nvar parse$1 = function(input) {\n  var tokens = [];\n  var value = input;\n\n  var next,\n    quote,\n    prev,\n    token,\n    escape,\n    escapePos,\n    whitespacePos,\n    parenthesesOpenPos;\n  var pos = 0;\n  var code = value.charCodeAt(pos);\n  var max = value.length;\n  var stack = [{ nodes: tokens }];\n  var balanced = 0;\n  var parent;\n\n  var name = \"\";\n  var before = \"\";\n  var after = \"\";\n\n  while (pos < max) {\n    // Whitespaces\n    if (code <= 32) {\n      next = pos;\n      do {\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (code <= 32);\n      token = value.slice(pos, next);\n\n      prev = tokens[tokens.length - 1];\n      if (code === closeParentheses && balanced) {\n        after = token;\n      } else if (prev && prev.type === \"div\") {\n        prev.after = token;\n        prev.sourceEndIndex += token.length;\n      } else if (\n        code === comma ||\n        code === colon ||\n        (code === slash &&\n          value.charCodeAt(next + 1) !== star &&\n          (!parent ||\n            (parent && parent.type === \"function\" && parent.value !== \"calc\")))\n      ) {\n        before = token;\n      } else {\n        tokens.push({\n          type: \"space\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      }\n\n      pos = next;\n\n      // Quotes\n    } else if (code === singleQuote || code === doubleQuote) {\n      next = pos;\n      quote = code === singleQuote ? \"'\" : '\"';\n      token = {\n        type: \"string\",\n        sourceIndex: pos,\n        quote: quote\n      };\n      do {\n        escape = false;\n        next = value.indexOf(quote, next + 1);\n        if (~next) {\n          escapePos = next;\n          while (value.charCodeAt(escapePos - 1) === backslash) {\n            escapePos -= 1;\n            escape = !escape;\n          }\n        } else {\n          value += quote;\n          next = value.length - 1;\n          token.unclosed = true;\n        }\n      } while (escape);\n      token.value = value.slice(pos + 1, next);\n      token.sourceEndIndex = token.unclosed ? next : next + 1;\n      tokens.push(token);\n      pos = next + 1;\n      code = value.charCodeAt(pos);\n\n      // Comments\n    } else if (code === slash && value.charCodeAt(pos + 1) === star) {\n      next = value.indexOf(\"*/\", pos);\n\n      token = {\n        type: \"comment\",\n        sourceIndex: pos,\n        sourceEndIndex: next + 2\n      };\n\n      if (next === -1) {\n        token.unclosed = true;\n        next = value.length;\n        token.sourceEndIndex = next;\n      }\n\n      token.value = value.slice(pos + 2, next);\n      tokens.push(token);\n\n      pos = next + 2;\n      code = value.charCodeAt(pos);\n\n      // Operation within calc\n    } else if (\n      (code === slash || code === star) &&\n      parent &&\n      parent.type === \"function\" &&\n      parent.value === \"calc\"\n    ) {\n      token = value[pos];\n      tokens.push({\n        type: \"word\",\n        sourceIndex: pos - before.length,\n        sourceEndIndex: pos + token.length,\n        value: token\n      });\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      // Dividers\n    } else if (code === slash || code === comma || code === colon) {\n      token = value[pos];\n\n      tokens.push({\n        type: \"div\",\n        sourceIndex: pos - before.length,\n        sourceEndIndex: pos + token.length,\n        value: token,\n        before: before,\n        after: \"\"\n      });\n      before = \"\";\n\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      // Open parentheses\n    } else if (openParentheses === code) {\n      // Whitespaces after open parentheses\n      next = pos;\n      do {\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (code <= 32);\n      parenthesesOpenPos = pos;\n      token = {\n        type: \"function\",\n        sourceIndex: pos - name.length,\n        value: name,\n        before: value.slice(parenthesesOpenPos + 1, next)\n      };\n      pos = next;\n\n      if (name === \"url\" && code !== singleQuote && code !== doubleQuote) {\n        next -= 1;\n        do {\n          escape = false;\n          next = value.indexOf(\")\", next + 1);\n          if (~next) {\n            escapePos = next;\n            while (value.charCodeAt(escapePos - 1) === backslash) {\n              escapePos -= 1;\n              escape = !escape;\n            }\n          } else {\n            value += \")\";\n            next = value.length - 1;\n            token.unclosed = true;\n          }\n        } while (escape);\n        // Whitespaces before closed\n        whitespacePos = next;\n        do {\n          whitespacePos -= 1;\n          code = value.charCodeAt(whitespacePos);\n        } while (code <= 32);\n        if (parenthesesOpenPos < whitespacePos) {\n          if (pos !== whitespacePos + 1) {\n            token.nodes = [\n              {\n                type: \"word\",\n                sourceIndex: pos,\n                sourceEndIndex: whitespacePos + 1,\n                value: value.slice(pos, whitespacePos + 1)\n              }\n            ];\n          } else {\n            token.nodes = [];\n          }\n          if (token.unclosed && whitespacePos + 1 !== next) {\n            token.after = \"\";\n            token.nodes.push({\n              type: \"space\",\n              sourceIndex: whitespacePos + 1,\n              sourceEndIndex: next,\n              value: value.slice(whitespacePos + 1, next)\n            });\n          } else {\n            token.after = value.slice(whitespacePos + 1, next);\n            token.sourceEndIndex = next;\n          }\n        } else {\n          token.after = \"\";\n          token.nodes = [];\n        }\n        pos = next + 1;\n        token.sourceEndIndex = token.unclosed ? next : pos;\n        code = value.charCodeAt(pos);\n        tokens.push(token);\n      } else {\n        balanced += 1;\n        token.after = \"\";\n        token.sourceEndIndex = pos + 1;\n        tokens.push(token);\n        stack.push(token);\n        tokens = token.nodes = [];\n        parent = token;\n      }\n      name = \"\";\n\n      // Close parentheses\n    } else if (closeParentheses === code && balanced) {\n      pos += 1;\n      code = value.charCodeAt(pos);\n\n      parent.after = after;\n      parent.sourceEndIndex += after.length;\n      after = \"\";\n      balanced -= 1;\n      stack[stack.length - 1].sourceEndIndex = pos;\n      stack.pop();\n      parent = stack[balanced];\n      tokens = parent.nodes;\n\n      // Words\n    } else {\n      next = pos;\n      do {\n        if (code === backslash) {\n          next += 1;\n        }\n        next += 1;\n        code = value.charCodeAt(next);\n      } while (\n        next < max &&\n        !(\n          code <= 32 ||\n          code === singleQuote ||\n          code === doubleQuote ||\n          code === comma ||\n          code === colon ||\n          code === slash ||\n          code === openParentheses ||\n          (code === star &&\n            parent &&\n            parent.type === \"function\" &&\n            parent.value === \"calc\") ||\n          (code === slash &&\n            parent.type === \"function\" &&\n            parent.value === \"calc\") ||\n          (code === closeParentheses && balanced)\n        )\n      );\n      token = value.slice(pos, next);\n\n      if (openParentheses === code) {\n        name = token;\n      } else if (\n        (uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) &&\n        plus === token.charCodeAt(1) &&\n        isUnicodeRange.test(token.slice(2))\n      ) {\n        tokens.push({\n          type: \"unicode-range\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      } else {\n        tokens.push({\n          type: \"word\",\n          sourceIndex: pos,\n          sourceEndIndex: next,\n          value: token\n        });\n      }\n\n      pos = next;\n    }\n  }\n\n  for (pos = stack.length - 1; pos; pos -= 1) {\n    stack[pos].unclosed = true;\n    stack[pos].sourceEndIndex = value.length;\n  }\n\n  return stack[0].nodes;\n};\n\nvar walk$1 = function walk(nodes, cb, bubble) {\n  var i, max, node, result;\n\n  for (i = 0, max = nodes.length; i < max; i += 1) {\n    node = nodes[i];\n    if (!bubble) {\n      result = cb(node, i, nodes);\n    }\n\n    if (\n      result !== false &&\n      node.type === \"function\" &&\n      Array.isArray(node.nodes)\n    ) {\n      walk(node.nodes, cb, bubble);\n    }\n\n    if (bubble) {\n      cb(node, i, nodes);\n    }\n  }\n};\n\nfunction stringifyNode(node, custom) {\n  var type = node.type;\n  var value = node.value;\n  var buf;\n  var customResult;\n\n  if (custom && (customResult = custom(node)) !== undefined) {\n    return customResult;\n  } else if (type === \"word\" || type === \"space\") {\n    return value;\n  } else if (type === \"string\") {\n    buf = node.quote || \"\";\n    return buf + value + (node.unclosed ? \"\" : buf);\n  } else if (type === \"comment\") {\n    return \"/*\" + value + (node.unclosed ? \"\" : \"*/\");\n  } else if (type === \"div\") {\n    return (node.before || \"\") + value + (node.after || \"\");\n  } else if (Array.isArray(node.nodes)) {\n    buf = stringify$1(node.nodes, custom);\n    if (type !== \"function\") {\n      return buf;\n    }\n    return (\n      value +\n      \"(\" +\n      (node.before || \"\") +\n      buf +\n      (node.after || \"\") +\n      (node.unclosed ? \"\" : \")\")\n    );\n  }\n  return value;\n}\n\nfunction stringify$1(nodes, custom) {\n  var result, i;\n\n  if (Array.isArray(nodes)) {\n    result = \"\";\n    for (i = nodes.length - 1; ~i; i -= 1) {\n      result = stringifyNode(nodes[i], custom) + result;\n    }\n    return result;\n  }\n  return stringifyNode(nodes, custom);\n}\n\nvar stringify_1 = stringify$1;\n\nvar unit;\nvar hasRequiredUnit;\n\nfunction requireUnit () {\n\tif (hasRequiredUnit) return unit;\n\thasRequiredUnit = 1;\n\tvar minus = \"-\".charCodeAt(0);\n\tvar plus = \"+\".charCodeAt(0);\n\tvar dot = \".\".charCodeAt(0);\n\tvar exp = \"e\".charCodeAt(0);\n\tvar EXP = \"E\".charCodeAt(0);\n\n\t// Check if three code points would start a number\n\t// https://www.w3.org/TR/css-syntax-3/#starts-with-a-number\n\tfunction likeNumber(value) {\n\t  var code = value.charCodeAt(0);\n\t  var nextCode;\n\n\t  if (code === plus || code === minus) {\n\t    nextCode = value.charCodeAt(1);\n\n\t    if (nextCode >= 48 && nextCode <= 57) {\n\t      return true;\n\t    }\n\n\t    var nextNextCode = value.charCodeAt(2);\n\n\t    if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {\n\t      return true;\n\t    }\n\n\t    return false;\n\t  }\n\n\t  if (code === dot) {\n\t    nextCode = value.charCodeAt(1);\n\n\t    if (nextCode >= 48 && nextCode <= 57) {\n\t      return true;\n\t    }\n\n\t    return false;\n\t  }\n\n\t  if (code >= 48 && code <= 57) {\n\t    return true;\n\t  }\n\n\t  return false;\n\t}\n\n\t// Consume a number\n\t// https://www.w3.org/TR/css-syntax-3/#consume-number\n\tunit = function(value) {\n\t  var pos = 0;\n\t  var length = value.length;\n\t  var code;\n\t  var nextCode;\n\t  var nextNextCode;\n\n\t  if (length === 0 || !likeNumber(value)) {\n\t    return false;\n\t  }\n\n\t  code = value.charCodeAt(pos);\n\n\t  if (code === plus || code === minus) {\n\t    pos++;\n\t  }\n\n\t  while (pos < length) {\n\t    code = value.charCodeAt(pos);\n\n\t    if (code < 48 || code > 57) {\n\t      break;\n\t    }\n\n\t    pos += 1;\n\t  }\n\n\t  code = value.charCodeAt(pos);\n\t  nextCode = value.charCodeAt(pos + 1);\n\n\t  if (code === dot && nextCode >= 48 && nextCode <= 57) {\n\t    pos += 2;\n\n\t    while (pos < length) {\n\t      code = value.charCodeAt(pos);\n\n\t      if (code < 48 || code > 57) {\n\t        break;\n\t      }\n\n\t      pos += 1;\n\t    }\n\t  }\n\n\t  code = value.charCodeAt(pos);\n\t  nextCode = value.charCodeAt(pos + 1);\n\t  nextNextCode = value.charCodeAt(pos + 2);\n\n\t  if (\n\t    (code === exp || code === EXP) &&\n\t    ((nextCode >= 48 && nextCode <= 57) ||\n\t      ((nextCode === plus || nextCode === minus) &&\n\t        nextNextCode >= 48 &&\n\t        nextNextCode <= 57))\n\t  ) {\n\t    pos += nextCode === plus || nextCode === minus ? 3 : 2;\n\n\t    while (pos < length) {\n\t      code = value.charCodeAt(pos);\n\n\t      if (code < 48 || code > 57) {\n\t        break;\n\t      }\n\n\t      pos += 1;\n\t    }\n\t  }\n\n\t  return {\n\t    number: value.slice(0, pos),\n\t    unit: value.slice(pos)\n\t  };\n\t};\n\treturn unit;\n}\n\nvar parse = parse$1;\nvar walk = walk$1;\nvar stringify = stringify_1;\n\nfunction ValueParser(value) {\n  if (this instanceof ValueParser) {\n    this.nodes = parse(value);\n    return this;\n  }\n  return new ValueParser(value);\n}\n\nValueParser.prototype.toString = function() {\n  return Array.isArray(this.nodes) ? stringify(this.nodes) : \"\";\n};\n\nValueParser.prototype.walk = function(cb, bubble) {\n  walk(this.nodes, cb, bubble);\n  return this;\n};\n\nValueParser.unit = requireUnit();\n\nValueParser.walk = walk;\n\nValueParser.stringify = stringify;\n\nvar lib = ValueParser;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdml0ZS9kaXN0L25vZGUvY2h1bmtzL2RlcC1JUVMtWmE3Ri5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdFO0FBQ1g7QUFDYzs7QUFFbkUsbUJBQW1CLHVEQUFtQixDQUFDLHVGQUFlO0FBQ3RELGtCQUFrQixrREFBYTtBQUMvQixnQkFBZ0IsMERBQW1CLENBQUMsdUZBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLElBQUk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qaW1pcHVsc2FyQGdpdGh1Yi5jb20vLi9ub2RlX21vZHVsZXMvdml0ZS9kaXN0L25vZGUvY2h1bmtzL2RlcC1JUVMtWmE3Ri5qcz9iOWUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZpbGVVUkxUb1BhdGggYXMgX19janNfZmlsZVVSTFRvUGF0aCB9IGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IGRpcm5hbWUgYXMgX19janNfZGlybmFtZSB9IGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIGFzIF9fY2pzX2NyZWF0ZVJlcXVpcmUgfSBmcm9tICdub2RlOm1vZHVsZSc7XG5cbmNvbnN0IF9fZmlsZW5hbWUgPSBfX2Nqc19maWxlVVJMVG9QYXRoKGltcG9ydC5tZXRhLnVybCk7XG5jb25zdCBfX2Rpcm5hbWUgPSBfX2Nqc19kaXJuYW1lKF9fZmlsZW5hbWUpO1xuY29uc3QgcmVxdWlyZSA9IF9fY2pzX2NyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcbmNvbnN0IF9fcmVxdWlyZSA9IHJlcXVpcmU7XG52YXIgb3BlblBhcmVudGhlc2VzID0gXCIoXCIuY2hhckNvZGVBdCgwKTtcbnZhciBjbG9zZVBhcmVudGhlc2VzID0gXCIpXCIuY2hhckNvZGVBdCgwKTtcbnZhciBzaW5nbGVRdW90ZSA9IFwiJ1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgZG91YmxlUXVvdGUgPSAnXCInLmNoYXJDb2RlQXQoMCk7XG52YXIgYmFja3NsYXNoID0gXCJcXFxcXCIuY2hhckNvZGVBdCgwKTtcbnZhciBzbGFzaCA9IFwiL1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgY29tbWEgPSBcIixcIi5jaGFyQ29kZUF0KDApO1xudmFyIGNvbG9uID0gXCI6XCIuY2hhckNvZGVBdCgwKTtcbnZhciBzdGFyID0gXCIqXCIuY2hhckNvZGVBdCgwKTtcbnZhciB1TG93ZXIgPSBcInVcIi5jaGFyQ29kZUF0KDApO1xudmFyIHVVcHBlciA9IFwiVVwiLmNoYXJDb2RlQXQoMCk7XG52YXIgcGx1cyA9IFwiK1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgaXNVbmljb2RlUmFuZ2UgPSAvXlthLWYwLTk/LV0rJC9pO1xuXG52YXIgcGFyc2UkMSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIHZhbHVlID0gaW5wdXQ7XG5cbiAgdmFyIG5leHQsXG4gICAgcXVvdGUsXG4gICAgcHJldixcbiAgICB0b2tlbixcbiAgICBlc2NhcGUsXG4gICAgZXNjYXBlUG9zLFxuICAgIHdoaXRlc3BhY2VQb3MsXG4gICAgcGFyZW50aGVzZXNPcGVuUG9zO1xuICB2YXIgcG9zID0gMDtcbiAgdmFyIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG4gIHZhciBtYXggPSB2YWx1ZS5sZW5ndGg7XG4gIHZhciBzdGFjayA9IFt7IG5vZGVzOiB0b2tlbnMgfV07XG4gIHZhciBiYWxhbmNlZCA9IDA7XG4gIHZhciBwYXJlbnQ7XG5cbiAgdmFyIG5hbWUgPSBcIlwiO1xuICB2YXIgYmVmb3JlID0gXCJcIjtcbiAgdmFyIGFmdGVyID0gXCJcIjtcblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgLy8gV2hpdGVzcGFjZXNcbiAgICBpZiAoY29kZSA8PSAzMikge1xuICAgICAgbmV4dCA9IHBvcztcbiAgICAgIGRvIHtcbiAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIH0gd2hpbGUgKGNvZGUgPD0gMzIpO1xuICAgICAgdG9rZW4gPSB2YWx1ZS5zbGljZShwb3MsIG5leHQpO1xuXG4gICAgICBwcmV2ID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChjb2RlID09PSBjbG9zZVBhcmVudGhlc2VzICYmIGJhbGFuY2VkKSB7XG4gICAgICAgIGFmdGVyID0gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKHByZXYgJiYgcHJldi50eXBlID09PSBcImRpdlwiKSB7XG4gICAgICAgIHByZXYuYWZ0ZXIgPSB0b2tlbjtcbiAgICAgICAgcHJldi5zb3VyY2VFbmRJbmRleCArPSB0b2tlbi5sZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBjb2RlID09PSBjb21tYSB8fFxuICAgICAgICBjb2RlID09PSBjb2xvbiB8fFxuICAgICAgICAoY29kZSA9PT0gc2xhc2ggJiZcbiAgICAgICAgICB2YWx1ZS5jaGFyQ29kZUF0KG5leHQgKyAxKSAhPT0gc3RhciAmJlxuICAgICAgICAgICghcGFyZW50IHx8XG4gICAgICAgICAgICAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSBcImZ1bmN0aW9uXCIgJiYgcGFyZW50LnZhbHVlICE9PSBcImNhbGNcIikpKVxuICAgICAgKSB7XG4gICAgICAgIGJlZm9yZSA9IHRva2VuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwic3BhY2VcIixcbiAgICAgICAgICBzb3VyY2VJbmRleDogcG9zLFxuICAgICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0LFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcG9zID0gbmV4dDtcblxuICAgICAgLy8gUXVvdGVzXG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBzaW5nbGVRdW90ZSB8fCBjb2RlID09PSBkb3VibGVRdW90ZSkge1xuICAgICAgbmV4dCA9IHBvcztcbiAgICAgIHF1b3RlID0gY29kZSA9PT0gc2luZ2xlUXVvdGUgPyBcIidcIiA6ICdcIic7XG4gICAgICB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgc291cmNlSW5kZXg6IHBvcyxcbiAgICAgICAgcXVvdGU6IHF1b3RlXG4gICAgICB9O1xuICAgICAgZG8ge1xuICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgbmV4dCA9IHZhbHVlLmluZGV4T2YocXVvdGUsIG5leHQgKyAxKTtcbiAgICAgICAgaWYgKH5uZXh0KSB7XG4gICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICB3aGlsZSAodmFsdWUuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gYmFja3NsYXNoKSB7XG4gICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgIGVzY2FwZSA9ICFlc2NhcGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlICs9IHF1b3RlO1xuICAgICAgICAgIG5leHQgPSB2YWx1ZS5sZW5ndGggLSAxO1xuICAgICAgICAgIHRva2VuLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoZXNjYXBlKTtcbiAgICAgIHRva2VuLnZhbHVlID0gdmFsdWUuc2xpY2UocG9zICsgMSwgbmV4dCk7XG4gICAgICB0b2tlbi5zb3VyY2VFbmRJbmRleCA9IHRva2VuLnVuY2xvc2VkID8gbmV4dCA6IG5leHQgKyAxO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgcG9zID0gbmV4dCArIDE7XG4gICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICAvLyBDb21tZW50c1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gc2xhc2ggJiYgdmFsdWUuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gc3Rhcikge1xuICAgICAgbmV4dCA9IHZhbHVlLmluZGV4T2YoXCIqL1wiLCBwb3MpO1xuXG4gICAgICB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogXCJjb21tZW50XCIsXG4gICAgICAgIHNvdXJjZUluZGV4OiBwb3MsXG4gICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0ICsgMlxuICAgICAgfTtcblxuICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgIHRva2VuLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgbmV4dCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgdG9rZW4uc291cmNlRW5kSW5kZXggPSBuZXh0O1xuICAgICAgfVxuXG4gICAgICB0b2tlbi52YWx1ZSA9IHZhbHVlLnNsaWNlKHBvcyArIDIsIG5leHQpO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuXG4gICAgICBwb3MgPSBuZXh0ICsgMjtcbiAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIC8vIE9wZXJhdGlvbiB3aXRoaW4gY2FsY1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAoY29kZSA9PT0gc2xhc2ggfHwgY29kZSA9PT0gc3RhcikgJiZcbiAgICAgIHBhcmVudCAmJlxuICAgICAgcGFyZW50LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgcGFyZW50LnZhbHVlID09PSBcImNhbGNcIlxuICAgICkge1xuICAgICAgdG9rZW4gPSB2YWx1ZVtwb3NdO1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiBcIndvcmRcIixcbiAgICAgICAgc291cmNlSW5kZXg6IHBvcyAtIGJlZm9yZS5sZW5ndGgsXG4gICAgICAgIHNvdXJjZUVuZEluZGV4OiBwb3MgKyB0b2tlbi5sZW5ndGgsXG4gICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgfSk7XG4gICAgICBwb3MgKz0gMTtcbiAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIC8vIERpdmlkZXJzXG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBzbGFzaCB8fCBjb2RlID09PSBjb21tYSB8fCBjb2RlID09PSBjb2xvbikge1xuICAgICAgdG9rZW4gPSB2YWx1ZVtwb3NdO1xuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiZGl2XCIsXG4gICAgICAgIHNvdXJjZUluZGV4OiBwb3MgLSBiZWZvcmUubGVuZ3RoLFxuICAgICAgICBzb3VyY2VFbmRJbmRleDogcG9zICsgdG9rZW4ubGVuZ3RoLFxuICAgICAgICB2YWx1ZTogdG9rZW4sXG4gICAgICAgIGJlZm9yZTogYmVmb3JlLFxuICAgICAgICBhZnRlcjogXCJcIlxuICAgICAgfSk7XG4gICAgICBiZWZvcmUgPSBcIlwiO1xuXG4gICAgICBwb3MgKz0gMTtcbiAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIC8vIE9wZW4gcGFyZW50aGVzZXNcbiAgICB9IGVsc2UgaWYgKG9wZW5QYXJlbnRoZXNlcyA9PT0gY29kZSkge1xuICAgICAgLy8gV2hpdGVzcGFjZXMgYWZ0ZXIgb3BlbiBwYXJlbnRoZXNlc1xuICAgICAgbmV4dCA9IHBvcztcbiAgICAgIGRvIHtcbiAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIH0gd2hpbGUgKGNvZGUgPD0gMzIpO1xuICAgICAgcGFyZW50aGVzZXNPcGVuUG9zID0gcG9zO1xuICAgICAgdG9rZW4gPSB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgc291cmNlSW5kZXg6IHBvcyAtIG5hbWUubGVuZ3RoLFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgYmVmb3JlOiB2YWx1ZS5zbGljZShwYXJlbnRoZXNlc09wZW5Qb3MgKyAxLCBuZXh0KVxuICAgICAgfTtcbiAgICAgIHBvcyA9IG5leHQ7XG5cbiAgICAgIGlmIChuYW1lID09PSBcInVybFwiICYmIGNvZGUgIT09IHNpbmdsZVF1b3RlICYmIGNvZGUgIT09IGRvdWJsZVF1b3RlKSB7XG4gICAgICAgIG5leHQgLT0gMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGVzY2FwZSA9IGZhbHNlO1xuICAgICAgICAgIG5leHQgPSB2YWx1ZS5pbmRleE9mKFwiKVwiLCBuZXh0ICsgMSk7XG4gICAgICAgICAgaWYgKH5uZXh0KSB7XG4gICAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0O1xuICAgICAgICAgICAgd2hpbGUgKHZhbHVlLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IGJhY2tzbGFzaCkge1xuICAgICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgICAgZXNjYXBlID0gIWVzY2FwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgKz0gXCIpXCI7XG4gICAgICAgICAgICBuZXh0ID0gdmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHRva2VuLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGVzY2FwZSk7XG4gICAgICAgIC8vIFdoaXRlc3BhY2VzIGJlZm9yZSBjbG9zZWRcbiAgICAgICAgd2hpdGVzcGFjZVBvcyA9IG5leHQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB3aGl0ZXNwYWNlUG9zIC09IDE7XG4gICAgICAgICAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQod2hpdGVzcGFjZVBvcyk7XG4gICAgICAgIH0gd2hpbGUgKGNvZGUgPD0gMzIpO1xuICAgICAgICBpZiAocGFyZW50aGVzZXNPcGVuUG9zIDwgd2hpdGVzcGFjZVBvcykge1xuICAgICAgICAgIGlmIChwb3MgIT09IHdoaXRlc3BhY2VQb3MgKyAxKSB7XG4gICAgICAgICAgICB0b2tlbi5ub2RlcyA9IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwid29yZFwiLFxuICAgICAgICAgICAgICAgIHNvdXJjZUluZGV4OiBwb3MsXG4gICAgICAgICAgICAgICAgc291cmNlRW5kSW5kZXg6IHdoaXRlc3BhY2VQb3MgKyAxLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zbGljZShwb3MsIHdoaXRlc3BhY2VQb3MgKyAxKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi5ub2RlcyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9rZW4udW5jbG9zZWQgJiYgd2hpdGVzcGFjZVBvcyArIDEgIT09IG5leHQpIHtcbiAgICAgICAgICAgIHRva2VuLmFmdGVyID0gXCJcIjtcbiAgICAgICAgICAgIHRva2VuLm5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcInNwYWNlXCIsXG4gICAgICAgICAgICAgIHNvdXJjZUluZGV4OiB3aGl0ZXNwYWNlUG9zICsgMSxcbiAgICAgICAgICAgICAgc291cmNlRW5kSW5kZXg6IG5leHQsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zbGljZSh3aGl0ZXNwYWNlUG9zICsgMSwgbmV4dClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi5hZnRlciA9IHZhbHVlLnNsaWNlKHdoaXRlc3BhY2VQb3MgKyAxLCBuZXh0KTtcbiAgICAgICAgICAgIHRva2VuLnNvdXJjZUVuZEluZGV4ID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW4uYWZ0ZXIgPSBcIlwiO1xuICAgICAgICAgIHRva2VuLm5vZGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gbmV4dCArIDE7XG4gICAgICAgIHRva2VuLnNvdXJjZUVuZEluZGV4ID0gdG9rZW4udW5jbG9zZWQgPyBuZXh0IDogcG9zO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYWxhbmNlZCArPSAxO1xuICAgICAgICB0b2tlbi5hZnRlciA9IFwiXCI7XG4gICAgICAgIHRva2VuLnNvdXJjZUVuZEluZGV4ID0gcG9zICsgMTtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICAgICAgdG9rZW5zID0gdG9rZW4ubm9kZXMgPSBbXTtcbiAgICAgICAgcGFyZW50ID0gdG9rZW47XG4gICAgICB9XG4gICAgICBuYW1lID0gXCJcIjtcblxuICAgICAgLy8gQ2xvc2UgcGFyZW50aGVzZXNcbiAgICB9IGVsc2UgaWYgKGNsb3NlUGFyZW50aGVzZXMgPT09IGNvZGUgJiYgYmFsYW5jZWQpIHtcbiAgICAgIHBvcyArPSAxO1xuICAgICAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgcGFyZW50LmFmdGVyID0gYWZ0ZXI7XG4gICAgICBwYXJlbnQuc291cmNlRW5kSW5kZXggKz0gYWZ0ZXIubGVuZ3RoO1xuICAgICAgYWZ0ZXIgPSBcIlwiO1xuICAgICAgYmFsYW5jZWQgLT0gMTtcbiAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnNvdXJjZUVuZEluZGV4ID0gcG9zO1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgICBwYXJlbnQgPSBzdGFja1tiYWxhbmNlZF07XG4gICAgICB0b2tlbnMgPSBwYXJlbnQubm9kZXM7XG5cbiAgICAgIC8vIFdvcmRzXG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQgPSBwb3M7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChjb2RlID09PSBiYWNrc2xhc2gpIHtcbiAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgIH0gd2hpbGUgKFxuICAgICAgICBuZXh0IDwgbWF4ICYmXG4gICAgICAgICEoXG4gICAgICAgICAgY29kZSA8PSAzMiB8fFxuICAgICAgICAgIGNvZGUgPT09IHNpbmdsZVF1b3RlIHx8XG4gICAgICAgICAgY29kZSA9PT0gZG91YmxlUXVvdGUgfHxcbiAgICAgICAgICBjb2RlID09PSBjb21tYSB8fFxuICAgICAgICAgIGNvZGUgPT09IGNvbG9uIHx8XG4gICAgICAgICAgY29kZSA9PT0gc2xhc2ggfHxcbiAgICAgICAgICBjb2RlID09PSBvcGVuUGFyZW50aGVzZXMgfHxcbiAgICAgICAgICAoY29kZSA9PT0gc3RhciAmJlxuICAgICAgICAgICAgcGFyZW50ICYmXG4gICAgICAgICAgICBwYXJlbnQudHlwZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICBwYXJlbnQudmFsdWUgPT09IFwiY2FsY1wiKSB8fFxuICAgICAgICAgIChjb2RlID09PSBzbGFzaCAmJlxuICAgICAgICAgICAgcGFyZW50LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgcGFyZW50LnZhbHVlID09PSBcImNhbGNcIikgfHxcbiAgICAgICAgICAoY29kZSA9PT0gY2xvc2VQYXJlbnRoZXNlcyAmJiBiYWxhbmNlZClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRva2VuID0gdmFsdWUuc2xpY2UocG9zLCBuZXh0KTtcblxuICAgICAgaWYgKG9wZW5QYXJlbnRoZXNlcyA9PT0gY29kZSkge1xuICAgICAgICBuYW1lID0gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAodUxvd2VyID09PSB0b2tlbi5jaGFyQ29kZUF0KDApIHx8IHVVcHBlciA9PT0gdG9rZW4uY2hhckNvZGVBdCgwKSkgJiZcbiAgICAgICAgcGx1cyA9PT0gdG9rZW4uY2hhckNvZGVBdCgxKSAmJlxuICAgICAgICBpc1VuaWNvZGVSYW5nZS50ZXN0KHRva2VuLnNsaWNlKDIpKVxuICAgICAgKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInVuaWNvZGUtcmFuZ2VcIixcbiAgICAgICAgICBzb3VyY2VJbmRleDogcG9zLFxuICAgICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0LFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcIndvcmRcIixcbiAgICAgICAgICBzb3VyY2VJbmRleDogcG9zLFxuICAgICAgICAgIHNvdXJjZUVuZEluZGV4OiBuZXh0LFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcG9zID0gbmV4dDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvczsgcG9zIC09IDEpIHtcbiAgICBzdGFja1twb3NdLnVuY2xvc2VkID0gdHJ1ZTtcbiAgICBzdGFja1twb3NdLnNvdXJjZUVuZEluZGV4ID0gdmFsdWUubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0YWNrWzBdLm5vZGVzO1xufTtcblxudmFyIHdhbGskMSA9IGZ1bmN0aW9uIHdhbGsobm9kZXMsIGNiLCBidWJibGUpIHtcbiAgdmFyIGksIG1heCwgbm9kZSwgcmVzdWx0O1xuXG4gIGZvciAoaSA9IDAsIG1heCA9IG5vZGVzLmxlbmd0aDsgaSA8IG1heDsgaSArPSAxKSB7XG4gICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICghYnViYmxlKSB7XG4gICAgICByZXN1bHQgPSBjYihub2RlLCBpLCBub2Rlcyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgcmVzdWx0ICE9PSBmYWxzZSAmJlxuICAgICAgbm9kZS50eXBlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkobm9kZS5ub2RlcylcbiAgICApIHtcbiAgICAgIHdhbGsobm9kZS5ub2RlcywgY2IsIGJ1YmJsZSk7XG4gICAgfVxuXG4gICAgaWYgKGJ1YmJsZSkge1xuICAgICAgY2Iobm9kZSwgaSwgbm9kZXMpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5Tm9kZShub2RlLCBjdXN0b20pIHtcbiAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XG4gIHZhciB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gIHZhciBidWY7XG4gIHZhciBjdXN0b21SZXN1bHQ7XG5cbiAgaWYgKGN1c3RvbSAmJiAoY3VzdG9tUmVzdWx0ID0gY3VzdG9tKG5vZGUpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGN1c3RvbVJlc3VsdDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcIndvcmRcIiB8fCB0eXBlID09PSBcInNwYWNlXCIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGJ1ZiA9IG5vZGUucXVvdGUgfHwgXCJcIjtcbiAgICByZXR1cm4gYnVmICsgdmFsdWUgKyAobm9kZS51bmNsb3NlZCA/IFwiXCIgOiBidWYpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgcmV0dXJuIFwiLypcIiArIHZhbHVlICsgKG5vZGUudW5jbG9zZWQgPyBcIlwiIDogXCIqL1wiKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcImRpdlwiKSB7XG4gICAgcmV0dXJuIChub2RlLmJlZm9yZSB8fCBcIlwiKSArIHZhbHVlICsgKG5vZGUuYWZ0ZXIgfHwgXCJcIik7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlLm5vZGVzKSkge1xuICAgIGJ1ZiA9IHN0cmluZ2lmeSQxKG5vZGUubm9kZXMsIGN1c3RvbSk7XG4gICAgaWYgKHR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIHZhbHVlICtcbiAgICAgIFwiKFwiICtcbiAgICAgIChub2RlLmJlZm9yZSB8fCBcIlwiKSArXG4gICAgICBidWYgK1xuICAgICAgKG5vZGUuYWZ0ZXIgfHwgXCJcIikgK1xuICAgICAgKG5vZGUudW5jbG9zZWQgPyBcIlwiIDogXCIpXCIpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeSQxKG5vZGVzLCBjdXN0b20pIHtcbiAgdmFyIHJlc3VsdCwgaTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAoaSA9IG5vZGVzLmxlbmd0aCAtIDE7IH5pOyBpIC09IDEpIHtcbiAgICAgIHJlc3VsdCA9IHN0cmluZ2lmeU5vZGUobm9kZXNbaV0sIGN1c3RvbSkgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ2lmeU5vZGUobm9kZXMsIGN1c3RvbSk7XG59XG5cbnZhciBzdHJpbmdpZnlfMSA9IHN0cmluZ2lmeSQxO1xuXG52YXIgdW5pdDtcbnZhciBoYXNSZXF1aXJlZFVuaXQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVVbml0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkVW5pdCkgcmV0dXJuIHVuaXQ7XG5cdGhhc1JlcXVpcmVkVW5pdCA9IDE7XG5cdHZhciBtaW51cyA9IFwiLVwiLmNoYXJDb2RlQXQoMCk7XG5cdHZhciBwbHVzID0gXCIrXCIuY2hhckNvZGVBdCgwKTtcblx0dmFyIGRvdCA9IFwiLlwiLmNoYXJDb2RlQXQoMCk7XG5cdHZhciBleHAgPSBcImVcIi5jaGFyQ29kZUF0KDApO1xuXHR2YXIgRVhQID0gXCJFXCIuY2hhckNvZGVBdCgwKTtcblxuXHQvLyBDaGVjayBpZiB0aHJlZSBjb2RlIHBvaW50cyB3b3VsZCBzdGFydCBhIG51bWJlclxuXHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXN5bnRheC0zLyNzdGFydHMtd2l0aC1hLW51bWJlclxuXHRmdW5jdGlvbiBsaWtlTnVtYmVyKHZhbHVlKSB7XG5cdCAgdmFyIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuXHQgIHZhciBuZXh0Q29kZTtcblxuXHQgIGlmIChjb2RlID09PSBwbHVzIHx8IGNvZGUgPT09IG1pbnVzKSB7XG5cdCAgICBuZXh0Q29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoMSk7XG5cblx0ICAgIGlmIChuZXh0Q29kZSA+PSA0OCAmJiBuZXh0Q29kZSA8PSA1Nykge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIG5leHROZXh0Q29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoMik7XG5cblx0ICAgIGlmIChuZXh0Q29kZSA9PT0gZG90ICYmIG5leHROZXh0Q29kZSA+PSA0OCAmJiBuZXh0TmV4dENvZGUgPD0gNTcpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICBpZiAoY29kZSA9PT0gZG90KSB7XG5cdCAgICBuZXh0Q29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoMSk7XG5cblx0ICAgIGlmIChuZXh0Q29kZSA+PSA0OCAmJiBuZXh0Q29kZSA8PSA1Nykge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIENvbnN1bWUgYSBudW1iZXJcblx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1zeW50YXgtMy8jY29uc3VtZS1udW1iZXJcblx0dW5pdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgdmFyIHBvcyA9IDA7XG5cdCAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0ICB2YXIgY29kZTtcblx0ICB2YXIgbmV4dENvZGU7XG5cdCAgdmFyIG5leHROZXh0Q29kZTtcblxuXHQgIGlmIChsZW5ndGggPT09IDAgfHwgIWxpa2VOdW1iZXIodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcblxuXHQgIGlmIChjb2RlID09PSBwbHVzIHx8IGNvZGUgPT09IG1pbnVzKSB7XG5cdCAgICBwb3MrKztcblx0ICB9XG5cblx0ICB3aGlsZSAocG9zIDwgbGVuZ3RoKSB7XG5cdCAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXG5cdCAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiA1Nykge1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblxuXHQgICAgcG9zICs9IDE7XG5cdCAgfVxuXG5cdCAgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zKTtcblx0ICBuZXh0Q29kZSA9IHZhbHVlLmNoYXJDb2RlQXQocG9zICsgMSk7XG5cblx0ICBpZiAoY29kZSA9PT0gZG90ICYmIG5leHRDb2RlID49IDQ4ICYmIG5leHRDb2RlIDw9IDU3KSB7XG5cdCAgICBwb3MgKz0gMjtcblxuXHQgICAgd2hpbGUgKHBvcyA8IGxlbmd0aCkge1xuXHQgICAgICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXG5cdCAgICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IDU3KSB7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblxuXHQgICAgICBwb3MgKz0gMTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MpO1xuXHQgIG5leHRDb2RlID0gdmFsdWUuY2hhckNvZGVBdChwb3MgKyAxKTtcblx0ICBuZXh0TmV4dENvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyArIDIpO1xuXG5cdCAgaWYgKFxuXHQgICAgKGNvZGUgPT09IGV4cCB8fCBjb2RlID09PSBFWFApICYmXG5cdCAgICAoKG5leHRDb2RlID49IDQ4ICYmIG5leHRDb2RlIDw9IDU3KSB8fFxuXHQgICAgICAoKG5leHRDb2RlID09PSBwbHVzIHx8IG5leHRDb2RlID09PSBtaW51cykgJiZcblx0ICAgICAgICBuZXh0TmV4dENvZGUgPj0gNDggJiZcblx0ICAgICAgICBuZXh0TmV4dENvZGUgPD0gNTcpKVxuXHQgICkge1xuXHQgICAgcG9zICs9IG5leHRDb2RlID09PSBwbHVzIHx8IG5leHRDb2RlID09PSBtaW51cyA/IDMgOiAyO1xuXG5cdCAgICB3aGlsZSAocG9zIDwgbGVuZ3RoKSB7XG5cdCAgICAgIGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KHBvcyk7XG5cblx0ICAgICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXG5cdCAgICAgIHBvcyArPSAxO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiB7XG5cdCAgICBudW1iZXI6IHZhbHVlLnNsaWNlKDAsIHBvcyksXG5cdCAgICB1bml0OiB2YWx1ZS5zbGljZShwb3MpXG5cdCAgfTtcblx0fTtcblx0cmV0dXJuIHVuaXQ7XG59XG5cbnZhciBwYXJzZSA9IHBhcnNlJDE7XG52YXIgd2FsayA9IHdhbGskMTtcbnZhciBzdHJpbmdpZnkgPSBzdHJpbmdpZnlfMTtcblxuZnVuY3Rpb24gVmFsdWVQYXJzZXIodmFsdWUpIHtcbiAgaWYgKHRoaXMgaW5zdGFuY2VvZiBWYWx1ZVBhcnNlcikge1xuICAgIHRoaXMubm9kZXMgPSBwYXJzZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIG5ldyBWYWx1ZVBhcnNlcih2YWx1ZSk7XG59XG5cblZhbHVlUGFyc2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLm5vZGVzKSA/IHN0cmluZ2lmeSh0aGlzLm5vZGVzKSA6IFwiXCI7XG59O1xuXG5WYWx1ZVBhcnNlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uKGNiLCBidWJibGUpIHtcbiAgd2Fsayh0aGlzLm5vZGVzLCBjYiwgYnViYmxlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5WYWx1ZVBhcnNlci51bml0ID0gcmVxdWlyZVVuaXQoKTtcblxuVmFsdWVQYXJzZXIud2FsayA9IHdhbGs7XG5cblZhbHVlUGFyc2VyLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcblxudmFyIGxpYiA9IFZhbHVlUGFyc2VyO1xuXG5leHBvcnQgeyBsaWIgYXMgbCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vite/dist/node/chunks/dep-IQS-Za7F.js\n");

/***/ })

}]);
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkjimipulsar_github_com"] = self["webpackChunkjimipulsar_github_com"] || []).push([["node_modules_rollup_dist_es_rollup_js"],{

/***/ "./node_modules/rollup/dist/es/rollup.js":
/*!***********************************************!*\
  !*** ./node_modules/rollup/dist/es/rollup.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VERSION: () => (/* reexport safe */ _shared_node_entry_js__WEBPACK_IMPORTED_MODULE_0__.version),\n/* harmony export */   defineConfig: () => (/* reexport safe */ _shared_node_entry_js__WEBPACK_IMPORTED_MODULE_0__.defineConfig),\n/* harmony export */   rollup: () => (/* reexport safe */ _shared_node_entry_js__WEBPACK_IMPORTED_MODULE_0__.rollup),\n/* harmony export */   watch: () => (/* reexport safe */ _shared_node_entry_js__WEBPACK_IMPORTED_MODULE_0__.watch)\n/* harmony export */ });\n/* harmony import */ var _shared_node_entry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared/node-entry.js */ \"./node_modules/rollup/dist/es/shared/node-entry.js\");\n/* harmony import */ var _shared_parseAst_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/parseAst.js */ \"./node_modules/rollup/dist/es/shared/parseAst.js\");\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../native.js */ \"./node_modules/rollup/dist/native.js\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:path */ \"node:path\");\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:process */ \"node:process\");\n/* harmony import */ var node_perf_hooks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! node:perf_hooks */ \"node:perf_hooks\");\n/* harmony import */ var node_fs_promises__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\");\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'tty'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/*\n  @license\n\tRollup.js v4.26.0\n\tWed, 13 Nov 2024 06:44:29 GMT - commit ae1d14b7855ff6568a6697d37271a5eb4d8e2d3e\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcm9sbHVwL2Rpc3QvZXMvcm9sbHVwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ3lGO0FBQzNEO0FBQ1I7QUFDSDtBQUNMO0FBQ1E7QUFDRztBQUNDO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qaW1pcHVsc2FyQGdpdGh1Yi5jb20vLi9ub2RlX21vZHVsZXMvcm9sbHVwL2Rpc3QvZXMvcm9sbHVwLmpzP2RiNTciXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgQGxpY2Vuc2Vcblx0Um9sbHVwLmpzIHY0LjI2LjBcblx0V2VkLCAxMyBOb3YgMjAyNCAwNjo0NDoyOSBHTVQgLSBjb21taXQgYWUxZDE0Yjc4NTVmZjY1NjhhNjY5N2QzNzI3MWE1ZWI0ZDhlMmQzZVxuXG5cdGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwXG5cblx0UmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuKi9cbmV4cG9ydCB7IHZlcnNpb24gYXMgVkVSU0lPTiwgZGVmaW5lQ29uZmlnLCByb2xsdXAsIHdhdGNoIH0gZnJvbSAnLi9zaGFyZWQvbm9kZS1lbnRyeS5qcyc7XG5pbXBvcnQgJy4vc2hhcmVkL3BhcnNlQXN0LmpzJztcbmltcG9ydCAnLi4vbmF0aXZlLmpzJztcbmltcG9ydCAnbm9kZTpwYXRoJztcbmltcG9ydCAncGF0aCc7XG5pbXBvcnQgJ25vZGU6cHJvY2Vzcyc7XG5pbXBvcnQgJ25vZGU6cGVyZl9ob29rcyc7XG5pbXBvcnQgJ25vZGU6ZnMvcHJvbWlzZXMnO1xuaW1wb3J0ICd0dHknO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/rollup/dist/es/rollup.js\n");

/***/ }),

/***/ "./node_modules/rollup/dist/es/shared/node-entry.js":
/*!**********************************************************!*\
  !*** ./node_modules/rollup/dist/es/shared/node-entry.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createFilter: () => (/* binding */ createFilter),\n/* harmony export */   defineConfig: () => (/* binding */ defineConfig),\n/* harmony export */   fseventsImporter: () => (/* binding */ fseventsImporter),\n/* harmony export */   getAugmentedNamespace: () => (/* binding */ getAugmentedNamespace),\n/* harmony export */   getDefaultExportFromCjs: () => (/* binding */ getDefaultExportFromCjs),\n/* harmony export */   rollup: () => (/* binding */ rollup),\n/* harmony export */   rollupInternal: () => (/* binding */ rollupInternal),\n/* harmony export */   version: () => (/* binding */ version),\n/* harmony export */   watch: () => (/* binding */ watch)\n/* harmony export */ });\n/* harmony import */ var _parseAst_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parseAst.js */ \"./node_modules/rollup/dist/es/shared/parseAst.js\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ \"node:path\");\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../native.js */ \"./node_modules/rollup/dist/native.js\");\n/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:process */ \"node:process\");\n/* harmony import */ var node_perf_hooks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:perf_hooks */ \"node:perf_hooks\");\n/* harmony import */ var node_fs_promises__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\");\nObject(function webpackMissingModule() { var e = new Error(\"Cannot find module 'tty'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ \"./node_modules/process/browser.js\");\n/*\n  @license\n\tRollup.js v4.26.0\n\tWed, 13 Nov 2024 06:44:29 GMT - commit ae1d14b7855ff6568a6697d37271a5eb4d8e2d3e\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\n\n\n\n\n\n\n\n\n\nvar version = \"4.26.0\";\n\nconst comma = ','.charCodeAt(0);\nconst semicolon = ';'.charCodeAt(0);\nconst chars$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\nfor (let i = 0; i < chars$1.length; i++) {\n    const c = chars$1.charCodeAt(i);\n    intToChar[i] = c;\n    charToInt[c] = i;\n}\nfunction decodeInteger(reader, relative) {\n    let value = 0;\n    let shift = 0;\n    let integer = 0;\n    do {\n        const c = reader.next();\n        integer = charToInt[c];\n        value |= (integer & 31) << shift;\n        shift += 5;\n    } while (integer & 32);\n    const shouldNegate = value & 1;\n    value >>>= 1;\n    if (shouldNegate) {\n        value = -0x80000000 | -value;\n    }\n    return relative + value;\n}\nfunction encodeInteger(builder, num, relative) {\n    let delta = num - relative;\n    delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;\n    do {\n        let clamped = delta & 0b011111;\n        delta >>>= 5;\n        if (delta > 0)\n            clamped |= 0b100000;\n        builder.write(intToChar[clamped]);\n    } while (delta > 0);\n    return num;\n}\nfunction hasMoreVlq(reader, max) {\n    if (reader.pos >= max)\n        return false;\n    return reader.peek() !== comma;\n}\n\nconst bufLength = 1024 * 16;\n// Provide a fallback for older environments.\nconst td = typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n        ? {\n            decode(buf) {\n                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                return out.toString();\n            },\n        }\n        : {\n            decode(buf) {\n                let out = '';\n                for (let i = 0; i < buf.length; i++) {\n                    out += String.fromCharCode(buf[i]);\n                }\n                return out;\n            },\n        };\nclass StringWriter {\n    constructor() {\n        this.pos = 0;\n        this.out = '';\n        this.buffer = new Uint8Array(bufLength);\n    }\n    write(v) {\n        const { buffer } = this;\n        buffer[this.pos++] = v;\n        if (this.pos === bufLength) {\n            this.out += td.decode(buffer);\n            this.pos = 0;\n        }\n    }\n    flush() {\n        const { buffer, out, pos } = this;\n        return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n    }\n}\nclass StringReader {\n    constructor(buffer) {\n        this.pos = 0;\n        this.buffer = buffer;\n    }\n    next() {\n        return this.buffer.charCodeAt(this.pos++);\n    }\n    peek() {\n        return this.buffer.charCodeAt(this.pos);\n    }\n    indexOf(char) {\n        const { buffer, pos } = this;\n        const idx = buffer.indexOf(char, pos);\n        return idx === -1 ? buffer.length : idx;\n    }\n}\n\nfunction decode(mappings) {\n    const { length } = mappings;\n    const reader = new StringReader(mappings);\n    const decoded = [];\n    let genColumn = 0;\n    let sourcesIndex = 0;\n    let sourceLine = 0;\n    let sourceColumn = 0;\n    let namesIndex = 0;\n    do {\n        const semi = reader.indexOf(';');\n        const line = [];\n        let sorted = true;\n        let lastCol = 0;\n        genColumn = 0;\n        while (reader.pos < semi) {\n            let seg;\n            genColumn = decodeInteger(reader, genColumn);\n            if (genColumn < lastCol)\n                sorted = false;\n            lastCol = genColumn;\n            if (hasMoreVlq(reader, semi)) {\n                sourcesIndex = decodeInteger(reader, sourcesIndex);\n                sourceLine = decodeInteger(reader, sourceLine);\n                sourceColumn = decodeInteger(reader, sourceColumn);\n                if (hasMoreVlq(reader, semi)) {\n                    namesIndex = decodeInteger(reader, namesIndex);\n                    seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n                }\n                else {\n                    seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n                }\n            }\n            else {\n                seg = [genColumn];\n            }\n            line.push(seg);\n            reader.pos++;\n        }\n        if (!sorted)\n            sort(line);\n        decoded.push(line);\n        reader.pos = semi + 1;\n    } while (reader.pos <= length);\n    return decoded;\n}\nfunction sort(line) {\n    line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[0] - b[0];\n}\nfunction encode(decoded) {\n    const writer = new StringWriter();\n    let sourcesIndex = 0;\n    let sourceLine = 0;\n    let sourceColumn = 0;\n    let namesIndex = 0;\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        if (i > 0)\n            writer.write(semicolon);\n        if (line.length === 0)\n            continue;\n        let genColumn = 0;\n        for (let j = 0; j < line.length; j++) {\n            const segment = line[j];\n            if (j > 0)\n                writer.write(comma);\n            genColumn = encodeInteger(writer, segment[0], genColumn);\n            if (segment.length === 1)\n                continue;\n            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n            sourceLine = encodeInteger(writer, segment[2], sourceLine);\n            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n            if (segment.length === 4)\n                continue;\n            namesIndex = encodeInteger(writer, segment[4], namesIndex);\n        }\n    }\n    return writer.flush();\n}\n\nclass BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n\nlet Chunk$1 = class Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t{\n\t\t\tthis.previous = null;\n\t\t\tthis.next = null;\n\t\t}\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\treset() {\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\t\tif (this.edited) {\n\t\t\tthis.content = this.original;\n\t\t\tthis.storeName = false;\n\t\t\tthis.edited = false;\n\t\t}\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// after split we should save the edit content record into the correct chunk\n\t\t\t// to make sure sourcemap correct\n\t\t\t// For example:\n\t\t\t// '  test'.trim()\n\t\t\t//     split   -> '  ' + 'test'\n\t\t\t//   ✔️ edit    -> '' + 'test'\n\t\t\t//   ✖️ edit    -> 'test' + '' \n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tthis.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tconst newChunk = this.split(this.end - trimmed.length);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tnewChunk.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n};\n\nfunction getBtoa() {\n\tif (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {\n\t\treturn (str) => globalThis.btoa(unescape(encodeURIComponent(str)));\n\t} else if (typeof Buffer === 'function') {\n\t\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\n\t} else {\n\t\treturn () => {\n\t\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t\t};\n\t}\n}\n\nconst btoa = /*#__PURE__*/ getBtoa();\n\nclass SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t\tif (typeof properties.x_google_ignoreList !== 'undefined') {\n\t\t\tthis.x_google_ignoreList = properties.x_google_ignoreList;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n\nfunction guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n\nconst toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n\nconst wordRegex = /\\w/;\n\nclass Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst contentLengthMinusOne = content.length - 1;\n\t\t\tlet contentLineEnd = content.indexOf('\\n', 0);\n\t\t\tlet previousContentLineEnd = -1;\n\t\t\t// Loop through each line in the content and add a segment, but stop if the last line is empty,\n\t\t\t// else code afterwards would fill one line too many\n\t\t\twhile (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {\n\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\t\tif (nameIndex >= 0) {\n\t\t\t\t\tsegment.push(nameIndex);\n\t\t\t\t}\n\t\t\t\tthis.rawSegments.push(segment);\n\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\n\t\t\t\tpreviousContentLineEnd = contentLineEnd;\n\t\t\t\tcontentLineEnd = content.indexOf('\\n', contentLineEnd + 1);\n\t\t\t}\n\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\n\t\t\tthis.advance(content.slice(previousContentLineEnd + 1));\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t\tthis.advance(content);\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\t\t// when iterating each char, check if it's in a word boundary\n\t\tlet charInHiresBoundary = false;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\n\t\t\t\t\tif (this.hires === 'boundary') {\n\t\t\t\t\t\t// in hires \"boundary\", group segments per word boundary than per char\n\t\t\t\t\t\tif (wordRegex.test(original[originalCharIndex])) {\n\t\t\t\t\t\t\t// for first char in the boundary found, start the boundary by pushing a segment\n\t\t\t\t\t\t\tif (!charInHiresBoundary) {\n\t\t\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\t\t\tcharInHiresBoundary = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// for non-word char, end the boundary by pushing a segment\n\t\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\t\tcharInHiresBoundary = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nclass MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk$1(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: undefined },\n\t\t\tignoreList: { writable: true, value: options.ignoreList },\n\t\t});\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: [\n\t\t\t\toptions.source ? getRelativePath(options.file || '', options.source) : options.file || '',\n\t\t\t],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : undefined,\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\t_ensureindentStr() {\n\t\tif (this.indentStr === undefined) {\n\t\t\tthis.indentStr = guessIndent(this.original);\n\t\t}\n\t}\n\n\t_getRawIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr;\n\t}\n\n\tgetIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tif (indentStr === undefined) {\n\t\t\tthis._ensureindentStr();\n\t\t\tindentStr = this.indentStr || '\\t';\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\toptions = options || {};\n\t\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n\t}\n\n\tupdate(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead',\n\t\t\t);\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst overwrite = options !== undefined ? options.overwrite : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: true,\n\t\t\t\tenumerable: true,\n\t\t\t});\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, !overwrite);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk$1(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\treset(start, end) {\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.reset();\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`,\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n\n\thasChanged() {\n\t\treturn this.original !== this.toString();\n\t}\n\n\t_replaceRegexp(searchValue, replacement) {\n\t\tfunction getReplacement(match, str) {\n\t\t\tif (typeof replacement === 'string') {\n\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\tconst num = +i;\n\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\treturn `$${i}`;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t}\n\t\t}\n\t\tfunction matchAll(re, str) {\n\t\t\tlet match;\n\t\t\tconst matches = [];\n\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\t\tif (searchValue.global) {\n\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\tmatches.forEach((match) => {\n\t\t\t\tif (match.index != null) {\n\t\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\t\tthis.overwrite(\n\t\t\t\t\t\t\tmatch.index,\n\t\t\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\t\t\treplacement\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tconst match = this.original.match(searchValue);\n\t\t\tif (match && match.index != null) {\n\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\tthis.overwrite(\n\t\t\t\t\t\tmatch.index,\n\t\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\t\treplacement\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t_replaceString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst index = original.indexOf(string);\n\n\t\tif (index !== -1) {\n\t\t\tthis.overwrite(index, index + string.length, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplace(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceString(searchValue, replacement);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n\n\t_replaceAllString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst stringLength = string.length;\n\t\tfor (\n\t\t\tlet index = original.indexOf(string);\n\t\t\tindex !== -1;\n\t\t\tindex = original.indexOf(string, index + stringLength)\n\t\t) {\n\t\t\tconst previous = original.slice(index, index + stringLength);\n\t\t\tif (previous !== replacement)\n\t\t\t\tthis.overwrite(index, index + stringLength, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplaceAll(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceAllString(searchValue, replacement);\n\t\t}\n\n\t\tif (!searchValue.global) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'MagicString.prototype.replaceAll called with a non-global RegExp argument',\n\t\t\t);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n}\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nlet Bundle$1 = class Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`',\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'ignoreList', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tlet x_google_ignoreList = undefined;\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\n\t\t\tif (source.ignoreList && sourceIndex !== -1) {\n\t\t\t\tif (x_google_ignoreList === undefined) {\n\t\t\t\t\tx_google_ignoreList = [];\n\t\t\t\t}\n\t\t\t\tx_google_ignoreList.push(sourceIndex);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content._getRawIndentString();\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length,\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n};\n\nfunction treeshakeNode(node, code, start, end) {\n    code.remove(start, end);\n    node.removeAnnotations(code);\n}\n\nconst NO_SEMICOLON = { isNoStatement: true };\n// This assumes there are only white-space and comments between start and the string we are looking for\nfunction findFirstOccurrenceOutsideComment(code, searchString, start = 0) {\n    let searchPos, charCodeAfterSlash;\n    searchPos = code.indexOf(searchString, start);\n    while (true) {\n        start = code.indexOf('/', start);\n        if (start === -1 || start >= searchPos)\n            return searchPos;\n        charCodeAfterSlash = code.charCodeAt(++start);\n        ++start;\n        // With our assumption, '/' always starts a comment. Determine comment type:\n        start =\n            charCodeAfterSlash === 47 /*\"/\"*/\n                ? code.indexOf('\\n', start) + 1\n                : code.indexOf('*/', start) + 2;\n        if (start > searchPos) {\n            searchPos = code.indexOf(searchString, start);\n        }\n    }\n}\nconst NON_WHITESPACE = /\\S/g;\nfunction findNonWhiteSpace(code, index) {\n    NON_WHITESPACE.lastIndex = index;\n    const result = NON_WHITESPACE.exec(code);\n    return result.index;\n}\nconst WHITESPACE = /\\s/;\nfunction findLastWhiteSpaceReverse(code, start, end) {\n    while (true) {\n        if (start >= end) {\n            return end;\n        }\n        if (WHITESPACE.test(code[end - 1])) {\n            end--;\n        }\n        else {\n            return end;\n        }\n    }\n}\n// This assumes \"code\" only contains white-space and comments\n// Returns position of line-comment if applicable\nfunction findFirstLineBreakOutsideComment(code) {\n    let lineBreakPos, charCodeAfterSlash, start = 0;\n    lineBreakPos = code.indexOf('\\n', start);\n    while (true) {\n        start = code.indexOf('/', start);\n        if (start === -1 || start > lineBreakPos)\n            return [lineBreakPos, lineBreakPos + 1];\n        // With our assumption, '/' always starts a comment. Determine comment type:\n        charCodeAfterSlash = code.charCodeAt(start + 1);\n        if (charCodeAfterSlash === 47 /*\"/\"*/)\n            return [start, lineBreakPos + 1];\n        start = code.indexOf('*/', start + 2) + 2;\n        if (start > lineBreakPos) {\n            lineBreakPos = code.indexOf('\\n', start);\n        }\n    }\n}\nfunction renderStatementList(statements, code, start, end, options) {\n    let currentNode, currentNodeStart, currentNodeNeedsBoundaries, nextNodeStart;\n    let nextNode = statements[0];\n    let nextNodeNeedsBoundaries = !nextNode.included || nextNode.needsBoundaries;\n    if (nextNodeNeedsBoundaries) {\n        nextNodeStart =\n            start + findFirstLineBreakOutsideComment(code.original.slice(start, nextNode.start))[1];\n    }\n    for (let nextIndex = 1; nextIndex <= statements.length; nextIndex++) {\n        currentNode = nextNode;\n        currentNodeStart = nextNodeStart;\n        currentNodeNeedsBoundaries = nextNodeNeedsBoundaries;\n        nextNode = statements[nextIndex];\n        nextNodeNeedsBoundaries =\n            nextNode === undefined ? false : !nextNode.included || nextNode.needsBoundaries;\n        if (currentNodeNeedsBoundaries || nextNodeNeedsBoundaries) {\n            nextNodeStart =\n                currentNode.end +\n                    findFirstLineBreakOutsideComment(code.original.slice(currentNode.end, nextNode === undefined ? end : nextNode.start))[1];\n            if (currentNode.included) {\n                if (currentNodeNeedsBoundaries) {\n                    currentNode.render(code, options, {\n                        end: nextNodeStart,\n                        start: currentNodeStart\n                    });\n                }\n                else {\n                    currentNode.render(code, options);\n                }\n            }\n            else {\n                treeshakeNode(currentNode, code, currentNodeStart, nextNodeStart);\n            }\n        }\n        else {\n            currentNode.render(code, options);\n        }\n    }\n}\n// This assumes that the first character is not part of the first node\nfunction getCommaSeparatedNodesWithBoundaries(nodes, code, start, end) {\n    const splitUpNodes = [];\n    let node, nextNodeStart, contentEnd, char;\n    let separator = start - 1;\n    for (const nextNode of nodes) {\n        if (node !== undefined) {\n            separator =\n                node.end +\n                    findFirstOccurrenceOutsideComment(code.original.slice(node.end, nextNode.start), ',');\n        }\n        nextNodeStart = contentEnd =\n            separator +\n                1 +\n                findFirstLineBreakOutsideComment(code.original.slice(separator + 1, nextNode.start))[1];\n        while (((char = code.original.charCodeAt(nextNodeStart)),\n            char === 32 /*\" \"*/ || char === 9 /*\"\\t\"*/ || char === 10 /*\"\\n\"*/ || char === 13) /*\"\\r\"*/)\n            nextNodeStart++;\n        if (node !== undefined) {\n            splitUpNodes.push({\n                contentEnd,\n                end: nextNodeStart,\n                node,\n                separator,\n                start\n            });\n        }\n        node = nextNode;\n        start = nextNodeStart;\n    }\n    splitUpNodes.push({\n        contentEnd: end,\n        end,\n        node: node,\n        separator: null,\n        start\n    });\n    return splitUpNodes;\n}\n// This assumes there are only white-space and comments between start and end\nfunction removeLineBreaks(code, start, end) {\n    while (true) {\n        const [removeStart, removeEnd] = findFirstLineBreakOutsideComment(code.original.slice(start, end));\n        if (removeStart === -1) {\n            break;\n        }\n        code.remove(start + removeStart, (start += removeEnd));\n    }\n}\n\nfunction getSystemExportStatement(exportedVariables, { exportNamesByVariable, snippets: { _, getObject, getPropertyAccess } }, modifier = '') {\n    if (exportedVariables.length === 1 &&\n        exportNamesByVariable.get(exportedVariables[0]).length === 1) {\n        const variable = exportedVariables[0];\n        return `exports(${JSON.stringify(exportNamesByVariable.get(variable)[0])},${_}${variable.getName(getPropertyAccess)}${modifier})`;\n    }\n    else {\n        const fields = [];\n        for (const variable of exportedVariables) {\n            for (const exportName of exportNamesByVariable.get(variable)) {\n                fields.push([exportName, variable.getName(getPropertyAccess) + modifier]);\n            }\n        }\n        return `exports(${getObject(fields, { lineBreakIndent: null })})`;\n    }\n}\n// This is only invoked if there is exactly one export name\nfunction renderSystemExportExpression(exportedVariable, expressionStart, expressionEnd, code, { exportNamesByVariable, snippets: { _ } }) {\n    code.prependRight(expressionStart, `exports(${JSON.stringify(exportNamesByVariable.get(exportedVariable)[0])},${_}`);\n    code.appendLeft(expressionEnd, ')');\n}\nfunction renderSystemExportFunction(exportedVariables, expressionStart, expressionEnd, needsParens, code, options) {\n    const { _, getDirectReturnIifeLeft } = options.snippets;\n    code.prependRight(expressionStart, getDirectReturnIifeLeft(['v'], `${getSystemExportStatement(exportedVariables, options)},${_}v`, { needsArrowReturnParens: true, needsWrappedFunction: needsParens }));\n    code.appendLeft(expressionEnd, ')');\n}\nfunction renderSystemExportSequenceAfterExpression(exportedVariable, expressionStart, expressionEnd, needsParens, code, options) {\n    const { _, getPropertyAccess } = options.snippets;\n    code.appendLeft(expressionEnd, `,${_}${getSystemExportStatement([exportedVariable], options)},${_}${exportedVariable.getName(getPropertyAccess)}`);\n    if (needsParens) {\n        code.prependRight(expressionStart, '(');\n        code.appendLeft(expressionEnd, ')');\n    }\n}\nfunction renderSystemExportSequenceBeforeExpression(exportedVariable, expressionStart, expressionEnd, needsParens, code, options, modifier) {\n    const { _ } = options.snippets;\n    code.prependRight(expressionStart, `${getSystemExportStatement([exportedVariable], options, modifier)},${_}`);\n    if (needsParens) {\n        code.prependRight(expressionStart, '(');\n        code.appendLeft(expressionEnd, ')');\n    }\n}\n\n/** @typedef { import('estree').Node} Node */\n/** @typedef {Node | {\n *   type: 'PropertyDefinition';\n *   computed: boolean;\n *   value: Node\n * }} NodeWithPropertyDefinition */\n\n/**\n *\n * @param {NodeWithPropertyDefinition} node\n * @param {NodeWithPropertyDefinition} parent\n * @returns {boolean}\n */\nfunction is_reference (node, parent) {\n\tif (node.type === 'MemberExpression') {\n\t\treturn !node.computed && is_reference(node.object, node);\n\t}\n\n\tif (node.type === 'Identifier') {\n\t\tif (!parent) return true;\n\n\t\tswitch (parent.type) {\n\t\t\t// disregard `bar` in `foo.bar`\n\t\t\tcase 'MemberExpression': return parent.computed || node === parent.object;\n\n\t\t\t// disregard the `foo` in `class {foo(){}}` but keep it in `class {[foo](){}}`\n\t\t\tcase 'MethodDefinition': return parent.computed;\n\n\t\t\t// disregard the `foo` in `class {foo=bar}` but keep it in `class {[foo]=bar}` and `class {bar=foo}`\n\t\t\tcase 'PropertyDefinition': return parent.computed || node === parent.value;\n\n\t\t\t// disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`\n\t\t\tcase 'Property': return parent.computed || node === parent.value;\n\n\t\t\t// disregard the `bar` in `export { foo as bar }` or\n\t\t\t// the foo in `import { foo as bar }`\n\t\t\tcase 'ExportSpecifier':\n\t\t\tcase 'ImportSpecifier': return node === parent.local;\n\n\t\t\t// disregard the `foo` in `foo: while (...) { ... break foo; ... continue foo;}`\n\t\t\tcase 'LabeledStatement':\n\t\t\tcase 'BreakStatement':\n\t\t\tcase 'ContinueStatement': return false;\n\t\t\tdefault: return true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nconst PureFunctionKey = Symbol('PureFunction');\nconst getPureFunctions = ({ treeshake }) => {\n    const pureFunctions = Object.create(null);\n    for (const functionName of treeshake ? treeshake.manualPureFunctions : []) {\n        let currentFunctions = pureFunctions;\n        for (const pathSegment of functionName.split('.')) {\n            currentFunctions = currentFunctions[pathSegment] ||= Object.create(null);\n        }\n        currentFunctions[PureFunctionKey] = true;\n    }\n    return pureFunctions;\n};\n\nfunction getOrCreate(map, key, init) {\n    const existing = map.get(key);\n    if (existing !== undefined) {\n        return existing;\n    }\n    const value = init();\n    map.set(key, value);\n    return value;\n}\nfunction getNewSet() {\n    return new Set();\n}\nfunction getNewArray() {\n    return [];\n}\n\nconst UnknownKey = Symbol('Unknown Key');\nconst UnknownNonAccessorKey = Symbol('Unknown Non-Accessor Key');\nconst UnknownInteger = Symbol('Unknown Integer');\nconst SymbolToStringTag = Symbol('Symbol.toStringTag');\nconst EMPTY_PATH = [];\nconst UNKNOWN_PATH = [UnknownKey];\n// For deoptimizations, this means we are modifying an unknown property but did\n// not lose track of the object or are creating a setter/getter;\n// For assignment effects it means we do not check for setter/getter effects\n// but only if something is mutated that is included, which is relevant for\n// Object.defineProperty\nconst UNKNOWN_NON_ACCESSOR_PATH = [UnknownNonAccessorKey];\nconst UNKNOWN_INTEGER_PATH = [UnknownInteger];\nconst EntitiesKey = Symbol('Entities');\nclass PathTracker {\n    constructor() {\n        this.entityPaths = Object.create(null, {\n            [EntitiesKey]: { value: new Set() }\n        });\n    }\n    trackEntityAtPathAndGetIfTracked(path, entity) {\n        const trackedEntities = this.getEntities(path);\n        if (trackedEntities.has(entity))\n            return true;\n        trackedEntities.add(entity);\n        return false;\n    }\n    withTrackedEntityAtPath(path, entity, onUntracked, returnIfTracked) {\n        const trackedEntities = this.getEntities(path);\n        if (trackedEntities.has(entity))\n            return returnIfTracked;\n        trackedEntities.add(entity);\n        const result = onUntracked();\n        trackedEntities.delete(entity);\n        return result;\n    }\n    getEntities(path) {\n        let currentPaths = this.entityPaths;\n        for (const pathSegment of path) {\n            currentPaths = currentPaths[pathSegment] =\n                currentPaths[pathSegment] ||\n                    Object.create(null, { [EntitiesKey]: { value: new Set() } });\n        }\n        return currentPaths[EntitiesKey];\n    }\n}\nconst SHARED_RECURSION_TRACKER = new PathTracker();\nclass DiscriminatedPathTracker {\n    constructor() {\n        this.entityPaths = Object.create(null, {\n            [EntitiesKey]: { value: new Map() }\n        });\n    }\n    trackEntityAtPathAndGetIfTracked(path, discriminator, entity) {\n        let currentPaths = this.entityPaths;\n        for (const pathSegment of path) {\n            currentPaths = currentPaths[pathSegment] =\n                currentPaths[pathSegment] ||\n                    Object.create(null, { [EntitiesKey]: { value: new Map() } });\n        }\n        const trackedEntities = getOrCreate(currentPaths[EntitiesKey], discriminator, (getNewSet));\n        if (trackedEntities.has(entity))\n            return true;\n        trackedEntities.add(entity);\n        return false;\n    }\n}\n\nfunction isFlagSet(flags, flag) {\n    return (flags & flag) !== 0;\n}\nfunction setFlag(flags, flag, value) {\n    return (flags & ~flag) | (-value & flag);\n}\n\nconst UnknownValue = Symbol('Unknown Value');\nconst UnknownTruthyValue = Symbol('Unknown Truthy Value');\nclass ExpressionEntity {\n    constructor() {\n        this.flags = 0;\n    }\n    get included() {\n        return isFlagSet(this.flags, 1 /* Flag.included */);\n    }\n    set included(value) {\n        this.flags = setFlag(this.flags, 1 /* Flag.included */, value);\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, _path, _recursionTracker) {\n        deoptimizeInteraction(interaction);\n    }\n    deoptimizePath(_path) { }\n    /**\n     * If possible it returns a stringifyable literal value for this node that\n     * can be used for inlining or comparing values. Otherwise, it should return\n     * UnknownValue.\n     */\n    getLiteralValueAtPath(_path, _recursionTracker, _origin) {\n        return UnknownValue;\n    }\n    getReturnExpressionWhenCalledAtPath(_path, _interaction, _recursionTracker, _origin) {\n        return UNKNOWN_RETURN_EXPRESSION;\n    }\n    hasEffectsOnInteractionAtPath(_path, _interaction, _context) {\n        return true;\n    }\n    include(_context, _includeChildrenRecursively, _options) {\n        this.included = true;\n    }\n    includeCallArguments(context, parameters) {\n        for (const argument of parameters) {\n            argument.include(context, false);\n        }\n    }\n    shouldBeIncluded(_context) {\n        return true;\n    }\n}\nconst UNKNOWN_EXPRESSION = new (class UnknownExpression extends ExpressionEntity {\n})();\nconst UNKNOWN_RETURN_EXPRESSION = [\n    UNKNOWN_EXPRESSION,\n    false\n];\nconst deoptimizeInteraction = (interaction) => {\n    for (const argument of interaction.args) {\n        argument?.deoptimizePath(UNKNOWN_PATH);\n    }\n};\n\nconst INTERACTION_ACCESSED = 0;\nconst INTERACTION_ASSIGNED = 1;\nconst INTERACTION_CALLED = 2;\nconst NODE_INTERACTION_UNKNOWN_ACCESS = {\n    args: [null],\n    type: INTERACTION_ACCESSED\n};\nconst NODE_INTERACTION_UNKNOWN_ASSIGNMENT = {\n    args: [null, UNKNOWN_EXPRESSION],\n    type: INTERACTION_ASSIGNED\n};\n// While this is technically a call without arguments, we can compare against\n// this reference in places where precise values or this argument would make a\n// difference\nconst NODE_INTERACTION_UNKNOWN_CALL = {\n    args: [null],\n    type: INTERACTION_CALLED,\n    withNew: false\n};\n\nclass Variable extends ExpressionEntity {\n    markReassigned() {\n        this.isReassigned = true;\n    }\n    constructor(name) {\n        super();\n        this.name = name;\n        this.alwaysRendered = false;\n        this.forbiddenNames = null;\n        this.globalName = null;\n        this.initReached = false;\n        this.isId = false;\n        this.kind = null;\n        this.renderBaseName = null;\n        this.renderName = null;\n        this.isReassigned = false;\n        this.onlyFunctionCallUsed = true;\n    }\n    /**\n     * Binds identifiers that reference this variable to this variable.\n     * Necessary to be able to change variable names.\n     */\n    addReference(_identifier) { }\n    /**\n     * Check if the identifier variable is only used as function call\n     * @returns true if the variable is only used as function call\n     */\n    getOnlyFunctionCallUsed() {\n        return this.onlyFunctionCallUsed;\n    }\n    /**\n     * Collect the places where the identifier variable is used\n     * @param usedPlace Where the variable is used\n     */\n    addUsedPlace(usedPlace) {\n        const isFunctionCall = usedPlace.parent.type === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.CallExpression &&\n            usedPlace.parent.callee === usedPlace;\n        if (!isFunctionCall && usedPlace.parent.type !== _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.ExportDefaultDeclaration) {\n            this.onlyFunctionCallUsed = false;\n        }\n    }\n    /**\n     * Prevent this variable from being renamed to this name to avoid name\n     * collisions\n     */\n    forbidName(name) {\n        (this.forbiddenNames ||= new Set()).add(name);\n    }\n    getBaseVariableName() {\n        return (this.renderedLikeHoisted?.getBaseVariableName() ||\n            this.renderBaseName ||\n            this.renderName ||\n            this.name);\n    }\n    getName(getPropertyAccess, useOriginalName) {\n        if (this.globalName) {\n            return this.globalName;\n        }\n        if (useOriginalName?.(this)) {\n            return this.name;\n        }\n        if (this.renderedLikeHoisted) {\n            return this.renderedLikeHoisted.getName(getPropertyAccess, useOriginalName);\n        }\n        const name = this.renderName || this.name;\n        return this.renderBaseName ? `${this.renderBaseName}${getPropertyAccess(name)}` : name;\n    }\n    hasEffectsOnInteractionAtPath(path, { type }, _context) {\n        return type !== INTERACTION_ACCESSED || path.length > 0;\n    }\n    /**\n     * Marks this variable as being part of the bundle, which is usually the case\n     * when one of its identifiers becomes part of the bundle. Returns true if it\n     * has not been included previously. Once a variable is included, it should\n     * take care all its declarations are included.\n     */\n    include() {\n        this.included = true;\n        this.renderedLikeHoisted?.include();\n    }\n    /**\n     * Links the rendered name of this variable to another variable and includes\n     * this variable if the other variable is included.\n     */\n    renderLikeHoisted(variable) {\n        this.renderedLikeHoisted = variable;\n    }\n    markCalledFromTryStatement() { }\n    setRenderNames(baseName, name) {\n        this.renderBaseName = baseName;\n        this.renderName = name;\n    }\n}\n\nclass ExternalVariable extends Variable {\n    constructor(module, name) {\n        super(name);\n        this.referenced = false;\n        this.module = module;\n        this.isNamespace = name === '*';\n    }\n    addReference(identifier) {\n        this.referenced = true;\n        if (this.name === 'default' || this.name === '*') {\n            this.module.suggestName(identifier.name);\n        }\n    }\n    hasEffectsOnInteractionAtPath(path, { type }) {\n        return type !== INTERACTION_ACCESSED || path.length > (this.isNamespace ? 1 : 0);\n    }\n    include() {\n        super.include();\n        this.module.used = true;\n    }\n}\n\nfunction cacheObjectGetters(object, getterProperties) {\n    for (const property of getterProperties) {\n        const propertyGetter = Object.getOwnPropertyDescriptor(object, property).get;\n        Object.defineProperty(object, property, {\n            get() {\n                const value = propertyGetter.call(object);\n                // This replaces the getter with a fixed value for subsequent calls\n                Object.defineProperty(object, property, { value });\n                return value;\n            }\n        });\n    }\n}\n\nconst RESERVED_NAMES = new Set([\n    'await',\n    'break',\n    'case',\n    'catch',\n    'class',\n    'const',\n    'continue',\n    'debugger',\n    'default',\n    'delete',\n    'do',\n    'else',\n    'enum',\n    'eval',\n    'export',\n    'extends',\n    'false',\n    'finally',\n    'for',\n    'function',\n    'if',\n    'implements',\n    'import',\n    'in',\n    'instanceof',\n    'interface',\n    'let',\n    'NaN',\n    'new',\n    'null',\n    'package',\n    'private',\n    'protected',\n    'public',\n    'return',\n    'static',\n    'super',\n    'switch',\n    'this',\n    'throw',\n    'true',\n    'try',\n    'typeof',\n    'undefined',\n    'var',\n    'void',\n    'while',\n    'with',\n    'yield'\n]);\n\nconst illegalCharacters = /[^\\w$]/g;\nconst startsWithDigit = (value) => /\\d/.test(value[0]);\nconst needsEscape = (value) => startsWithDigit(value) || RESERVED_NAMES.has(value) || value === 'arguments';\nfunction isLegal(value) {\n    if (needsEscape(value)) {\n        return false;\n    }\n    return !illegalCharacters.test(value);\n}\nfunction makeLegal(value) {\n    value = value\n        .replace(/-(\\w)/g, (_, letter) => letter.toUpperCase())\n        .replace(illegalCharacters, '_');\n    if (needsEscape(value))\n        value = `_${value}`;\n    return value || '_';\n}\nconst VALID_IDENTIFIER_REGEXP = /^[$_\\p{ID_Start}][$\\u200C\\u200D\\p{ID_Continue}]*$/u;\nconst NUMBER_REGEXP = /^(?:0|[1-9]\\d*)$/;\nfunction stringifyObjectKeyIfNeeded(key) {\n    if (VALID_IDENTIFIER_REGEXP.test(key)) {\n        return key === '__proto__' ? '[\"__proto__\"]' : key;\n    }\n    if (NUMBER_REGEXP.test(key) && +key <= Number.MAX_SAFE_INTEGER) {\n        return key;\n    }\n    return JSON.stringify(key);\n}\nfunction stringifyIdentifierIfNeeded(key) {\n    if (VALID_IDENTIFIER_REGEXP.test(key)) {\n        return key;\n    }\n    return JSON.stringify(key);\n}\n\nclass ExternalModule {\n    constructor(options, id, moduleSideEffects, meta, renormalizeRenderPath, attributes) {\n        this.options = options;\n        this.id = id;\n        this.renormalizeRenderPath = renormalizeRenderPath;\n        this.dynamicImporters = [];\n        this.execIndex = Infinity;\n        this.exportedVariables = new Map();\n        this.importers = [];\n        this.reexported = false;\n        this.used = false;\n        this.declarations = new Map();\n        this.mostCommonSuggestion = 0;\n        this.nameSuggestions = new Map();\n        this.suggestedVariableName = makeLegal(id.split(/[/\\\\]/).pop());\n        const { importers, dynamicImporters } = this;\n        this.info = {\n            ast: null,\n            attributes,\n            code: null,\n            dynamicallyImportedIdResolutions: _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY,\n            dynamicallyImportedIds: _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY,\n            get dynamicImporters() {\n                return dynamicImporters.sort();\n            },\n            exportedBindings: null,\n            exports: null,\n            hasDefaultExport: null,\n            id,\n            implicitlyLoadedAfterOneOf: _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY,\n            implicitlyLoadedBefore: _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY,\n            importedIdResolutions: _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY,\n            importedIds: _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY,\n            get importers() {\n                return importers.sort();\n            },\n            isEntry: false,\n            isExternal: true,\n            isIncluded: null,\n            meta,\n            moduleSideEffects,\n            syntheticNamedExports: false\n        };\n    }\n    cacheInfoGetters() {\n        cacheObjectGetters(this.info, ['dynamicImporters', 'importers']);\n    }\n    getVariableForExportName(name) {\n        const declaration = this.declarations.get(name);\n        if (declaration)\n            return [declaration];\n        const externalVariable = new ExternalVariable(this, name);\n        this.declarations.set(name, externalVariable);\n        this.exportedVariables.set(externalVariable, name);\n        return [externalVariable];\n    }\n    suggestName(name) {\n        const value = (this.nameSuggestions.get(name) ?? 0) + 1;\n        this.nameSuggestions.set(name, value);\n        if (value > this.mostCommonSuggestion) {\n            this.mostCommonSuggestion = value;\n            this.suggestedVariableName = name;\n        }\n    }\n    warnUnusedImports() {\n        const unused = [...this.declarations]\n            .filter(([name, declaration]) => name !== '*' && !declaration.included && !this.reexported && !declaration.referenced)\n            .map(([name]) => name);\n        if (unused.length === 0)\n            return;\n        const importersSet = new Set();\n        for (const name of unused) {\n            for (const importer of this.declarations.get(name).module.importers) {\n                importersSet.add(importer);\n            }\n        }\n        const importersArray = [...importersSet];\n        this.options.onLog(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logUnusedExternalImports)(this.id, unused, importersArray));\n    }\n}\n\nfunction markModuleAndImpureDependenciesAsExecuted(baseModule) {\n    baseModule.isExecuted = true;\n    const modules = [baseModule];\n    const visitedModules = new Set();\n    for (const module of modules) {\n        for (const dependency of [...module.dependencies, ...module.implicitlyLoadedBefore]) {\n            if (!(dependency instanceof ExternalModule) &&\n                !dependency.isExecuted &&\n                (dependency.info.moduleSideEffects || module.implicitlyLoadedBefore.has(dependency)) &&\n                !visitedModules.has(dependency.id)) {\n                dependency.isExecuted = true;\n                visitedModules.add(dependency.id);\n                modules.push(dependency);\n            }\n        }\n    }\n}\n\nconst doNothing = () => { };\n\n// This file is generated by scripts/generate-child-node-keys.js.\n// Do not edit this file directly.\nconst childNodeKeys = {\n    ArrayExpression: ['elements'],\n    ArrayPattern: ['elements'],\n    ArrowFunctionExpression: ['params', 'body'],\n    AssignmentExpression: ['left', 'right'],\n    AssignmentPattern: ['left', 'right'],\n    AwaitExpression: ['argument'],\n    BinaryExpression: ['left', 'right'],\n    BlockStatement: ['body'],\n    BreakStatement: ['label'],\n    CallExpression: ['callee', 'arguments'],\n    CatchClause: ['param', 'body'],\n    ChainExpression: ['expression'],\n    ClassBody: ['body'],\n    ClassDeclaration: ['decorators', 'id', 'superClass', 'body'],\n    ClassExpression: ['decorators', 'id', 'superClass', 'body'],\n    ConditionalExpression: ['test', 'consequent', 'alternate'],\n    ContinueStatement: ['label'],\n    DebuggerStatement: [],\n    Decorator: ['expression'],\n    DoWhileStatement: ['body', 'test'],\n    EmptyStatement: [],\n    ExportAllDeclaration: ['exported', 'source', 'attributes'],\n    ExportDefaultDeclaration: ['declaration'],\n    ExportNamedDeclaration: ['specifiers', 'source', 'attributes', 'declaration'],\n    ExportSpecifier: ['local', 'exported'],\n    ExpressionStatement: ['expression'],\n    ForInStatement: ['left', 'right', 'body'],\n    ForOfStatement: ['left', 'right', 'body'],\n    ForStatement: ['init', 'test', 'update', 'body'],\n    FunctionDeclaration: ['id', 'params', 'body'],\n    FunctionExpression: ['id', 'params', 'body'],\n    Identifier: [],\n    IfStatement: ['test', 'consequent', 'alternate'],\n    ImportAttribute: ['key', 'value'],\n    ImportDeclaration: ['specifiers', 'source', 'attributes'],\n    ImportDefaultSpecifier: ['local'],\n    ImportExpression: ['source', 'options'],\n    ImportNamespaceSpecifier: ['local'],\n    ImportSpecifier: ['imported', 'local'],\n    JSXAttribute: ['name', 'value'],\n    JSXClosingElement: ['name'],\n    JSXClosingFragment: [],\n    JSXElement: ['openingElement', 'children', 'closingElement'],\n    JSXEmptyExpression: [],\n    JSXExpressionContainer: ['expression'],\n    JSXFragment: ['openingFragment', 'children', 'closingFragment'],\n    JSXIdentifier: [],\n    JSXMemberExpression: ['object', 'property'],\n    JSXNamespacedName: ['namespace', 'name'],\n    JSXOpeningElement: ['name', 'attributes'],\n    JSXOpeningFragment: [],\n    JSXSpreadAttribute: ['argument'],\n    JSXSpreadChild: ['expression'],\n    JSXText: [],\n    LabeledStatement: ['label', 'body'],\n    Literal: [],\n    LogicalExpression: ['left', 'right'],\n    MemberExpression: ['object', 'property'],\n    MetaProperty: ['meta', 'property'],\n    MethodDefinition: ['decorators', 'key', 'value'],\n    NewExpression: ['callee', 'arguments'],\n    ObjectExpression: ['properties'],\n    ObjectPattern: ['properties'],\n    PanicError: [],\n    ParseError: [],\n    PrivateIdentifier: [],\n    Program: ['body'],\n    Property: ['key', 'value'],\n    PropertyDefinition: ['decorators', 'key', 'value'],\n    RestElement: ['argument'],\n    ReturnStatement: ['argument'],\n    SequenceExpression: ['expressions'],\n    SpreadElement: ['argument'],\n    StaticBlock: ['body'],\n    Super: [],\n    SwitchCase: ['test', 'consequent'],\n    SwitchStatement: ['discriminant', 'cases'],\n    TaggedTemplateExpression: ['tag', 'quasi'],\n    TemplateElement: [],\n    TemplateLiteral: ['quasis', 'expressions'],\n    ThisExpression: [],\n    ThrowStatement: ['argument'],\n    TryStatement: ['block', 'handler', 'finalizer'],\n    UnaryExpression: ['argument'],\n    UpdateExpression: ['argument'],\n    VariableDeclaration: ['declarations'],\n    VariableDeclarator: ['id', 'init'],\n    WhileStatement: ['test', 'body'],\n    YieldExpression: ['argument']\n};\n\nfunction createInclusionContext() {\n    return {\n        brokenFlow: false,\n        hasBreak: false,\n        hasContinue: false,\n        includedCallArguments: new Set(),\n        includedLabels: new Set()\n    };\n}\nfunction createHasEffectsContext() {\n    return {\n        accessed: new PathTracker(),\n        assigned: new PathTracker(),\n        brokenFlow: false,\n        called: new DiscriminatedPathTracker(),\n        hasBreak: false,\n        hasContinue: false,\n        ignore: {\n            breaks: false,\n            continues: false,\n            labels: new Set(),\n            returnYield: false,\n            this: false\n        },\n        includedLabels: new Set(),\n        instantiated: new DiscriminatedPathTracker(),\n        replacedVariableInits: new Map()\n    };\n}\n\nconst INCLUDE_PARAMETERS = 'variables';\nconst IS_SKIPPED_CHAIN = Symbol('IS_SKIPPED_CHAIN');\nclass NodeBase extends ExpressionEntity {\n    /**\n     * Nodes can apply custom deoptimizations once they become part of the\n     * executed code. To do this, they must initialize this as false, implement\n     * applyDeoptimizations and call this from include and hasEffects if they have\n     * custom handlers\n     */\n    get deoptimized() {\n        return isFlagSet(this.flags, 2 /* Flag.deoptimized */);\n    }\n    set deoptimized(value) {\n        this.flags = setFlag(this.flags, 2 /* Flag.deoptimized */, value);\n    }\n    constructor(parent, parentScope) {\n        super();\n        this.parent = parent;\n        this.scope = parentScope;\n        this.createScope(parentScope);\n    }\n    addExportedVariables(_variables, _exportNamesByVariable) { }\n    /**\n     * Override this to bind assignments to variables and do any initialisations\n     * that require the scopes to be populated with variables.\n     */\n    bind() {\n        for (const key of childNodeKeys[this.type]) {\n            const value = this[key];\n            if (Array.isArray(value)) {\n                for (const child of value) {\n                    child?.bind();\n                }\n            }\n            else if (value) {\n                value.bind();\n            }\n        }\n    }\n    /**\n     * Override if this node should receive a different scope than the parent\n     * scope.\n     */\n    createScope(parentScope) {\n        this.scope = parentScope;\n    }\n    hasEffects(context) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        for (const key of childNodeKeys[this.type]) {\n            const value = this[key];\n            if (value === null)\n                continue;\n            if (Array.isArray(value)) {\n                for (const child of value) {\n                    if (child?.hasEffects(context))\n                        return true;\n                }\n            }\n            else if (value.hasEffects(context))\n                return true;\n        }\n        return false;\n    }\n    hasEffectsAsAssignmentTarget(context, _checkAccess) {\n        return (this.hasEffects(context) ||\n            this.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.assignmentInteraction, context));\n    }\n    include(context, includeChildrenRecursively, _options) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        this.included = true;\n        for (const key of childNodeKeys[this.type]) {\n            const value = this[key];\n            if (value === null)\n                continue;\n            if (Array.isArray(value)) {\n                for (const child of value) {\n                    child?.include(context, includeChildrenRecursively);\n                }\n            }\n            else {\n                value.include(context, includeChildrenRecursively);\n            }\n        }\n    }\n    includeAsAssignmentTarget(context, includeChildrenRecursively, _deoptimizeAccess) {\n        this.include(context, includeChildrenRecursively);\n    }\n    /**\n     * Override to perform special initialisation steps after the scope is\n     * initialised\n     */\n    initialise() {\n        this.scope.context.magicString.addSourcemapLocation(this.start);\n        this.scope.context.magicString.addSourcemapLocation(this.end);\n    }\n    parseNode(esTreeNode) {\n        for (const [key, value] of Object.entries(esTreeNode)) {\n            // Skip properties defined on the class already.\n            // This way, we can override this function to add custom initialisation and then call super.parseNode\n            // Note: this doesn't skip properties with defined getters/setters which we use to pack wrap booleans\n            // in bitfields. Those are still assigned from the value in the esTreeNode.\n            if (this.hasOwnProperty(key))\n                continue;\n            if (key.charCodeAt(0) === 95 /* _ */) {\n                if (key === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.ANNOTATION_KEY) {\n                    this.annotations = value;\n                }\n                else if (key === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.INVALID_ANNOTATION_KEY) {\n                    this.invalidAnnotations = value;\n                }\n            }\n            else if (typeof value !== 'object' || value === null) {\n                this[key] = value;\n            }\n            else if (Array.isArray(value)) {\n                this[key] = new Array(value.length);\n                let index = 0;\n                for (const child of value) {\n                    this[key][index++] =\n                        child === null\n                            ? null\n                            : new (this.scope.context.getNodeConstructor(child.type))(this, this.scope).parseNode(child);\n                }\n            }\n            else {\n                this[key] = new (this.scope.context.getNodeConstructor(value.type))(this, this.scope).parseNode(value);\n            }\n        }\n        // extend child keys for unknown node types\n        childNodeKeys[esTreeNode.type] ||= createChildNodeKeysForNode(esTreeNode);\n        this.initialise();\n        return this;\n    }\n    removeAnnotations(code) {\n        if (this.annotations) {\n            for (const annotation of this.annotations) {\n                code.remove(annotation.start, annotation.end);\n            }\n        }\n    }\n    render(code, options) {\n        for (const key of childNodeKeys[this.type]) {\n            const value = this[key];\n            if (value === null)\n                continue;\n            if (Array.isArray(value)) {\n                for (const child of value) {\n                    child?.render(code, options);\n                }\n            }\n            else {\n                value.render(code, options);\n            }\n        }\n    }\n    setAssignedValue(value) {\n        this.assignmentInteraction = { args: [null, value], type: INTERACTION_ASSIGNED };\n    }\n    shouldBeIncluded(context) {\n        return this.included || (!context.brokenFlow && this.hasEffects(createHasEffectsContext()));\n    }\n    /**\n     * Just deoptimize everything by default so that when e.g. we do not track\n     * something properly, it is deoptimized.\n     * @protected\n     */\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        for (const key of childNodeKeys[this.type]) {\n            const value = this[key];\n            if (value === null)\n                continue;\n            if (Array.isArray(value)) {\n                for (const child of value) {\n                    child?.deoptimizePath(UNKNOWN_PATH);\n                }\n            }\n            else {\n                value.deoptimizePath(UNKNOWN_PATH);\n            }\n        }\n        this.scope.context.requestTreeshakingPass();\n    }\n}\nfunction createChildNodeKeysForNode(esTreeNode) {\n    return Object.keys(esTreeNode).filter(key => typeof esTreeNode[key] === 'object' && key.charCodeAt(0) !== 95 /* _ */);\n}\n\nfunction isObjectExpressionNode(node) {\n    return node instanceof NodeBase && node.type === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.ObjectExpression;\n}\nfunction isPropertyNode(node) {\n    return node.type === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.Property;\n}\n\nfunction assembleMemberDescriptions(memberDescriptions, inheritedDescriptions = null) {\n    return Object.create(inheritedDescriptions, memberDescriptions);\n}\nconst UNDEFINED_EXPRESSION = new (class UndefinedExpression extends ExpressionEntity {\n    getLiteralValueAtPath() {\n        return undefined;\n    }\n})();\nconst returnsUnknown = {\n    value: {\n        hasEffectsWhenCalled: null,\n        returns: UNKNOWN_EXPRESSION\n    }\n};\nconst UNKNOWN_LITERAL_BOOLEAN = new (class UnknownBoolean extends ExpressionEntity {\n    getReturnExpressionWhenCalledAtPath(path) {\n        if (path.length === 1) {\n            return getMemberReturnExpressionWhenCalled(literalBooleanMembers, path[0]);\n        }\n        return UNKNOWN_RETURN_EXPRESSION;\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        if (interaction.type === INTERACTION_ACCESSED) {\n            return path.length > 1;\n        }\n        if (interaction.type === INTERACTION_CALLED && path.length === 1) {\n            return hasMemberEffectWhenCalled(literalBooleanMembers, path[0], interaction, context);\n        }\n        return true;\n    }\n})();\nconst returnsBoolean = {\n    value: {\n        hasEffectsWhenCalled: null,\n        returns: UNKNOWN_LITERAL_BOOLEAN\n    }\n};\nconst UNKNOWN_LITERAL_NUMBER = new (class UnknownNumber extends ExpressionEntity {\n    getReturnExpressionWhenCalledAtPath(path) {\n        if (path.length === 1) {\n            return getMemberReturnExpressionWhenCalled(literalNumberMembers, path[0]);\n        }\n        return UNKNOWN_RETURN_EXPRESSION;\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        if (interaction.type === INTERACTION_ACCESSED) {\n            return path.length > 1;\n        }\n        if (interaction.type === INTERACTION_CALLED && path.length === 1) {\n            return hasMemberEffectWhenCalled(literalNumberMembers, path[0], interaction, context);\n        }\n        return true;\n    }\n})();\nconst returnsNumber = {\n    value: {\n        hasEffectsWhenCalled: null,\n        returns: UNKNOWN_LITERAL_NUMBER\n    }\n};\nconst UNKNOWN_LITERAL_STRING = new (class UnknownString extends ExpressionEntity {\n    getReturnExpressionWhenCalledAtPath(path) {\n        if (path.length === 1) {\n            return getMemberReturnExpressionWhenCalled(literalStringMembers, path[0]);\n        }\n        return UNKNOWN_RETURN_EXPRESSION;\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        if (interaction.type === INTERACTION_ACCESSED) {\n            return path.length > 1;\n        }\n        if (interaction.type === INTERACTION_CALLED && path.length === 1) {\n            return hasMemberEffectWhenCalled(literalStringMembers, path[0], interaction, context);\n        }\n        return true;\n    }\n})();\nconst returnsString = {\n    value: {\n        hasEffectsWhenCalled: null,\n        returns: UNKNOWN_LITERAL_STRING\n    }\n};\nconst stringReplace = {\n    value: {\n        hasEffectsWhenCalled({ args }, context) {\n            const argument1 = args[2];\n            return (args.length < 3 ||\n                (typeof argument1.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, {\n                    deoptimizeCache() { }\n                }) === 'symbol' &&\n                    argument1.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_CALL, context)));\n        },\n        returns: UNKNOWN_LITERAL_STRING\n    }\n};\nconst objectMembers = assembleMemberDescriptions({\n    hasOwnProperty: returnsBoolean,\n    isPrototypeOf: returnsBoolean,\n    propertyIsEnumerable: returnsBoolean,\n    toLocaleString: returnsString,\n    toString: returnsString,\n    valueOf: returnsUnknown\n});\nconst literalBooleanMembers = assembleMemberDescriptions({\n    valueOf: returnsBoolean\n}, objectMembers);\nconst literalNumberMembers = assembleMemberDescriptions({\n    toExponential: returnsString,\n    toFixed: returnsString,\n    toLocaleString: returnsString,\n    toPrecision: returnsString,\n    valueOf: returnsNumber\n}, objectMembers);\n/**\n * RegExp are stateful when they have the global or sticky flags set.\n * But if we actually don't use them, the side effect does not matter.\n * the check logic in `hasEffectsOnInteractionAtPath`.\n */\nconst literalRegExpMembers = assembleMemberDescriptions({\n    exec: returnsUnknown,\n    test: returnsBoolean\n}, objectMembers);\nconst literalStringMembers = assembleMemberDescriptions({\n    anchor: returnsString,\n    at: returnsUnknown,\n    big: returnsString,\n    blink: returnsString,\n    bold: returnsString,\n    charAt: returnsString,\n    charCodeAt: returnsNumber,\n    codePointAt: returnsUnknown,\n    concat: returnsString,\n    endsWith: returnsBoolean,\n    fixed: returnsString,\n    fontcolor: returnsString,\n    fontsize: returnsString,\n    includes: returnsBoolean,\n    indexOf: returnsNumber,\n    italics: returnsString,\n    lastIndexOf: returnsNumber,\n    link: returnsString,\n    localeCompare: returnsNumber,\n    match: returnsUnknown,\n    matchAll: returnsUnknown,\n    normalize: returnsString,\n    padEnd: returnsString,\n    padStart: returnsString,\n    repeat: returnsString,\n    replace: stringReplace,\n    replaceAll: stringReplace,\n    search: returnsNumber,\n    slice: returnsString,\n    small: returnsString,\n    split: returnsUnknown,\n    startsWith: returnsBoolean,\n    strike: returnsString,\n    sub: returnsString,\n    substr: returnsString,\n    substring: returnsString,\n    sup: returnsString,\n    toLocaleLowerCase: returnsString,\n    toLocaleUpperCase: returnsString,\n    toLowerCase: returnsString,\n    toString: returnsString, // overrides the toString() method of the Object object; it does not inherit Object.prototype.toString()\n    toUpperCase: returnsString,\n    trim: returnsString,\n    trimEnd: returnsString,\n    trimLeft: returnsString,\n    trimRight: returnsString,\n    trimStart: returnsString,\n    valueOf: returnsString\n}, objectMembers);\nfunction getLiteralMembersForValue(value) {\n    if (value instanceof RegExp) {\n        return literalRegExpMembers;\n    }\n    switch (typeof value) {\n        case 'boolean': {\n            return literalBooleanMembers;\n        }\n        case 'number': {\n            return literalNumberMembers;\n        }\n        case 'string': {\n            return literalStringMembers;\n        }\n    }\n    return Object.create(null);\n}\nfunction hasMemberEffectWhenCalled(members, memberName, interaction, context) {\n    if (typeof memberName !== 'string' || !members[memberName]) {\n        return true;\n    }\n    return members[memberName].hasEffectsWhenCalled?.(interaction, context) || false;\n}\nfunction getMemberReturnExpressionWhenCalled(members, memberName) {\n    if (typeof memberName !== 'string' || !members[memberName])\n        return UNKNOWN_RETURN_EXPRESSION;\n    return [members[memberName].returns, false];\n}\n\nclass SpreadElement extends NodeBase {\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        if (path.length > 0) {\n            this.argument.deoptimizeArgumentsOnInteractionAtPath(interaction, [UnknownKey, ...path], recursionTracker);\n        }\n    }\n    hasEffects(context) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        const { propertyReadSideEffects } = this.scope.context.options\n            .treeshake;\n        return (this.argument.hasEffects(context) ||\n            (propertyReadSideEffects &&\n                (propertyReadSideEffects === 'always' ||\n                    this.argument.hasEffectsOnInteractionAtPath(UNKNOWN_PATH, NODE_INTERACTION_UNKNOWN_ACCESS, context))));\n    }\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        // Only properties of properties of the argument could become subject to reassignment\n        // This will also reassign the return values of iterators\n        this.argument.deoptimizePath([UnknownKey, UnknownKey]);\n        this.scope.context.requestTreeshakingPass();\n    }\n}\n\nclass Method extends ExpressionEntity {\n    constructor(description) {\n        super();\n        this.description = description;\n    }\n    deoptimizeArgumentsOnInteractionAtPath({ args, type }, path) {\n        if (type === INTERACTION_CALLED && path.length === 0) {\n            if (this.description.mutatesSelfAsArray) {\n                args[0]?.deoptimizePath(UNKNOWN_INTEGER_PATH);\n            }\n            if (this.description.mutatesArgs) {\n                for (let index = 1; index < args.length; index++) {\n                    args[index].deoptimizePath(UNKNOWN_PATH);\n                }\n            }\n        }\n    }\n    getReturnExpressionWhenCalledAtPath(path, { args }) {\n        if (path.length > 0) {\n            return UNKNOWN_RETURN_EXPRESSION;\n        }\n        return [\n            this.description.returnsPrimitive ||\n                (this.description.returns === 'self'\n                    ? args[0] || UNKNOWN_EXPRESSION\n                    : this.description.returns()),\n            false\n        ];\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        const { type } = interaction;\n        if (path.length > (type === INTERACTION_ACCESSED ? 1 : 0)) {\n            return true;\n        }\n        if (type === INTERACTION_CALLED) {\n            const { args } = interaction;\n            if (this.description.mutatesSelfAsArray === true &&\n                args[0]?.hasEffectsOnInteractionAtPath(UNKNOWN_INTEGER_PATH, NODE_INTERACTION_UNKNOWN_ASSIGNMENT, context)) {\n                return true;\n            }\n            if (this.description.callsArgs) {\n                for (const argumentIndex of this.description.callsArgs) {\n                    if (args[argumentIndex + 1]?.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_CALL, context)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\nconst METHOD_RETURNS_BOOLEAN = [\n    new Method({\n        callsArgs: null,\n        mutatesArgs: false,\n        mutatesSelfAsArray: false,\n        returns: null,\n        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN\n    })\n];\nconst METHOD_RETURNS_STRING = [\n    new Method({\n        callsArgs: null,\n        mutatesArgs: false,\n        mutatesSelfAsArray: false,\n        returns: null,\n        returnsPrimitive: UNKNOWN_LITERAL_STRING\n    })\n];\nconst METHOD_RETURNS_NUMBER = [\n    new Method({\n        callsArgs: null,\n        mutatesArgs: false,\n        mutatesSelfAsArray: false,\n        returns: null,\n        returnsPrimitive: UNKNOWN_LITERAL_NUMBER\n    })\n];\nconst METHOD_RETURNS_UNKNOWN = [\n    new Method({\n        callsArgs: null,\n        mutatesArgs: false,\n        mutatesSelfAsArray: false,\n        returns: null,\n        returnsPrimitive: UNKNOWN_EXPRESSION\n    })\n];\n\nconst INTEGER_REG_EXP = /^\\d+$/;\nclass ObjectEntity extends ExpressionEntity {\n    get hasLostTrack() {\n        return isFlagSet(this.flags, 2048 /* Flag.hasLostTrack */);\n    }\n    set hasLostTrack(value) {\n        this.flags = setFlag(this.flags, 2048 /* Flag.hasLostTrack */, value);\n    }\n    get hasUnknownDeoptimizedInteger() {\n        return isFlagSet(this.flags, 4096 /* Flag.hasUnknownDeoptimizedInteger */);\n    }\n    set hasUnknownDeoptimizedInteger(value) {\n        this.flags = setFlag(this.flags, 4096 /* Flag.hasUnknownDeoptimizedInteger */, value);\n    }\n    get hasUnknownDeoptimizedProperty() {\n        return isFlagSet(this.flags, 8192 /* Flag.hasUnknownDeoptimizedProperty */);\n    }\n    set hasUnknownDeoptimizedProperty(value) {\n        this.flags = setFlag(this.flags, 8192 /* Flag.hasUnknownDeoptimizedProperty */, value);\n    }\n    // If a PropertyMap is used, this will be taken as propertiesAndGettersByKey\n    // and we assume there are no setters or getters\n    constructor(properties, prototypeExpression, immutable = false) {\n        super();\n        this.prototypeExpression = prototypeExpression;\n        this.immutable = immutable;\n        this.additionalExpressionsToBeDeoptimized = new Set();\n        this.allProperties = [];\n        this.deoptimizedPaths = Object.create(null);\n        this.expressionsToBeDeoptimizedByKey = Object.create(null);\n        this.gettersByKey = Object.create(null);\n        this.propertiesAndGettersByKey = Object.create(null);\n        this.propertiesAndSettersByKey = Object.create(null);\n        this.settersByKey = Object.create(null);\n        this.unknownIntegerProps = [];\n        this.unmatchableGetters = [];\n        this.unmatchablePropertiesAndGetters = [];\n        this.unmatchableSetters = [];\n        if (Array.isArray(properties)) {\n            this.buildPropertyMaps(properties);\n        }\n        else {\n            this.propertiesAndGettersByKey = this.propertiesAndSettersByKey = properties;\n            for (const propertiesForKey of Object.values(properties)) {\n                this.allProperties.push(...propertiesForKey);\n            }\n        }\n    }\n    deoptimizeAllProperties(noAccessors) {\n        const isDeoptimized = this.hasLostTrack || this.hasUnknownDeoptimizedProperty;\n        if (noAccessors) {\n            this.hasUnknownDeoptimizedProperty = true;\n        }\n        else {\n            this.hasLostTrack = true;\n        }\n        if (isDeoptimized) {\n            return;\n        }\n        for (const properties of [\n            ...Object.values(this.propertiesAndGettersByKey),\n            ...Object.values(this.settersByKey)\n        ]) {\n            for (const property of properties) {\n                property.deoptimizePath(UNKNOWN_PATH);\n            }\n        }\n        // While the prototype itself cannot be mutated, each property can\n        this.prototypeExpression?.deoptimizePath([UnknownKey, UnknownKey]);\n        this.deoptimizeCachedEntities();\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        const [key, ...subPath] = path;\n        const { args, type } = interaction;\n        if (this.hasLostTrack ||\n            // single paths that are deoptimized will not become getters or setters\n            ((type === INTERACTION_CALLED || path.length > 1) &&\n                (this.hasUnknownDeoptimizedProperty ||\n                    (typeof key === 'string' && this.deoptimizedPaths[key])))) {\n            deoptimizeInteraction(interaction);\n            return;\n        }\n        const [propertiesForExactMatchByKey, relevantPropertiesByKey, relevantUnmatchableProperties] = type === INTERACTION_CALLED || path.length > 1\n            ? [\n                this.propertiesAndGettersByKey,\n                this.propertiesAndGettersByKey,\n                this.unmatchablePropertiesAndGetters\n            ]\n            : type === INTERACTION_ACCESSED\n                ? [this.propertiesAndGettersByKey, this.gettersByKey, this.unmatchableGetters]\n                : [this.propertiesAndSettersByKey, this.settersByKey, this.unmatchableSetters];\n        if (typeof key === 'string') {\n            if (propertiesForExactMatchByKey[key]) {\n                const properties = relevantPropertiesByKey[key];\n                if (properties) {\n                    for (const property of properties) {\n                        property.deoptimizeArgumentsOnInteractionAtPath(interaction, subPath, recursionTracker);\n                    }\n                }\n                if (!this.immutable) {\n                    for (const argument of args) {\n                        if (argument) {\n                            this.additionalExpressionsToBeDeoptimized.add(argument);\n                        }\n                    }\n                }\n                return;\n            }\n            for (const property of relevantUnmatchableProperties) {\n                property.deoptimizeArgumentsOnInteractionAtPath(interaction, subPath, recursionTracker);\n            }\n            if (INTEGER_REG_EXP.test(key)) {\n                for (const property of this.unknownIntegerProps) {\n                    property.deoptimizeArgumentsOnInteractionAtPath(interaction, subPath, recursionTracker);\n                }\n            }\n        }\n        else {\n            for (const properties of [\n                ...Object.values(relevantPropertiesByKey),\n                relevantUnmatchableProperties\n            ]) {\n                for (const property of properties) {\n                    property.deoptimizeArgumentsOnInteractionAtPath(interaction, subPath, recursionTracker);\n                }\n            }\n            for (const property of this.unknownIntegerProps) {\n                property.deoptimizeArgumentsOnInteractionAtPath(interaction, subPath, recursionTracker);\n            }\n        }\n        if (!this.immutable) {\n            for (const argument of args) {\n                if (argument) {\n                    this.additionalExpressionsToBeDeoptimized.add(argument);\n                }\n            }\n        }\n        this.prototypeExpression?.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n    }\n    deoptimizeIntegerProperties() {\n        if (this.hasLostTrack ||\n            this.hasUnknownDeoptimizedProperty ||\n            this.hasUnknownDeoptimizedInteger) {\n            return;\n        }\n        this.hasUnknownDeoptimizedInteger = true;\n        for (const [key, propertiesAndGetters] of Object.entries(this.propertiesAndGettersByKey)) {\n            if (INTEGER_REG_EXP.test(key)) {\n                for (const property of propertiesAndGetters) {\n                    property.deoptimizePath(UNKNOWN_PATH);\n                }\n            }\n        }\n        this.deoptimizeCachedIntegerEntities();\n    }\n    // Assumption: If only a specific path is deoptimized, no accessors are created\n    deoptimizePath(path) {\n        if (this.hasLostTrack || this.immutable) {\n            return;\n        }\n        const key = path[0];\n        if (path.length === 1) {\n            if (key === UnknownInteger) {\n                return this.deoptimizeIntegerProperties();\n            }\n            else if (typeof key !== 'string') {\n                return this.deoptimizeAllProperties(key === UnknownNonAccessorKey);\n            }\n            if (!this.deoptimizedPaths[key]) {\n                this.deoptimizedPaths[key] = true;\n                // we only deoptimizeCache exact matches as in all other cases,\n                // we do not return a literal value or return expression\n                const expressionsToBeDeoptimized = this.expressionsToBeDeoptimizedByKey[key];\n                if (expressionsToBeDeoptimized) {\n                    for (const expression of expressionsToBeDeoptimized) {\n                        expression.deoptimizeCache();\n                    }\n                }\n            }\n        }\n        const subPath = path.length === 1 ? UNKNOWN_PATH : path.slice(1);\n        for (const property of typeof key === 'string'\n            ? [\n                ...(this.propertiesAndGettersByKey[key] || this.unmatchablePropertiesAndGetters),\n                ...(this.settersByKey[key] || this.unmatchableSetters)\n            ]\n            : this.allProperties) {\n            property.deoptimizePath(subPath);\n        }\n        this.prototypeExpression?.deoptimizePath(path.length === 1 ? [...path, UnknownKey] : path);\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        if (path.length === 0) {\n            return UnknownTruthyValue;\n        }\n        const key = path[0];\n        const expressionAtPath = this.getMemberExpressionAndTrackDeopt(key, origin);\n        if (expressionAtPath) {\n            return expressionAtPath.getLiteralValueAtPath(path.slice(1), recursionTracker, origin);\n        }\n        if (this.prototypeExpression) {\n            return this.prototypeExpression.getLiteralValueAtPath(path, recursionTracker, origin);\n        }\n        if (path.length === 1) {\n            return undefined;\n        }\n        return UnknownValue;\n    }\n    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {\n        if (path.length === 0) {\n            return UNKNOWN_RETURN_EXPRESSION;\n        }\n        const [key, ...subPath] = path;\n        const expressionAtPath = this.getMemberExpressionAndTrackDeopt(key, origin);\n        if (expressionAtPath) {\n            return expressionAtPath.getReturnExpressionWhenCalledAtPath(subPath, interaction, recursionTracker, origin);\n        }\n        if (this.prototypeExpression) {\n            return this.prototypeExpression.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);\n        }\n        return UNKNOWN_RETURN_EXPRESSION;\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        const [key, ...subPath] = path;\n        if (subPath.length > 0 || interaction.type === INTERACTION_CALLED) {\n            const expressionAtPath = this.getMemberExpression(key);\n            if (expressionAtPath) {\n                return expressionAtPath.hasEffectsOnInteractionAtPath(subPath, interaction, context);\n            }\n            if (this.prototypeExpression) {\n                return this.prototypeExpression.hasEffectsOnInteractionAtPath(path, interaction, context);\n            }\n            return true;\n        }\n        if (key === UnknownNonAccessorKey)\n            return false;\n        if (this.hasLostTrack)\n            return true;\n        const [propertiesAndAccessorsByKey, accessorsByKey, unmatchableAccessors] = interaction.type === INTERACTION_ACCESSED\n            ? [this.propertiesAndGettersByKey, this.gettersByKey, this.unmatchableGetters]\n            : [this.propertiesAndSettersByKey, this.settersByKey, this.unmatchableSetters];\n        if (typeof key === 'string') {\n            if (propertiesAndAccessorsByKey[key]) {\n                const accessors = accessorsByKey[key];\n                if (accessors) {\n                    for (const accessor of accessors) {\n                        if (accessor.hasEffectsOnInteractionAtPath(subPath, interaction, context))\n                            return true;\n                    }\n                }\n                return false;\n            }\n            for (const accessor of unmatchableAccessors) {\n                if (accessor.hasEffectsOnInteractionAtPath(subPath, interaction, context)) {\n                    return true;\n                }\n            }\n        }\n        else {\n            for (const accessors of [...Object.values(accessorsByKey), unmatchableAccessors]) {\n                for (const accessor of accessors) {\n                    if (accessor.hasEffectsOnInteractionAtPath(subPath, interaction, context))\n                        return true;\n                }\n            }\n        }\n        if (this.prototypeExpression) {\n            return this.prototypeExpression.hasEffectsOnInteractionAtPath(path, interaction, context);\n        }\n        return false;\n    }\n    buildPropertyMaps(properties) {\n        const { allProperties, propertiesAndGettersByKey, propertiesAndSettersByKey, settersByKey, gettersByKey, unknownIntegerProps, unmatchablePropertiesAndGetters, unmatchableGetters, unmatchableSetters } = this;\n        const unmatchablePropertiesAndSetters = [];\n        for (let index = properties.length - 1; index >= 0; index--) {\n            const { key, kind, property } = properties[index];\n            allProperties.push(property);\n            if (typeof key === 'string') {\n                if (kind === 'set') {\n                    if (!propertiesAndSettersByKey[key]) {\n                        propertiesAndSettersByKey[key] = [property, ...unmatchablePropertiesAndSetters];\n                        settersByKey[key] = [property, ...unmatchableSetters];\n                    }\n                }\n                else if (kind === 'get') {\n                    if (!propertiesAndGettersByKey[key]) {\n                        propertiesAndGettersByKey[key] = [property, ...unmatchablePropertiesAndGetters];\n                        gettersByKey[key] = [property, ...unmatchableGetters];\n                    }\n                }\n                else {\n                    if (!propertiesAndSettersByKey[key]) {\n                        propertiesAndSettersByKey[key] = [property, ...unmatchablePropertiesAndSetters];\n                    }\n                    if (!propertiesAndGettersByKey[key]) {\n                        propertiesAndGettersByKey[key] = [property, ...unmatchablePropertiesAndGetters];\n                    }\n                }\n            }\n            else {\n                if (key === UnknownInteger) {\n                    unknownIntegerProps.push(property);\n                    continue;\n                }\n                if (kind === 'set')\n                    unmatchableSetters.push(property);\n                if (kind === 'get')\n                    unmatchableGetters.push(property);\n                if (kind !== 'get')\n                    unmatchablePropertiesAndSetters.push(property);\n                if (kind !== 'set')\n                    unmatchablePropertiesAndGetters.push(property);\n            }\n        }\n    }\n    deoptimizeCachedEntities() {\n        for (const expressionsToBeDeoptimized of Object.values(this.expressionsToBeDeoptimizedByKey)) {\n            for (const expression of expressionsToBeDeoptimized) {\n                expression.deoptimizeCache();\n            }\n        }\n        for (const expression of this.additionalExpressionsToBeDeoptimized) {\n            expression.deoptimizePath(UNKNOWN_PATH);\n        }\n    }\n    deoptimizeCachedIntegerEntities() {\n        for (const [key, expressionsToBeDeoptimized] of Object.entries(this.expressionsToBeDeoptimizedByKey)) {\n            if (INTEGER_REG_EXP.test(key)) {\n                for (const expression of expressionsToBeDeoptimized) {\n                    expression.deoptimizeCache();\n                }\n            }\n        }\n        for (const expression of this.additionalExpressionsToBeDeoptimized) {\n            expression.deoptimizePath(UNKNOWN_INTEGER_PATH);\n        }\n    }\n    getMemberExpression(key) {\n        if (this.hasLostTrack ||\n            this.hasUnknownDeoptimizedProperty ||\n            typeof key !== 'string' ||\n            (this.hasUnknownDeoptimizedInteger && INTEGER_REG_EXP.test(key)) ||\n            this.deoptimizedPaths[key]) {\n            return UNKNOWN_EXPRESSION;\n        }\n        const properties = this.propertiesAndGettersByKey[key];\n        if (properties?.length === 1) {\n            return properties[0];\n        }\n        if (properties ||\n            this.unmatchablePropertiesAndGetters.length > 0 ||\n            (this.unknownIntegerProps.length > 0 && INTEGER_REG_EXP.test(key))) {\n            return UNKNOWN_EXPRESSION;\n        }\n        return null;\n    }\n    getMemberExpressionAndTrackDeopt(key, origin) {\n        if (typeof key !== 'string') {\n            return UNKNOWN_EXPRESSION;\n        }\n        const expression = this.getMemberExpression(key);\n        if (!(expression === UNKNOWN_EXPRESSION || this.immutable)) {\n            const expressionsToBeDeoptimized = (this.expressionsToBeDeoptimizedByKey[key] =\n                this.expressionsToBeDeoptimizedByKey[key] || []);\n            expressionsToBeDeoptimized.push(origin);\n        }\n        return expression;\n    }\n}\n\nconst isInteger = (property) => typeof property === 'string' && /^\\d+$/.test(property);\n// This makes sure unknown properties are not handled as \"undefined\" but as\n// \"unknown\" but without access side effects. An exception is done for numeric\n// properties as we do not expect new builtin properties to be numbers, this\n// will improve tree-shaking for out-of-bounds array properties\nconst OBJECT_PROTOTYPE_FALLBACK = new (class ObjectPrototypeFallbackExpression extends ExpressionEntity {\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path) {\n        if (interaction.type === INTERACTION_CALLED && path.length === 1 && !isInteger(path[0])) {\n            deoptimizeInteraction(interaction);\n        }\n    }\n    getLiteralValueAtPath(path) {\n        // We ignore number properties as we do not expect new properties to be\n        // numbers and also want to keep handling out-of-bound array elements as\n        // \"undefined\"\n        return path.length === 1 && isInteger(path[0]) ? undefined : UnknownValue;\n    }\n    hasEffectsOnInteractionAtPath(path, { type }) {\n        return path.length > 1 || type === INTERACTION_CALLED;\n    }\n})();\nconst OBJECT_PROTOTYPE = new ObjectEntity({\n    __proto__: null,\n    hasOwnProperty: METHOD_RETURNS_BOOLEAN,\n    isPrototypeOf: METHOD_RETURNS_BOOLEAN,\n    propertyIsEnumerable: METHOD_RETURNS_BOOLEAN,\n    toLocaleString: METHOD_RETURNS_STRING,\n    toString: METHOD_RETURNS_STRING,\n    valueOf: METHOD_RETURNS_UNKNOWN\n}, OBJECT_PROTOTYPE_FALLBACK, true);\n\nconst NEW_ARRAY_PROPERTIES = [\n    { key: UnknownInteger, kind: 'init', property: UNKNOWN_EXPRESSION },\n    { key: 'length', kind: 'init', property: UNKNOWN_LITERAL_NUMBER }\n];\nconst METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN = [\n    new Method({\n        callsArgs: [0],\n        mutatesArgs: false,\n        mutatesSelfAsArray: 'deopt-only',\n        returns: null,\n        returnsPrimitive: UNKNOWN_LITERAL_BOOLEAN\n    })\n];\nconst METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER = [\n    new Method({\n        callsArgs: [0],\n        mutatesArgs: false,\n        mutatesSelfAsArray: 'deopt-only',\n        returns: null,\n        returnsPrimitive: UNKNOWN_LITERAL_NUMBER\n    })\n];\nconst METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY = [\n    new Method({\n        callsArgs: null,\n        mutatesArgs: false,\n        mutatesSelfAsArray: true,\n        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),\n        returnsPrimitive: null\n    })\n];\nconst METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY = [\n    new Method({\n        callsArgs: null,\n        mutatesArgs: false,\n        mutatesSelfAsArray: 'deopt-only',\n        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),\n        returnsPrimitive: null\n    })\n];\nconst METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY = [\n    new Method({\n        callsArgs: [0],\n        mutatesArgs: false,\n        mutatesSelfAsArray: 'deopt-only',\n        returns: () => new ObjectEntity(NEW_ARRAY_PROPERTIES, ARRAY_PROTOTYPE),\n        returnsPrimitive: null\n    })\n];\nconst METHOD_MUTATES_SELF_AND_ARGS_RETURNS_NUMBER = [\n    new Method({\n        callsArgs: null,\n        mutatesArgs: true,\n        mutatesSelfAsArray: true,\n        returns: null,\n        returnsPrimitive: UNKNOWN_LITERAL_NUMBER\n    })\n];\nconst METHOD_MUTATES_SELF_RETURNS_UNKNOWN = [\n    new Method({\n        callsArgs: null,\n        mutatesArgs: false,\n        mutatesSelfAsArray: true,\n        returns: null,\n        returnsPrimitive: UNKNOWN_EXPRESSION\n    })\n];\nconst METHOD_DEOPTS_SELF_RETURNS_UNKNOWN = [\n    new Method({\n        callsArgs: null,\n        mutatesArgs: false,\n        mutatesSelfAsArray: 'deopt-only',\n        returns: null,\n        returnsPrimitive: UNKNOWN_EXPRESSION\n    })\n];\nconst METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN = [\n    new Method({\n        callsArgs: [0],\n        mutatesArgs: false,\n        mutatesSelfAsArray: 'deopt-only',\n        returns: null,\n        returnsPrimitive: UNKNOWN_EXPRESSION\n    })\n];\nconst METHOD_MUTATES_SELF_RETURNS_SELF = [\n    new Method({\n        callsArgs: null,\n        mutatesArgs: false,\n        mutatesSelfAsArray: true,\n        returns: 'self',\n        returnsPrimitive: null\n    })\n];\nconst METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF = [\n    new Method({\n        callsArgs: [0],\n        mutatesArgs: false,\n        mutatesSelfAsArray: true,\n        returns: 'self',\n        returnsPrimitive: null\n    })\n];\nconst ARRAY_PROTOTYPE = new ObjectEntity({\n    __proto__: null,\n    // We assume that accessors have effects as we do not track the accessed value afterwards\n    at: METHOD_DEOPTS_SELF_RETURNS_UNKNOWN,\n    concat: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,\n    copyWithin: METHOD_MUTATES_SELF_RETURNS_SELF,\n    entries: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,\n    every: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN,\n    fill: METHOD_MUTATES_SELF_RETURNS_SELF,\n    filter: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,\n    find: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,\n    findIndex: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER,\n    findLast: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,\n    findLastIndex: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NUMBER,\n    flat: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,\n    flatMap: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,\n    forEach: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,\n    includes: METHOD_RETURNS_BOOLEAN,\n    indexOf: METHOD_RETURNS_NUMBER,\n    join: METHOD_RETURNS_STRING,\n    keys: METHOD_RETURNS_UNKNOWN,\n    lastIndexOf: METHOD_RETURNS_NUMBER,\n    map: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_NEW_ARRAY,\n    pop: METHOD_MUTATES_SELF_RETURNS_UNKNOWN,\n    push: METHOD_MUTATES_SELF_AND_ARGS_RETURNS_NUMBER,\n    reduce: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,\n    reduceRight: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_UNKNOWN,\n    reverse: METHOD_MUTATES_SELF_RETURNS_SELF,\n    shift: METHOD_MUTATES_SELF_RETURNS_UNKNOWN,\n    slice: METHOD_DEOPTS_SELF_RETURNS_NEW_ARRAY,\n    some: METHOD_CALLS_ARG_DEOPTS_SELF_RETURNS_BOOLEAN,\n    sort: METHOD_CALLS_ARG_MUTATES_SELF_RETURNS_SELF,\n    splice: METHOD_MUTATES_SELF_RETURNS_NEW_ARRAY,\n    toLocaleString: METHOD_RETURNS_STRING,\n    toString: METHOD_RETURNS_STRING,\n    unshift: METHOD_MUTATES_SELF_AND_ARGS_RETURNS_NUMBER,\n    values: METHOD_DEOPTS_SELF_RETURNS_UNKNOWN\n}, OBJECT_PROTOTYPE, true);\n\nclass ArrayExpression extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.objectEntity = null;\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n    }\n    deoptimizePath(path) {\n        this.getObjectEntity().deoptimizePath(path);\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);\n    }\n    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {\n        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        return this.getObjectEntity().hasEffectsOnInteractionAtPath(path, interaction, context);\n    }\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        let hasSpread = false;\n        for (let index = 0; index < this.elements.length; index++) {\n            const element = this.elements[index];\n            if (element && (hasSpread || element instanceof SpreadElement)) {\n                hasSpread = true;\n                element.deoptimizePath(UNKNOWN_PATH);\n            }\n        }\n        this.scope.context.requestTreeshakingPass();\n    }\n    getObjectEntity() {\n        if (this.objectEntity !== null) {\n            return this.objectEntity;\n        }\n        const properties = [\n            { key: 'length', kind: 'init', property: UNKNOWN_LITERAL_NUMBER }\n        ];\n        let hasSpread = false;\n        for (let index = 0; index < this.elements.length; index++) {\n            const element = this.elements[index];\n            if (hasSpread || element instanceof SpreadElement) {\n                if (element) {\n                    hasSpread = true;\n                    properties.unshift({ key: UnknownInteger, kind: 'init', property: element });\n                }\n            }\n            else if (element) {\n                properties.push({ key: String(index), kind: 'init', property: element });\n            }\n            else {\n                properties.push({ key: String(index), kind: 'init', property: UNDEFINED_EXPRESSION });\n            }\n        }\n        return (this.objectEntity = new ObjectEntity(properties, ARRAY_PROTOTYPE));\n    }\n}\n\n/* eslint sort-keys: \"off\" */\nconst ValueProperties = Symbol('Value Properties');\nconst getTruthyLiteralValue = () => UnknownTruthyValue;\nconst returnFalse = () => false;\nconst returnTrue = () => true;\nconst PURE = {\n    deoptimizeArgumentsOnCall: doNothing,\n    getLiteralValue: getTruthyLiteralValue,\n    hasEffectsWhenCalled: returnFalse\n};\nconst IMPURE = {\n    deoptimizeArgumentsOnCall: doNothing,\n    getLiteralValue: getTruthyLiteralValue,\n    hasEffectsWhenCalled: returnTrue\n};\nconst PURE_WITH_ARRAY = {\n    deoptimizeArgumentsOnCall: doNothing,\n    getLiteralValue: getTruthyLiteralValue,\n    hasEffectsWhenCalled({ args }) {\n        return args.length > 1 && !(args[1] instanceof ArrayExpression);\n    }\n};\nconst GETTER_ACCESS = {\n    deoptimizeArgumentsOnCall: doNothing,\n    getLiteralValue: getTruthyLiteralValue,\n    hasEffectsWhenCalled({ args }, context) {\n        const [_thisArgument, firstArgument] = args;\n        return (!(firstArgument instanceof ExpressionEntity) ||\n            firstArgument.hasEffectsOnInteractionAtPath(UNKNOWN_PATH, NODE_INTERACTION_UNKNOWN_ACCESS, context));\n    }\n};\n// We use shortened variables to reduce file size here\n/* OBJECT */\nconst O = {\n    __proto__: null,\n    [ValueProperties]: IMPURE\n};\n/* PURE FUNCTION */\nconst PF = {\n    __proto__: null,\n    [ValueProperties]: PURE\n};\n/* PURE FUNCTION IF FIRST ARG DOES NOT CONTAIN A GETTER */\nconst PF_NO_GETTER = {\n    __proto__: null,\n    [ValueProperties]: GETTER_ACCESS\n};\n/* FUNCTION THAT MUTATES FIRST ARG WITHOUT TRIGGERING ACCESSORS */\nconst MUTATES_ARG_WITHOUT_ACCESSOR = {\n    __proto__: null,\n    [ValueProperties]: {\n        deoptimizeArgumentsOnCall({ args: [, firstArgument] }) {\n            firstArgument?.deoptimizePath(UNKNOWN_PATH);\n        },\n        getLiteralValue: getTruthyLiteralValue,\n        hasEffectsWhenCalled({ args }, context) {\n            return (args.length <= 1 ||\n                args[1].hasEffectsOnInteractionAtPath(UNKNOWN_NON_ACCESSOR_PATH, NODE_INTERACTION_UNKNOWN_ASSIGNMENT, context));\n        }\n    }\n};\n/* CONSTRUCTOR */\nconst C = {\n    __proto__: null,\n    [ValueProperties]: IMPURE,\n    prototype: O\n};\n/* PURE CONSTRUCTOR */\nconst PC = {\n    __proto__: null,\n    [ValueProperties]: PURE,\n    prototype: O\n};\nconst PC_WITH_ARRAY = {\n    __proto__: null,\n    [ValueProperties]: PURE_WITH_ARRAY,\n    prototype: O\n};\nconst ARRAY_TYPE = {\n    __proto__: null,\n    [ValueProperties]: PURE,\n    from: O,\n    of: PF,\n    prototype: O\n};\nconst INTL_MEMBER = {\n    __proto__: null,\n    [ValueProperties]: PURE,\n    supportedLocalesOf: PC\n};\nconst knownGlobals = {\n    // Placeholders for global objects to avoid shape mutations\n    global: O,\n    globalThis: O,\n    self: O,\n    window: O,\n    // Common globals\n    __proto__: null,\n    [ValueProperties]: IMPURE,\n    Array: {\n        __proto__: null,\n        [ValueProperties]: IMPURE,\n        from: O,\n        isArray: PF,\n        of: PF,\n        prototype: O\n    },\n    ArrayBuffer: {\n        __proto__: null,\n        [ValueProperties]: PURE,\n        isView: PF,\n        prototype: O\n    },\n    AggregateError: PC_WITH_ARRAY,\n    Atomics: O,\n    BigInt: C,\n    BigInt64Array: C,\n    BigUint64Array: C,\n    Boolean: PC,\n    constructor: C,\n    DataView: PC,\n    Date: {\n        __proto__: null,\n        [ValueProperties]: PURE,\n        now: PF,\n        parse: PF,\n        prototype: O,\n        UTC: PF\n    },\n    decodeURI: PF,\n    decodeURIComponent: PF,\n    encodeURI: PF,\n    encodeURIComponent: PF,\n    Error: PC,\n    escape: PF,\n    eval: O,\n    EvalError: PC,\n    FinalizationRegistry: C,\n    Float32Array: ARRAY_TYPE,\n    Float64Array: ARRAY_TYPE,\n    Function: C,\n    hasOwnProperty: O,\n    Infinity: O,\n    Int16Array: ARRAY_TYPE,\n    Int32Array: ARRAY_TYPE,\n    Int8Array: ARRAY_TYPE,\n    isFinite: PF,\n    isNaN: PF,\n    isPrototypeOf: O,\n    JSON: O,\n    Map: PC_WITH_ARRAY,\n    Math: {\n        __proto__: null,\n        [ValueProperties]: IMPURE,\n        abs: PF,\n        acos: PF,\n        acosh: PF,\n        asin: PF,\n        asinh: PF,\n        atan: PF,\n        atan2: PF,\n        atanh: PF,\n        cbrt: PF,\n        ceil: PF,\n        clz32: PF,\n        cos: PF,\n        cosh: PF,\n        exp: PF,\n        expm1: PF,\n        floor: PF,\n        fround: PF,\n        hypot: PF,\n        imul: PF,\n        log: PF,\n        log10: PF,\n        log1p: PF,\n        log2: PF,\n        max: PF,\n        min: PF,\n        pow: PF,\n        random: PF,\n        round: PF,\n        sign: PF,\n        sin: PF,\n        sinh: PF,\n        sqrt: PF,\n        tan: PF,\n        tanh: PF,\n        trunc: PF\n    },\n    NaN: O,\n    Number: {\n        __proto__: null,\n        [ValueProperties]: PURE,\n        isFinite: PF,\n        isInteger: PF,\n        isNaN: PF,\n        isSafeInteger: PF,\n        parseFloat: PF,\n        parseInt: PF,\n        prototype: O\n    },\n    Object: {\n        __proto__: null,\n        [ValueProperties]: PURE,\n        create: PF,\n        // Technically those can throw in certain situations, but we ignore this as\n        // code that relies on this will hopefully wrap this in a try-catch, which\n        // deoptimizes everything anyway\n        defineProperty: MUTATES_ARG_WITHOUT_ACCESSOR,\n        defineProperties: MUTATES_ARG_WITHOUT_ACCESSOR,\n        freeze: MUTATES_ARG_WITHOUT_ACCESSOR,\n        getOwnPropertyDescriptor: PF,\n        getOwnPropertyDescriptors: PF,\n        getOwnPropertyNames: PF,\n        getOwnPropertySymbols: PF,\n        getPrototypeOf: PF,\n        hasOwn: PF,\n        is: PF,\n        isExtensible: PF,\n        isFrozen: PF,\n        isSealed: PF,\n        keys: PF,\n        fromEntries: O,\n        entries: PF_NO_GETTER,\n        values: PF_NO_GETTER,\n        prototype: O\n    },\n    parseFloat: PF,\n    parseInt: PF,\n    Promise: {\n        __proto__: null,\n        [ValueProperties]: IMPURE,\n        all: O,\n        allSettled: O,\n        any: O,\n        prototype: O,\n        race: O,\n        reject: O,\n        resolve: O\n    },\n    propertyIsEnumerable: O,\n    Proxy: {\n        __proto__: null,\n        [ValueProperties]: {\n            deoptimizeArgumentsOnCall: ({ args: [, target, parameter] }) => {\n                if (isObjectExpressionNode(parameter)) {\n                    const hasSpreadElement = parameter.properties.some(property => !isPropertyNode(property));\n                    if (!hasSpreadElement) {\n                        for (const property of parameter.properties) {\n                            property.deoptimizeArgumentsOnInteractionAtPath({\n                                args: [null, target],\n                                type: INTERACTION_CALLED,\n                                withNew: false\n                            }, EMPTY_PATH, SHARED_RECURSION_TRACKER);\n                        }\n                        return;\n                    }\n                }\n                target.deoptimizePath(UNKNOWN_PATH);\n            },\n            getLiteralValue: getTruthyLiteralValue,\n            hasEffectsWhenCalled: returnTrue\n        }\n    },\n    RangeError: PC,\n    ReferenceError: PC,\n    Reflect: O,\n    RegExp: PC,\n    Set: PC_WITH_ARRAY,\n    SharedArrayBuffer: C,\n    String: {\n        __proto__: null,\n        [ValueProperties]: PURE,\n        fromCharCode: PF,\n        fromCodePoint: PF,\n        prototype: O,\n        raw: PF\n    },\n    Symbol: {\n        __proto__: null,\n        [ValueProperties]: PURE,\n        for: PF,\n        keyFor: PF,\n        prototype: O,\n        toStringTag: {\n            __proto__: null,\n            [ValueProperties]: {\n                deoptimizeArgumentsOnCall: doNothing,\n                getLiteralValue() {\n                    return SymbolToStringTag;\n                },\n                hasEffectsWhenCalled: returnTrue\n            }\n        }\n    },\n    SyntaxError: PC,\n    toLocaleString: O,\n    toString: O,\n    TypeError: PC,\n    Uint16Array: ARRAY_TYPE,\n    Uint32Array: ARRAY_TYPE,\n    Uint8Array: ARRAY_TYPE,\n    Uint8ClampedArray: ARRAY_TYPE,\n    // Technically, this is a global, but it needs special handling\n    // undefined: ?,\n    unescape: PF,\n    URIError: PC,\n    valueOf: O,\n    WeakMap: PC_WITH_ARRAY,\n    WeakRef: C,\n    WeakSet: PC_WITH_ARRAY,\n    // Additional globals shared by Node and Browser that are not strictly part of the language\n    clearInterval: C,\n    clearTimeout: C,\n    console: {\n        __proto__: null,\n        [ValueProperties]: IMPURE,\n        assert: C,\n        clear: C,\n        count: C,\n        countReset: C,\n        debug: C,\n        dir: C,\n        dirxml: C,\n        error: C,\n        exception: C,\n        group: C,\n        groupCollapsed: C,\n        groupEnd: C,\n        info: C,\n        log: C,\n        table: C,\n        time: C,\n        timeEnd: C,\n        timeLog: C,\n        trace: C,\n        warn: C\n    },\n    Intl: {\n        __proto__: null,\n        [ValueProperties]: IMPURE,\n        Collator: INTL_MEMBER,\n        DateTimeFormat: INTL_MEMBER,\n        DisplayNames: INTL_MEMBER,\n        ListFormat: INTL_MEMBER,\n        Locale: INTL_MEMBER,\n        NumberFormat: INTL_MEMBER,\n        PluralRules: INTL_MEMBER,\n        RelativeTimeFormat: INTL_MEMBER,\n        Segmenter: INTL_MEMBER\n    },\n    setInterval: C,\n    setTimeout: C,\n    TextDecoder: C,\n    TextEncoder: C,\n    URL: {\n        __proto__: null,\n        [ValueProperties]: IMPURE,\n        prototype: O,\n        canParse: PF\n    },\n    URLSearchParams: C,\n    // Browser specific globals\n    AbortController: C,\n    AbortSignal: C,\n    addEventListener: O,\n    alert: O,\n    AnalyserNode: C,\n    Animation: C,\n    AnimationEvent: C,\n    applicationCache: O,\n    ApplicationCache: C,\n    ApplicationCacheErrorEvent: C,\n    atob: O,\n    Attr: C,\n    Audio: C,\n    AudioBuffer: C,\n    AudioBufferSourceNode: C,\n    AudioContext: C,\n    AudioDestinationNode: C,\n    AudioListener: C,\n    AudioNode: C,\n    AudioParam: C,\n    AudioProcessingEvent: C,\n    AudioScheduledSourceNode: C,\n    AudioWorkletNode: C,\n    BarProp: C,\n    BaseAudioContext: C,\n    BatteryManager: C,\n    BeforeUnloadEvent: C,\n    BiquadFilterNode: C,\n    Blob: C,\n    BlobEvent: C,\n    blur: O,\n    BroadcastChannel: C,\n    btoa: O,\n    ByteLengthQueuingStrategy: C,\n    Cache: C,\n    caches: O,\n    CacheStorage: C,\n    cancelAnimationFrame: O,\n    cancelIdleCallback: O,\n    CanvasCaptureMediaStreamTrack: C,\n    CanvasGradient: C,\n    CanvasPattern: C,\n    CanvasRenderingContext2D: C,\n    ChannelMergerNode: C,\n    ChannelSplitterNode: C,\n    CharacterData: C,\n    clientInformation: O,\n    ClipboardEvent: C,\n    close: O,\n    closed: O,\n    CloseEvent: C,\n    Comment: C,\n    CompositionEvent: C,\n    confirm: O,\n    ConstantSourceNode: C,\n    ConvolverNode: C,\n    CountQueuingStrategy: C,\n    createImageBitmap: O,\n    Credential: C,\n    CredentialsContainer: C,\n    crypto: O,\n    Crypto: C,\n    CryptoKey: C,\n    CSS: C,\n    CSSConditionRule: C,\n    CSSFontFaceRule: C,\n    CSSGroupingRule: C,\n    CSSImportRule: C,\n    CSSKeyframeRule: C,\n    CSSKeyframesRule: C,\n    CSSMediaRule: C,\n    CSSNamespaceRule: C,\n    CSSPageRule: C,\n    CSSRule: C,\n    CSSRuleList: C,\n    CSSStyleDeclaration: C,\n    CSSStyleRule: C,\n    CSSStyleSheet: C,\n    CSSSupportsRule: C,\n    CustomElementRegistry: C,\n    customElements: O,\n    CustomEvent: {\n        __proto__: null,\n        [ValueProperties]: {\n            deoptimizeArgumentsOnCall({ args }) {\n                args[2]?.deoptimizePath(['detail']);\n            },\n            getLiteralValue: getTruthyLiteralValue,\n            hasEffectsWhenCalled: returnFalse\n        },\n        prototype: O\n    },\n    DataTransfer: C,\n    DataTransferItem: C,\n    DataTransferItemList: C,\n    defaultstatus: O,\n    defaultStatus: O,\n    DelayNode: C,\n    DeviceMotionEvent: C,\n    DeviceOrientationEvent: C,\n    devicePixelRatio: O,\n    dispatchEvent: O,\n    document: O,\n    Document: C,\n    DocumentFragment: C,\n    DocumentType: C,\n    DOMError: C,\n    DOMException: C,\n    DOMImplementation: C,\n    DOMMatrix: C,\n    DOMMatrixReadOnly: C,\n    DOMParser: C,\n    DOMPoint: C,\n    DOMPointReadOnly: C,\n    DOMQuad: C,\n    DOMRect: C,\n    DOMRectReadOnly: C,\n    DOMStringList: C,\n    DOMStringMap: C,\n    DOMTokenList: C,\n    DragEvent: C,\n    DynamicsCompressorNode: C,\n    Element: C,\n    ErrorEvent: C,\n    Event: C,\n    EventSource: C,\n    EventTarget: C,\n    external: O,\n    fetch: O,\n    File: C,\n    FileList: C,\n    FileReader: C,\n    find: O,\n    focus: O,\n    FocusEvent: C,\n    FontFace: C,\n    FontFaceSetLoadEvent: C,\n    FormData: C,\n    frames: O,\n    GainNode: C,\n    Gamepad: C,\n    GamepadButton: C,\n    GamepadEvent: C,\n    getComputedStyle: O,\n    getSelection: O,\n    HashChangeEvent: C,\n    Headers: C,\n    history: O,\n    History: C,\n    HTMLAllCollection: C,\n    HTMLAnchorElement: C,\n    HTMLAreaElement: C,\n    HTMLAudioElement: C,\n    HTMLBaseElement: C,\n    HTMLBodyElement: C,\n    HTMLBRElement: C,\n    HTMLButtonElement: C,\n    HTMLCanvasElement: C,\n    HTMLCollection: C,\n    HTMLContentElement: C,\n    HTMLDataElement: C,\n    HTMLDataListElement: C,\n    HTMLDetailsElement: C,\n    HTMLDialogElement: C,\n    HTMLDirectoryElement: C,\n    HTMLDivElement: C,\n    HTMLDListElement: C,\n    HTMLDocument: C,\n    HTMLElement: C,\n    HTMLEmbedElement: C,\n    HTMLFieldSetElement: C,\n    HTMLFontElement: C,\n    HTMLFormControlsCollection: C,\n    HTMLFormElement: C,\n    HTMLFrameElement: C,\n    HTMLFrameSetElement: C,\n    HTMLHeadElement: C,\n    HTMLHeadingElement: C,\n    HTMLHRElement: C,\n    HTMLHtmlElement: C,\n    HTMLIFrameElement: C,\n    HTMLImageElement: C,\n    HTMLInputElement: C,\n    HTMLLabelElement: C,\n    HTMLLegendElement: C,\n    HTMLLIElement: C,\n    HTMLLinkElement: C,\n    HTMLMapElement: C,\n    HTMLMarqueeElement: C,\n    HTMLMediaElement: C,\n    HTMLMenuElement: C,\n    HTMLMetaElement: C,\n    HTMLMeterElement: C,\n    HTMLModElement: C,\n    HTMLObjectElement: C,\n    HTMLOListElement: C,\n    HTMLOptGroupElement: C,\n    HTMLOptionElement: C,\n    HTMLOptionsCollection: C,\n    HTMLOutputElement: C,\n    HTMLParagraphElement: C,\n    HTMLParamElement: C,\n    HTMLPictureElement: C,\n    HTMLPreElement: C,\n    HTMLProgressElement: C,\n    HTMLQuoteElement: C,\n    HTMLScriptElement: C,\n    HTMLSelectElement: C,\n    HTMLShadowElement: C,\n    HTMLSlotElement: C,\n    HTMLSourceElement: C,\n    HTMLSpanElement: C,\n    HTMLStyleElement: C,\n    HTMLTableCaptionElement: C,\n    HTMLTableCellElement: C,\n    HTMLTableColElement: C,\n    HTMLTableElement: C,\n    HTMLTableRowElement: C,\n    HTMLTableSectionElement: C,\n    HTMLTemplateElement: C,\n    HTMLTextAreaElement: C,\n    HTMLTimeElement: C,\n    HTMLTitleElement: C,\n    HTMLTrackElement: C,\n    HTMLUListElement: C,\n    HTMLUnknownElement: C,\n    HTMLVideoElement: C,\n    IDBCursor: C,\n    IDBCursorWithValue: C,\n    IDBDatabase: C,\n    IDBFactory: C,\n    IDBIndex: C,\n    IDBKeyRange: C,\n    IDBObjectStore: C,\n    IDBOpenDBRequest: C,\n    IDBRequest: C,\n    IDBTransaction: C,\n    IDBVersionChangeEvent: C,\n    IdleDeadline: C,\n    IIRFilterNode: C,\n    Image: C,\n    ImageBitmap: C,\n    ImageBitmapRenderingContext: C,\n    ImageCapture: C,\n    ImageData: C,\n    indexedDB: O,\n    innerHeight: O,\n    innerWidth: O,\n    InputEvent: C,\n    IntersectionObserver: C,\n    IntersectionObserverEntry: C,\n    isSecureContext: O,\n    KeyboardEvent: C,\n    KeyframeEffect: C,\n    length: O,\n    localStorage: O,\n    location: O,\n    Location: C,\n    locationbar: O,\n    matchMedia: O,\n    MediaDeviceInfo: C,\n    MediaDevices: C,\n    MediaElementAudioSourceNode: C,\n    MediaEncryptedEvent: C,\n    MediaError: C,\n    MediaKeyMessageEvent: C,\n    MediaKeySession: C,\n    MediaKeyStatusMap: C,\n    MediaKeySystemAccess: C,\n    MediaList: C,\n    MediaQueryList: C,\n    MediaQueryListEvent: C,\n    MediaRecorder: C,\n    MediaSettingsRange: C,\n    MediaSource: C,\n    MediaStream: C,\n    MediaStreamAudioDestinationNode: C,\n    MediaStreamAudioSourceNode: C,\n    MediaStreamEvent: C,\n    MediaStreamTrack: C,\n    MediaStreamTrackEvent: C,\n    menubar: O,\n    MessageChannel: C,\n    MessageEvent: C,\n    MessagePort: C,\n    MIDIAccess: C,\n    MIDIConnectionEvent: C,\n    MIDIInput: C,\n    MIDIInputMap: C,\n    MIDIMessageEvent: C,\n    MIDIOutput: C,\n    MIDIOutputMap: C,\n    MIDIPort: C,\n    MimeType: C,\n    MimeTypeArray: C,\n    MouseEvent: C,\n    moveBy: O,\n    moveTo: O,\n    MutationEvent: C,\n    MutationObserver: C,\n    MutationRecord: C,\n    name: O,\n    NamedNodeMap: C,\n    NavigationPreloadManager: C,\n    navigator: O,\n    Navigator: C,\n    NetworkInformation: C,\n    Node: C,\n    NodeFilter: O,\n    NodeIterator: C,\n    NodeList: C,\n    Notification: C,\n    OfflineAudioCompletionEvent: C,\n    OfflineAudioContext: C,\n    offscreenBuffering: O,\n    OffscreenCanvas: C,\n    open: O,\n    openDatabase: O,\n    Option: C,\n    origin: O,\n    OscillatorNode: C,\n    outerHeight: O,\n    outerWidth: O,\n    PageTransitionEvent: C,\n    pageXOffset: O,\n    pageYOffset: O,\n    PannerNode: C,\n    parent: O,\n    Path2D: C,\n    PaymentAddress: C,\n    PaymentRequest: C,\n    PaymentRequestUpdateEvent: C,\n    PaymentResponse: C,\n    performance: O,\n    Performance: C,\n    PerformanceEntry: C,\n    PerformanceLongTaskTiming: C,\n    PerformanceMark: C,\n    PerformanceMeasure: C,\n    PerformanceNavigation: C,\n    PerformanceNavigationTiming: C,\n    PerformanceObserver: C,\n    PerformanceObserverEntryList: C,\n    PerformancePaintTiming: C,\n    PerformanceResourceTiming: C,\n    PerformanceTiming: C,\n    PeriodicWave: C,\n    Permissions: C,\n    PermissionStatus: C,\n    personalbar: O,\n    PhotoCapabilities: C,\n    Plugin: C,\n    PluginArray: C,\n    PointerEvent: C,\n    PopStateEvent: C,\n    postMessage: O,\n    Presentation: C,\n    PresentationAvailability: C,\n    PresentationConnection: C,\n    PresentationConnectionAvailableEvent: C,\n    PresentationConnectionCloseEvent: C,\n    PresentationConnectionList: C,\n    PresentationReceiver: C,\n    PresentationRequest: C,\n    print: O,\n    ProcessingInstruction: C,\n    ProgressEvent: C,\n    PromiseRejectionEvent: C,\n    prompt: O,\n    PushManager: C,\n    PushSubscription: C,\n    PushSubscriptionOptions: C,\n    queueMicrotask: O,\n    RadioNodeList: C,\n    Range: C,\n    ReadableStream: C,\n    RemotePlayback: C,\n    removeEventListener: O,\n    Request: C,\n    requestAnimationFrame: O,\n    requestIdleCallback: O,\n    resizeBy: O,\n    ResizeObserver: C,\n    ResizeObserverEntry: C,\n    resizeTo: O,\n    Response: C,\n    RTCCertificate: C,\n    RTCDataChannel: C,\n    RTCDataChannelEvent: C,\n    RTCDtlsTransport: C,\n    RTCIceCandidate: C,\n    RTCIceTransport: C,\n    RTCPeerConnection: C,\n    RTCPeerConnectionIceEvent: C,\n    RTCRtpReceiver: C,\n    RTCRtpSender: C,\n    RTCSctpTransport: C,\n    RTCSessionDescription: C,\n    RTCStatsReport: C,\n    RTCTrackEvent: C,\n    screen: O,\n    Screen: C,\n    screenLeft: O,\n    ScreenOrientation: C,\n    screenTop: O,\n    screenX: O,\n    screenY: O,\n    ScriptProcessorNode: C,\n    scroll: O,\n    scrollbars: O,\n    scrollBy: O,\n    scrollTo: O,\n    scrollX: O,\n    scrollY: O,\n    SecurityPolicyViolationEvent: C,\n    Selection: C,\n    ServiceWorker: C,\n    ServiceWorkerContainer: C,\n    ServiceWorkerRegistration: C,\n    sessionStorage: O,\n    ShadowRoot: C,\n    SharedWorker: C,\n    SourceBuffer: C,\n    SourceBufferList: C,\n    speechSynthesis: O,\n    SpeechSynthesisEvent: C,\n    SpeechSynthesisUtterance: C,\n    StaticRange: C,\n    status: O,\n    statusbar: O,\n    StereoPannerNode: C,\n    stop: O,\n    Storage: C,\n    StorageEvent: C,\n    StorageManager: C,\n    styleMedia: O,\n    StyleSheet: C,\n    StyleSheetList: C,\n    SubtleCrypto: C,\n    SVGAElement: C,\n    SVGAngle: C,\n    SVGAnimatedAngle: C,\n    SVGAnimatedBoolean: C,\n    SVGAnimatedEnumeration: C,\n    SVGAnimatedInteger: C,\n    SVGAnimatedLength: C,\n    SVGAnimatedLengthList: C,\n    SVGAnimatedNumber: C,\n    SVGAnimatedNumberList: C,\n    SVGAnimatedPreserveAspectRatio: C,\n    SVGAnimatedRect: C,\n    SVGAnimatedString: C,\n    SVGAnimatedTransformList: C,\n    SVGAnimateElement: C,\n    SVGAnimateMotionElement: C,\n    SVGAnimateTransformElement: C,\n    SVGAnimationElement: C,\n    SVGCircleElement: C,\n    SVGClipPathElement: C,\n    SVGComponentTransferFunctionElement: C,\n    SVGDefsElement: C,\n    SVGDescElement: C,\n    SVGDiscardElement: C,\n    SVGElement: C,\n    SVGEllipseElement: C,\n    SVGFEBlendElement: C,\n    SVGFEColorMatrixElement: C,\n    SVGFEComponentTransferElement: C,\n    SVGFECompositeElement: C,\n    SVGFEConvolveMatrixElement: C,\n    SVGFEDiffuseLightingElement: C,\n    SVGFEDisplacementMapElement: C,\n    SVGFEDistantLightElement: C,\n    SVGFEDropShadowElement: C,\n    SVGFEFloodElement: C,\n    SVGFEFuncAElement: C,\n    SVGFEFuncBElement: C,\n    SVGFEFuncGElement: C,\n    SVGFEFuncRElement: C,\n    SVGFEGaussianBlurElement: C,\n    SVGFEImageElement: C,\n    SVGFEMergeElement: C,\n    SVGFEMergeNodeElement: C,\n    SVGFEMorphologyElement: C,\n    SVGFEOffsetElement: C,\n    SVGFEPointLightElement: C,\n    SVGFESpecularLightingElement: C,\n    SVGFESpotLightElement: C,\n    SVGFETileElement: C,\n    SVGFETurbulenceElement: C,\n    SVGFilterElement: C,\n    SVGForeignObjectElement: C,\n    SVGGElement: C,\n    SVGGeometryElement: C,\n    SVGGradientElement: C,\n    SVGGraphicsElement: C,\n    SVGImageElement: C,\n    SVGLength: C,\n    SVGLengthList: C,\n    SVGLinearGradientElement: C,\n    SVGLineElement: C,\n    SVGMarkerElement: C,\n    SVGMaskElement: C,\n    SVGMatrix: C,\n    SVGMetadataElement: C,\n    SVGMPathElement: C,\n    SVGNumber: C,\n    SVGNumberList: C,\n    SVGPathElement: C,\n    SVGPatternElement: C,\n    SVGPoint: C,\n    SVGPointList: C,\n    SVGPolygonElement: C,\n    SVGPolylineElement: C,\n    SVGPreserveAspectRatio: C,\n    SVGRadialGradientElement: C,\n    SVGRect: C,\n    SVGRectElement: C,\n    SVGScriptElement: C,\n    SVGSetElement: C,\n    SVGStopElement: C,\n    SVGStringList: C,\n    SVGStyleElement: C,\n    SVGSVGElement: C,\n    SVGSwitchElement: C,\n    SVGSymbolElement: C,\n    SVGTextContentElement: C,\n    SVGTextElement: C,\n    SVGTextPathElement: C,\n    SVGTextPositioningElement: C,\n    SVGTitleElement: C,\n    SVGTransform: C,\n    SVGTransformList: C,\n    SVGTSpanElement: C,\n    SVGUnitTypes: C,\n    SVGUseElement: C,\n    SVGViewElement: C,\n    TaskAttributionTiming: C,\n    Text: C,\n    TextEvent: C,\n    TextMetrics: C,\n    TextTrack: C,\n    TextTrackCue: C,\n    TextTrackCueList: C,\n    TextTrackList: C,\n    TimeRanges: C,\n    toolbar: O,\n    top: O,\n    Touch: C,\n    TouchEvent: C,\n    TouchList: C,\n    TrackEvent: C,\n    TransitionEvent: C,\n    TreeWalker: C,\n    UIEvent: C,\n    ValidityState: C,\n    visualViewport: O,\n    VisualViewport: C,\n    VTTCue: C,\n    WaveShaperNode: C,\n    WebAssembly: O,\n    WebGL2RenderingContext: C,\n    WebGLActiveInfo: C,\n    WebGLBuffer: C,\n    WebGLContextEvent: C,\n    WebGLFramebuffer: C,\n    WebGLProgram: C,\n    WebGLQuery: C,\n    WebGLRenderbuffer: C,\n    WebGLRenderingContext: C,\n    WebGLSampler: C,\n    WebGLShader: C,\n    WebGLShaderPrecisionFormat: C,\n    WebGLSync: C,\n    WebGLTexture: C,\n    WebGLTransformFeedback: C,\n    WebGLUniformLocation: C,\n    WebGLVertexArrayObject: C,\n    WebSocket: C,\n    WheelEvent: C,\n    Window: C,\n    Worker: C,\n    WritableStream: C,\n    XMLDocument: C,\n    XMLHttpRequest: C,\n    XMLHttpRequestEventTarget: C,\n    XMLHttpRequestUpload: C,\n    XMLSerializer: C,\n    XPathEvaluator: C,\n    XPathExpression: C,\n    XPathResult: C,\n    XSLTProcessor: C\n};\nfor (const global of ['window', 'global', 'self', 'globalThis']) {\n    knownGlobals[global] = knownGlobals;\n}\nfunction getGlobalAtPath(path) {\n    let currentGlobal = knownGlobals;\n    for (const pathSegment of path) {\n        if (typeof pathSegment !== 'string') {\n            return null;\n        }\n        currentGlobal = currentGlobal[pathSegment];\n        if (!currentGlobal) {\n            return null;\n        }\n    }\n    return currentGlobal[ValueProperties];\n}\n\nclass GlobalVariable extends Variable {\n    constructor(name) {\n        super(name);\n        // Ensure we use live-bindings for globals as we do not know if they have\n        // been reassigned\n        this.markReassigned();\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        switch (interaction.type) {\n            // While there is no point in testing these cases as at the moment, they\n            // are also covered via other means, we keep them for completeness\n            case INTERACTION_ACCESSED:\n            case INTERACTION_ASSIGNED: {\n                if (!getGlobalAtPath([this.name, ...path].slice(0, -1))) {\n                    super.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n                }\n                return;\n            }\n            case INTERACTION_CALLED: {\n                const globalAtPath = getGlobalAtPath([this.name, ...path]);\n                if (globalAtPath) {\n                    globalAtPath.deoptimizeArgumentsOnCall(interaction);\n                }\n                else {\n                    super.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n                }\n                return;\n            }\n        }\n    }\n    getLiteralValueAtPath(path, _recursionTracker, _origin) {\n        const globalAtPath = getGlobalAtPath([this.name, ...path]);\n        return globalAtPath ? globalAtPath.getLiteralValue() : UnknownValue;\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        switch (interaction.type) {\n            case INTERACTION_ACCESSED: {\n                if (path.length === 0) {\n                    // Technically, \"undefined\" is a global variable of sorts\n                    return this.name !== 'undefined' && !getGlobalAtPath([this.name]);\n                }\n                return !getGlobalAtPath([this.name, ...path].slice(0, -1));\n            }\n            case INTERACTION_ASSIGNED: {\n                return true;\n            }\n            case INTERACTION_CALLED: {\n                const globalAtPath = getGlobalAtPath([this.name, ...path]);\n                return !globalAtPath || globalAtPath.hasEffectsWhenCalled(interaction, context);\n            }\n        }\n    }\n}\n\nclass LocalVariable extends Variable {\n    constructor(name, declarator, init, context, kind) {\n        super(name);\n        this.init = init;\n        this.calledFromTryStatement = false;\n        this.additionalInitializers = null;\n        this.expressionsToBeDeoptimized = [];\n        this.declarations = declarator ? [declarator] : [];\n        this.deoptimizationTracker = context.deoptimizationTracker;\n        this.module = context.module;\n        this.kind = kind;\n    }\n    addDeclaration(identifier, init) {\n        this.declarations.push(identifier);\n        this.markInitializersForDeoptimization().push(init);\n    }\n    consolidateInitializers() {\n        if (this.additionalInitializers) {\n            for (const initializer of this.additionalInitializers) {\n                initializer.deoptimizePath(UNKNOWN_PATH);\n            }\n            this.additionalInitializers = null;\n        }\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        if (this.isReassigned) {\n            deoptimizeInteraction(interaction);\n            return;\n        }\n        recursionTracker.withTrackedEntityAtPath(path, this.init, () => this.init.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker), undefined);\n    }\n    deoptimizePath(path) {\n        if (this.isReassigned ||\n            this.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path, this)) {\n            return;\n        }\n        if (path.length === 0) {\n            this.markReassigned();\n            const expressionsToBeDeoptimized = this.expressionsToBeDeoptimized;\n            this.expressionsToBeDeoptimized = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY;\n            for (const expression of expressionsToBeDeoptimized) {\n                expression.deoptimizeCache();\n            }\n            this.init.deoptimizePath(UNKNOWN_PATH);\n        }\n        else {\n            this.init.deoptimizePath(path);\n        }\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        if (this.isReassigned) {\n            return UnknownValue;\n        }\n        return recursionTracker.withTrackedEntityAtPath(path, this.init, () => {\n            this.expressionsToBeDeoptimized.push(origin);\n            return this.init.getLiteralValueAtPath(path, recursionTracker, origin);\n        }, UnknownValue);\n    }\n    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {\n        if (this.isReassigned) {\n            return UNKNOWN_RETURN_EXPRESSION;\n        }\n        return recursionTracker.withTrackedEntityAtPath(path, this.init, () => {\n            this.expressionsToBeDeoptimized.push(origin);\n            return this.init.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);\n        }, UNKNOWN_RETURN_EXPRESSION);\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        switch (interaction.type) {\n            case INTERACTION_ACCESSED: {\n                if (this.isReassigned)\n                    return true;\n                return (!context.accessed.trackEntityAtPathAndGetIfTracked(path, this) &&\n                    this.init.hasEffectsOnInteractionAtPath(path, interaction, context));\n            }\n            case INTERACTION_ASSIGNED: {\n                if (this.included)\n                    return true;\n                if (path.length === 0)\n                    return false;\n                if (this.isReassigned)\n                    return true;\n                return (!context.assigned.trackEntityAtPathAndGetIfTracked(path, this) &&\n                    this.init.hasEffectsOnInteractionAtPath(path, interaction, context));\n            }\n            case INTERACTION_CALLED: {\n                if (this.isReassigned)\n                    return true;\n                return (!(interaction.withNew ? context.instantiated : context.called).trackEntityAtPathAndGetIfTracked(path, interaction.args, this) &&\n                    this.init.hasEffectsOnInteractionAtPath(path, interaction, context));\n            }\n        }\n    }\n    include() {\n        if (!this.included) {\n            super.include();\n            for (const declaration of this.declarations) {\n                // If node is a default export, it can save a tree-shaking run to include the full declaration now\n                if (!declaration.included)\n                    declaration.include(createInclusionContext(), false);\n                let node = declaration.parent;\n                while (!node.included) {\n                    // We do not want to properly include parents in case they are part of a dead branch\n                    // in which case .include() might pull in more dead code\n                    node.included = true;\n                    if (node.type === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.Program)\n                        break;\n                    node = node.parent;\n                }\n            }\n        }\n    }\n    includeCallArguments(context, parameters) {\n        if (this.isReassigned || context.includedCallArguments.has(this.init)) {\n            for (const argument of parameters) {\n                argument.include(context, false);\n            }\n        }\n        else {\n            context.includedCallArguments.add(this.init);\n            this.init.includeCallArguments(context, parameters);\n            context.includedCallArguments.delete(this.init);\n        }\n    }\n    markCalledFromTryStatement() {\n        this.calledFromTryStatement = true;\n    }\n    markInitializersForDeoptimization() {\n        if (this.additionalInitializers === null) {\n            this.additionalInitializers = [this.init];\n            this.init = UNKNOWN_EXPRESSION;\n            this.markReassigned();\n        }\n        return this.additionalInitializers;\n    }\n}\n\nconst tdzVariableKinds = new Set(['class', 'const', 'let', 'var', 'using', 'await using']);\nclass IdentifierBase extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.variable = null;\n        this.isVariableReference = false;\n    }\n    get isTDZAccess() {\n        if (!isFlagSet(this.flags, 4 /* Flag.tdzAccessDefined */)) {\n            return null;\n        }\n        return isFlagSet(this.flags, 8 /* Flag.tdzAccess */);\n    }\n    set isTDZAccess(value) {\n        this.flags = setFlag(this.flags, 4 /* Flag.tdzAccessDefined */, true);\n        this.flags = setFlag(this.flags, 8 /* Flag.tdzAccess */, value);\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        this.variable.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n    }\n    deoptimizePath(path) {\n        if (path.length === 0 && !this.scope.contains(this.name)) {\n            this.disallowImportReassignment();\n        }\n        // We keep conditional chaining because an unknown Node could have an\n        // Identifier as property that might be deoptimized by default\n        this.variable?.deoptimizePath(path);\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        return this.getVariableRespectingTDZ().getLiteralValueAtPath(path, recursionTracker, origin);\n    }\n    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {\n        const [expression, isPure] = this.getVariableRespectingTDZ().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);\n        return [expression, isPure || this.isPureFunction(path)];\n    }\n    hasEffects(context) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        if (this.isPossibleTDZ() && this.variable.kind !== 'var') {\n            return true;\n        }\n        return (this.scope.context.options.treeshake\n            .unknownGlobalSideEffects &&\n            this.variable instanceof GlobalVariable &&\n            !this.isPureFunction(EMPTY_PATH) &&\n            this.variable.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_ACCESS, context));\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        switch (interaction.type) {\n            case INTERACTION_ACCESSED: {\n                return (this.variable !== null &&\n                    !this.isPureFunction(path) &&\n                    this.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(path, interaction, context));\n            }\n            case INTERACTION_ASSIGNED: {\n                return (path.length > 0 ? this.getVariableRespectingTDZ() : this.variable).hasEffectsOnInteractionAtPath(path, interaction, context);\n            }\n            case INTERACTION_CALLED: {\n                return (!this.isPureFunction(path) &&\n                    this.getVariableRespectingTDZ().hasEffectsOnInteractionAtPath(path, interaction, context));\n            }\n        }\n    }\n    include() {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        if (!this.included) {\n            this.included = true;\n            if (this.variable !== null) {\n                this.scope.context.includeVariableInModule(this.variable);\n            }\n        }\n    }\n    includeCallArguments(context, parameters) {\n        this.variable.includeCallArguments(context, parameters);\n    }\n    isPossibleTDZ() {\n        // return cached value to avoid issues with the next tree-shaking pass\n        const cachedTdzAccess = this.isTDZAccess;\n        if (cachedTdzAccess !== null)\n            return cachedTdzAccess;\n        if (!(this.variable instanceof LocalVariable &&\n            this.variable.kind &&\n            tdzVariableKinds.has(this.variable.kind) &&\n            // We ignore modules that did not receive a treeshaking pass yet as that\n            // causes many false positives due to circular dependencies or disabled\n            // moduleSideEffects.\n            this.variable.module.hasTreeShakingPassStarted)) {\n            return (this.isTDZAccess = false);\n        }\n        let decl_id;\n        if (this.variable.declarations &&\n            this.variable.declarations.length === 1 &&\n            (decl_id = this.variable.declarations[0]) &&\n            this.start < decl_id.start &&\n            closestParentFunctionOrProgram(this) === closestParentFunctionOrProgram(decl_id)) {\n            // a variable accessed before its declaration\n            // in the same function or at top level of module\n            return (this.isTDZAccess = true);\n        }\n        if (!this.variable.initReached) {\n            // Either a const/let TDZ violation or\n            // var use before declaration was encountered.\n            return (this.isTDZAccess = true);\n        }\n        return (this.isTDZAccess = false);\n    }\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        if (this.variable instanceof LocalVariable) {\n            // When accessing a variable from a module without side effects, this\n            // means we use an export of that module and therefore need to potentially\n            // include it in the bundle.\n            if (!this.variable.module.isExecuted) {\n                markModuleAndImpureDependenciesAsExecuted(this.variable.module);\n            }\n            this.variable.consolidateInitializers();\n            this.scope.context.requestTreeshakingPass();\n        }\n        if (this.isVariableReference) {\n            this.variable.addUsedPlace(this);\n            this.scope.context.requestTreeshakingPass();\n        }\n    }\n    disallowImportReassignment() {\n        return this.scope.context.error((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logIllegalImportReassignment)(this.name, this.scope.context.module.id), this.start);\n    }\n    getVariableRespectingTDZ() {\n        if (this.isPossibleTDZ()) {\n            return UNKNOWN_EXPRESSION;\n        }\n        return this.variable;\n    }\n    isPureFunction(path) {\n        let currentPureFunction = this.scope.context.manualPureFunctions[this.name];\n        for (const segment of path) {\n            if (currentPureFunction) {\n                if (currentPureFunction[PureFunctionKey]) {\n                    return true;\n                }\n                currentPureFunction = currentPureFunction[segment];\n            }\n            else {\n                return false;\n            }\n        }\n        return currentPureFunction?.[PureFunctionKey];\n    }\n}\nfunction closestParentFunctionOrProgram(node) {\n    while (node && !/^Program|Function/.test(node.type)) {\n        node = node.parent;\n    }\n    // one of: ArrowFunctionExpression, FunctionDeclaration, FunctionExpression or Program\n    return node;\n}\n\nclass Identifier extends IdentifierBase {\n    constructor() {\n        super(...arguments);\n        this.variable = null;\n    }\n    addExportedVariables(variables, exportNamesByVariable) {\n        if (exportNamesByVariable.has(this.variable)) {\n            variables.push(this.variable);\n        }\n    }\n    bind() {\n        if (!this.variable && is_reference(this, this.parent)) {\n            this.variable = this.scope.findVariable(this.name);\n            this.variable.addReference(this);\n            this.isVariableReference = true;\n        }\n    }\n    declare(kind, init) {\n        let variable;\n        const { treeshake } = this.scope.context.options;\n        switch (kind) {\n            case 'var': {\n                variable = this.scope.addDeclaration(this, this.scope.context, init, kind);\n                if (treeshake && treeshake.correctVarValueBeforeDeclaration) {\n                    // Necessary to make sure the init is deoptimized. We cannot call deoptimizePath here.\n                    variable.markInitializersForDeoptimization();\n                }\n                break;\n            }\n            case 'function': {\n                // in strict mode, functions are only hoisted within a scope but not across block scopes\n                variable = this.scope.addDeclaration(this, this.scope.context, init, kind);\n                break;\n            }\n            case 'let':\n            case 'const':\n            case 'using':\n            case 'await using':\n            case 'class': {\n                variable = this.scope.addDeclaration(this, this.scope.context, init, kind);\n                break;\n            }\n            case 'parameter': {\n                variable = this.scope.addParameterDeclaration(this);\n                break;\n            }\n            /* istanbul ignore next */\n            default: {\n                /* istanbul ignore next */\n                throw new Error(`Internal Error: Unexpected identifier kind ${kind}.`);\n            }\n        }\n        return [(this.variable = variable)];\n    }\n    markDeclarationReached() {\n        this.variable.initReached = true;\n    }\n    render(code, { snippets: { getPropertyAccess }, useOriginalName }, { renderedParentType, isCalleeOfRenderedParent, isShorthandProperty } = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BLANK) {\n        if (this.variable) {\n            const name = this.variable.getName(getPropertyAccess, useOriginalName);\n            if (name !== this.name) {\n                code.overwrite(this.start, this.end, name, {\n                    contentOnly: true,\n                    storeName: true\n                });\n                if (isShorthandProperty) {\n                    code.prependRight(this.start, `${this.name}: `);\n                }\n            }\n            // In strict mode, any variable named \"eval\" must be the actual \"eval\" function\n            if (name === 'eval' &&\n                renderedParentType === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.CallExpression &&\n                isCalleeOfRenderedParent) {\n                code.appendRight(this.start, '0, ');\n            }\n        }\n    }\n}\n\nconst chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$';\nconst base = 64;\nfunction toBase64(value) {\n    let outString = '';\n    do {\n        const currentDigit = value % base;\n        value = (value / base) | 0;\n        outString = chars[currentDigit] + outString;\n    } while (value !== 0);\n    return outString;\n}\n\nfunction getSafeName(baseName, usedNames, forbiddenNames) {\n    let safeName = baseName;\n    let count = 1;\n    while (usedNames.has(safeName) || RESERVED_NAMES.has(safeName) || forbiddenNames?.has(safeName)) {\n        safeName = `${baseName}$${toBase64(count++)}`;\n    }\n    usedNames.add(safeName);\n    return safeName;\n}\n\nclass Scope {\n    constructor() {\n        this.children = [];\n        this.variables = new Map();\n    }\n    /*\n    Redeclaration rules:\n    - var can redeclare var\n    - in function scopes, function and var can redeclare function and var\n    - var is hoisted across scopes, function remains in the scope it is declared\n    - var and function can redeclare function parameters, but parameters cannot redeclare parameters\n    - function cannot redeclare catch scope parameters\n    - var can redeclare catch scope parameters in a way\n        - if the parameter is an identifier and not a pattern\n        - then the variable is still declared in the hoisted outer scope, but the initializer is assigned to the parameter\n    - const, let, class, and function except in the cases above cannot redeclare anything\n     */\n    addDeclaration(identifier, context, init, kind) {\n        const name = identifier.name;\n        const existingVariable = this.hoistedVariables?.get(name) || this.variables.get(name);\n        if (existingVariable) {\n            const existingKind = existingVariable.kind;\n            if (kind === 'var' && existingKind === 'var') {\n                existingVariable.addDeclaration(identifier, init);\n                return existingVariable;\n            }\n            context.error((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logRedeclarationError)(name), identifier.start);\n        }\n        const newVariable = new LocalVariable(identifier.name, identifier, init, context, kind);\n        this.variables.set(name, newVariable);\n        return newVariable;\n    }\n    addHoistedVariable(name, variable) {\n        (this.hoistedVariables ||= new Map()).set(name, variable);\n    }\n    contains(name) {\n        return this.variables.has(name);\n    }\n    findVariable(_name) {\n        /* istanbul ignore next */\n        throw new Error('Internal Error: findVariable needs to be implemented by a subclass');\n    }\n}\n\nclass ChildScope extends Scope {\n    constructor(parent, context) {\n        super();\n        this.parent = parent;\n        this.context = context;\n        this.accessedOutsideVariables = new Map();\n        parent.children.push(this);\n    }\n    addAccessedDynamicImport(importExpression) {\n        (this.accessedDynamicImports || (this.accessedDynamicImports = new Set())).add(importExpression);\n        if (this.parent instanceof ChildScope) {\n            this.parent.addAccessedDynamicImport(importExpression);\n        }\n    }\n    addAccessedGlobals(globals, accessedGlobalsByScope) {\n        const accessedGlobals = accessedGlobalsByScope.get(this) || new Set();\n        for (const name of globals) {\n            accessedGlobals.add(name);\n        }\n        accessedGlobalsByScope.set(this, accessedGlobals);\n        if (this.parent instanceof ChildScope) {\n            this.parent.addAccessedGlobals(globals, accessedGlobalsByScope);\n        }\n    }\n    addNamespaceMemberAccess(name, variable) {\n        this.accessedOutsideVariables.set(name, variable);\n        this.parent.addNamespaceMemberAccess(name, variable);\n    }\n    addReturnExpression(expression) {\n        if (this.parent instanceof ChildScope) {\n            this.parent.addReturnExpression(expression);\n        }\n    }\n    addUsedOutsideNames(usedNames, format, exportNamesByVariable, accessedGlobalsByScope) {\n        for (const variable of this.accessedOutsideVariables.values()) {\n            if (variable.included) {\n                usedNames.add(variable.getBaseVariableName());\n                if (format === 'system' && exportNamesByVariable.has(variable)) {\n                    usedNames.add('exports');\n                }\n            }\n        }\n        const accessedGlobals = accessedGlobalsByScope.get(this);\n        if (accessedGlobals) {\n            for (const name of accessedGlobals) {\n                usedNames.add(name);\n            }\n        }\n    }\n    contains(name) {\n        return this.variables.has(name) || this.parent.contains(name);\n    }\n    deconflict(format, exportNamesByVariable, accessedGlobalsByScope) {\n        const usedNames = new Set();\n        this.addUsedOutsideNames(usedNames, format, exportNamesByVariable, accessedGlobalsByScope);\n        if (this.accessedDynamicImports) {\n            for (const importExpression of this.accessedDynamicImports) {\n                if (importExpression.inlineNamespace) {\n                    usedNames.add(importExpression.inlineNamespace.getBaseVariableName());\n                }\n            }\n        }\n        for (const [name, variable] of this.variables) {\n            if (variable.included || variable.alwaysRendered) {\n                variable.setRenderNames(null, getSafeName(name, usedNames, variable.forbiddenNames));\n            }\n        }\n        for (const scope of this.children) {\n            scope.deconflict(format, exportNamesByVariable, accessedGlobalsByScope);\n        }\n    }\n    findLexicalBoundary() {\n        return this.parent.findLexicalBoundary();\n    }\n    findGlobal(name) {\n        const variable = this.parent.findVariable(name);\n        this.accessedOutsideVariables.set(name, variable);\n        return variable;\n    }\n    findVariable(name) {\n        const knownVariable = this.variables.get(name) || this.accessedOutsideVariables.get(name);\n        if (knownVariable) {\n            return knownVariable;\n        }\n        const variable = this.parent.findVariable(name);\n        this.accessedOutsideVariables.set(name, variable);\n        return variable;\n    }\n}\n\nfunction checkEffectForNodes(nodes, context) {\n    for (const node of nodes) {\n        if (node.hasEffects(context)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nclass MethodBase extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.accessedValue = null;\n    }\n    get computed() {\n        return isFlagSet(this.flags, 1024 /* Flag.computed */);\n    }\n    set computed(value) {\n        this.flags = setFlag(this.flags, 1024 /* Flag.computed */, value);\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        if (interaction.type === INTERACTION_ACCESSED && this.kind === 'get' && path.length === 0) {\n            return this.value.deoptimizeArgumentsOnInteractionAtPath({\n                args: interaction.args,\n                type: INTERACTION_CALLED,\n                withNew: false\n            }, EMPTY_PATH, recursionTracker);\n        }\n        if (interaction.type === INTERACTION_ASSIGNED && this.kind === 'set' && path.length === 0) {\n            return this.value.deoptimizeArgumentsOnInteractionAtPath({\n                args: interaction.args,\n                type: INTERACTION_CALLED,\n                withNew: false\n            }, EMPTY_PATH, recursionTracker);\n        }\n        this.getAccessedValue()[0].deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n    }\n    // As getter properties directly receive their values from fixed function\n    // expressions, there is no known situation where a getter is deoptimized.\n    deoptimizeCache() { }\n    deoptimizePath(path) {\n        this.getAccessedValue()[0].deoptimizePath(path);\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        return this.getAccessedValue()[0].getLiteralValueAtPath(path, recursionTracker, origin);\n    }\n    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {\n        return this.getAccessedValue()[0].getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);\n    }\n    hasEffects(context) {\n        return this.key.hasEffects(context);\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        if (this.kind === 'get' && interaction.type === INTERACTION_ACCESSED && path.length === 0) {\n            return this.value.hasEffectsOnInteractionAtPath(EMPTY_PATH, {\n                args: interaction.args,\n                type: INTERACTION_CALLED,\n                withNew: false\n            }, context);\n        }\n        // setters are only called for empty paths\n        if (this.kind === 'set' && interaction.type === INTERACTION_ASSIGNED) {\n            return this.value.hasEffectsOnInteractionAtPath(EMPTY_PATH, {\n                args: interaction.args,\n                type: INTERACTION_CALLED,\n                withNew: false\n            }, context);\n        }\n        return this.getAccessedValue()[0].hasEffectsOnInteractionAtPath(path, interaction, context);\n    }\n    applyDeoptimizations() { }\n    getAccessedValue() {\n        if (this.accessedValue === null) {\n            if (this.kind === 'get') {\n                this.accessedValue = UNKNOWN_RETURN_EXPRESSION;\n                return (this.accessedValue = this.value.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_CALL, SHARED_RECURSION_TRACKER, this));\n            }\n            else {\n                return (this.accessedValue = [this.value, false]);\n            }\n        }\n        return this.accessedValue;\n    }\n}\n\nclass MethodDefinition extends MethodBase {\n    hasEffects(context) {\n        return super.hasEffects(context) || checkEffectForNodes(this.decorators, context);\n    }\n    applyDeoptimizations() { }\n}\n\nclass BlockScope extends ChildScope {\n    constructor(parent) {\n        super(parent, parent.context);\n    }\n    addDeclaration(identifier, context, init, kind) {\n        if (kind === 'var') {\n            const name = identifier.name;\n            const existingVariable = this.hoistedVariables?.get(name) || this.variables.get(name);\n            if (existingVariable) {\n                if (existingVariable.kind === 'var' ||\n                    (kind === 'var' && existingVariable.kind === 'parameter')) {\n                    existingVariable.addDeclaration(identifier, init);\n                    return existingVariable;\n                }\n                return context.error((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logRedeclarationError)(name), identifier.start);\n            }\n            const declaredVariable = this.parent.addDeclaration(identifier, context, init, kind);\n            // Necessary to make sure the init is deoptimized for conditional declarations.\n            // We cannot call deoptimizePath here.\n            declaredVariable.markInitializersForDeoptimization();\n            // We add the variable to this and all parent scopes to reliably detect conflicts\n            this.addHoistedVariable(name, declaredVariable);\n            return declaredVariable;\n        }\n        return super.addDeclaration(identifier, context, init, kind);\n    }\n}\n\nclass StaticBlock extends NodeBase {\n    createScope(parentScope) {\n        this.scope = new BlockScope(parentScope);\n    }\n    hasEffects(context) {\n        for (const node of this.body) {\n            if (node.hasEffects(context))\n                return true;\n        }\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        for (const node of this.body) {\n            if (includeChildrenRecursively || node.shouldBeIncluded(context))\n                node.include(context, includeChildrenRecursively);\n        }\n    }\n    render(code, options) {\n        if (this.body.length > 0) {\n            const bodyStartPos = findFirstOccurrenceOutsideComment(code.original.slice(this.start, this.end), '{') + 1;\n            renderStatementList(this.body, code, this.start + bodyStartPos, this.end - 1, options);\n        }\n        else {\n            super.render(code, options);\n        }\n    }\n}\nfunction isStaticBlock(statement) {\n    return statement.type === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.StaticBlock;\n}\n\nclass ObjectMember extends ExpressionEntity {\n    constructor(object, key) {\n        super();\n        this.object = object;\n        this.key = key;\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        this.object.deoptimizeArgumentsOnInteractionAtPath(interaction, [this.key, ...path], recursionTracker);\n    }\n    deoptimizePath(path) {\n        this.object.deoptimizePath([this.key, ...path]);\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        return this.object.getLiteralValueAtPath([this.key, ...path], recursionTracker, origin);\n    }\n    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {\n        return this.object.getReturnExpressionWhenCalledAtPath([this.key, ...path], interaction, recursionTracker, origin);\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        return this.object.hasEffectsOnInteractionAtPath([this.key, ...path], interaction, context);\n    }\n}\n\nclass ClassNode extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.objectEntity = null;\n    }\n    createScope(parentScope) {\n        this.scope = new ChildScope(parentScope, parentScope.context);\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n    }\n    deoptimizeCache() {\n        this.getObjectEntity().deoptimizeAllProperties();\n    }\n    deoptimizePath(path) {\n        this.getObjectEntity().deoptimizePath(path);\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);\n    }\n    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {\n        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);\n    }\n    hasEffects(context) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        const initEffect = this.superClass?.hasEffects(context) || this.body.hasEffects(context);\n        this.id?.markDeclarationReached();\n        return initEffect || super.hasEffects(context) || checkEffectForNodes(this.decorators, context);\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        return interaction.type === INTERACTION_CALLED && path.length === 0\n            ? !interaction.withNew ||\n                (this.classConstructor === null\n                    ? this.superClass?.hasEffectsOnInteractionAtPath(path, interaction, context)\n                    : this.classConstructor.hasEffectsOnInteractionAtPath(path, interaction, context)) ||\n                false\n            : this.getObjectEntity().hasEffectsOnInteractionAtPath(path, interaction, context);\n    }\n    include(context, includeChildrenRecursively) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        this.included = true;\n        this.superClass?.include(context, includeChildrenRecursively);\n        this.body.include(context, includeChildrenRecursively);\n        for (const decorator of this.decorators)\n            decorator.include(context, includeChildrenRecursively);\n        if (this.id) {\n            this.id.markDeclarationReached();\n            this.id.include();\n        }\n    }\n    initialise() {\n        super.initialise();\n        this.id?.declare('class', this);\n        for (const method of this.body.body) {\n            if (method instanceof MethodDefinition && method.kind === 'constructor') {\n                this.classConstructor = method;\n                return;\n            }\n        }\n        this.classConstructor = null;\n    }\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        for (const definition of this.body.body) {\n            if (!isStaticBlock(definition) &&\n                !(definition.static ||\n                    (definition instanceof MethodDefinition && definition.kind === 'constructor'))) {\n                // Calls to methods are not tracked, ensure that the return value is deoptimized\n                definition.deoptimizePath(UNKNOWN_PATH);\n            }\n        }\n        this.scope.context.requestTreeshakingPass();\n    }\n    getObjectEntity() {\n        if (this.objectEntity !== null) {\n            return this.objectEntity;\n        }\n        const staticProperties = [];\n        const dynamicMethods = [];\n        for (const definition of this.body.body) {\n            if (isStaticBlock(definition))\n                continue;\n            const properties = definition.static ? staticProperties : dynamicMethods;\n            const definitionKind = definition.kind;\n            // Note that class fields do not end up on the prototype\n            if (properties === dynamicMethods && !definitionKind)\n                continue;\n            const kind = definitionKind === 'set' || definitionKind === 'get' ? definitionKind : 'init';\n            let key;\n            if (definition.computed) {\n                const keyValue = definition.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);\n                if (typeof keyValue === 'symbol') {\n                    properties.push({ key: UnknownKey, kind, property: definition });\n                    continue;\n                }\n                else {\n                    key = String(keyValue);\n                }\n            }\n            else {\n                key =\n                    definition.key instanceof Identifier\n                        ? definition.key.name\n                        : String(definition.key.value);\n            }\n            properties.push({ key, kind, property: definition });\n        }\n        staticProperties.unshift({\n            key: 'prototype',\n            kind: 'init',\n            property: new ObjectEntity(dynamicMethods, this.superClass ? new ObjectMember(this.superClass, 'prototype') : OBJECT_PROTOTYPE)\n        });\n        return (this.objectEntity = new ObjectEntity(staticProperties, this.superClass || OBJECT_PROTOTYPE));\n    }\n}\n\nclass ClassDeclaration extends ClassNode {\n    initialise() {\n        super.initialise();\n        if (this.id !== null) {\n            this.id.variable.isId = true;\n        }\n    }\n    parseNode(esTreeNode) {\n        if (esTreeNode.id !== null) {\n            this.id = new Identifier(this, this.scope.parent).parseNode(esTreeNode.id);\n        }\n        return super.parseNode(esTreeNode);\n    }\n    render(code, options) {\n        const { exportNamesByVariable, format, snippets: { _, getPropertyAccess } } = options;\n        if (this.id) {\n            const { variable, name } = this.id;\n            if (format === 'system' && exportNamesByVariable.has(variable)) {\n                code.appendLeft(this.end, `${_}${getSystemExportStatement([variable], options)};`);\n            }\n            const renderedVariable = variable.getName(getPropertyAccess);\n            if (renderedVariable !== name) {\n                this.decorators.map(decorator => decorator.render(code, options));\n                this.superClass?.render(code, options);\n                this.body.render(code, {\n                    ...options,\n                    useOriginalName: (_variable) => _variable === variable\n                });\n                code.prependRight(this.start, `let ${renderedVariable}${_}=${_}`);\n                code.prependLeft(this.end, ';');\n                return;\n            }\n        }\n        super.render(code, options);\n    }\n    applyDeoptimizations() {\n        super.applyDeoptimizations();\n        const { id, scope } = this;\n        if (id) {\n            const { name, variable } = id;\n            for (const accessedVariable of scope.accessedOutsideVariables.values()) {\n                if (accessedVariable !== variable) {\n                    accessedVariable.forbidName(name);\n                }\n            }\n        }\n    }\n}\n\nclass ArgumentsVariable extends LocalVariable {\n    constructor(context) {\n        super('arguments', null, UNKNOWN_EXPRESSION, context, 'other');\n        this.deoptimizedArguments = [];\n    }\n    addArgumentToBeDeoptimized(argument) {\n        if (this.included) {\n            argument.deoptimizePath(UNKNOWN_PATH);\n        }\n        else {\n            this.deoptimizedArguments.push(argument);\n        }\n    }\n    hasEffectsOnInteractionAtPath(path, { type }) {\n        return type !== INTERACTION_ACCESSED || path.length > 1;\n    }\n    include() {\n        super.include();\n        for (const argument of this.deoptimizedArguments) {\n            argument.deoptimizePath(UNKNOWN_PATH);\n        }\n        this.deoptimizedArguments.length = 0;\n    }\n}\n\nconst MAX_TRACKED_INTERACTIONS = 20;\nconst NO_INTERACTIONS = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY;\nconst UNKNOWN_DEOPTIMIZED_FIELD = new Set([UnknownKey]);\nconst EMPTY_PATH_TRACKER = new PathTracker();\nconst UNKNOWN_DEOPTIMIZED_ENTITY = new Set([UNKNOWN_EXPRESSION]);\nclass ParameterVariable extends LocalVariable {\n    constructor(name, declarator, context) {\n        super(name, declarator, UNKNOWN_EXPRESSION, context, 'parameter');\n        this.deoptimizationInteractions = [];\n        this.deoptimizations = new PathTracker();\n        this.deoptimizedFields = new Set();\n        this.entitiesToBeDeoptimized = new Set();\n        this.expressionsUseTheKnownValue = [];\n        this.knownValue = null;\n        this.knownValueLiteral = UnknownValue;\n        this.frozenValue = null;\n    }\n    addEntityToBeDeoptimized(entity) {\n        if (entity === UNKNOWN_EXPRESSION) {\n            // As unknown expressions fully deoptimize all interactions, we can clear\n            // the interaction cache at this point provided we keep this optimization\n            // in mind when adding new interactions\n            if (!this.entitiesToBeDeoptimized.has(UNKNOWN_EXPRESSION)) {\n                this.entitiesToBeDeoptimized.add(UNKNOWN_EXPRESSION);\n                for (const { interaction } of this.deoptimizationInteractions) {\n                    deoptimizeInteraction(interaction);\n                }\n                this.deoptimizationInteractions = NO_INTERACTIONS;\n            }\n        }\n        else if (this.deoptimizedFields.has(UnknownKey)) {\n            // This means that we already deoptimized all interactions and no longer\n            // track them\n            entity.deoptimizePath(UNKNOWN_PATH);\n        }\n        else if (!this.entitiesToBeDeoptimized.has(entity)) {\n            this.entitiesToBeDeoptimized.add(entity);\n            for (const field of this.deoptimizedFields) {\n                entity.deoptimizePath([field]);\n            }\n            for (const { interaction, path } of this.deoptimizationInteractions) {\n                entity.deoptimizeArgumentsOnInteractionAtPath(interaction, path, SHARED_RECURSION_TRACKER);\n            }\n        }\n    }\n    markReassigned() {\n        if (this.isReassigned) {\n            return;\n        }\n        super.markReassigned();\n        for (const expression of this.expressionsUseTheKnownValue) {\n            expression.deoptimizeCache();\n        }\n        this.expressionsUseTheKnownValue = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY;\n    }\n    deoptimizeCache() {\n        this.markReassigned();\n    }\n    /**\n     * Update the known value of the parameter variable.\n     * Must be called for every function call, so it can track all the arguments,\n     * and deoptimizeCache itself to mark reassigned if the argument is changed.\n     * @param argument The argument of the function call\n     */\n    updateKnownValue(argument) {\n        if (this.isReassigned) {\n            return;\n        }\n        if (this.knownValue === null) {\n            this.knownValue = argument;\n            this.knownValueLiteral = argument.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);\n            return;\n        }\n        // the same literal or identifier, do nothing\n        if (this.knownValue === argument ||\n            (this.knownValue instanceof Identifier &&\n                argument instanceof Identifier &&\n                this.knownValue.variable === argument.variable)) {\n            return;\n        }\n        const oldValue = this.knownValueLiteral;\n        if (typeof oldValue === 'symbol') {\n            this.markReassigned();\n            return;\n        }\n        // add tracking for the new argument\n        const newValue = argument.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);\n        if (newValue !== oldValue) {\n            this.markReassigned();\n        }\n    }\n    /**\n     * This function freezes the known value of the parameter variable,\n     * so the optimization starts with a certain ExpressionEntity.\n     * The optimization can be undone by calling `markReassigned`.\n     * @returns the frozen value\n     */\n    getKnownValue() {\n        if (this.frozenValue === null) {\n            this.frozenValue = this.knownValue || UNKNOWN_EXPRESSION;\n        }\n        return this.frozenValue;\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        if (this.isReassigned) {\n            return UnknownValue;\n        }\n        const knownValue = this.getKnownValue();\n        this.expressionsUseTheKnownValue.push(origin);\n        return recursionTracker.withTrackedEntityAtPath(path, knownValue, () => knownValue.getLiteralValueAtPath(path, recursionTracker, origin), UnknownValue);\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        if (this.isReassigned || interaction.type === INTERACTION_ASSIGNED) {\n            return super.hasEffectsOnInteractionAtPath(path, interaction, context);\n        }\n        const knownValue = this.getKnownValue();\n        return knownValue.hasEffectsOnInteractionAtPath(path, interaction, context);\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path) {\n        // For performance reasons, we fully deoptimize all deeper interactions\n        if (path.length >= 2 ||\n            this.entitiesToBeDeoptimized.has(UNKNOWN_EXPRESSION) ||\n            this.deoptimizationInteractions.length >= MAX_TRACKED_INTERACTIONS ||\n            (path.length === 1 &&\n                (this.deoptimizedFields.has(UnknownKey) ||\n                    (interaction.type === INTERACTION_CALLED && this.deoptimizedFields.has(path[0]))))) {\n            deoptimizeInteraction(interaction);\n            return;\n        }\n        if (!this.deoptimizations.trackEntityAtPathAndGetIfTracked(path, interaction.args)) {\n            for (const entity of this.entitiesToBeDeoptimized) {\n                entity.deoptimizeArgumentsOnInteractionAtPath(interaction, path, SHARED_RECURSION_TRACKER);\n            }\n            if (!this.entitiesToBeDeoptimized.has(UNKNOWN_EXPRESSION)) {\n                this.deoptimizationInteractions.push({\n                    interaction,\n                    path\n                });\n            }\n        }\n    }\n    deoptimizePath(path) {\n        if (path.length === 0) {\n            this.markReassigned();\n            return;\n        }\n        if (this.deoptimizedFields.has(UnknownKey)) {\n            return;\n        }\n        const key = path[0];\n        if (this.deoptimizedFields.has(key)) {\n            return;\n        }\n        this.deoptimizedFields.add(key);\n        for (const entity of this.entitiesToBeDeoptimized) {\n            // We do not need a recursion tracker here as we already track whether\n            // this field is deoptimized\n            entity.deoptimizePath([key]);\n        }\n        if (key === UnknownKey) {\n            // save some memory\n            this.deoptimizationInteractions = NO_INTERACTIONS;\n            this.deoptimizations = EMPTY_PATH_TRACKER;\n            this.deoptimizedFields = UNKNOWN_DEOPTIMIZED_FIELD;\n            this.entitiesToBeDeoptimized = UNKNOWN_DEOPTIMIZED_ENTITY;\n        }\n    }\n    getReturnExpressionWhenCalledAtPath(path) {\n        // We deoptimize everything that is called as that will trivially deoptimize\n        // the corresponding return expressions as well and avoid badly performing\n        // and complicated alternatives\n        if (path.length === 0) {\n            this.deoptimizePath(UNKNOWN_PATH);\n        }\n        else if (!this.deoptimizedFields.has(path[0])) {\n            this.deoptimizePath([path[0]]);\n        }\n        return UNKNOWN_RETURN_EXPRESSION;\n    }\n}\n\nclass ThisVariable extends ParameterVariable {\n    constructor(context) {\n        super('this', null, context);\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        return (context.replacedVariableInits.get(this) || UNKNOWN_EXPRESSION).hasEffectsOnInteractionAtPath(path, interaction, context);\n    }\n}\n\nclass CatchBodyScope extends ChildScope {\n    constructor(parent) {\n        super(parent, parent.context);\n        this.parent = parent;\n    }\n    addDeclaration(identifier, context, init, kind) {\n        if (kind === 'var') {\n            const name = identifier.name;\n            const existingVariable = this.hoistedVariables?.get(name) || this.variables.get(name);\n            if (existingVariable) {\n                const existingKind = existingVariable.kind;\n                if (existingKind === 'parameter' &&\n                    // If this is a destructured parameter, it is forbidden to redeclare\n                    existingVariable.declarations[0].parent.type === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.CatchClause) {\n                    // If this is a var with the same name as the catch scope parameter,\n                    // the assignment actually goes to the parameter and the var is\n                    // hoisted without assignment. Locally, it is shadowed by the\n                    // parameter\n                    const declaredVariable = this.parent.parent.addDeclaration(identifier, context, UNDEFINED_EXPRESSION, kind);\n                    // To avoid the need to rewrite the declaration, we link the variable\n                    // names. If we ever implement a logic that splits initialization and\n                    // assignment for hoisted vars, the \"renderLikeHoisted\" logic can be\n                    // removed again.\n                    // We do not need to check whether there already is a linked\n                    // variable because then declaredVariable would be that linked\n                    // variable.\n                    existingVariable.renderLikeHoisted(declaredVariable);\n                    this.addHoistedVariable(name, declaredVariable);\n                    return declaredVariable;\n                }\n                if (existingKind === 'var') {\n                    existingVariable.addDeclaration(identifier, init);\n                    return existingVariable;\n                }\n                return context.error((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logRedeclarationError)(name), identifier.start);\n            }\n            // We only add parameters to parameter scopes\n            const declaredVariable = this.parent.parent.addDeclaration(identifier, context, init, kind);\n            // Necessary to make sure the init is deoptimized for conditional declarations.\n            // We cannot call deoptimizePath here.\n            declaredVariable.markInitializersForDeoptimization();\n            // We add the variable to this and all parent scopes to reliably detect conflicts\n            this.addHoistedVariable(name, declaredVariable);\n            return declaredVariable;\n        }\n        return super.addDeclaration(identifier, context, init, kind);\n    }\n}\n\nclass FunctionBodyScope extends ChildScope {\n    constructor(parent) {\n        super(parent, parent.context);\n    }\n    // There is stuff that is only allowed in function scopes, i.e. functions can\n    // be redeclared, functions and var can redeclare each other\n    addDeclaration(identifier, context, init, kind) {\n        const name = identifier.name;\n        const existingVariable = this.hoistedVariables?.get(name) || this.variables.get(name);\n        if (existingVariable) {\n            const existingKind = existingVariable.kind;\n            if ((kind === 'var' || kind === 'function') &&\n                (existingKind === 'var' || existingKind === 'function' || existingKind === 'parameter')) {\n                existingVariable.addDeclaration(identifier, init);\n                return existingVariable;\n            }\n            context.error((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logRedeclarationError)(name), identifier.start);\n        }\n        const newVariable = new LocalVariable(identifier.name, identifier, init, context, kind);\n        this.variables.set(name, newVariable);\n        return newVariable;\n    }\n}\n\nclass ParameterScope extends ChildScope {\n    constructor(parent, isCatchScope) {\n        super(parent, parent.context);\n        this.parameters = [];\n        this.hasRest = false;\n        this.bodyScope = isCatchScope ? new CatchBodyScope(this) : new FunctionBodyScope(this);\n    }\n    /**\n     * Adds a parameter to this scope. Parameters must be added in the correct\n     * order, i.e. from left to right.\n     */\n    addParameterDeclaration(identifier) {\n        const { name, start } = identifier;\n        const existingParameter = this.variables.get(name);\n        if (existingParameter) {\n            return this.context.error((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logDuplicateArgumentNameError)(name), start);\n        }\n        const variable = new ParameterVariable(name, identifier, this.context);\n        this.variables.set(name, variable);\n        // We also add it to the body scope to detect name conflicts with local\n        // variables. We still need the intermediate scope, though, as parameter\n        // defaults are NOT taken from the body scope but from the parameters or\n        // outside scope.\n        this.bodyScope.addHoistedVariable(name, variable);\n        return variable;\n    }\n    addParameterVariables(parameters, hasRest) {\n        this.parameters = parameters;\n        for (const parameterList of parameters) {\n            for (const parameter of parameterList) {\n                parameter.alwaysRendered = true;\n            }\n        }\n        this.hasRest = hasRest;\n    }\n    includeCallArguments(context, parameters) {\n        let calledFromTryStatement = false;\n        let argumentIncluded = false;\n        const restParameter = this.hasRest && this.parameters[this.parameters.length - 1];\n        for (const checkedArgument of parameters) {\n            if (checkedArgument instanceof SpreadElement) {\n                for (const argument of parameters) {\n                    argument.include(context, false);\n                }\n                break;\n            }\n        }\n        for (let index = parameters.length - 1; index >= 0; index--) {\n            const parameterVariables = this.parameters[index] || restParameter;\n            const argument = parameters[index];\n            if (parameterVariables) {\n                calledFromTryStatement = false;\n                if (parameterVariables.length === 0) {\n                    // handle empty destructuring\n                    argumentIncluded = true;\n                }\n                else {\n                    for (const variable of parameterVariables) {\n                        if (variable.included) {\n                            argumentIncluded = true;\n                        }\n                        if (variable.calledFromTryStatement) {\n                            calledFromTryStatement = true;\n                        }\n                    }\n                }\n            }\n            if (!argumentIncluded && argument.shouldBeIncluded(context)) {\n                argumentIncluded = true;\n            }\n            if (argumentIncluded) {\n                argument.include(context, calledFromTryStatement);\n            }\n        }\n    }\n}\n\nclass ReturnValueScope extends ParameterScope {\n    constructor() {\n        super(...arguments);\n        this.returnExpression = null;\n        this.returnExpressions = [];\n    }\n    addReturnExpression(expression) {\n        this.returnExpressions.push(expression);\n    }\n    getReturnExpression() {\n        if (this.returnExpression === null)\n            this.updateReturnExpression();\n        return this.returnExpression;\n    }\n    updateReturnExpression() {\n        if (this.returnExpressions.length === 1) {\n            this.returnExpression = this.returnExpressions[0];\n        }\n        else {\n            this.returnExpression = UNKNOWN_EXPRESSION;\n            for (const expression of this.returnExpressions) {\n                expression.deoptimizePath(UNKNOWN_PATH);\n            }\n        }\n    }\n}\n\nclass FunctionScope extends ReturnValueScope {\n    constructor(parent) {\n        const { context } = parent;\n        super(parent, false);\n        this.variables.set('arguments', (this.argumentsVariable = new ArgumentsVariable(context)));\n        this.variables.set('this', (this.thisVariable = new ThisVariable(context)));\n    }\n    findLexicalBoundary() {\n        return this;\n    }\n    includeCallArguments(context, parameters) {\n        super.includeCallArguments(context, parameters);\n        if (this.argumentsVariable.included) {\n            for (const argument of parameters) {\n                if (!argument.included) {\n                    argument.include(context, false);\n                }\n            }\n        }\n    }\n}\n\nclass ExpressionStatement extends NodeBase {\n    initialise() {\n        super.initialise();\n        if (this.directive &&\n            this.directive !== 'use strict' &&\n            this.parent.type === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.Program) {\n            this.scope.context.log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, \n            // This is necessary, because either way (deleting or not) can lead to errors.\n            (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logModuleLevelDirective)(this.directive, this.scope.context.module.id), this.start);\n        }\n    }\n    removeAnnotations(code) {\n        this.expression.removeAnnotations(code);\n    }\n    render(code, options) {\n        super.render(code, options);\n        if (code.original[this.end - 1] !== ';') {\n            code.appendLeft(this.end, ';');\n        }\n    }\n    shouldBeIncluded(context) {\n        if (this.directive && this.directive !== 'use strict')\n            return this.parent.type !== _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.Program;\n        return super.shouldBeIncluded(context);\n    }\n    applyDeoptimizations() { }\n}\n\nclass BlockStatement extends NodeBase {\n    get deoptimizeBody() {\n        return isFlagSet(this.flags, 32768 /* Flag.deoptimizeBody */);\n    }\n    set deoptimizeBody(value) {\n        this.flags = setFlag(this.flags, 32768 /* Flag.deoptimizeBody */, value);\n    }\n    get directlyIncluded() {\n        return isFlagSet(this.flags, 16384 /* Flag.directlyIncluded */);\n    }\n    set directlyIncluded(value) {\n        this.flags = setFlag(this.flags, 16384 /* Flag.directlyIncluded */, value);\n    }\n    addImplicitReturnExpressionToScope() {\n        const lastStatement = this.body[this.body.length - 1];\n        if (!lastStatement || lastStatement.type !== _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.ReturnStatement) {\n            this.scope.addReturnExpression(UNKNOWN_EXPRESSION);\n        }\n    }\n    createScope(parentScope) {\n        this.scope = this.parent.preventChildBlockScope\n            ? parentScope\n            : new BlockScope(parentScope);\n    }\n    hasEffects(context) {\n        if (this.deoptimizeBody)\n            return true;\n        for (const node of this.body) {\n            if (context.brokenFlow)\n                break;\n            if (node.hasEffects(context))\n                return true;\n        }\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        if (!(this.deoptimizeBody && this.directlyIncluded)) {\n            this.included = true;\n            this.directlyIncluded = true;\n            if (this.deoptimizeBody)\n                includeChildrenRecursively = true;\n            for (const node of this.body) {\n                if (includeChildrenRecursively || node.shouldBeIncluded(context))\n                    node.include(context, includeChildrenRecursively);\n            }\n        }\n    }\n    initialise() {\n        super.initialise();\n        const firstBodyStatement = this.body[0];\n        this.deoptimizeBody =\n            firstBodyStatement instanceof ExpressionStatement &&\n                firstBodyStatement.directive === 'use asm';\n    }\n    render(code, options) {\n        if (this.body.length > 0) {\n            renderStatementList(this.body, code, this.start + 1, this.end - 1, options);\n        }\n        else {\n            super.render(code, options);\n        }\n    }\n}\n\nclass RestElement extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.declarationInit = null;\n    }\n    addExportedVariables(variables, exportNamesByVariable) {\n        this.argument.addExportedVariables(variables, exportNamesByVariable);\n    }\n    declare(kind, init) {\n        this.declarationInit = init;\n        return this.argument.declare(kind, UNKNOWN_EXPRESSION);\n    }\n    deoptimizePath(path) {\n        if (path.length === 0) {\n            this.argument.deoptimizePath(EMPTY_PATH);\n        }\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        return (path.length > 0 ||\n            this.argument.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context));\n    }\n    markDeclarationReached() {\n        this.argument.markDeclarationReached();\n    }\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        if (this.declarationInit !== null) {\n            this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);\n            this.scope.context.requestTreeshakingPass();\n        }\n    }\n}\n\nclass FunctionBase extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.objectEntity = null;\n        this.parameterVariableValuesDeoptimized = false;\n    }\n    get async() {\n        return isFlagSet(this.flags, 256 /* Flag.async */);\n    }\n    set async(value) {\n        this.flags = setFlag(this.flags, 256 /* Flag.async */, value);\n    }\n    get deoptimizedReturn() {\n        return isFlagSet(this.flags, 512 /* Flag.deoptimizedReturn */);\n    }\n    set deoptimizedReturn(value) {\n        this.flags = setFlag(this.flags, 512 /* Flag.deoptimizedReturn */, value);\n    }\n    get generator() {\n        return isFlagSet(this.flags, 4194304 /* Flag.generator */);\n    }\n    set generator(value) {\n        this.flags = setFlag(this.flags, 4194304 /* Flag.generator */, value);\n    }\n    updateParameterVariableValues(_arguments) {\n        for (let position = 0; position < this.params.length; position++) {\n            const parameter = this.params[position];\n            if (!(parameter instanceof Identifier)) {\n                continue;\n            }\n            const parameterVariable = parameter.variable;\n            const argument = _arguments[position + 1] ?? UNDEFINED_EXPRESSION;\n            parameterVariable.updateKnownValue(argument);\n        }\n    }\n    deoptimizeParameterVariableValues() {\n        for (const parameter of this.params) {\n            if (parameter instanceof Identifier) {\n                const parameterVariable = parameter.variable;\n                parameterVariable.markReassigned();\n            }\n        }\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        if (interaction.type === INTERACTION_CALLED) {\n            const { parameters } = this.scope;\n            const { args } = interaction;\n            let hasRest = false;\n            for (let position = 0; position < args.length - 1; position++) {\n                const parameter = this.params[position];\n                // Only the \"this\" argument arg[0] can be null\n                const argument = args[position + 1];\n                if (argument instanceof SpreadElement) {\n                    this.deoptimizeParameterVariableValues();\n                }\n                if (hasRest || parameter instanceof RestElement) {\n                    hasRest = true;\n                    argument.deoptimizePath(UNKNOWN_PATH);\n                }\n                else if (parameter instanceof Identifier) {\n                    parameters[position][0].addEntityToBeDeoptimized(argument);\n                    this.addArgumentToBeDeoptimized(argument);\n                }\n                else if (parameter) {\n                    argument.deoptimizePath(UNKNOWN_PATH);\n                }\n                else {\n                    this.addArgumentToBeDeoptimized(argument);\n                }\n            }\n            this.updateParameterVariableValues(args);\n        }\n        else {\n            this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n        }\n    }\n    deoptimizePath(path) {\n        this.getObjectEntity().deoptimizePath(path);\n        if (path.length === 1 && path[0] === UnknownKey) {\n            // A reassignment of UNKNOWN_PATH is considered equivalent to having lost track\n            // which means the return expression and parameters need to be reassigned\n            this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);\n            for (const parameterList of this.scope.parameters) {\n                for (const parameter of parameterList) {\n                    parameter.deoptimizePath(UNKNOWN_PATH);\n                    parameter.markReassigned();\n                }\n            }\n        }\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);\n    }\n    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {\n        if (path.length > 0) {\n            return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);\n        }\n        if (this.async) {\n            if (!this.deoptimizedReturn) {\n                this.deoptimizedReturn = true;\n                this.scope.getReturnExpression().deoptimizePath(UNKNOWN_PATH);\n                this.scope.context.requestTreeshakingPass();\n            }\n            return UNKNOWN_RETURN_EXPRESSION;\n        }\n        return [this.scope.getReturnExpression(), false];\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        if (path.length > 0 || interaction.type !== INTERACTION_CALLED) {\n            return this.getObjectEntity().hasEffectsOnInteractionAtPath(path, interaction, context);\n        }\n        if (this.annotationNoSideEffects) {\n            return false;\n        }\n        if (this.async) {\n            const { propertyReadSideEffects } = this.scope.context.options\n                .treeshake;\n            const returnExpression = this.scope.getReturnExpression();\n            if (returnExpression.hasEffectsOnInteractionAtPath(['then'], NODE_INTERACTION_UNKNOWN_CALL, context) ||\n                (propertyReadSideEffects &&\n                    (propertyReadSideEffects === 'always' ||\n                        returnExpression.hasEffectsOnInteractionAtPath(['then'], NODE_INTERACTION_UNKNOWN_ACCESS, context)))) {\n                return true;\n            }\n        }\n        for (const parameter of this.params) {\n            if (parameter.hasEffects(context))\n                return true;\n        }\n        return false;\n    }\n    /**\n     * If the function (expression or declaration) is only used as function calls\n     */\n    onlyFunctionCallUsed() {\n        let variable = null;\n        if (this.parent.type === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.VariableDeclarator) {\n            variable = this.parent.id.variable ?? null;\n        }\n        if (this.parent.type === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.ExportDefaultDeclaration) {\n            variable = this.parent.variable;\n        }\n        return variable?.getOnlyFunctionCallUsed() ?? false;\n    }\n    include(context, includeChildrenRecursively) {\n        if (!this.parameterVariableValuesDeoptimized && !this.onlyFunctionCallUsed()) {\n            this.parameterVariableValuesDeoptimized = true;\n            this.deoptimizeParameterVariableValues();\n        }\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        this.included = true;\n        const { brokenFlow } = context;\n        context.brokenFlow = false;\n        this.body.include(context, includeChildrenRecursively);\n        context.brokenFlow = brokenFlow;\n    }\n    includeCallArguments(context, parameters) {\n        this.scope.includeCallArguments(context, parameters);\n    }\n    initialise() {\n        super.initialise();\n        if (this.body instanceof BlockStatement) {\n            this.body.addImplicitReturnExpressionToScope();\n        }\n        else {\n            this.scope.addReturnExpression(this.body);\n        }\n        if (this.annotations &&\n            this.scope.context.options.treeshake.annotations) {\n            this.annotationNoSideEffects = this.annotations.some(comment => comment.type === 'noSideEffects');\n        }\n    }\n    parseNode(esTreeNode) {\n        const { body, params } = esTreeNode;\n        const { scope } = this;\n        const { bodyScope, context } = scope;\n        // We need to ensure that parameters are declared before the body is parsed\n        // so that the scope already knows all parameters and can detect conflicts\n        // when parsing the body.\n        const parameters = (this.params = params.map((parameter) => new (context.getNodeConstructor(parameter.type))(this, scope).parseNode(parameter)));\n        scope.addParameterVariables(parameters.map(parameter => parameter.declare('parameter', UNKNOWN_EXPRESSION)), parameters[parameters.length - 1] instanceof RestElement);\n        this.body = new (context.getNodeConstructor(body.type))(this, bodyScope).parseNode(body);\n        return super.parseNode(esTreeNode);\n    }\n    addArgumentToBeDeoptimized(_argument) { }\n    applyDeoptimizations() { }\n}\nFunctionBase.prototype.preventChildBlockScope = true;\n\nclass FunctionNode extends FunctionBase {\n    constructor() {\n        super(...arguments);\n        this.objectEntity = null;\n    }\n    createScope(parentScope) {\n        this.scope = new FunctionScope(parentScope);\n        this.constructedEntity = new ObjectEntity(Object.create(null), OBJECT_PROTOTYPE);\n        // This makes sure that all deoptimizations of \"this\" are applied to the\n        // constructed entity.\n        this.scope.thisVariable.addEntityToBeDeoptimized(this.constructedEntity);\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        super.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n        if (interaction.type === INTERACTION_CALLED && path.length === 0 && interaction.args[0]) {\n            // args[0] is the \"this\" argument\n            this.scope.thisVariable.addEntityToBeDeoptimized(interaction.args[0]);\n        }\n    }\n    hasEffects(context) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        if (this.annotationNoSideEffects) {\n            return false;\n        }\n        return !!this.id?.hasEffects(context);\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        if (super.hasEffectsOnInteractionAtPath(path, interaction, context))\n            return true;\n        if (this.annotationNoSideEffects) {\n            return false;\n        }\n        if (interaction.type === INTERACTION_CALLED) {\n            const thisInit = context.replacedVariableInits.get(this.scope.thisVariable);\n            context.replacedVariableInits.set(this.scope.thisVariable, interaction.withNew ? this.constructedEntity : UNKNOWN_EXPRESSION);\n            const { brokenFlow, ignore, replacedVariableInits } = context;\n            context.ignore = {\n                breaks: false,\n                continues: false,\n                labels: new Set(),\n                returnYield: true,\n                this: interaction.withNew\n            };\n            if (this.body.hasEffects(context))\n                return true;\n            context.brokenFlow = brokenFlow;\n            if (thisInit) {\n                replacedVariableInits.set(this.scope.thisVariable, thisInit);\n            }\n            else {\n                replacedVariableInits.delete(this.scope.thisVariable);\n            }\n            context.ignore = ignore;\n        }\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        super.include(context, includeChildrenRecursively);\n        this.id?.include();\n        const hasArguments = this.scope.argumentsVariable.included;\n        for (const parameter of this.params) {\n            if (!(parameter instanceof Identifier) || hasArguments) {\n                parameter.include(context, includeChildrenRecursively);\n            }\n        }\n    }\n    initialise() {\n        super.initialise();\n        this.id?.declare('function', this);\n    }\n    addArgumentToBeDeoptimized(argument) {\n        this.scope.argumentsVariable.addArgumentToBeDeoptimized(argument);\n    }\n    getObjectEntity() {\n        if (this.objectEntity !== null) {\n            return this.objectEntity;\n        }\n        return (this.objectEntity = new ObjectEntity([\n            {\n                key: 'prototype',\n                kind: 'init',\n                property: new ObjectEntity([], OBJECT_PROTOTYPE)\n            }\n        ], OBJECT_PROTOTYPE));\n    }\n}\n\nclass FunctionDeclaration extends FunctionNode {\n    initialise() {\n        super.initialise();\n        if (this.id !== null) {\n            this.id.variable.isId = true;\n        }\n    }\n    onlyFunctionCallUsed() {\n        // call super.onlyFunctionCallUsed for export default anonymous function\n        return this.id?.variable.getOnlyFunctionCallUsed() ?? super.onlyFunctionCallUsed();\n    }\n    parseNode(esTreeNode) {\n        if (esTreeNode.id !== null) {\n            this.id = new Identifier(this, this.scope.parent).parseNode(esTreeNode.id);\n        }\n        return super.parseNode(esTreeNode);\n    }\n}\n\n// The header ends at the first non-white-space after \"default\"\nfunction getDeclarationStart(code, start) {\n    return findNonWhiteSpace(code, findFirstOccurrenceOutsideComment(code, 'default', start) + 7);\n}\nfunction getFunctionIdInsertPosition(code, start) {\n    const declarationEnd = findFirstOccurrenceOutsideComment(code, 'function', start) + 'function'.length;\n    code = code.slice(declarationEnd, findFirstOccurrenceOutsideComment(code, '(', declarationEnd));\n    const generatorStarPos = findFirstOccurrenceOutsideComment(code, '*');\n    if (generatorStarPos === -1) {\n        return declarationEnd;\n    }\n    return declarationEnd + generatorStarPos + 1;\n}\nclass ExportDefaultDeclaration extends NodeBase {\n    include(context, includeChildrenRecursively) {\n        super.include(context, includeChildrenRecursively);\n        if (includeChildrenRecursively) {\n            this.scope.context.includeVariableInModule(this.variable);\n        }\n    }\n    initialise() {\n        super.initialise();\n        const declaration = this.declaration;\n        this.declarationName =\n            (declaration.id && declaration.id.name) || this.declaration.name;\n        this.variable = this.scope.addExportDefaultDeclaration(this.declarationName || this.scope.context.getModuleName(), this, this.scope.context);\n        this.scope.context.addExport(this);\n    }\n    removeAnnotations(code) {\n        this.declaration.removeAnnotations(code);\n    }\n    render(code, options, nodeRenderOptions) {\n        const { start, end } = nodeRenderOptions;\n        const declarationStart = getDeclarationStart(code.original, this.start);\n        if (this.declaration instanceof FunctionDeclaration) {\n            this.renderNamedDeclaration(code, declarationStart, this.declaration.id === null\n                ? getFunctionIdInsertPosition(code.original, declarationStart)\n                : null, options);\n        }\n        else if (this.declaration instanceof ClassDeclaration) {\n            this.renderNamedDeclaration(code, declarationStart, this.declaration.id === null\n                ? findFirstOccurrenceOutsideComment(code.original, 'class', start) + 'class'.length\n                : null, options);\n        }\n        else if (this.variable.getOriginalVariable() !== this.variable) {\n            // Remove altogether to prevent re-declaring the same variable\n            treeshakeNode(this, code, start, end);\n            return;\n        }\n        else if (this.variable.included) {\n            this.renderVariableDeclaration(code, declarationStart, options);\n        }\n        else {\n            code.remove(this.start, declarationStart);\n            this.declaration.render(code, options, {\n                renderedSurroundingElement: _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.ExpressionStatement\n            });\n            if (code.original[this.end - 1] !== ';') {\n                code.appendLeft(this.end, ';');\n            }\n            return;\n        }\n        this.declaration.render(code, options);\n    }\n    applyDeoptimizations() { }\n    renderNamedDeclaration(code, declarationStart, idInsertPosition, options) {\n        const { exportNamesByVariable, format, snippets: { getPropertyAccess } } = options;\n        const name = this.variable.getName(getPropertyAccess);\n        // Remove `export default`\n        code.remove(this.start, declarationStart);\n        if (idInsertPosition !== null) {\n            code.appendLeft(idInsertPosition, ` ${name}`);\n        }\n        if (format === 'system' &&\n            this.declaration instanceof ClassDeclaration &&\n            exportNamesByVariable.has(this.variable)) {\n            code.appendLeft(this.end, ` ${getSystemExportStatement([this.variable], options)};`);\n        }\n    }\n    renderVariableDeclaration(code, declarationStart, { format, exportNamesByVariable, snippets: { cnst, getPropertyAccess } }) {\n        const hasTrailingSemicolon = code.original.charCodeAt(this.end - 1) === 59; /*\";\"*/\n        const systemExportNames = format === 'system' && exportNamesByVariable.get(this.variable);\n        if (systemExportNames) {\n            code.overwrite(this.start, declarationStart, `${cnst} ${this.variable.getName(getPropertyAccess)} = exports(${JSON.stringify(systemExportNames[0])}, `);\n            code.appendRight(hasTrailingSemicolon ? this.end - 1 : this.end, ')' + (hasTrailingSemicolon ? '' : ';'));\n        }\n        else {\n            code.overwrite(this.start, declarationStart, `${cnst} ${this.variable.getName(getPropertyAccess)} = `);\n            if (!hasTrailingSemicolon) {\n                code.appendLeft(this.end, ';');\n            }\n        }\n    }\n}\nExportDefaultDeclaration.prototype.needsBoundaries = true;\n\nconst needsEscapeRegEx = /[\\n\\r'\\\\\\u2028\\u2029]/;\nconst quoteNewlineRegEx = /([\\n\\r'\\u2028\\u2029])/g;\nconst backSlashRegEx = /\\\\/g;\nfunction escapeId(id) {\n    if (!needsEscapeRegEx.test(id))\n        return id;\n    return id.replace(backSlashRegEx, '\\\\\\\\').replace(quoteNewlineRegEx, '\\\\$1');\n}\n\nconst INTEROP_DEFAULT_VARIABLE = '_interopDefault';\nconst INTEROP_DEFAULT_COMPAT_VARIABLE = '_interopDefaultCompat';\nconst INTEROP_NAMESPACE_VARIABLE = '_interopNamespace';\nconst INTEROP_NAMESPACE_COMPAT_VARIABLE = '_interopNamespaceCompat';\nconst INTEROP_NAMESPACE_DEFAULT_VARIABLE = '_interopNamespaceDefault';\nconst INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE = '_interopNamespaceDefaultOnly';\nconst MERGE_NAMESPACES_VARIABLE = '_mergeNamespaces';\nconst DOCUMENT_CURRENT_SCRIPT = '_documentCurrentScript';\nconst defaultInteropHelpersByInteropType = {\n    auto: INTEROP_DEFAULT_VARIABLE,\n    compat: INTEROP_DEFAULT_COMPAT_VARIABLE,\n    default: null,\n    defaultOnly: null,\n    esModule: null\n};\nconst isDefaultAProperty = (interopType, externalLiveBindings) => interopType === 'esModule' ||\n    (externalLiveBindings && (interopType === 'auto' || interopType === 'compat'));\nconst namespaceInteropHelpersByInteropType = {\n    auto: INTEROP_NAMESPACE_VARIABLE,\n    compat: INTEROP_NAMESPACE_COMPAT_VARIABLE,\n    default: INTEROP_NAMESPACE_DEFAULT_VARIABLE,\n    defaultOnly: INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE,\n    esModule: null\n};\nconst canDefaultBeTakenFromNamespace = (interopType, externalLiveBindings) => interopType !== 'esModule' && isDefaultAProperty(interopType, externalLiveBindings);\nconst getHelpersBlock = (additionalHelpers, accessedGlobals, indent, snippets, liveBindings, freeze, symbols) => {\n    const usedHelpers = new Set(additionalHelpers);\n    for (const variable of HELPER_NAMES) {\n        if (accessedGlobals.has(variable)) {\n            usedHelpers.add(variable);\n        }\n    }\n    return HELPER_NAMES.map(variable => usedHelpers.has(variable)\n        ? HELPER_GENERATORS[variable](indent, snippets, liveBindings, freeze, symbols, usedHelpers)\n        : '').join('');\n};\nconst HELPER_GENERATORS = {\n    [DOCUMENT_CURRENT_SCRIPT](_t, { _, n }) {\n        return `var ${DOCUMENT_CURRENT_SCRIPT}${_}=${_}typeof document${_}!==${_}'undefined'${_}?${_}document.currentScript${_}:${_}null;${n}`;\n    },\n    [INTEROP_DEFAULT_COMPAT_VARIABLE](_t, snippets, liveBindings) {\n        const { _, getDirectReturnFunction, n } = snippets;\n        const [left, right] = getDirectReturnFunction(['e'], {\n            functionReturn: true,\n            lineBreakIndent: null,\n            name: INTEROP_DEFAULT_COMPAT_VARIABLE\n        });\n        return (`${left}${getIsCompatNamespace(snippets)}${_}?${_}` +\n            `${liveBindings ? getDefaultLiveBinding(snippets) : getDefaultStatic(snippets)}${right}${n}${n}`);\n    },\n    [INTEROP_DEFAULT_VARIABLE](_t, snippets, liveBindings) {\n        const { _, getDirectReturnFunction, n } = snippets;\n        const [left, right] = getDirectReturnFunction(['e'], {\n            functionReturn: true,\n            lineBreakIndent: null,\n            name: INTEROP_DEFAULT_VARIABLE\n        });\n        return (`${left}e${_}&&${_}e.__esModule${_}?${_}` +\n            `${liveBindings ? getDefaultLiveBinding(snippets) : getDefaultStatic(snippets)}${right}${n}${n}`);\n    },\n    [INTEROP_NAMESPACE_COMPAT_VARIABLE](t, snippets, liveBindings, freeze, symbols, usedHelpers) {\n        const { _, getDirectReturnFunction, n } = snippets;\n        if (usedHelpers.has(INTEROP_NAMESPACE_DEFAULT_VARIABLE)) {\n            const [left, right] = getDirectReturnFunction(['e'], {\n                functionReturn: true,\n                lineBreakIndent: null,\n                name: INTEROP_NAMESPACE_COMPAT_VARIABLE\n            });\n            return `${left}${getIsCompatNamespace(snippets)}${_}?${_}e${_}:${_}${INTEROP_NAMESPACE_DEFAULT_VARIABLE}(e)${right}${n}${n}`;\n        }\n        return (`function ${INTEROP_NAMESPACE_COMPAT_VARIABLE}(e)${_}{${n}` +\n            `${t}if${_}(${getIsCompatNamespace(snippets)})${_}return e;${n}` +\n            createNamespaceObject(t, t, snippets, liveBindings, freeze, symbols) +\n            `}${n}${n}`);\n    },\n    [INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE](_t, snippets, _liveBindings, freeze, symbols) {\n        const { getDirectReturnFunction, getObject, n, _ } = snippets;\n        const [left, right] = getDirectReturnFunction(['e'], {\n            functionReturn: true,\n            lineBreakIndent: null,\n            name: INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE\n        });\n        return `${left}${getFrozen(freeze, getWithToStringTag(symbols, getObject([\n            [null, `__proto__:${_}null`],\n            ['default', 'e']\n        ], { lineBreakIndent: null }), snippets))}${right}${n}${n}`;\n    },\n    [INTEROP_NAMESPACE_DEFAULT_VARIABLE](t, snippets, liveBindings, freeze, symbols) {\n        const { _, n } = snippets;\n        return (`function ${INTEROP_NAMESPACE_DEFAULT_VARIABLE}(e)${_}{${n}` +\n            createNamespaceObject(t, t, snippets, liveBindings, freeze, symbols) +\n            `}${n}${n}`);\n    },\n    [INTEROP_NAMESPACE_VARIABLE](t, snippets, liveBindings, freeze, symbols, usedHelpers) {\n        const { _, getDirectReturnFunction, n } = snippets;\n        if (usedHelpers.has(INTEROP_NAMESPACE_DEFAULT_VARIABLE)) {\n            const [left, right] = getDirectReturnFunction(['e'], {\n                functionReturn: true,\n                lineBreakIndent: null,\n                name: INTEROP_NAMESPACE_VARIABLE\n            });\n            return `${left}e${_}&&${_}e.__esModule${_}?${_}e${_}:${_}${INTEROP_NAMESPACE_DEFAULT_VARIABLE}(e)${right}${n}${n}`;\n        }\n        return (`function ${INTEROP_NAMESPACE_VARIABLE}(e)${_}{${n}` +\n            `${t}if${_}(e${_}&&${_}e.__esModule)${_}return e;${n}` +\n            createNamespaceObject(t, t, snippets, liveBindings, freeze, symbols) +\n            `}${n}${n}`);\n    },\n    [MERGE_NAMESPACES_VARIABLE](t, snippets, liveBindings, freeze, symbols) {\n        const { _, cnst, n } = snippets;\n        const useForEach = cnst === 'var' && liveBindings;\n        return (`function ${MERGE_NAMESPACES_VARIABLE}(n, m)${_}{${n}` +\n            `${t}${loopOverNamespaces(`{${n}` +\n                `${t}${t}${t}if${_}(k${_}!==${_}'default'${_}&&${_}!(k in n))${_}{${n}` +\n                (liveBindings\n                    ? useForEach\n                        ? copyOwnPropertyLiveBinding\n                        : copyPropertyLiveBinding\n                    : copyPropertyStatic)(t, t + t + t + t, snippets) +\n                `${t}${t}${t}}${n}` +\n                `${t}${t}}`, useForEach, t, snippets)}${n}` +\n            `${t}return ${getFrozen(freeze, getWithToStringTag(symbols, 'n', snippets))};${n}` +\n            `}${n}${n}`);\n    }\n};\nconst getDefaultLiveBinding = ({ _, getObject }) => `e${_}:${_}${getObject([['default', 'e']], { lineBreakIndent: null })}`;\nconst getDefaultStatic = ({ _, getPropertyAccess }) => `e${getPropertyAccess('default')}${_}:${_}e`;\nconst getIsCompatNamespace = ({ _ }) => `e${_}&&${_}typeof e${_}===${_}'object'${_}&&${_}'default'${_}in e`;\nconst createNamespaceObject = (t, index, snippets, liveBindings, freeze, symbols) => {\n    const { _, cnst, getObject, getPropertyAccess, n, s } = snippets;\n    const copyProperty = `{${n}` +\n        (liveBindings ? copyNonDefaultOwnPropertyLiveBinding : copyPropertyStatic)(t, index + t + t, snippets) +\n        `${index}${t}}`;\n    return (`${index}${cnst} n${_}=${_}Object.create(null${symbols ? `,${_}{${_}[Symbol.toStringTag]:${_}${getToStringTagValue(getObject)}${_}}` : ''});${n}` +\n        `${index}if${_}(e)${_}{${n}` +\n        `${index}${t}${loopOverKeys(copyProperty, !liveBindings, snippets)}${n}` +\n        `${index}}${n}` +\n        `${index}n${getPropertyAccess('default')}${_}=${_}e;${n}` +\n        `${index}return ${getFrozen(freeze, 'n')}${s}${n}`);\n};\nconst loopOverKeys = (body, allowVariableLoopVariable, { _, cnst, getFunctionIntro, s }) => cnst !== 'var' || allowVariableLoopVariable\n    ? `for${_}(${cnst} k in e)${_}${body}`\n    : `Object.keys(e).forEach(${getFunctionIntro(['k'], {\n        isAsync: false,\n        name: null\n    })}${body})${s}`;\nconst loopOverNamespaces = (body, useForEach, t, { _, cnst, getDirectReturnFunction, getFunctionIntro, n }) => {\n    if (useForEach) {\n        const [left, right] = getDirectReturnFunction(['e'], {\n            functionReturn: false,\n            lineBreakIndent: { base: t, t },\n            name: null\n        });\n        return (`m.forEach(${left}` +\n            `e${_}&&${_}typeof e${_}!==${_}'string'${_}&&${_}!Array.isArray(e)${_}&&${_}Object.keys(e).forEach(${getFunctionIntro(['k'], {\n                isAsync: false,\n                name: null\n            })}${body})${right});`);\n    }\n    return (`for${_}(var i${_}=${_}0;${_}i${_}<${_}m.length;${_}i++)${_}{${n}` +\n        `${t}${t}${cnst} e${_}=${_}m[i];${n}` +\n        `${t}${t}if${_}(typeof e${_}!==${_}'string'${_}&&${_}!Array.isArray(e))${_}{${_}for${_}(${cnst} k in e)${_}${body}${_}}${n}${t}}`);\n};\nconst copyNonDefaultOwnPropertyLiveBinding = (t, index, snippets) => {\n    const { _, n } = snippets;\n    return (`${index}if${_}(k${_}!==${_}'default')${_}{${n}` +\n        copyOwnPropertyLiveBinding(t, index + t, snippets) +\n        `${index}}${n}`);\n};\nconst copyOwnPropertyLiveBinding = (t, index, { _, cnst, getDirectReturnFunction, n }) => {\n    const [left, right] = getDirectReturnFunction([], {\n        functionReturn: true,\n        lineBreakIndent: null,\n        name: null\n    });\n    return (`${index}${cnst} d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n}` +\n        `${index}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n}` +\n        `${index}${t}enumerable:${_}true,${n}` +\n        `${index}${t}get:${_}${left}e[k]${right}${n}` +\n        `${index}});${n}`);\n};\nconst copyPropertyLiveBinding = (t, index, { _, cnst, getDirectReturnFunction, n }) => {\n    const [left, right] = getDirectReturnFunction([], {\n        functionReturn: true,\n        lineBreakIndent: null,\n        name: null\n    });\n    return (`${index}${cnst} d${_}=${_}Object.getOwnPropertyDescriptor(e,${_}k);${n}` +\n        `${index}if${_}(d)${_}{${n}` +\n        `${index}${t}Object.defineProperty(n,${_}k,${_}d.get${_}?${_}d${_}:${_}{${n}` +\n        `${index}${t}${t}enumerable:${_}true,${n}` +\n        `${index}${t}${t}get:${_}${left}e[k]${right}${n}` +\n        `${index}${t}});${n}` +\n        `${index}}${n}`);\n};\nconst copyPropertyStatic = (_t, index, { _, n }) => `${index}n[k]${_}=${_}e[k];${n}`;\nconst getFrozen = (freeze, fragment) => freeze ? `Object.freeze(${fragment})` : fragment;\nconst getWithToStringTag = (symbols, fragment, { _, getObject }) => symbols\n    ? `Object.defineProperty(${fragment},${_}Symbol.toStringTag,${_}${getToStringTagValue(getObject)})`\n    : fragment;\nconst HELPER_NAMES = Object.keys(HELPER_GENERATORS);\nfunction getToStringTagValue(getObject) {\n    return getObject([['value', \"'Module'\"]], {\n        lineBreakIndent: null\n    });\n}\n\nclass Literal extends NodeBase {\n    deoptimizeArgumentsOnInteractionAtPath() { }\n    getLiteralValueAtPath(path) {\n        if (path.length > 0 ||\n            // unknown literals can also be null but do not start with an \"n\"\n            (this.value === null && this.scope.context.code.charCodeAt(this.start) !== 110) ||\n            typeof this.value === 'bigint' ||\n            // to support shims for regular expressions\n            this.scope.context.code.charCodeAt(this.start) === 47) {\n            return UnknownValue;\n        }\n        return this.value;\n    }\n    getReturnExpressionWhenCalledAtPath(path) {\n        if (path.length !== 1)\n            return UNKNOWN_RETURN_EXPRESSION;\n        return getMemberReturnExpressionWhenCalled(this.members, path[0]);\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        switch (interaction.type) {\n            case INTERACTION_ACCESSED: {\n                return path.length > (this.value === null ? 0 : 1);\n            }\n            case INTERACTION_ASSIGNED: {\n                return true;\n            }\n            case INTERACTION_CALLED: {\n                if (this.included &&\n                    this.value instanceof RegExp &&\n                    (this.value.global || this.value.sticky)) {\n                    return true;\n                }\n                return (path.length !== 1 ||\n                    hasMemberEffectWhenCalled(this.members, path[0], interaction, context));\n            }\n        }\n    }\n    initialise() {\n        super.initialise();\n        this.members = getLiteralMembersForValue(this.value);\n    }\n    parseNode(esTreeNode) {\n        this.value = esTreeNode.value;\n        this.regex = esTreeNode.regex;\n        return super.parseNode(esTreeNode);\n    }\n    render(code) {\n        if (typeof this.value === 'string') {\n            code.indentExclusionRanges.push([this.start + 1, this.end - 1]);\n        }\n    }\n}\n\nfunction getChainElementLiteralValueAtPath(element, object, path, recursionTracker, origin) {\n    if ('getLiteralValueAtPathAsChainElement' in object) {\n        const calleeValue = object.getLiteralValueAtPathAsChainElement(EMPTY_PATH, SHARED_RECURSION_TRACKER, origin);\n        if (calleeValue === IS_SKIPPED_CHAIN || (element.optional && calleeValue == null)) {\n            return IS_SKIPPED_CHAIN;\n        }\n    }\n    else if (element.optional &&\n        object.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, origin) == null) {\n        return IS_SKIPPED_CHAIN;\n    }\n    return element.getLiteralValueAtPath(path, recursionTracker, origin);\n}\n\n// To avoid infinite recursions\nconst MAX_PATH_DEPTH = 7;\nfunction getResolvablePropertyKey(memberExpression) {\n    return memberExpression.computed\n        ? getResolvableComputedPropertyKey(memberExpression.property)\n        : memberExpression.property.name;\n}\nfunction getResolvableComputedPropertyKey(propertyKey) {\n    if (propertyKey instanceof Literal) {\n        return String(propertyKey.value);\n    }\n    return null;\n}\nfunction getPathIfNotComputed(memberExpression) {\n    const nextPathKey = memberExpression.propertyKey;\n    const object = memberExpression.object;\n    if (typeof nextPathKey === 'string') {\n        if (object instanceof Identifier) {\n            return [\n                { key: object.name, pos: object.start },\n                { key: nextPathKey, pos: memberExpression.property.start }\n            ];\n        }\n        if (object instanceof MemberExpression) {\n            const parentPath = getPathIfNotComputed(object);\n            return (parentPath && [...parentPath, { key: nextPathKey, pos: memberExpression.property.start }]);\n        }\n    }\n    return null;\n}\nfunction getStringFromPath(path) {\n    let pathString = path[0].key;\n    for (let index = 1; index < path.length; index++) {\n        pathString += '.' + path[index].key;\n    }\n    return pathString;\n}\nclass MemberExpression extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.variable = null;\n        this.expressionsToBeDeoptimized = [];\n    }\n    get computed() {\n        return isFlagSet(this.flags, 1024 /* Flag.computed */);\n    }\n    set computed(value) {\n        this.flags = setFlag(this.flags, 1024 /* Flag.computed */, value);\n    }\n    get optional() {\n        return isFlagSet(this.flags, 128 /* Flag.optional */);\n    }\n    set optional(value) {\n        this.flags = setFlag(this.flags, 128 /* Flag.optional */, value);\n    }\n    get assignmentDeoptimized() {\n        return isFlagSet(this.flags, 16 /* Flag.assignmentDeoptimized */);\n    }\n    set assignmentDeoptimized(value) {\n        this.flags = setFlag(this.flags, 16 /* Flag.assignmentDeoptimized */, value);\n    }\n    get bound() {\n        return isFlagSet(this.flags, 32 /* Flag.bound */);\n    }\n    set bound(value) {\n        this.flags = setFlag(this.flags, 32 /* Flag.bound */, value);\n    }\n    get isUndefined() {\n        return isFlagSet(this.flags, 64 /* Flag.isUndefined */);\n    }\n    set isUndefined(value) {\n        this.flags = setFlag(this.flags, 64 /* Flag.isUndefined */, value);\n    }\n    bind() {\n        this.bound = true;\n        const path = getPathIfNotComputed(this);\n        const baseVariable = path && this.scope.findVariable(path[0].key);\n        if (baseVariable?.isNamespace) {\n            const resolvedVariable = resolveNamespaceVariables(baseVariable, path.slice(1), this.scope.context);\n            if (!resolvedVariable) {\n                super.bind();\n            }\n            else if (resolvedVariable === 'undefined') {\n                this.isUndefined = true;\n            }\n            else {\n                this.variable = resolvedVariable;\n                this.scope.addNamespaceMemberAccess(getStringFromPath(path), resolvedVariable);\n            }\n        }\n        else {\n            super.bind();\n        }\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        if (this.variable) {\n            this.variable.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n        }\n        else if (!this.isUndefined) {\n            if (path.length < MAX_PATH_DEPTH) {\n                this.object.deoptimizeArgumentsOnInteractionAtPath(interaction, [this.getPropertyKey(), ...path], recursionTracker);\n            }\n            else {\n                deoptimizeInteraction(interaction);\n            }\n        }\n    }\n    deoptimizeCache() {\n        const { expressionsToBeDeoptimized, object } = this;\n        this.expressionsToBeDeoptimized = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY;\n        this.propertyKey = UnknownKey;\n        object.deoptimizePath(UNKNOWN_PATH);\n        for (const expression of expressionsToBeDeoptimized) {\n            expression.deoptimizeCache();\n        }\n    }\n    deoptimizePath(path) {\n        if (path.length === 0)\n            this.disallowNamespaceReassignment();\n        if (this.variable) {\n            this.variable.deoptimizePath(path);\n        }\n        else if (!this.isUndefined && path.length < MAX_PATH_DEPTH) {\n            const propertyKey = this.getPropertyKey();\n            this.object.deoptimizePath([\n                propertyKey === UnknownKey ? UnknownNonAccessorKey : propertyKey,\n                ...path\n            ]);\n        }\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        if (this.variable) {\n            return this.variable.getLiteralValueAtPath(path, recursionTracker, origin);\n        }\n        if (this.isUndefined) {\n            return undefined;\n        }\n        if (this.propertyKey !== UnknownKey && path.length < MAX_PATH_DEPTH) {\n            this.expressionsToBeDeoptimized.push(origin);\n            return this.object.getLiteralValueAtPath([this.getPropertyKey(), ...path], recursionTracker, origin);\n        }\n        return UnknownValue;\n    }\n    getLiteralValueAtPathAsChainElement(path, recursionTracker, origin) {\n        if (this.variable) {\n            return this.variable.getLiteralValueAtPath(path, recursionTracker, origin);\n        }\n        if (this.isUndefined) {\n            return undefined;\n        }\n        return getChainElementLiteralValueAtPath(this, this.object, path, recursionTracker, origin);\n    }\n    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {\n        if (this.variable) {\n            return this.variable.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);\n        }\n        if (this.isUndefined) {\n            return [UNDEFINED_EXPRESSION, false];\n        }\n        if (this.propertyKey !== UnknownKey && path.length < MAX_PATH_DEPTH) {\n            this.expressionsToBeDeoptimized.push(origin);\n            return this.object.getReturnExpressionWhenCalledAtPath([this.getPropertyKey(), ...path], interaction, recursionTracker, origin);\n        }\n        return UNKNOWN_RETURN_EXPRESSION;\n    }\n    hasEffects(context) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        return (this.property.hasEffects(context) ||\n            this.object.hasEffects(context) ||\n            this.hasAccessEffect(context));\n    }\n    hasEffectsAsChainElement(context) {\n        if (this.variable || this.isUndefined)\n            return this.hasEffects(context);\n        const objectHasEffects = 'hasEffectsAsChainElement' in this.object\n            ? this.object.hasEffectsAsChainElement(context)\n            : this.object.hasEffects(context);\n        if (objectHasEffects === IS_SKIPPED_CHAIN)\n            return IS_SKIPPED_CHAIN;\n        if (this.optional &&\n            this.object.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this) == null) {\n            return objectHasEffects || IS_SKIPPED_CHAIN;\n        }\n        // We only apply deoptimizations lazily once we know we are not skipping\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        return objectHasEffects || this.property.hasEffects(context) || this.hasAccessEffect(context);\n    }\n    hasEffectsAsAssignmentTarget(context, checkAccess) {\n        if (checkAccess && !this.deoptimized)\n            this.applyDeoptimizations();\n        if (!this.assignmentDeoptimized)\n            this.applyAssignmentDeoptimization();\n        return (this.property.hasEffects(context) ||\n            this.object.hasEffects(context) ||\n            (checkAccess && this.hasAccessEffect(context)) ||\n            this.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.assignmentInteraction, context));\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        if (this.variable) {\n            return this.variable.hasEffectsOnInteractionAtPath(path, interaction, context);\n        }\n        if (this.isUndefined) {\n            return true;\n        }\n        if (path.length < MAX_PATH_DEPTH) {\n            return this.object.hasEffectsOnInteractionAtPath([this.getPropertyKey(), ...path], interaction, context);\n        }\n        return true;\n    }\n    include(context, includeChildrenRecursively) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        this.includeProperties(context, includeChildrenRecursively);\n    }\n    includeAsAssignmentTarget(context, includeChildrenRecursively, deoptimizeAccess) {\n        if (!this.assignmentDeoptimized)\n            this.applyAssignmentDeoptimization();\n        if (deoptimizeAccess) {\n            this.include(context, includeChildrenRecursively);\n        }\n        else {\n            this.includeProperties(context, includeChildrenRecursively);\n        }\n    }\n    includeCallArguments(context, parameters) {\n        if (this.variable) {\n            this.variable.includeCallArguments(context, parameters);\n        }\n        else {\n            super.includeCallArguments(context, parameters);\n        }\n    }\n    initialise() {\n        super.initialise();\n        this.propertyKey = getResolvablePropertyKey(this);\n        this.accessInteraction = { args: [this.object], type: INTERACTION_ACCESSED };\n    }\n    render(code, options, { renderedParentType, isCalleeOfRenderedParent, renderedSurroundingElement } = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BLANK) {\n        if (this.variable || this.isUndefined) {\n            const { snippets: { getPropertyAccess } } = options;\n            let replacement = this.variable ? this.variable.getName(getPropertyAccess) : 'undefined';\n            if (renderedParentType && isCalleeOfRenderedParent)\n                replacement = '0, ' + replacement;\n            code.overwrite(this.start, this.end, replacement, {\n                contentOnly: true,\n                storeName: true\n            });\n        }\n        else {\n            if (renderedParentType && isCalleeOfRenderedParent) {\n                code.appendRight(this.start, '0, ');\n            }\n            this.object.render(code, options, { renderedSurroundingElement });\n            this.property.render(code, options);\n        }\n    }\n    setAssignedValue(value) {\n        this.assignmentInteraction = {\n            args: [this.object, value],\n            type: INTERACTION_ASSIGNED\n        };\n    }\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        const { propertyReadSideEffects } = this.scope.context.options\n            .treeshake;\n        if (\n        // Namespaces are not bound and should not be deoptimized\n        this.bound &&\n            propertyReadSideEffects &&\n            !(this.variable || this.isUndefined)) {\n            const propertyKey = this.getPropertyKey();\n            this.object.deoptimizeArgumentsOnInteractionAtPath(this.accessInteraction, [propertyKey], SHARED_RECURSION_TRACKER);\n            this.scope.context.requestTreeshakingPass();\n        }\n        if (this.variable) {\n            this.variable.addUsedPlace(this);\n            this.scope.context.requestTreeshakingPass();\n        }\n    }\n    applyAssignmentDeoptimization() {\n        this.assignmentDeoptimized = true;\n        const { propertyReadSideEffects } = this.scope.context.options\n            .treeshake;\n        if (\n        // Namespaces are not bound and should not be deoptimized\n        this.bound &&\n            propertyReadSideEffects &&\n            !(this.variable || this.isUndefined)) {\n            this.object.deoptimizeArgumentsOnInteractionAtPath(this.assignmentInteraction, [this.getPropertyKey()], SHARED_RECURSION_TRACKER);\n            this.scope.context.requestTreeshakingPass();\n        }\n    }\n    disallowNamespaceReassignment() {\n        if (this.object instanceof Identifier) {\n            const variable = this.scope.findVariable(this.object.name);\n            if (variable.isNamespace) {\n                if (this.variable) {\n                    this.scope.context.includeVariableInModule(this.variable);\n                }\n                this.scope.context.log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logIllegalImportReassignment)(this.object.name, this.scope.context.module.id), this.start);\n            }\n        }\n    }\n    getPropertyKey() {\n        if (this.propertyKey === null) {\n            this.propertyKey = UnknownKey;\n            const value = this.property.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);\n            return (this.propertyKey =\n                value === SymbolToStringTag\n                    ? value\n                    : typeof value === 'symbol'\n                        ? UnknownKey\n                        : String(value));\n        }\n        return this.propertyKey;\n    }\n    hasAccessEffect(context) {\n        const { propertyReadSideEffects } = this.scope.context.options\n            .treeshake;\n        return (!(this.variable || this.isUndefined) &&\n            propertyReadSideEffects &&\n            (propertyReadSideEffects === 'always' ||\n                this.object.hasEffectsOnInteractionAtPath([this.getPropertyKey()], this.accessInteraction, context)));\n    }\n    includeProperties(context, includeChildrenRecursively) {\n        if (!this.included) {\n            this.included = true;\n            if (this.variable) {\n                this.scope.context.includeVariableInModule(this.variable);\n            }\n        }\n        this.object.include(context, includeChildrenRecursively);\n        this.property.include(context, includeChildrenRecursively);\n    }\n}\nfunction resolveNamespaceVariables(baseVariable, path, astContext) {\n    if (path.length === 0)\n        return baseVariable;\n    if (!baseVariable.isNamespace || baseVariable instanceof ExternalVariable)\n        return null;\n    const exportName = path[0].key;\n    const variable = baseVariable.context.traceExport(exportName);\n    if (!variable) {\n        if (path.length === 1) {\n            const fileName = baseVariable.context.fileName;\n            astContext.log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logMissingExport)(exportName, astContext.module.id, fileName), path[0].pos);\n            return 'undefined';\n        }\n        return null;\n    }\n    return resolveNamespaceVariables(variable, path.slice(1), astContext);\n}\n\nconst FILE_PREFIX = 'ROLLUP_FILE_URL_';\nconst IMPORT = 'import';\nclass MetaProperty extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.metaProperty = null;\n        this.preliminaryChunkId = null;\n        this.referenceId = null;\n    }\n    getReferencedFileName(outputPluginDriver) {\n        const { meta: { name }, metaProperty } = this;\n        if (name === IMPORT && metaProperty?.startsWith(FILE_PREFIX)) {\n            return outputPluginDriver.getFileName(metaProperty.slice(FILE_PREFIX.length));\n        }\n        return null;\n    }\n    hasEffects() {\n        return false;\n    }\n    hasEffectsOnInteractionAtPath(path, { type }) {\n        return path.length > 1 || type !== INTERACTION_ACCESSED;\n    }\n    include() {\n        if (!this.included) {\n            this.included = true;\n            if (this.meta.name === IMPORT) {\n                this.scope.context.addImportMeta(this);\n                const parent = this.parent;\n                const metaProperty = (this.metaProperty =\n                    parent instanceof MemberExpression && typeof parent.propertyKey === 'string'\n                        ? parent.propertyKey\n                        : null);\n                if (metaProperty?.startsWith(FILE_PREFIX)) {\n                    this.referenceId = metaProperty.slice(FILE_PREFIX.length);\n                }\n            }\n        }\n    }\n    render(code, renderOptions) {\n        const { format, pluginDriver, snippets } = renderOptions;\n        const { scope: { context: { module } }, meta: { name }, metaProperty, parent, preliminaryChunkId, referenceId, start, end } = this;\n        const { id: moduleId } = module;\n        if (name !== IMPORT)\n            return;\n        const chunkId = preliminaryChunkId;\n        if (referenceId) {\n            const fileName = pluginDriver.getFileName(referenceId);\n            const relativePath = (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.normalize)((0,node_path__WEBPACK_IMPORTED_MODULE_1__.relative)((0,node_path__WEBPACK_IMPORTED_MODULE_1__.dirname)(chunkId), fileName));\n            const replacement = pluginDriver.hookFirstSync('resolveFileUrl', [\n                { chunkId, fileName, format, moduleId, referenceId, relativePath }\n            ]) || relativeUrlMechanisms[format](relativePath);\n            code.overwrite(parent.start, parent.end, replacement, { contentOnly: true });\n            return;\n        }\n        let replacement = pluginDriver.hookFirstSync('resolveImportMeta', [\n            metaProperty,\n            { chunkId, format, moduleId }\n        ]);\n        if (!replacement) {\n            replacement = importMetaMechanisms[format]?.(metaProperty, { chunkId, snippets });\n            renderOptions.accessedDocumentCurrentScript ||=\n                formatsMaybeAccessDocumentCurrentScript.includes(format) && replacement !== 'undefined';\n        }\n        if (typeof replacement === 'string') {\n            if (parent instanceof MemberExpression) {\n                code.overwrite(parent.start, parent.end, replacement, { contentOnly: true });\n            }\n            else {\n                code.overwrite(start, end, replacement, { contentOnly: true });\n            }\n        }\n    }\n    setResolution(format, accessedGlobalsByScope, preliminaryChunkId) {\n        this.preliminaryChunkId = preliminaryChunkId;\n        const accessedGlobals = (this.metaProperty?.startsWith(FILE_PREFIX) ? accessedFileUrlGlobals : accessedMetaUrlGlobals)[format];\n        if (accessedGlobals.length > 0) {\n            this.scope.addAccessedGlobals(accessedGlobals, accessedGlobalsByScope);\n        }\n    }\n}\nconst formatsMaybeAccessDocumentCurrentScript = ['cjs', 'iife', 'umd'];\nconst accessedMetaUrlGlobals = {\n    amd: ['document', 'module', 'URL'],\n    cjs: ['document', 'require', 'URL', DOCUMENT_CURRENT_SCRIPT],\n    es: [],\n    iife: ['document', 'URL', DOCUMENT_CURRENT_SCRIPT],\n    system: ['module'],\n    umd: ['document', 'require', 'URL', DOCUMENT_CURRENT_SCRIPT]\n};\nconst accessedFileUrlGlobals = {\n    amd: ['document', 'require', 'URL'],\n    cjs: ['document', 'require', 'URL'],\n    es: [],\n    iife: ['document', 'URL'],\n    system: ['module', 'URL'],\n    umd: ['document', 'require', 'URL']\n};\nconst getResolveUrl = (path, URL = 'URL') => `new ${URL}(${path}).href`;\nconst getRelativeUrlFromDocument = (relativePath, umd = false) => getResolveUrl(`'${escapeId(relativePath)}', ${umd ? `typeof document === 'undefined' ? location.href : ` : ''}document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT' && document.currentScript.src || document.baseURI`);\nconst getGenericImportMetaMechanism = (getUrl) => (property, { chunkId }) => {\n    const urlMechanism = getUrl(chunkId);\n    return property === null\n        ? `({ url: ${urlMechanism} })`\n        : property === 'url'\n            ? urlMechanism\n            : 'undefined';\n};\nconst getFileUrlFromFullPath = (path) => `require('u' + 'rl').pathToFileURL(${path}).href`;\nconst getFileUrlFromRelativePath = (path) => getFileUrlFromFullPath(`__dirname + '/${escapeId(path)}'`);\nconst getUrlFromDocument = (chunkId, umd = false) => `${umd ? `typeof document === 'undefined' ? location.href : ` : ''}(${DOCUMENT_CURRENT_SCRIPT} && ${DOCUMENT_CURRENT_SCRIPT}.tagName.toUpperCase() === 'SCRIPT' && ${DOCUMENT_CURRENT_SCRIPT}.src || new URL('${escapeId(chunkId)}', document.baseURI).href)`;\nconst relativeUrlMechanisms = {\n    amd: relativePath => {\n        if (relativePath[0] !== '.')\n            relativePath = './' + relativePath;\n        return getResolveUrl(`require.toUrl('${escapeId(relativePath)}'), document.baseURI`);\n    },\n    cjs: relativePath => `(typeof document === 'undefined' ? ${getFileUrlFromRelativePath(relativePath)} : ${getRelativeUrlFromDocument(relativePath)})`,\n    es: relativePath => getResolveUrl(`'${escapeId(relativePath)}', import.meta.url`),\n    iife: relativePath => getRelativeUrlFromDocument(relativePath),\n    system: relativePath => getResolveUrl(`'${escapeId(relativePath)}', module.meta.url`),\n    umd: relativePath => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getFileUrlFromRelativePath(relativePath)} : ${getRelativeUrlFromDocument(relativePath, true)})`\n};\nconst importMetaMechanisms = {\n    amd: getGenericImportMetaMechanism(() => getResolveUrl(`module.uri, document.baseURI`)),\n    cjs: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' ? ${getFileUrlFromFullPath('__filename')} : ${getUrlFromDocument(chunkId)})`),\n    iife: getGenericImportMetaMechanism(chunkId => getUrlFromDocument(chunkId)),\n    system: (property, { snippets: { getPropertyAccess } }) => property === null ? `module.meta` : `module.meta${getPropertyAccess(property)}`,\n    umd: getGenericImportMetaMechanism(chunkId => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getFileUrlFromFullPath('__filename')} : ${getUrlFromDocument(chunkId, true)})`)\n};\n\nclass UndefinedVariable extends Variable {\n    constructor() {\n        super('undefined');\n    }\n    getLiteralValueAtPath() {\n        return undefined;\n    }\n}\n\nclass ExportDefaultVariable extends LocalVariable {\n    constructor(name, exportDefaultDeclaration, context) {\n        super(name, exportDefaultDeclaration, exportDefaultDeclaration.declaration, context, 'other');\n        this.hasId = false;\n        this.originalId = null;\n        this.originalVariable = null;\n        const declaration = exportDefaultDeclaration.declaration;\n        if ((declaration instanceof FunctionDeclaration || declaration instanceof ClassDeclaration) &&\n            declaration.id) {\n            this.hasId = true;\n            this.originalId = declaration.id;\n        }\n        else if (declaration instanceof Identifier) {\n            this.originalId = declaration;\n        }\n    }\n    addReference(identifier) {\n        if (!this.hasId) {\n            this.name = identifier.name;\n        }\n    }\n    addUsedPlace(usedPlace) {\n        const original = this.getOriginalVariable();\n        if (original === this) {\n            super.addUsedPlace(usedPlace);\n        }\n        else {\n            original.addUsedPlace(usedPlace);\n        }\n    }\n    forbidName(name) {\n        const original = this.getOriginalVariable();\n        if (original === this) {\n            super.forbidName(name);\n        }\n        else {\n            original.forbidName(name);\n        }\n    }\n    getAssignedVariableName() {\n        return (this.originalId && this.originalId.name) || null;\n    }\n    getBaseVariableName() {\n        const original = this.getOriginalVariable();\n        return original === this ? super.getBaseVariableName() : original.getBaseVariableName();\n    }\n    getDirectOriginalVariable() {\n        return this.originalId &&\n            (this.hasId ||\n                !(this.originalId.isPossibleTDZ() ||\n                    this.originalId.variable.isReassigned ||\n                    this.originalId.variable instanceof UndefinedVariable ||\n                    // this avoids a circular dependency\n                    'syntheticNamespace' in this.originalId.variable))\n            ? this.originalId.variable\n            : null;\n    }\n    getName(getPropertyAccess) {\n        const original = this.getOriginalVariable();\n        return original === this\n            ? super.getName(getPropertyAccess)\n            : original.getName(getPropertyAccess);\n    }\n    getOriginalVariable() {\n        if (this.originalVariable)\n            return this.originalVariable;\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let original = this;\n        let currentVariable;\n        const checkedVariables = new Set();\n        do {\n            checkedVariables.add(original);\n            currentVariable = original;\n            original = currentVariable.getDirectOriginalVariable();\n        } while (original instanceof ExportDefaultVariable && !checkedVariables.has(original));\n        return (this.originalVariable = original || currentVariable);\n    }\n}\n\nclass NamespaceVariable extends Variable {\n    constructor(context) {\n        super(context.getModuleName());\n        this.memberVariables = null;\n        this.mergedNamespaces = [];\n        this.referencedEarly = false;\n        this.references = [];\n        this.context = context;\n        this.module = context.module;\n    }\n    addReference(identifier) {\n        this.references.push(identifier);\n        this.name = identifier.name;\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        if (path.length > 1 || (path.length === 1 && interaction.type === INTERACTION_CALLED)) {\n            const key = path[0];\n            if (typeof key === 'string') {\n                this.getMemberVariables()[key]?.deoptimizeArgumentsOnInteractionAtPath(interaction, path.slice(1), recursionTracker);\n            }\n            else {\n                deoptimizeInteraction(interaction);\n            }\n        }\n    }\n    deoptimizePath(path) {\n        if (path.length > 1) {\n            const key = path[0];\n            if (typeof key === 'string') {\n                this.getMemberVariables()[key]?.deoptimizePath(path.slice(1));\n            }\n        }\n    }\n    getLiteralValueAtPath(path) {\n        if (path[0] === SymbolToStringTag) {\n            return 'Module';\n        }\n        return UnknownValue;\n    }\n    getMemberVariables() {\n        if (this.memberVariables) {\n            return this.memberVariables;\n        }\n        const memberVariables = Object.create(null);\n        const sortedExports = [...this.context.getExports(), ...this.context.getReexports()].sort();\n        for (const name of sortedExports) {\n            if (name[0] !== '*' && name !== this.module.info.syntheticNamedExports) {\n                const exportedVariable = this.context.traceExport(name);\n                if (exportedVariable) {\n                    memberVariables[name] = exportedVariable;\n                }\n            }\n        }\n        return (this.memberVariables = memberVariables);\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        const { type } = interaction;\n        if (path.length === 0) {\n            // This can only be a call anyway\n            return true;\n        }\n        if (path.length === 1 && type !== INTERACTION_CALLED) {\n            return type === INTERACTION_ASSIGNED;\n        }\n        const key = path[0];\n        if (typeof key !== 'string') {\n            return true;\n        }\n        const memberVariable = this.getMemberVariables()[key];\n        return (!memberVariable ||\n            memberVariable.hasEffectsOnInteractionAtPath(path.slice(1), interaction, context));\n    }\n    include() {\n        super.include();\n        this.context.includeAllExports();\n    }\n    prepare(accessedGlobalsByScope) {\n        if (this.mergedNamespaces.length > 0) {\n            this.module.scope.addAccessedGlobals([MERGE_NAMESPACES_VARIABLE], accessedGlobalsByScope);\n        }\n    }\n    renderBlock(options) {\n        const { exportNamesByVariable, format, freeze, indent: t, symbols, snippets: { _, cnst, getObject, getPropertyAccess, n, s } } = options;\n        const memberVariables = this.getMemberVariables();\n        const members = Object.entries(memberVariables)\n            .filter(([_, variable]) => variable.included)\n            .map(([name, variable]) => {\n            if (this.referencedEarly || variable.isReassigned || variable === this) {\n                return [\n                    null,\n                    `get ${stringifyObjectKeyIfNeeded(name)}${_}()${_}{${_}return ${variable.getName(getPropertyAccess)}${s}${_}}`\n                ];\n            }\n            return [name, variable.getName(getPropertyAccess)];\n        });\n        members.unshift([null, `__proto__:${_}null`]);\n        let output = getObject(members, { lineBreakIndent: { base: '', t } });\n        if (this.mergedNamespaces.length > 0) {\n            const assignmentArguments = this.mergedNamespaces.map(variable => variable.getName(getPropertyAccess));\n            output = `/*#__PURE__*/${MERGE_NAMESPACES_VARIABLE}(${output},${_}[${assignmentArguments.join(`,${_}`)}])`;\n        }\n        else {\n            // The helper to merge namespaces will also take care of freezing and toStringTag\n            if (symbols) {\n                output = `/*#__PURE__*/Object.defineProperty(${output},${_}Symbol.toStringTag,${_}${getToStringTagValue(getObject)})`;\n            }\n            if (freeze) {\n                output = `/*#__PURE__*/Object.freeze(${output})`;\n            }\n        }\n        const name = this.getName(getPropertyAccess);\n        output = `${cnst} ${name}${_}=${_}${output};`;\n        if (format === 'system' && exportNamesByVariable.has(this)) {\n            output += `${n}${getSystemExportStatement([this], options)};`;\n        }\n        return output;\n    }\n    renderFirst() {\n        return this.referencedEarly;\n    }\n    setMergedNamespaces(mergedNamespaces) {\n        this.mergedNamespaces = mergedNamespaces;\n        const moduleExecIndex = this.context.getModuleExecIndex();\n        for (const identifier of this.references) {\n            const { context } = identifier.scope;\n            if (context.getModuleExecIndex() <= moduleExecIndex) {\n                this.referencedEarly = true;\n                break;\n            }\n        }\n    }\n}\nNamespaceVariable.prototype.isNamespace = true;\n\nclass SyntheticNamedExportVariable extends Variable {\n    constructor(context, name, syntheticNamespace) {\n        super(name);\n        this.baseVariable = null;\n        this.context = context;\n        this.module = context.module;\n        this.syntheticNamespace = syntheticNamespace;\n    }\n    getBaseVariable() {\n        if (this.baseVariable)\n            return this.baseVariable;\n        let baseVariable = this.syntheticNamespace;\n        while (baseVariable instanceof ExportDefaultVariable ||\n            baseVariable instanceof SyntheticNamedExportVariable) {\n            if (baseVariable instanceof ExportDefaultVariable) {\n                const original = baseVariable.getOriginalVariable();\n                if (original === baseVariable)\n                    break;\n                baseVariable = original;\n            }\n            if (baseVariable instanceof SyntheticNamedExportVariable) {\n                baseVariable = baseVariable.syntheticNamespace;\n            }\n        }\n        return (this.baseVariable = baseVariable);\n    }\n    getBaseVariableName() {\n        return this.syntheticNamespace.getBaseVariableName();\n    }\n    getName(getPropertyAccess) {\n        return `${this.syntheticNamespace.getName(getPropertyAccess)}${getPropertyAccess(this.name)}`;\n    }\n    include() {\n        super.include();\n        this.context.includeVariableInModule(this.syntheticNamespace);\n    }\n    setRenderNames(baseName, name) {\n        super.setRenderNames(baseName, name);\n    }\n}\n\nclass ExternalChunk {\n    constructor(module, options, inputBase) {\n        this.options = options;\n        this.inputBase = inputBase;\n        this.defaultVariableName = '';\n        this.namespaceVariableName = '';\n        this.variableName = '';\n        this.fileName = null;\n        this.importAttributes = null;\n        this.id = module.id;\n        this.moduleInfo = module.info;\n        this.renormalizeRenderPath = module.renormalizeRenderPath;\n        this.suggestedVariableName = module.suggestedVariableName;\n    }\n    getFileName() {\n        if (this.fileName) {\n            return this.fileName;\n        }\n        const { paths } = this.options;\n        return (this.fileName =\n            (typeof paths === 'function' ? paths(this.id) : paths[this.id]) ||\n                (this.renormalizeRenderPath ? (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.normalize)((0,node_path__WEBPACK_IMPORTED_MODULE_1__.relative)(this.inputBase, this.id)) : this.id));\n    }\n    getImportAttributes(snippets) {\n        return (this.importAttributes ||= formatAttributes(this.options.format === 'es' &&\n            this.options.externalImportAttributes &&\n            this.moduleInfo.attributes, snippets));\n    }\n    getImportPath(importer) {\n        return escapeId(this.renormalizeRenderPath\n            ? (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.getImportPath)(importer, this.getFileName(), this.options.format === 'amd', false)\n            : this.getFileName());\n    }\n}\nfunction formatAttributes(attributes, { getObject }) {\n    if (!attributes) {\n        return null;\n    }\n    const assertionEntries = Object.entries(attributes).map(([key, value]) => [key, `'${value}'`]);\n    if (assertionEntries.length > 0) {\n        return getObject(assertionEntries, { lineBreakIndent: null });\n    }\n    return null;\n}\n\nfunction removeJsExtension(name) {\n    return name.endsWith('.js') ? name.slice(0, -3) : name;\n}\n\nfunction getCompleteAmdId(options, chunkId) {\n    if (options.autoId) {\n        return `${options.basePath ? options.basePath + '/' : ''}${removeJsExtension(chunkId)}`;\n    }\n    return options.id ?? '';\n}\n\nfunction getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings, reexportProtoFromExternal, mechanism = 'return ') {\n    const { _, getDirectReturnFunction, getFunctionIntro, getPropertyAccess, n, s } = snippets;\n    if (!namedExportsMode) {\n        return `${n}${n}${mechanism}${getSingleDefaultExport(exports, dependencies, interop, externalLiveBindings, getPropertyAccess)};`;\n    }\n    let exportBlock = '';\n    if (namedExportsMode) {\n        for (const { defaultVariableName, importPath, isChunk, name, namedExportsMode: depNamedExportsMode, namespaceVariableName, reexports } of dependencies) {\n            if (!reexports) {\n                continue;\n            }\n            for (const specifier of reexports) {\n                if (specifier.reexported !== '*') {\n                    const importName = getReexportedImportName(name, specifier.imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, importPath, externalLiveBindings, getPropertyAccess);\n                    if (exportBlock)\n                        exportBlock += n;\n                    if (specifier.imported !== '*' && specifier.needsLiveBinding) {\n                        const [left, right] = getDirectReturnFunction([], {\n                            functionReturn: true,\n                            lineBreakIndent: null,\n                            name: null\n                        });\n                        exportBlock +=\n                            `Object.defineProperty(exports,${_}${JSON.stringify(specifier.reexported)},${_}{${n}` +\n                                `${t}enumerable:${_}true,${n}` +\n                                `${t}get:${_}${left}${importName}${right}${n}});`;\n                    }\n                    else if (specifier.reexported === '__proto__') {\n                        exportBlock +=\n                            `Object.defineProperty(exports,${_}\"__proto__\",${_}{${n}` +\n                                `${t}enumerable:${_}true,${n}` +\n                                `${t}value:${_}${importName}${n}});`;\n                    }\n                    else {\n                        exportBlock += `exports${getPropertyAccess(specifier.reexported)}${_}=${_}${importName};`;\n                    }\n                }\n            }\n        }\n    }\n    for (const { exported, local } of exports) {\n        const lhs = `exports${getPropertyAccess(exported)}`;\n        const rhs = local;\n        if (lhs !== rhs) {\n            if (exportBlock)\n                exportBlock += n;\n            exportBlock +=\n                exported === '__proto__'\n                    ? `Object.defineProperty(exports,${_}\"__proto__\",${_}{${n}` +\n                        `${t}enumerable:${_}true,${n}` +\n                        `${t}value:${_}${rhs}${n}});`\n                    : `${lhs}${_}=${_}${rhs};`;\n        }\n    }\n    if (namedExportsMode) {\n        for (const { name, reexports } of dependencies) {\n            if (!reexports) {\n                continue;\n            }\n            for (const specifier of reexports) {\n                if (specifier.reexported === '*') {\n                    if (exportBlock)\n                        exportBlock += n;\n                    if (!specifier.needsLiveBinding && reexportProtoFromExternal) {\n                        const protoString = \"'__proto__'\";\n                        exportBlock +=\n                            `Object.prototype.hasOwnProperty.call(${name},${_}${protoString})${_}&&${n}` +\n                                `${t}!Object.prototype.hasOwnProperty.call(exports,${_}${protoString})${_}&&${n}` +\n                                `${t}Object.defineProperty(exports,${_}${protoString},${_}{${n}` +\n                                `${t}${t}enumerable:${_}true,${n}` +\n                                `${t}${t}value:${_}${name}[${protoString}]${n}` +\n                                `${t}});${n}${n}`;\n                    }\n                    const copyPropertyIfNecessary = `{${n}${t}if${_}(k${_}!==${_}'default'${_}&&${_}!Object.prototype.hasOwnProperty.call(exports,${_}k))${_}${getDefineProperty(name, specifier.needsLiveBinding, t, snippets)}${s}${n}}`;\n                    exportBlock += `Object.keys(${name}).forEach(${getFunctionIntro(['k'], {\n                        isAsync: false,\n                        name: null\n                    })}${copyPropertyIfNecessary});`;\n                }\n            }\n        }\n    }\n    if (exportBlock) {\n        return `${n}${n}${exportBlock}`;\n    }\n    return '';\n}\nfunction getSingleDefaultExport(exports, dependencies, interop, externalLiveBindings, getPropertyAccess) {\n    if (exports.length > 0) {\n        return exports[0].local;\n    }\n    else {\n        for (const { defaultVariableName, importPath, isChunk, name, namedExportsMode: depNamedExportsMode, namespaceVariableName, reexports } of dependencies) {\n            if (reexports) {\n                return getReexportedImportName(name, reexports[0].imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, importPath, externalLiveBindings, getPropertyAccess);\n            }\n        }\n    }\n}\nfunction getReexportedImportName(moduleVariableName, imported, depNamedExportsMode, isChunk, defaultVariableName, namespaceVariableName, interop, moduleId, externalLiveBindings, getPropertyAccess) {\n    if (imported === 'default') {\n        if (!isChunk) {\n            const moduleInterop = interop(moduleId);\n            const variableName = defaultInteropHelpersByInteropType[moduleInterop]\n                ? defaultVariableName\n                : moduleVariableName;\n            return isDefaultAProperty(moduleInterop, externalLiveBindings)\n                ? `${variableName}${getPropertyAccess('default')}`\n                : variableName;\n        }\n        return depNamedExportsMode\n            ? `${moduleVariableName}${getPropertyAccess('default')}`\n            : moduleVariableName;\n    }\n    if (imported === '*') {\n        return (isChunk ? !depNamedExportsMode : namespaceInteropHelpersByInteropType[interop(moduleId)])\n            ? namespaceVariableName\n            : moduleVariableName;\n    }\n    return `${moduleVariableName}${getPropertyAccess(imported)}`;\n}\nfunction getEsModuleValue(getObject) {\n    return getObject([['value', 'true']], {\n        lineBreakIndent: null\n    });\n}\nfunction getNamespaceMarkers(hasNamedExports, addEsModule, addNamespaceToStringTag, { _, getObject }) {\n    if (hasNamedExports) {\n        if (addEsModule) {\n            if (addNamespaceToStringTag) {\n                return `Object.defineProperties(exports,${_}${getObject([\n                    ['__esModule', getEsModuleValue(getObject)],\n                    [null, `[Symbol.toStringTag]:${_}${getToStringTagValue(getObject)}`]\n                ], {\n                    lineBreakIndent: null\n                })});`;\n            }\n            return `Object.defineProperty(exports,${_}'__esModule',${_}${getEsModuleValue(getObject)});`;\n        }\n        if (addNamespaceToStringTag) {\n            return `Object.defineProperty(exports,${_}Symbol.toStringTag,${_}${getToStringTagValue(getObject)});`;\n        }\n    }\n    return '';\n}\nconst getDefineProperty = (name, needsLiveBinding, t, { _, getDirectReturnFunction, n }) => {\n    if (needsLiveBinding) {\n        const [left, right] = getDirectReturnFunction([], {\n            functionReturn: true,\n            lineBreakIndent: null,\n            name: null\n        });\n        return (`Object.defineProperty(exports,${_}k,${_}{${n}` +\n            `${t}${t}enumerable:${_}true,${n}` +\n            `${t}${t}get:${_}${left}${name}[k]${right}${n}${t}})`);\n    }\n    return `exports[k]${_}=${_}${name}[k]`;\n};\n\nfunction getInteropBlock(dependencies, interop, externalLiveBindings, freeze, symbols, accessedGlobals, indent, snippets) {\n    const { _, cnst, n } = snippets;\n    const neededInteropHelpers = new Set();\n    const interopStatements = [];\n    const addInteropStatement = (helperVariableName, helper, dependencyVariableName) => {\n        neededInteropHelpers.add(helper);\n        interopStatements.push(`${cnst} ${helperVariableName}${_}=${_}/*#__PURE__*/${helper}(${dependencyVariableName});`);\n    };\n    for (const { defaultVariableName, imports, importPath, isChunk, name, namedExportsMode, namespaceVariableName, reexports } of dependencies) {\n        if (isChunk) {\n            for (const { imported, reexported } of [\n                ...(imports || []),\n                ...(reexports || [])\n            ]) {\n                if (imported === '*' && reexported !== '*') {\n                    if (!namedExportsMode) {\n                        addInteropStatement(namespaceVariableName, INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE, name);\n                    }\n                    break;\n                }\n            }\n        }\n        else {\n            const moduleInterop = interop(importPath);\n            let hasDefault = false;\n            let hasNamespace = false;\n            for (const { imported, reexported } of [\n                ...(imports || []),\n                ...(reexports || [])\n            ]) {\n                let helper;\n                let variableName;\n                if (imported === 'default') {\n                    if (!hasDefault) {\n                        hasDefault = true;\n                        if (defaultVariableName !== namespaceVariableName) {\n                            variableName = defaultVariableName;\n                            helper = defaultInteropHelpersByInteropType[moduleInterop];\n                        }\n                    }\n                }\n                else if (imported === '*' && reexported !== '*' && !hasNamespace) {\n                    hasNamespace = true;\n                    helper = namespaceInteropHelpersByInteropType[moduleInterop];\n                    variableName = namespaceVariableName;\n                }\n                if (helper) {\n                    addInteropStatement(variableName, helper, name);\n                }\n            }\n        }\n    }\n    return `${getHelpersBlock(neededInteropHelpers, accessedGlobals, indent, snippets, externalLiveBindings, freeze, symbols)}${interopStatements.length > 0 ? `${interopStatements.join(n)}${n}${n}` : ''}`;\n}\n\nfunction addJsExtension(name) {\n    return name.endsWith('.js') ? name : name + '.js';\n}\n\n// AMD resolution will only respect the AMD baseUrl if the .js extension is omitted.\n// The assumption is that this makes sense for all relative ids:\n// https://requirejs.org/docs/api.html#jsfiles\nfunction updateExtensionForRelativeAmdId(id, forceJsExtensionForImports) {\n    if (id[0] !== '.') {\n        return id;\n    }\n    return forceJsExtensionForImports ? addJsExtension(id) : removeJsExtension(id);\n}\n\nconst builtinModules = [\n\t\"assert\",\n\t\"assert/strict\",\n\t\"async_hooks\",\n\t\"buffer\",\n\t\"child_process\",\n\t\"cluster\",\n\t\"console\",\n\t\"constants\",\n\t\"crypto\",\n\t\"dgram\",\n\t\"diagnostics_channel\",\n\t\"dns\",\n\t\"dns/promises\",\n\t\"domain\",\n\t\"events\",\n\t\"fs\",\n\t\"fs/promises\",\n\t\"http\",\n\t\"http2\",\n\t\"https\",\n\t\"inspector\",\n\t\"inspector/promises\",\n\t\"module\",\n\t\"net\",\n\t\"os\",\n\t\"path\",\n\t\"path/posix\",\n\t\"path/win32\",\n\t\"perf_hooks\",\n\t\"process\",\n\t\"punycode\",\n\t\"querystring\",\n\t\"readline\",\n\t\"readline/promises\",\n\t\"repl\",\n\t\"stream\",\n\t\"stream/consumers\",\n\t\"stream/promises\",\n\t\"stream/web\",\n\t\"string_decoder\",\n\t\"timers\",\n\t\"timers/promises\",\n\t\"tls\",\n\t\"trace_events\",\n\t\"tty\",\n\t\"url\",\n\t\"util\",\n\t\"util/types\",\n\t\"v8\",\n\t\"vm\",\n\t\"wasi\",\n\t\"worker_threads\",\n\t\"zlib\"\n];\n\nconst nodeBuiltins = new Set(builtinModules);\nfunction warnOnBuiltins(log, dependencies) {\n    const externalBuiltins = dependencies\n        .map(({ importPath }) => importPath)\n        .filter(importPath => nodeBuiltins.has(importPath) || importPath.startsWith('node:'));\n    if (externalBuiltins.length === 0)\n        return;\n    log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logMissingNodeBuiltins)(externalBuiltins));\n}\n\nfunction amd(magicString, { accessedGlobals, dependencies, exports, hasDefaultExport, hasExports, id, indent: t, intro, isEntryFacade, isModuleFacade, namedExportsMode, log, outro, snippets }, { amd, esModule, externalLiveBindings, freeze, generatedCode: { symbols }, interop, reexportProtoFromExternal, strict }) {\n    warnOnBuiltins(log, dependencies);\n    const deps = dependencies.map(m => `'${updateExtensionForRelativeAmdId(m.importPath, amd.forceJsExtensionForImports)}'`);\n    const parameters = dependencies.map(m => m.name);\n    const { n, getNonArrowFunctionIntro, _ } = snippets;\n    if (namedExportsMode && hasExports) {\n        parameters.unshift(`exports`);\n        deps.unshift(`'exports'`);\n    }\n    if (accessedGlobals.has('require')) {\n        parameters.unshift('require');\n        deps.unshift(`'require'`);\n    }\n    if (accessedGlobals.has('module')) {\n        parameters.unshift('module');\n        deps.unshift(`'module'`);\n    }\n    const completeAmdId = getCompleteAmdId(amd, id);\n    const defineParameters = (completeAmdId ? `'${completeAmdId}',${_}` : ``) +\n        (deps.length > 0 ? `[${deps.join(`,${_}`)}],${_}` : ``);\n    const useStrict = strict ? `${_}'use strict';` : '';\n    magicString.prepend(`${intro}${getInteropBlock(dependencies, interop, externalLiveBindings, freeze, symbols, accessedGlobals, t, snippets)}`);\n    const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings, reexportProtoFromExternal);\n    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, isEntryFacade && (esModule === true || (esModule === 'if-default-prop' && hasDefaultExport)), isModuleFacade && symbols, snippets);\n    if (namespaceMarkers) {\n        namespaceMarkers = n + n + namespaceMarkers;\n    }\n    magicString\n        .append(`${exportBlock}${namespaceMarkers}${outro}`)\n        .indent(t)\n        // factory function should be wrapped by parentheses to avoid lazy parsing,\n        // cf. https://v8.dev/blog/preparser#pife\n        .prepend(`${amd.define}(${defineParameters}(${getNonArrowFunctionIntro(parameters, {\n        isAsync: false,\n        name: null\n    })}{${useStrict}${n}${n}`)\n        .append(`${n}${n}}));`);\n}\n\nfunction cjs(magicString, { accessedGlobals, dependencies, exports, hasDefaultExport, hasExports, indent: t, intro, isEntryFacade, isModuleFacade, namedExportsMode, outro, snippets }, { compact, esModule, externalLiveBindings, freeze, interop, generatedCode: { symbols }, reexportProtoFromExternal, strict }) {\n    const { _, n } = snippets;\n    const useStrict = strict ? `'use strict';${n}${n}` : '';\n    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, isEntryFacade && (esModule === true || (esModule === 'if-default-prop' && hasDefaultExport)), isModuleFacade && symbols, snippets);\n    if (namespaceMarkers) {\n        namespaceMarkers += n + n;\n    }\n    const importBlock = getImportBlock$1(dependencies, snippets, compact);\n    const interopBlock = getInteropBlock(dependencies, interop, externalLiveBindings, freeze, symbols, accessedGlobals, t, snippets);\n    magicString.prepend(`${useStrict}${intro}${namespaceMarkers}${importBlock}${interopBlock}`);\n    const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings, reexportProtoFromExternal, `module.exports${_}=${_}`);\n    magicString.append(`${exportBlock}${outro}`);\n}\nfunction getImportBlock$1(dependencies, { _, cnst, n }, compact) {\n    let importBlock = '';\n    let definingVariable = false;\n    for (const { importPath, name, reexports, imports } of dependencies) {\n        if (!reexports && !imports) {\n            if (importBlock) {\n                importBlock += compact && !definingVariable ? ',' : `;${n}`;\n            }\n            definingVariable = false;\n            importBlock += `require('${importPath}')`;\n        }\n        else {\n            importBlock += compact && definingVariable ? ',' : `${importBlock ? `;${n}` : ''}${cnst} `;\n            definingVariable = true;\n            importBlock += `${name}${_}=${_}require('${importPath}')`;\n        }\n    }\n    if (importBlock) {\n        return `${importBlock};${n}${n}`;\n    }\n    return '';\n}\n\nfunction es(magicString, { accessedGlobals, indent: t, intro, outro, dependencies, exports, snippets }, { externalLiveBindings, freeze, generatedCode: { symbols }, importAttributesKey }) {\n    const { n } = snippets;\n    const importBlock = getImportBlock(dependencies, importAttributesKey, snippets);\n    if (importBlock.length > 0)\n        intro += importBlock.join(n) + n + n;\n    intro += getHelpersBlock(null, accessedGlobals, t, snippets, externalLiveBindings, freeze, symbols);\n    if (intro)\n        magicString.prepend(intro);\n    const exportBlock = getExportBlock(exports, snippets);\n    if (exportBlock.length > 0)\n        magicString.append(n + n + exportBlock.join(n).trim());\n    if (outro)\n        magicString.append(outro);\n    magicString.trim();\n}\nfunction getImportBlock(dependencies, importAttributesKey, { _ }) {\n    const importBlock = [];\n    for (const { importPath, reexports, imports, name, attributes } of dependencies) {\n        const assertion = attributes ? `${_}${importAttributesKey}${_}${attributes}` : '';\n        const pathWithAssertion = `'${importPath}'${assertion};`;\n        if (!reexports && !imports) {\n            importBlock.push(`import${_}${pathWithAssertion}`);\n            continue;\n        }\n        if (imports) {\n            let defaultImport = null;\n            let starImport = null;\n            const importedNames = [];\n            for (const specifier of imports) {\n                if (specifier.imported === 'default') {\n                    defaultImport = specifier;\n                }\n                else if (specifier.imported === '*') {\n                    starImport = specifier;\n                }\n                else {\n                    importedNames.push(specifier);\n                }\n            }\n            if (starImport) {\n                importBlock.push(`import${_}*${_}as ${starImport.local} from${_}${pathWithAssertion}`);\n            }\n            if (defaultImport && importedNames.length === 0) {\n                importBlock.push(`import ${defaultImport.local} from${_}${pathWithAssertion}`);\n            }\n            else if (importedNames.length > 0) {\n                importBlock.push(`import ${defaultImport ? `${defaultImport.local},${_}` : ''}{${_}${importedNames\n                    .map(specifier => specifier.imported === specifier.local\n                    ? specifier.imported\n                    : `${stringifyIdentifierIfNeeded(specifier.imported)} as ${specifier.local}`)\n                    .join(`,${_}`)}${_}}${_}from${_}${pathWithAssertion}`);\n            }\n        }\n        if (reexports) {\n            let starExport = null;\n            const namespaceReexports = [];\n            const namedReexports = [];\n            for (const specifier of reexports) {\n                if (specifier.reexported === '*') {\n                    starExport = specifier;\n                }\n                else if (specifier.imported === '*') {\n                    namespaceReexports.push(specifier);\n                }\n                else {\n                    namedReexports.push(specifier);\n                }\n            }\n            if (starExport) {\n                importBlock.push(`export${_}*${_}from${_}${pathWithAssertion}`);\n            }\n            if (namespaceReexports.length > 0) {\n                if (!imports ||\n                    !imports.some(specifier => specifier.imported === '*' && specifier.local === name)) {\n                    importBlock.push(`import${_}*${_}as ${name} from${_}${pathWithAssertion}`);\n                }\n                for (const specifier of namespaceReexports) {\n                    importBlock.push(`export${_}{${_}${name === specifier.reexported\n                        ? name\n                        : `${name} as ${stringifyIdentifierIfNeeded(specifier.reexported)}`} };`);\n                }\n            }\n            if (namedReexports.length > 0) {\n                importBlock.push(`export${_}{${_}${namedReexports\n                    .map(specifier => specifier.imported === specifier.reexported\n                    ? stringifyIdentifierIfNeeded(specifier.imported)\n                    : `${stringifyIdentifierIfNeeded(specifier.imported)} as ${stringifyIdentifierIfNeeded(specifier.reexported)}`)\n                    .join(`,${_}`)}${_}}${_}from${_}${pathWithAssertion}`);\n            }\n        }\n    }\n    return importBlock;\n}\nfunction getExportBlock(exports, { _, cnst }) {\n    const exportBlock = [];\n    const exportDeclaration = new Array(exports.length);\n    let index = 0;\n    for (const specifier of exports) {\n        if (specifier.expression) {\n            exportBlock.push(`${cnst} ${specifier.local}${_}=${_}${specifier.expression};`);\n        }\n        exportDeclaration[index++] =\n            specifier.exported === specifier.local\n                ? specifier.local\n                : `${specifier.local} as ${stringifyIdentifierIfNeeded(specifier.exported)}`;\n    }\n    if (exportDeclaration.length > 0) {\n        exportBlock.push(`export${_}{${_}${exportDeclaration.join(`,${_}`)}${_}};`);\n    }\n    return exportBlock;\n}\n\nconst keypath = (keypath, getPropertyAccess) => keypath.split('.').map(getPropertyAccess).join('');\n\nfunction setupNamespace(name, root, globals, { _, getPropertyAccess, s }, compact, log) {\n    const parts = name.split('.');\n    // Check if the key exists in the object's prototype.\n    const isReserved = parts[0] in Object.prototype;\n    if (log && isReserved) {\n        log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logReservedNamespace)(parts[0]));\n    }\n    parts[0] =\n        (typeof globals === 'function'\n            ? globals(parts[0])\n            : isReserved\n                ? parts[0]\n                : globals[parts[0]]) || parts[0];\n    parts.pop();\n    let propertyPath = root;\n    return (parts\n        .map(part => {\n        propertyPath += getPropertyAccess(part);\n        return `${propertyPath}${_}=${_}${propertyPath}${_}||${_}{}${s}`;\n    })\n        .join(compact ? ',' : '\\n') + (compact && parts.length > 0 ? ';' : '\\n'));\n}\nfunction assignToDeepVariable(deepName, root, globals, assignment, { _, getPropertyAccess }, log) {\n    const parts = deepName.split('.');\n    // Check if the key exists in the object's prototype.\n    const isReserved = parts[0] in Object.prototype;\n    if (log && isReserved) {\n        log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logReservedNamespace)(parts[0]));\n    }\n    parts[0] =\n        (typeof globals === 'function'\n            ? globals(parts[0])\n            : isReserved\n                ? parts[0]\n                : globals[parts[0]]) || parts[0];\n    const last = parts.pop();\n    let propertyPath = root;\n    let deepAssignment = [\n        ...parts.map(part => {\n            propertyPath += getPropertyAccess(part);\n            return `${propertyPath}${_}=${_}${propertyPath}${_}||${_}{}`;\n        }),\n        `${propertyPath}${getPropertyAccess(last)}`\n    ].join(`,${_}`) + `${_}=${_}${assignment}`;\n    if (parts.length > 0) {\n        deepAssignment = `(${deepAssignment})`;\n    }\n    return deepAssignment;\n}\n\nfunction trimEmptyImports(dependencies) {\n    let index = dependencies.length;\n    while (index--) {\n        const { imports, reexports } = dependencies[index];\n        if (imports || reexports) {\n            return dependencies.slice(0, index + 1);\n        }\n    }\n    return [];\n}\n\nfunction iife(magicString, { accessedGlobals, dependencies, exports, hasDefaultExport, hasExports, indent: t, intro, namedExportsMode, log, outro, snippets }, { compact, esModule, extend, freeze, externalLiveBindings, reexportProtoFromExternal, globals, interop, name, generatedCode: { symbols }, strict }) {\n    const { _, getNonArrowFunctionIntro, getPropertyAccess, n } = snippets;\n    const isNamespaced = name && name.includes('.');\n    const useVariableAssignment = !extend && !isNamespaced;\n    if (name && useVariableAssignment && !isLegal(name)) {\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logIllegalIdentifierAsName)(name));\n    }\n    warnOnBuiltins(log, dependencies);\n    const external = trimEmptyImports(dependencies);\n    const deps = external.map(dep => dep.globalName || 'null');\n    const parameters = external.map(m => m.name);\n    if (hasExports && !name) {\n        log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logMissingNameOptionForIifeExport)());\n    }\n    if (namedExportsMode && hasExports) {\n        if (extend) {\n            deps.unshift(`this${keypath(name, getPropertyAccess)}${_}=${_}this${keypath(name, getPropertyAccess)}${_}||${_}{}`);\n            parameters.unshift('exports');\n        }\n        else {\n            deps.unshift('{}');\n            parameters.unshift('exports');\n        }\n    }\n    const useStrict = strict ? `${t}'use strict';${n}` : '';\n    const interopBlock = getInteropBlock(dependencies, interop, externalLiveBindings, freeze, symbols, accessedGlobals, t, snippets);\n    magicString.prepend(`${intro}${interopBlock}`);\n    let wrapperIntro = `(${getNonArrowFunctionIntro(parameters, {\n        isAsync: false,\n        name: null\n    })}{${n}${useStrict}${n}`;\n    if (hasExports) {\n        if (name && !(extend && namedExportsMode)) {\n            wrapperIntro =\n                (useVariableAssignment ? `var ${name}` : `this${keypath(name, getPropertyAccess)}`) +\n                    `${_}=${_}${wrapperIntro}`;\n        }\n        if (isNamespaced) {\n            wrapperIntro = setupNamespace(name, 'this', globals, snippets, compact, log) + wrapperIntro;\n        }\n    }\n    let wrapperOutro = `${n}${n}})(${deps.join(`,${_}`)});`;\n    if (hasExports && !extend && namedExportsMode) {\n        wrapperOutro = `${n}${n}${t}return exports;${wrapperOutro}`;\n    }\n    const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings, reexportProtoFromExternal);\n    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, esModule === true || (esModule === 'if-default-prop' && hasDefaultExport), symbols, snippets);\n    if (namespaceMarkers) {\n        namespaceMarkers = n + n + namespaceMarkers;\n    }\n    magicString\n        .append(`${exportBlock}${namespaceMarkers}${outro}`)\n        .indent(t)\n        .prepend(wrapperIntro)\n        .append(wrapperOutro);\n}\n\nconst MISSING_EXPORT_SHIM_VARIABLE = '_missingExportShim';\n\nfunction system(magicString, { accessedGlobals, dependencies, exports, hasExports, indent: t, intro, snippets, outro, usesTopLevelAwait }, { externalLiveBindings, freeze, name, generatedCode: { symbols }, strict, systemNullSetters }) {\n    const { _, getFunctionIntro, getNonArrowFunctionIntro, n, s } = snippets;\n    const { importBindings, setters, starExcludes } = analyzeDependencies(dependencies, exports, t, snippets);\n    const registeredName = name ? `'${name}',${_}` : '';\n    const wrapperParameters = accessedGlobals.has('module')\n        ? ['exports', 'module']\n        : hasExports\n            ? ['exports']\n            : [];\n    // factory function should be wrapped by parentheses to avoid lazy parsing,\n    // cf. https://v8.dev/blog/preparser#pife\n    let wrapperStart = `System.register(${registeredName}[` +\n        dependencies.map(({ importPath }) => `'${importPath}'`).join(`,${_}`) +\n        `],${_}(${getNonArrowFunctionIntro(wrapperParameters, {\n            isAsync: false,\n            name: null\n        })}{${n}${t}${strict ? \"'use strict';\" : ''}` +\n        getStarExcludesBlock(starExcludes, t, snippets) +\n        getImportBindingsBlock(importBindings, t, snippets) +\n        `${n}${t}return${_}{${setters.length > 0\n            ? `${n}${t}${t}setters:${_}[${setters\n                .map(setter => setter\n                ? `${getFunctionIntro(['module'], {\n                    isAsync: false,\n                    name: null\n                })}{${n}${t}${t}${t}${setter}${n}${t}${t}}`\n                : systemNullSetters\n                    ? `null`\n                    : `${getFunctionIntro([], { isAsync: false, name: null })}{}`)\n                .join(`,${_}`)}],`\n            : ''}${n}`;\n    wrapperStart += `${t}${t}execute:${_}(${getNonArrowFunctionIntro([], {\n        isAsync: usesTopLevelAwait,\n        name: null\n    })}{${n}${n}`;\n    const wrapperEnd = `${t}${t}})${n}${t}}${s}${n}}));`;\n    magicString\n        .prepend(intro +\n        getHelpersBlock(null, accessedGlobals, t, snippets, externalLiveBindings, freeze, symbols) +\n        getHoistedExportsBlock(exports, t, snippets))\n        .append(`${outro}${n}${n}` +\n        getSyntheticExportsBlock(exports, t, snippets) +\n        getMissingExportsBlock(exports, t, snippets))\n        .indent(`${t}${t}${t}`)\n        .append(wrapperEnd)\n        .prepend(wrapperStart);\n}\nfunction analyzeDependencies(dependencies, exports, t, { _, cnst, getObject, getPropertyAccess, n }) {\n    const importBindings = [];\n    const setters = [];\n    let starExcludes = null;\n    for (const { imports, reexports } of dependencies) {\n        const setter = [];\n        if (imports) {\n            for (const specifier of imports) {\n                importBindings.push(specifier.local);\n                if (specifier.imported === '*') {\n                    setter.push(`${specifier.local}${_}=${_}module;`);\n                }\n                else {\n                    setter.push(`${specifier.local}${_}=${_}module${getPropertyAccess(specifier.imported)};`);\n                }\n            }\n        }\n        if (reexports) {\n            const reexportedNames = [];\n            let hasStarReexport = false;\n            for (const { imported, reexported } of reexports) {\n                if (reexported === '*') {\n                    hasStarReexport = true;\n                }\n                else {\n                    reexportedNames.push([\n                        reexported,\n                        imported === '*' ? 'module' : `module${getPropertyAccess(imported)}`\n                    ]);\n                }\n            }\n            if (reexportedNames.length > 1 || hasStarReexport) {\n                if (hasStarReexport) {\n                    if (!starExcludes) {\n                        starExcludes = getStarExcludes({ dependencies, exports });\n                    }\n                    reexportedNames.unshift([null, `__proto__:${_}null`]);\n                    const exportMapping = getObject(reexportedNames, { lineBreakIndent: null });\n                    setter.push(`${cnst} setter${_}=${_}${exportMapping};`, `for${_}(${cnst} name in module)${_}{`, `${t}if${_}(!_starExcludes[name])${_}setter[name]${_}=${_}module[name];`, '}', 'exports(setter);');\n                }\n                else {\n                    const exportMapping = getObject(reexportedNames, { lineBreakIndent: null });\n                    setter.push(`exports(${exportMapping});`);\n                }\n            }\n            else {\n                const [key, value] = reexportedNames[0];\n                setter.push(`exports(${JSON.stringify(key)},${_}${value});`);\n            }\n        }\n        setters.push(setter.join(`${n}${t}${t}${t}`));\n    }\n    return { importBindings, setters, starExcludes };\n}\nconst getStarExcludes = ({ dependencies, exports }) => {\n    const starExcludes = new Set(exports.map(expt => expt.exported));\n    starExcludes.add('default');\n    for (const { reexports } of dependencies) {\n        if (reexports) {\n            for (const reexport of reexports) {\n                if (reexport.reexported !== '*')\n                    starExcludes.add(reexport.reexported);\n            }\n        }\n    }\n    return starExcludes;\n};\nconst getStarExcludesBlock = (starExcludes, t, { _, cnst, getObject, n }) => {\n    if (starExcludes) {\n        const fields = [...starExcludes].map(property => [\n            property,\n            '1'\n        ]);\n        fields.unshift([null, `__proto__:${_}null`]);\n        return `${n}${t}${cnst} _starExcludes${_}=${_}${getObject(fields, {\n            lineBreakIndent: { base: t, t }\n        })};`;\n    }\n    return '';\n};\nconst getImportBindingsBlock = (importBindings, t, { _, n }) => (importBindings.length > 0 ? `${n}${t}var ${importBindings.join(`,${_}`)};` : '');\nconst getHoistedExportsBlock = (exports, t, snippets) => getExportsBlock(exports.filter(expt => expt.hoisted).map(expt => ({ name: expt.exported, value: expt.local })), t, snippets);\nfunction getExportsBlock(exports, t, { _, n }) {\n    if (exports.length === 0) {\n        return '';\n    }\n    if (exports.length === 1) {\n        return `exports(${JSON.stringify(exports[0].name)},${_}${exports[0].value});${n}${n}`;\n    }\n    return (`exports({${n}` +\n        exports\n            .map(({ name, value }) => `${t}${stringifyObjectKeyIfNeeded(name)}:${_}${value}`)\n            .join(`,${n}`) +\n        `${n}});${n}${n}`);\n}\nconst getSyntheticExportsBlock = (exports, t, snippets) => getExportsBlock(exports\n    .filter(expt => expt.expression)\n    .map(expt => ({ name: expt.exported, value: expt.local })), t, snippets);\nconst getMissingExportsBlock = (exports, t, snippets) => getExportsBlock(exports\n    .filter(expt => expt.local === MISSING_EXPORT_SHIM_VARIABLE)\n    .map(expt => ({ name: expt.exported, value: MISSING_EXPORT_SHIM_VARIABLE })), t, snippets);\n\nfunction globalProperty(name, globalVariable, getPropertyAccess) {\n    if (!name)\n        return 'null';\n    return `${globalVariable}${keypath(name, getPropertyAccess)}`;\n}\nfunction safeAccess(name, globalVariable, { _, getPropertyAccess }) {\n    let propertyPath = globalVariable;\n    return name\n        .split('.')\n        .map(part => (propertyPath += getPropertyAccess(part)))\n        .join(`${_}&&${_}`);\n}\nfunction umd(magicString, { accessedGlobals, dependencies, exports, hasDefaultExport, hasExports, id, indent: t, intro, namedExportsMode, log, outro, snippets }, { amd, compact, esModule, extend, externalLiveBindings, freeze, interop, name, generatedCode: { symbols }, globals, noConflict, reexportProtoFromExternal, strict }) {\n    const { _, cnst, getFunctionIntro, getNonArrowFunctionIntro, getPropertyAccess, n, s } = snippets;\n    const factoryVariable = compact ? 'f' : 'factory';\n    const globalVariable = compact ? 'g' : 'global';\n    if (hasExports && !name) {\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logMissingNameOptionForUmdExport)());\n    }\n    warnOnBuiltins(log, dependencies);\n    const amdDeps = dependencies.map(m => `'${updateExtensionForRelativeAmdId(m.importPath, amd.forceJsExtensionForImports)}'`);\n    const cjsDeps = dependencies.map(m => `require('${m.importPath}')`);\n    const trimmedImports = trimEmptyImports(dependencies);\n    const globalDeps = trimmedImports.map(module => globalProperty(module.globalName, globalVariable, getPropertyAccess));\n    const factoryParameters = trimmedImports.map(m => m.name);\n    if (namedExportsMode && (hasExports || noConflict)) {\n        amdDeps.unshift(`'exports'`);\n        cjsDeps.unshift(`exports`);\n        globalDeps.unshift(assignToDeepVariable(name, globalVariable, globals, `${extend ? `${globalProperty(name, globalVariable, getPropertyAccess)}${_}||${_}` : ''}{}`, snippets, log));\n        factoryParameters.unshift('exports');\n    }\n    const completeAmdId = getCompleteAmdId(amd, id);\n    const amdParameters = (completeAmdId ? `'${completeAmdId}',${_}` : ``) +\n        (amdDeps.length > 0 ? `[${amdDeps.join(`,${_}`)}],${_}` : ``);\n    const define = amd.define;\n    const cjsExport = !namedExportsMode && hasExports ? `module.exports${_}=${_}` : ``;\n    const useStrict = strict ? `${_}'use strict';${n}` : ``;\n    let iifeExport;\n    if (noConflict) {\n        const noConflictExportsVariable = compact ? 'e' : 'exports';\n        let factory;\n        if (!namedExportsMode && hasExports) {\n            factory = `${cnst} ${noConflictExportsVariable}${_}=${_}${assignToDeepVariable(name, globalVariable, globals, `${factoryVariable}(${globalDeps.join(`,${_}`)})`, snippets, log)};`;\n        }\n        else {\n            const module = globalDeps.shift();\n            factory =\n                `${cnst} ${noConflictExportsVariable}${_}=${_}${module};${n}` +\n                    `${t}${t}${factoryVariable}(${[noConflictExportsVariable, ...globalDeps].join(`,${_}`)});`;\n        }\n        iifeExport =\n            `(${getFunctionIntro([], { isAsync: false, name: null })}{${n}` +\n                `${t}${t}${cnst} current${_}=${_}${safeAccess(name, globalVariable, snippets)};${n}` +\n                `${t}${t}${factory}${n}` +\n                `${t}${t}${noConflictExportsVariable}.noConflict${_}=${_}${getFunctionIntro([], {\n                    isAsync: false,\n                    name: null\n                })}{${_}` +\n                `${globalProperty(name, globalVariable, getPropertyAccess)}${_}=${_}current;${_}return ${noConflictExportsVariable}${s}${_}};${n}` +\n                `${t}})()`;\n    }\n    else {\n        iifeExport = `${factoryVariable}(${globalDeps.join(`,${_}`)})`;\n        if (!namedExportsMode && hasExports) {\n            iifeExport = assignToDeepVariable(name, globalVariable, globals, iifeExport, snippets, log);\n        }\n    }\n    const iifeNeedsGlobal = hasExports || (noConflict && namedExportsMode) || globalDeps.length > 0;\n    const wrapperParameters = [factoryVariable];\n    if (iifeNeedsGlobal) {\n        wrapperParameters.unshift(globalVariable);\n    }\n    const globalArgument = iifeNeedsGlobal ? `this,${_}` : '';\n    const iifeStart = iifeNeedsGlobal\n        ? `(${globalVariable}${_}=${_}typeof globalThis${_}!==${_}'undefined'${_}?${_}globalThis${_}:${_}${globalVariable}${_}||${_}self,${_}`\n        : '';\n    const iifeEnd = iifeNeedsGlobal ? ')' : '';\n    const cjsIntro = iifeNeedsGlobal\n        ? `${t}typeof exports${_}===${_}'object'${_}&&${_}typeof module${_}!==${_}'undefined'${_}?` +\n            `${_}${cjsExport}${factoryVariable}(${cjsDeps.join(`,${_}`)})${_}:${n}`\n        : '';\n    const wrapperIntro = `(${getNonArrowFunctionIntro(wrapperParameters, { isAsync: false, name: null })}{${n}` +\n        cjsIntro +\n        `${t}typeof ${define}${_}===${_}'function'${_}&&${_}${define}.amd${_}?${_}${define}(${amdParameters}${factoryVariable})${_}:${n}` +\n        `${t}${iifeStart}${iifeExport}${iifeEnd};${n}` +\n        // factory function should be wrapped by parentheses to avoid lazy parsing,\n        // cf. https://v8.dev/blog/preparser#pife\n        `})(${globalArgument}(${getNonArrowFunctionIntro(factoryParameters, {\n            isAsync: false,\n            name: null\n        })}{${useStrict}${n}`;\n    const wrapperOutro = n + n + '}));';\n    magicString.prepend(`${intro}${getInteropBlock(dependencies, interop, externalLiveBindings, freeze, symbols, accessedGlobals, t, snippets)}`);\n    const exportBlock = getExportBlock$1(exports, dependencies, namedExportsMode, interop, snippets, t, externalLiveBindings, reexportProtoFromExternal);\n    let namespaceMarkers = getNamespaceMarkers(namedExportsMode && hasExports, esModule === true || (esModule === 'if-default-prop' && hasDefaultExport), symbols, snippets);\n    if (namespaceMarkers) {\n        namespaceMarkers = n + n + namespaceMarkers;\n    }\n    magicString\n        .append(`${exportBlock}${namespaceMarkers}${outro}`)\n        .trim()\n        .indent(t)\n        .append(wrapperOutro)\n        .prepend(wrapperIntro);\n}\n\nconst finalisers = { amd, cjs, es, iife, system, umd };\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction getAugmentedNamespace(n) {\n  if (n.__esModule) return n;\n  var f = n.default;\n\tif (typeof f == \"function\") {\n\t\tvar a = function a () {\n\t\t\tif (this instanceof a) {\n        return Reflect.construct(f, arguments, this.constructor);\n\t\t\t}\n\t\t\treturn f.apply(this, arguments);\n\t\t};\n\t\ta.prototype = f.prototype;\n  } else a = {};\n  Object.defineProperty(a, '__esModule', {value: true});\n\tObject.keys(n).forEach(function (k) {\n\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn n[k];\n\t\t\t}\n\t\t});\n\t});\n\treturn a;\n}\n\nvar utils = {};\n\nvar constants;\nvar hasRequiredConstants;\n\nfunction requireConstants () {\n\tif (hasRequiredConstants) return constants;\n\thasRequiredConstants = 1;\n\n\tconst WIN_SLASH = '\\\\\\\\/';\n\tconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n\t/**\n\t * Posix glob regex\n\t */\n\n\tconst DOT_LITERAL = '\\\\.';\n\tconst PLUS_LITERAL = '\\\\+';\n\tconst QMARK_LITERAL = '\\\\?';\n\tconst SLASH_LITERAL = '\\\\/';\n\tconst ONE_CHAR = '(?=.)';\n\tconst QMARK = '[^/]';\n\tconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\n\tconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\n\tconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\n\tconst NO_DOT = `(?!${DOT_LITERAL})`;\n\tconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\n\tconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\n\tconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\n\tconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\n\tconst STAR = `${QMARK}*?`;\n\tconst SEP = '/';\n\n\tconst POSIX_CHARS = {\n\t  DOT_LITERAL,\n\t  PLUS_LITERAL,\n\t  QMARK_LITERAL,\n\t  SLASH_LITERAL,\n\t  ONE_CHAR,\n\t  QMARK,\n\t  END_ANCHOR,\n\t  DOTS_SLASH,\n\t  NO_DOT,\n\t  NO_DOTS,\n\t  NO_DOT_SLASH,\n\t  NO_DOTS_SLASH,\n\t  QMARK_NO_DOT,\n\t  STAR,\n\t  START_ANCHOR,\n\t  SEP\n\t};\n\n\t/**\n\t * Windows glob regex\n\t */\n\n\tconst WINDOWS_CHARS = {\n\t  ...POSIX_CHARS,\n\n\t  SLASH_LITERAL: `[${WIN_SLASH}]`,\n\t  QMARK: WIN_NO_SLASH,\n\t  STAR: `${WIN_NO_SLASH}*?`,\n\t  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n\t  NO_DOT: `(?!${DOT_LITERAL})`,\n\t  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n\t  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n\t  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n\t  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n\t  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n\t  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,\n\t  SEP: '\\\\'\n\t};\n\n\t/**\n\t * POSIX Bracket Regex\n\t */\n\n\tconst POSIX_REGEX_SOURCE = {\n\t  alnum: 'a-zA-Z0-9',\n\t  alpha: 'a-zA-Z',\n\t  ascii: '\\\\x00-\\\\x7F',\n\t  blank: ' \\\\t',\n\t  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n\t  digit: '0-9',\n\t  graph: '\\\\x21-\\\\x7E',\n\t  lower: 'a-z',\n\t  print: '\\\\x20-\\\\x7E ',\n\t  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n\t  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n\t  upper: 'A-Z',\n\t  word: 'A-Za-z0-9_',\n\t  xdigit: 'A-Fa-f0-9'\n\t};\n\n\tconstants = {\n\t  MAX_LENGTH: 1024 * 64,\n\t  POSIX_REGEX_SOURCE,\n\n\t  // regular expressions\n\t  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n\t  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n\t  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n\t  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n\t  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n\t  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n\t  // Replace globs with equivalent patterns to reduce parsing time.\n\t  REPLACEMENTS: {\n\t    '***': '*',\n\t    '**/**': '**',\n\t    '**/**/**': '**'\n\t  },\n\n\t  // Digits\n\t  CHAR_0: 48, /* 0 */\n\t  CHAR_9: 57, /* 9 */\n\n\t  // Alphabet chars.\n\t  CHAR_UPPERCASE_A: 65, /* A */\n\t  CHAR_LOWERCASE_A: 97, /* a */\n\t  CHAR_UPPERCASE_Z: 90, /* Z */\n\t  CHAR_LOWERCASE_Z: 122, /* z */\n\n\t  CHAR_LEFT_PARENTHESES: 40, /* ( */\n\t  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n\t  CHAR_ASTERISK: 42, /* * */\n\n\t  // Non-alphabetic chars.\n\t  CHAR_AMPERSAND: 38, /* & */\n\t  CHAR_AT: 64, /* @ */\n\t  CHAR_BACKWARD_SLASH: 92, /* \\ */\n\t  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n\t  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n\t  CHAR_COLON: 58, /* : */\n\t  CHAR_COMMA: 44, /* , */\n\t  CHAR_DOT: 46, /* . */\n\t  CHAR_DOUBLE_QUOTE: 34, /* \" */\n\t  CHAR_EQUAL: 61, /* = */\n\t  CHAR_EXCLAMATION_MARK: 33, /* ! */\n\t  CHAR_FORM_FEED: 12, /* \\f */\n\t  CHAR_FORWARD_SLASH: 47, /* / */\n\t  CHAR_GRAVE_ACCENT: 96, /* ` */\n\t  CHAR_HASH: 35, /* # */\n\t  CHAR_HYPHEN_MINUS: 45, /* - */\n\t  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n\t  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n\t  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n\t  CHAR_LINE_FEED: 10, /* \\n */\n\t  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n\t  CHAR_PERCENT: 37, /* % */\n\t  CHAR_PLUS: 43, /* + */\n\t  CHAR_QUESTION_MARK: 63, /* ? */\n\t  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n\t  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n\t  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n\t  CHAR_SEMICOLON: 59, /* ; */\n\t  CHAR_SINGLE_QUOTE: 39, /* ' */\n\t  CHAR_SPACE: 32, /*   */\n\t  CHAR_TAB: 9, /* \\t */\n\t  CHAR_UNDERSCORE: 95, /* _ */\n\t  CHAR_VERTICAL_LINE: 124, /* | */\n\t  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n\t  /**\n\t   * Create EXTGLOB_CHARS\n\t   */\n\n\t  extglobChars(chars) {\n\t    return {\n\t      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n\t      '?': { type: 'qmark', open: '(?:', close: ')?' },\n\t      '+': { type: 'plus', open: '(?:', close: ')+' },\n\t      '*': { type: 'star', open: '(?:', close: ')*' },\n\t      '@': { type: 'at', open: '(?:', close: ')' }\n\t    };\n\t  },\n\n\t  /**\n\t   * Create GLOB_CHARS\n\t   */\n\n\t  globChars(win32) {\n\t    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n\t  }\n\t};\n\treturn constants;\n}\n\n/*global navigator*/\n\nvar hasRequiredUtils;\n\nfunction requireUtils () {\n\tif (hasRequiredUtils) return utils;\n\thasRequiredUtils = 1;\n\t(function (exports) {\n\n\t\tconst {\n\t\t  REGEX_BACKSLASH,\n\t\t  REGEX_REMOVE_BACKSLASH,\n\t\t  REGEX_SPECIAL_CHARS,\n\t\t  REGEX_SPECIAL_CHARS_GLOBAL\n\t\t} = /*@__PURE__*/ requireConstants();\n\n\t\texports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\t\texports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\n\t\texports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\n\t\texports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\n\t\texports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\n\t\texports.isWindows = () => {\n\t\t  if (typeof navigator !== 'undefined' && navigator.platform) {\n\t\t    const platform = navigator.platform.toLowerCase();\n\t\t    return platform === 'win32' || platform === 'windows';\n\t\t  }\n\n\t\t  if (typeof process !== 'undefined' && process.platform) {\n\t\t    return process.platform === 'win32';\n\t\t  }\n\n\t\t  return false;\n\t\t};\n\n\t\texports.removeBackslashes = str => {\n\t\t  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n\t\t    return match === '\\\\' ? '' : match;\n\t\t  });\n\t\t};\n\n\t\texports.escapeLast = (input, char, lastIdx) => {\n\t\t  const idx = input.lastIndexOf(char, lastIdx);\n\t\t  if (idx === -1) return input;\n\t\t  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n\t\t  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n\t\t};\n\n\t\texports.removePrefix = (input, state = {}) => {\n\t\t  let output = input;\n\t\t  if (output.startsWith('./')) {\n\t\t    output = output.slice(2);\n\t\t    state.prefix = './';\n\t\t  }\n\t\t  return output;\n\t\t};\n\n\t\texports.wrapOutput = (input, state = {}, options = {}) => {\n\t\t  const prepend = options.contains ? '' : '^';\n\t\t  const append = options.contains ? '' : '$';\n\n\t\t  let output = `${prepend}(?:${input})${append}`;\n\t\t  if (state.negated === true) {\n\t\t    output = `(?:^(?!${output}).*$)`;\n\t\t  }\n\t\t  return output;\n\t\t};\n\n\t\texports.basename = (path, { windows } = {}) => {\n\t\t  const segs = path.split(windows ? /[\\\\/]/ : '/');\n\t\t  const last = segs[segs.length - 1];\n\n\t\t  if (last === '') {\n\t\t    return segs[segs.length - 2];\n\t\t  }\n\n\t\t  return last;\n\t\t}; \n\t} (utils));\n\treturn utils;\n}\n\nvar scan_1;\nvar hasRequiredScan;\n\nfunction requireScan () {\n\tif (hasRequiredScan) return scan_1;\n\thasRequiredScan = 1;\n\n\tconst utils = /*@__PURE__*/ requireUtils();\n\tconst {\n\t  CHAR_ASTERISK,             /* * */\n\t  CHAR_AT,                   /* @ */\n\t  CHAR_BACKWARD_SLASH,       /* \\ */\n\t  CHAR_COMMA,                /* , */\n\t  CHAR_DOT,                  /* . */\n\t  CHAR_EXCLAMATION_MARK,     /* ! */\n\t  CHAR_FORWARD_SLASH,        /* / */\n\t  CHAR_LEFT_CURLY_BRACE,     /* { */\n\t  CHAR_LEFT_PARENTHESES,     /* ( */\n\t  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n\t  CHAR_PLUS,                 /* + */\n\t  CHAR_QUESTION_MARK,        /* ? */\n\t  CHAR_RIGHT_CURLY_BRACE,    /* } */\n\t  CHAR_RIGHT_PARENTHESES,    /* ) */\n\t  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n\t} = /*@__PURE__*/ requireConstants();\n\n\tconst isPathSeparator = code => {\n\t  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n\t};\n\n\tconst depth = token => {\n\t  if (token.isPrefix !== true) {\n\t    token.depth = token.isGlobstar ? Infinity : 1;\n\t  }\n\t};\n\n\t/**\n\t * Quickly scans a glob pattern and returns an object with a handful of\n\t * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n\t * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n\t * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n\t *\n\t * ```js\n\t * const pm = require('picomatch');\n\t * console.log(pm.scan('foo/bar/*.js'));\n\t * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n\t * ```\n\t * @param {String} `str`\n\t * @param {Object} `options`\n\t * @return {Object} Returns an object with tokens and regex source string.\n\t * @api public\n\t */\n\n\tconst scan = (input, options) => {\n\t  const opts = options || {};\n\n\t  const length = input.length - 1;\n\t  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n\t  const slashes = [];\n\t  const tokens = [];\n\t  const parts = [];\n\n\t  let str = input;\n\t  let index = -1;\n\t  let start = 0;\n\t  let lastIndex = 0;\n\t  let isBrace = false;\n\t  let isBracket = false;\n\t  let isGlob = false;\n\t  let isExtglob = false;\n\t  let isGlobstar = false;\n\t  let braceEscaped = false;\n\t  let backslashes = false;\n\t  let negated = false;\n\t  let negatedExtglob = false;\n\t  let finished = false;\n\t  let braces = 0;\n\t  let prev;\n\t  let code;\n\t  let token = { value: '', depth: 0, isGlob: false };\n\n\t  const eos = () => index >= length;\n\t  const peek = () => str.charCodeAt(index + 1);\n\t  const advance = () => {\n\t    prev = code;\n\t    return str.charCodeAt(++index);\n\t  };\n\n\t  while (index < length) {\n\t    code = advance();\n\t    let next;\n\n\t    if (code === CHAR_BACKWARD_SLASH) {\n\t      backslashes = token.backslashes = true;\n\t      code = advance();\n\n\t      if (code === CHAR_LEFT_CURLY_BRACE) {\n\t        braceEscaped = true;\n\t      }\n\t      continue;\n\t    }\n\n\t    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n\t      braces++;\n\n\t      while (eos() !== true && (code = advance())) {\n\t        if (code === CHAR_BACKWARD_SLASH) {\n\t          backslashes = token.backslashes = true;\n\t          advance();\n\t          continue;\n\t        }\n\n\t        if (code === CHAR_LEFT_CURLY_BRACE) {\n\t          braces++;\n\t          continue;\n\t        }\n\n\t        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n\t          isBrace = token.isBrace = true;\n\t          isGlob = token.isGlob = true;\n\t          finished = true;\n\n\t          if (scanToEnd === true) {\n\t            continue;\n\t          }\n\n\t          break;\n\t        }\n\n\t        if (braceEscaped !== true && code === CHAR_COMMA) {\n\t          isBrace = token.isBrace = true;\n\t          isGlob = token.isGlob = true;\n\t          finished = true;\n\n\t          if (scanToEnd === true) {\n\t            continue;\n\t          }\n\n\t          break;\n\t        }\n\n\t        if (code === CHAR_RIGHT_CURLY_BRACE) {\n\t          braces--;\n\n\t          if (braces === 0) {\n\t            braceEscaped = false;\n\t            isBrace = token.isBrace = true;\n\t            finished = true;\n\t            break;\n\t          }\n\t        }\n\t      }\n\n\t      if (scanToEnd === true) {\n\t        continue;\n\t      }\n\n\t      break;\n\t    }\n\n\t    if (code === CHAR_FORWARD_SLASH) {\n\t      slashes.push(index);\n\t      tokens.push(token);\n\t      token = { value: '', depth: 0, isGlob: false };\n\n\t      if (finished === true) continue;\n\t      if (prev === CHAR_DOT && index === (start + 1)) {\n\t        start += 2;\n\t        continue;\n\t      }\n\n\t      lastIndex = index + 1;\n\t      continue;\n\t    }\n\n\t    if (opts.noext !== true) {\n\t      const isExtglobChar = code === CHAR_PLUS\n\t        || code === CHAR_AT\n\t        || code === CHAR_ASTERISK\n\t        || code === CHAR_QUESTION_MARK\n\t        || code === CHAR_EXCLAMATION_MARK;\n\n\t      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n\t        isGlob = token.isGlob = true;\n\t        isExtglob = token.isExtglob = true;\n\t        finished = true;\n\t        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n\t          negatedExtglob = true;\n\t        }\n\n\t        if (scanToEnd === true) {\n\t          while (eos() !== true && (code = advance())) {\n\t            if (code === CHAR_BACKWARD_SLASH) {\n\t              backslashes = token.backslashes = true;\n\t              code = advance();\n\t              continue;\n\t            }\n\n\t            if (code === CHAR_RIGHT_PARENTHESES) {\n\t              isGlob = token.isGlob = true;\n\t              finished = true;\n\t              break;\n\t            }\n\t          }\n\t          continue;\n\t        }\n\t        break;\n\t      }\n\t    }\n\n\t    if (code === CHAR_ASTERISK) {\n\t      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n\t      isGlob = token.isGlob = true;\n\t      finished = true;\n\n\t      if (scanToEnd === true) {\n\t        continue;\n\t      }\n\t      break;\n\t    }\n\n\t    if (code === CHAR_QUESTION_MARK) {\n\t      isGlob = token.isGlob = true;\n\t      finished = true;\n\n\t      if (scanToEnd === true) {\n\t        continue;\n\t      }\n\t      break;\n\t    }\n\n\t    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n\t      while (eos() !== true && (next = advance())) {\n\t        if (next === CHAR_BACKWARD_SLASH) {\n\t          backslashes = token.backslashes = true;\n\t          advance();\n\t          continue;\n\t        }\n\n\t        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n\t          isBracket = token.isBracket = true;\n\t          isGlob = token.isGlob = true;\n\t          finished = true;\n\t          break;\n\t        }\n\t      }\n\n\t      if (scanToEnd === true) {\n\t        continue;\n\t      }\n\n\t      break;\n\t    }\n\n\t    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n\t      negated = token.negated = true;\n\t      start++;\n\t      continue;\n\t    }\n\n\t    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n\t      isGlob = token.isGlob = true;\n\n\t      if (scanToEnd === true) {\n\t        while (eos() !== true && (code = advance())) {\n\t          if (code === CHAR_LEFT_PARENTHESES) {\n\t            backslashes = token.backslashes = true;\n\t            code = advance();\n\t            continue;\n\t          }\n\n\t          if (code === CHAR_RIGHT_PARENTHESES) {\n\t            finished = true;\n\t            break;\n\t          }\n\t        }\n\t        continue;\n\t      }\n\t      break;\n\t    }\n\n\t    if (isGlob === true) {\n\t      finished = true;\n\n\t      if (scanToEnd === true) {\n\t        continue;\n\t      }\n\n\t      break;\n\t    }\n\t  }\n\n\t  if (opts.noext === true) {\n\t    isExtglob = false;\n\t    isGlob = false;\n\t  }\n\n\t  let base = str;\n\t  let prefix = '';\n\t  let glob = '';\n\n\t  if (start > 0) {\n\t    prefix = str.slice(0, start);\n\t    str = str.slice(start);\n\t    lastIndex -= start;\n\t  }\n\n\t  if (base && isGlob === true && lastIndex > 0) {\n\t    base = str.slice(0, lastIndex);\n\t    glob = str.slice(lastIndex);\n\t  } else if (isGlob === true) {\n\t    base = '';\n\t    glob = str;\n\t  } else {\n\t    base = str;\n\t  }\n\n\t  if (base && base !== '' && base !== '/' && base !== str) {\n\t    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n\t      base = base.slice(0, -1);\n\t    }\n\t  }\n\n\t  if (opts.unescape === true) {\n\t    if (glob) glob = utils.removeBackslashes(glob);\n\n\t    if (base && backslashes === true) {\n\t      base = utils.removeBackslashes(base);\n\t    }\n\t  }\n\n\t  const state = {\n\t    prefix,\n\t    input,\n\t    start,\n\t    base,\n\t    glob,\n\t    isBrace,\n\t    isBracket,\n\t    isGlob,\n\t    isExtglob,\n\t    isGlobstar,\n\t    negated,\n\t    negatedExtglob\n\t  };\n\n\t  if (opts.tokens === true) {\n\t    state.maxDepth = 0;\n\t    if (!isPathSeparator(code)) {\n\t      tokens.push(token);\n\t    }\n\t    state.tokens = tokens;\n\t  }\n\n\t  if (opts.parts === true || opts.tokens === true) {\n\t    let prevIndex;\n\n\t    for (let idx = 0; idx < slashes.length; idx++) {\n\t      const n = prevIndex ? prevIndex + 1 : start;\n\t      const i = slashes[idx];\n\t      const value = input.slice(n, i);\n\t      if (opts.tokens) {\n\t        if (idx === 0 && start !== 0) {\n\t          tokens[idx].isPrefix = true;\n\t          tokens[idx].value = prefix;\n\t        } else {\n\t          tokens[idx].value = value;\n\t        }\n\t        depth(tokens[idx]);\n\t        state.maxDepth += tokens[idx].depth;\n\t      }\n\t      if (idx !== 0 || value !== '') {\n\t        parts.push(value);\n\t      }\n\t      prevIndex = i;\n\t    }\n\n\t    if (prevIndex && prevIndex + 1 < input.length) {\n\t      const value = input.slice(prevIndex + 1);\n\t      parts.push(value);\n\n\t      if (opts.tokens) {\n\t        tokens[tokens.length - 1].value = value;\n\t        depth(tokens[tokens.length - 1]);\n\t        state.maxDepth += tokens[tokens.length - 1].depth;\n\t      }\n\t    }\n\n\t    state.slashes = slashes;\n\t    state.parts = parts;\n\t  }\n\n\t  return state;\n\t};\n\n\tscan_1 = scan;\n\treturn scan_1;\n}\n\nvar parse_1;\nvar hasRequiredParse;\n\nfunction requireParse () {\n\tif (hasRequiredParse) return parse_1;\n\thasRequiredParse = 1;\n\n\tconst constants = /*@__PURE__*/ requireConstants();\n\tconst utils = /*@__PURE__*/ requireUtils();\n\n\t/**\n\t * Constants\n\t */\n\n\tconst {\n\t  MAX_LENGTH,\n\t  POSIX_REGEX_SOURCE,\n\t  REGEX_NON_SPECIAL_CHARS,\n\t  REGEX_SPECIAL_CHARS_BACKREF,\n\t  REPLACEMENTS\n\t} = constants;\n\n\t/**\n\t * Helpers\n\t */\n\n\tconst expandRange = (args, options) => {\n\t  if (typeof options.expandRange === 'function') {\n\t    return options.expandRange(...args, options);\n\t  }\n\n\t  args.sort();\n\t  const value = `[${args.join('-')}]`;\n\n\t  return value;\n\t};\n\n\t/**\n\t * Create the message for a syntax error\n\t */\n\n\tconst syntaxError = (type, char) => {\n\t  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n\t};\n\n\t/**\n\t * Parse the given input string.\n\t * @param {String} input\n\t * @param {Object} options\n\t * @return {Object}\n\t */\n\n\tconst parse = (input, options) => {\n\t  if (typeof input !== 'string') {\n\t    throw new TypeError('Expected a string');\n\t  }\n\n\t  input = REPLACEMENTS[input] || input;\n\n\t  const opts = { ...options };\n\t  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n\t  let len = input.length;\n\t  if (len > max) {\n\t    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n\t  }\n\n\t  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n\t  const tokens = [bos];\n\n\t  const capture = opts.capture ? '' : '?:';\n\n\t  // create constants based on platform, for windows or posix\n\t  const PLATFORM_CHARS = constants.globChars(opts.windows);\n\t  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n\t  const {\n\t    DOT_LITERAL,\n\t    PLUS_LITERAL,\n\t    SLASH_LITERAL,\n\t    ONE_CHAR,\n\t    DOTS_SLASH,\n\t    NO_DOT,\n\t    NO_DOT_SLASH,\n\t    NO_DOTS_SLASH,\n\t    QMARK,\n\t    QMARK_NO_DOT,\n\t    STAR,\n\t    START_ANCHOR\n\t  } = PLATFORM_CHARS;\n\n\t  const globstar = opts => {\n\t    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n\t  };\n\n\t  const nodot = opts.dot ? '' : NO_DOT;\n\t  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n\t  let star = opts.bash === true ? globstar(opts) : STAR;\n\n\t  if (opts.capture) {\n\t    star = `(${star})`;\n\t  }\n\n\t  // minimatch options support\n\t  if (typeof opts.noext === 'boolean') {\n\t    opts.noextglob = opts.noext;\n\t  }\n\n\t  const state = {\n\t    input,\n\t    index: -1,\n\t    start: 0,\n\t    dot: opts.dot === true,\n\t    consumed: '',\n\t    output: '',\n\t    prefix: '',\n\t    backtrack: false,\n\t    negated: false,\n\t    brackets: 0,\n\t    braces: 0,\n\t    parens: 0,\n\t    quotes: 0,\n\t    globstar: false,\n\t    tokens\n\t  };\n\n\t  input = utils.removePrefix(input, state);\n\t  len = input.length;\n\n\t  const extglobs = [];\n\t  const braces = [];\n\t  const stack = [];\n\t  let prev = bos;\n\t  let value;\n\n\t  /**\n\t   * Tokenizing helpers\n\t   */\n\n\t  const eos = () => state.index === len - 1;\n\t  const peek = state.peek = (n = 1) => input[state.index + n];\n\t  const advance = state.advance = () => input[++state.index] || '';\n\t  const remaining = () => input.slice(state.index + 1);\n\t  const consume = (value = '', num = 0) => {\n\t    state.consumed += value;\n\t    state.index += num;\n\t  };\n\n\t  const append = token => {\n\t    state.output += token.output != null ? token.output : token.value;\n\t    consume(token.value);\n\t  };\n\n\t  const negate = () => {\n\t    let count = 1;\n\n\t    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n\t      advance();\n\t      state.start++;\n\t      count++;\n\t    }\n\n\t    if (count % 2 === 0) {\n\t      return false;\n\t    }\n\n\t    state.negated = true;\n\t    state.start++;\n\t    return true;\n\t  };\n\n\t  const increment = type => {\n\t    state[type]++;\n\t    stack.push(type);\n\t  };\n\n\t  const decrement = type => {\n\t    state[type]--;\n\t    stack.pop();\n\t  };\n\n\t  /**\n\t   * Push tokens onto the tokens array. This helper speeds up\n\t   * tokenizing by 1) helping us avoid backtracking as much as possible,\n\t   * and 2) helping us avoid creating extra tokens when consecutive\n\t   * characters are plain text. This improves performance and simplifies\n\t   * lookbehinds.\n\t   */\n\n\t  const push = tok => {\n\t    if (prev.type === 'globstar') {\n\t      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n\t      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n\t      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n\t        state.output = state.output.slice(0, -prev.output.length);\n\t        prev.type = 'star';\n\t        prev.value = '*';\n\t        prev.output = star;\n\t        state.output += prev.output;\n\t      }\n\t    }\n\n\t    if (extglobs.length && tok.type !== 'paren') {\n\t      extglobs[extglobs.length - 1].inner += tok.value;\n\t    }\n\n\t    if (tok.value || tok.output) append(tok);\n\t    if (prev && prev.type === 'text' && tok.type === 'text') {\n\t      prev.output = (prev.output || prev.value) + tok.value;\n\t      prev.value += tok.value;\n\t      return;\n\t    }\n\n\t    tok.prev = prev;\n\t    tokens.push(tok);\n\t    prev = tok;\n\t  };\n\n\t  const extglobOpen = (type, value) => {\n\t    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n\t    token.prev = prev;\n\t    token.parens = state.parens;\n\t    token.output = state.output;\n\t    const output = (opts.capture ? '(' : '') + token.open;\n\n\t    increment('parens');\n\t    push({ type, value, output: state.output ? '' : ONE_CHAR });\n\t    push({ type: 'paren', extglob: true, value: advance(), output });\n\t    extglobs.push(token);\n\t  };\n\n\t  const extglobClose = token => {\n\t    let output = token.close + (opts.capture ? ')' : '');\n\t    let rest;\n\n\t    if (token.type === 'negate') {\n\t      let extglobStar = star;\n\n\t      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n\t        extglobStar = globstar(opts);\n\t      }\n\n\t      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n\t        output = token.close = `)$))${extglobStar}`;\n\t      }\n\n\t      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n\t        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n\t        // In this case, we need to parse the string and use it in the output of the original pattern.\n\t        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n\t        //\n\t        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n\t        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n\t        output = token.close = `)${expression})${extglobStar})`;\n\t      }\n\n\t      if (token.prev.type === 'bos') {\n\t        state.negatedExtglob = true;\n\t      }\n\t    }\n\n\t    push({ type: 'paren', extglob: true, value, output });\n\t    decrement('parens');\n\t  };\n\n\t  /**\n\t   * Fast paths\n\t   */\n\n\t  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n\t    let backslashes = false;\n\n\t    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n\t      if (first === '\\\\') {\n\t        backslashes = true;\n\t        return m;\n\t      }\n\n\t      if (first === '?') {\n\t        if (esc) {\n\t          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n\t        }\n\t        if (index === 0) {\n\t          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n\t        }\n\t        return QMARK.repeat(chars.length);\n\t      }\n\n\t      if (first === '.') {\n\t        return DOT_LITERAL.repeat(chars.length);\n\t      }\n\n\t      if (first === '*') {\n\t        if (esc) {\n\t          return esc + first + (rest ? star : '');\n\t        }\n\t        return star;\n\t      }\n\t      return esc ? m : `\\\\${m}`;\n\t    });\n\n\t    if (backslashes === true) {\n\t      if (opts.unescape === true) {\n\t        output = output.replace(/\\\\/g, '');\n\t      } else {\n\t        output = output.replace(/\\\\+/g, m => {\n\t          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n\t        });\n\t      }\n\t    }\n\n\t    if (output === input && opts.contains === true) {\n\t      state.output = input;\n\t      return state;\n\t    }\n\n\t    state.output = utils.wrapOutput(output, state, options);\n\t    return state;\n\t  }\n\n\t  /**\n\t   * Tokenize input until we reach end-of-string\n\t   */\n\n\t  while (!eos()) {\n\t    value = advance();\n\n\t    if (value === '\\u0000') {\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Escaped characters\n\t     */\n\n\t    if (value === '\\\\') {\n\t      const next = peek();\n\n\t      if (next === '/' && opts.bash !== true) {\n\t        continue;\n\t      }\n\n\t      if (next === '.' || next === ';') {\n\t        continue;\n\t      }\n\n\t      if (!next) {\n\t        value += '\\\\';\n\t        push({ type: 'text', value });\n\t        continue;\n\t      }\n\n\t      // collapse slashes to reduce potential for exploits\n\t      const match = /^\\\\+/.exec(remaining());\n\t      let slashes = 0;\n\n\t      if (match && match[0].length > 2) {\n\t        slashes = match[0].length;\n\t        state.index += slashes;\n\t        if (slashes % 2 !== 0) {\n\t          value += '\\\\';\n\t        }\n\t      }\n\n\t      if (opts.unescape === true) {\n\t        value = advance();\n\t      } else {\n\t        value += advance();\n\t      }\n\n\t      if (state.brackets === 0) {\n\t        push({ type: 'text', value });\n\t        continue;\n\t      }\n\t    }\n\n\t    /**\n\t     * If we're inside a regex character class, continue\n\t     * until we reach the closing bracket.\n\t     */\n\n\t    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n\t      if (opts.posix !== false && value === ':') {\n\t        const inner = prev.value.slice(1);\n\t        if (inner.includes('[')) {\n\t          prev.posix = true;\n\n\t          if (inner.includes(':')) {\n\t            const idx = prev.value.lastIndexOf('[');\n\t            const pre = prev.value.slice(0, idx);\n\t            const rest = prev.value.slice(idx + 2);\n\t            const posix = POSIX_REGEX_SOURCE[rest];\n\t            if (posix) {\n\t              prev.value = pre + posix;\n\t              state.backtrack = true;\n\t              advance();\n\n\t              if (!bos.output && tokens.indexOf(prev) === 1) {\n\t                bos.output = ONE_CHAR;\n\t              }\n\t              continue;\n\t            }\n\t          }\n\t        }\n\t      }\n\n\t      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n\t        value = `\\\\${value}`;\n\t      }\n\n\t      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n\t        value = `\\\\${value}`;\n\t      }\n\n\t      if (opts.posix === true && value === '!' && prev.value === '[') {\n\t        value = '^';\n\t      }\n\n\t      prev.value += value;\n\t      append({ value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * If we're inside a quoted string, continue\n\t     * until we reach the closing double quote.\n\t     */\n\n\t    if (state.quotes === 1 && value !== '\"') {\n\t      value = utils.escapeRegex(value);\n\t      prev.value += value;\n\t      append({ value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Double quotes\n\t     */\n\n\t    if (value === '\"') {\n\t      state.quotes = state.quotes === 1 ? 0 : 1;\n\t      if (opts.keepQuotes === true) {\n\t        push({ type: 'text', value });\n\t      }\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Parentheses\n\t     */\n\n\t    if (value === '(') {\n\t      increment('parens');\n\t      push({ type: 'paren', value });\n\t      continue;\n\t    }\n\n\t    if (value === ')') {\n\t      if (state.parens === 0 && opts.strictBrackets === true) {\n\t        throw new SyntaxError(syntaxError('opening', '('));\n\t      }\n\n\t      const extglob = extglobs[extglobs.length - 1];\n\t      if (extglob && state.parens === extglob.parens + 1) {\n\t        extglobClose(extglobs.pop());\n\t        continue;\n\t      }\n\n\t      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n\t      decrement('parens');\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Square brackets\n\t     */\n\n\t    if (value === '[') {\n\t      if (opts.nobracket === true || !remaining().includes(']')) {\n\t        if (opts.nobracket !== true && opts.strictBrackets === true) {\n\t          throw new SyntaxError(syntaxError('closing', ']'));\n\t        }\n\n\t        value = `\\\\${value}`;\n\t      } else {\n\t        increment('brackets');\n\t      }\n\n\t      push({ type: 'bracket', value });\n\t      continue;\n\t    }\n\n\t    if (value === ']') {\n\t      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n\t        push({ type: 'text', value, output: `\\\\${value}` });\n\t        continue;\n\t      }\n\n\t      if (state.brackets === 0) {\n\t        if (opts.strictBrackets === true) {\n\t          throw new SyntaxError(syntaxError('opening', '['));\n\t        }\n\n\t        push({ type: 'text', value, output: `\\\\${value}` });\n\t        continue;\n\t      }\n\n\t      decrement('brackets');\n\n\t      const prevValue = prev.value.slice(1);\n\t      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n\t        value = `/${value}`;\n\t      }\n\n\t      prev.value += value;\n\t      append({ value });\n\n\t      // when literal brackets are explicitly disabled\n\t      // assume we should match with a regex character class\n\t      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n\t        continue;\n\t      }\n\n\t      const escaped = utils.escapeRegex(prev.value);\n\t      state.output = state.output.slice(0, -prev.value.length);\n\n\t      // when literal brackets are explicitly enabled\n\t      // assume we should escape the brackets to match literal characters\n\t      if (opts.literalBrackets === true) {\n\t        state.output += escaped;\n\t        prev.value = escaped;\n\t        continue;\n\t      }\n\n\t      // when the user specifies nothing, try to match both\n\t      prev.value = `(${capture}${escaped}|${prev.value})`;\n\t      state.output += prev.value;\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Braces\n\t     */\n\n\t    if (value === '{' && opts.nobrace !== true) {\n\t      increment('braces');\n\n\t      const open = {\n\t        type: 'brace',\n\t        value,\n\t        output: '(',\n\t        outputIndex: state.output.length,\n\t        tokensIndex: state.tokens.length\n\t      };\n\n\t      braces.push(open);\n\t      push(open);\n\t      continue;\n\t    }\n\n\t    if (value === '}') {\n\t      const brace = braces[braces.length - 1];\n\n\t      if (opts.nobrace === true || !brace) {\n\t        push({ type: 'text', value, output: value });\n\t        continue;\n\t      }\n\n\t      let output = ')';\n\n\t      if (brace.dots === true) {\n\t        const arr = tokens.slice();\n\t        const range = [];\n\n\t        for (let i = arr.length - 1; i >= 0; i--) {\n\t          tokens.pop();\n\t          if (arr[i].type === 'brace') {\n\t            break;\n\t          }\n\t          if (arr[i].type !== 'dots') {\n\t            range.unshift(arr[i].value);\n\t          }\n\t        }\n\n\t        output = expandRange(range, opts);\n\t        state.backtrack = true;\n\t      }\n\n\t      if (brace.comma !== true && brace.dots !== true) {\n\t        const out = state.output.slice(0, brace.outputIndex);\n\t        const toks = state.tokens.slice(brace.tokensIndex);\n\t        brace.value = brace.output = '\\\\{';\n\t        value = output = '\\\\}';\n\t        state.output = out;\n\t        for (const t of toks) {\n\t          state.output += (t.output || t.value);\n\t        }\n\t      }\n\n\t      push({ type: 'brace', value, output });\n\t      decrement('braces');\n\t      braces.pop();\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Pipes\n\t     */\n\n\t    if (value === '|') {\n\t      if (extglobs.length > 0) {\n\t        extglobs[extglobs.length - 1].conditions++;\n\t      }\n\t      push({ type: 'text', value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Commas\n\t     */\n\n\t    if (value === ',') {\n\t      let output = value;\n\n\t      const brace = braces[braces.length - 1];\n\t      if (brace && stack[stack.length - 1] === 'braces') {\n\t        brace.comma = true;\n\t        output = '|';\n\t      }\n\n\t      push({ type: 'comma', value, output });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Slashes\n\t     */\n\n\t    if (value === '/') {\n\t      // if the beginning of the glob is \"./\", advance the start\n\t      // to the current index, and don't add the \"./\" characters\n\t      // to the state. This greatly simplifies lookbehinds when\n\t      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n\t      if (prev.type === 'dot' && state.index === state.start + 1) {\n\t        state.start = state.index + 1;\n\t        state.consumed = '';\n\t        state.output = '';\n\t        tokens.pop();\n\t        prev = bos; // reset \"prev\" to the first token\n\t        continue;\n\t      }\n\n\t      push({ type: 'slash', value, output: SLASH_LITERAL });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Dots\n\t     */\n\n\t    if (value === '.') {\n\t      if (state.braces > 0 && prev.type === 'dot') {\n\t        if (prev.value === '.') prev.output = DOT_LITERAL;\n\t        const brace = braces[braces.length - 1];\n\t        prev.type = 'dots';\n\t        prev.output += value;\n\t        prev.value += value;\n\t        brace.dots = true;\n\t        continue;\n\t      }\n\n\t      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n\t        push({ type: 'text', value, output: DOT_LITERAL });\n\t        continue;\n\t      }\n\n\t      push({ type: 'dot', value, output: DOT_LITERAL });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Question marks\n\t     */\n\n\t    if (value === '?') {\n\t      const isGroup = prev && prev.value === '(';\n\t      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n\t        extglobOpen('qmark', value);\n\t        continue;\n\t      }\n\n\t      if (prev && prev.type === 'paren') {\n\t        const next = peek();\n\t        let output = value;\n\n\t        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n\t          output = `\\\\${value}`;\n\t        }\n\n\t        push({ type: 'text', value, output });\n\t        continue;\n\t      }\n\n\t      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n\t        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n\t        continue;\n\t      }\n\n\t      push({ type: 'qmark', value, output: QMARK });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Exclamation\n\t     */\n\n\t    if (value === '!') {\n\t      if (opts.noextglob !== true && peek() === '(') {\n\t        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n\t          extglobOpen('negate', value);\n\t          continue;\n\t        }\n\t      }\n\n\t      if (opts.nonegate !== true && state.index === 0) {\n\t        negate();\n\t        continue;\n\t      }\n\t    }\n\n\t    /**\n\t     * Plus\n\t     */\n\n\t    if (value === '+') {\n\t      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n\t        extglobOpen('plus', value);\n\t        continue;\n\t      }\n\n\t      if ((prev && prev.value === '(') || opts.regex === false) {\n\t        push({ type: 'plus', value, output: PLUS_LITERAL });\n\t        continue;\n\t      }\n\n\t      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n\t        push({ type: 'plus', value });\n\t        continue;\n\t      }\n\n\t      push({ type: 'plus', value: PLUS_LITERAL });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Plain text\n\t     */\n\n\t    if (value === '@') {\n\t      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n\t        push({ type: 'at', extglob: true, value, output: '' });\n\t        continue;\n\t      }\n\n\t      push({ type: 'text', value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Plain text\n\t     */\n\n\t    if (value !== '*') {\n\t      if (value === '$' || value === '^') {\n\t        value = `\\\\${value}`;\n\t      }\n\n\t      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n\t      if (match) {\n\t        value += match[0];\n\t        state.index += match[0].length;\n\t      }\n\n\t      push({ type: 'text', value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Stars\n\t     */\n\n\t    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n\t      prev.type = 'star';\n\t      prev.star = true;\n\t      prev.value += value;\n\t      prev.output = star;\n\t      state.backtrack = true;\n\t      state.globstar = true;\n\t      consume(value);\n\t      continue;\n\t    }\n\n\t    let rest = remaining();\n\t    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n\t      extglobOpen('star', value);\n\t      continue;\n\t    }\n\n\t    if (prev.type === 'star') {\n\t      if (opts.noglobstar === true) {\n\t        consume(value);\n\t        continue;\n\t      }\n\n\t      const prior = prev.prev;\n\t      const before = prior.prev;\n\t      const isStart = prior.type === 'slash' || prior.type === 'bos';\n\t      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n\t      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n\t        push({ type: 'star', value, output: '' });\n\t        continue;\n\t      }\n\n\t      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n\t      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n\t      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n\t        push({ type: 'star', value, output: '' });\n\t        continue;\n\t      }\n\n\t      // strip consecutive `/**/`\n\t      while (rest.slice(0, 3) === '/**') {\n\t        const after = input[state.index + 4];\n\t        if (after && after !== '/') {\n\t          break;\n\t        }\n\t        rest = rest.slice(3);\n\t        consume('/**', 3);\n\t      }\n\n\t      if (prior.type === 'bos' && eos()) {\n\t        prev.type = 'globstar';\n\t        prev.value += value;\n\t        prev.output = globstar(opts);\n\t        state.output = prev.output;\n\t        state.globstar = true;\n\t        consume(value);\n\t        continue;\n\t      }\n\n\t      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n\t        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n\t        prior.output = `(?:${prior.output}`;\n\n\t        prev.type = 'globstar';\n\t        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n\t        prev.value += value;\n\t        state.globstar = true;\n\t        state.output += prior.output + prev.output;\n\t        consume(value);\n\t        continue;\n\t      }\n\n\t      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n\t        const end = rest[1] !== void 0 ? '|$' : '';\n\n\t        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n\t        prior.output = `(?:${prior.output}`;\n\n\t        prev.type = 'globstar';\n\t        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n\t        prev.value += value;\n\n\t        state.output += prior.output + prev.output;\n\t        state.globstar = true;\n\n\t        consume(value + advance());\n\n\t        push({ type: 'slash', value: '/', output: '' });\n\t        continue;\n\t      }\n\n\t      if (prior.type === 'bos' && rest[0] === '/') {\n\t        prev.type = 'globstar';\n\t        prev.value += value;\n\t        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n\t        state.output = prev.output;\n\t        state.globstar = true;\n\t        consume(value + advance());\n\t        push({ type: 'slash', value: '/', output: '' });\n\t        continue;\n\t      }\n\n\t      // remove single star from output\n\t      state.output = state.output.slice(0, -prev.output.length);\n\n\t      // reset previous token to globstar\n\t      prev.type = 'globstar';\n\t      prev.output = globstar(opts);\n\t      prev.value += value;\n\n\t      // reset output with globstar\n\t      state.output += prev.output;\n\t      state.globstar = true;\n\t      consume(value);\n\t      continue;\n\t    }\n\n\t    const token = { type: 'star', value, output: star };\n\n\t    if (opts.bash === true) {\n\t      token.output = '.*?';\n\t      if (prev.type === 'bos' || prev.type === 'slash') {\n\t        token.output = nodot + token.output;\n\t      }\n\t      push(token);\n\t      continue;\n\t    }\n\n\t    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n\t      token.output = value;\n\t      push(token);\n\t      continue;\n\t    }\n\n\t    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n\t      if (prev.type === 'dot') {\n\t        state.output += NO_DOT_SLASH;\n\t        prev.output += NO_DOT_SLASH;\n\n\t      } else if (opts.dot === true) {\n\t        state.output += NO_DOTS_SLASH;\n\t        prev.output += NO_DOTS_SLASH;\n\n\t      } else {\n\t        state.output += nodot;\n\t        prev.output += nodot;\n\t      }\n\n\t      if (peek() !== '*') {\n\t        state.output += ONE_CHAR;\n\t        prev.output += ONE_CHAR;\n\t      }\n\t    }\n\n\t    push(token);\n\t  }\n\n\t  while (state.brackets > 0) {\n\t    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n\t    state.output = utils.escapeLast(state.output, '[');\n\t    decrement('brackets');\n\t  }\n\n\t  while (state.parens > 0) {\n\t    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n\t    state.output = utils.escapeLast(state.output, '(');\n\t    decrement('parens');\n\t  }\n\n\t  while (state.braces > 0) {\n\t    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n\t    state.output = utils.escapeLast(state.output, '{');\n\t    decrement('braces');\n\t  }\n\n\t  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n\t    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n\t  }\n\n\t  // rebuild the output if we had to backtrack at any point\n\t  if (state.backtrack === true) {\n\t    state.output = '';\n\n\t    for (const token of state.tokens) {\n\t      state.output += token.output != null ? token.output : token.value;\n\n\t      if (token.suffix) {\n\t        state.output += token.suffix;\n\t      }\n\t    }\n\t  }\n\n\t  return state;\n\t};\n\n\t/**\n\t * Fast paths for creating regular expressions for common glob patterns.\n\t * This can significantly speed up processing and has very little downside\n\t * impact when none of the fast paths match.\n\t */\n\n\tparse.fastpaths = (input, options) => {\n\t  const opts = { ...options };\n\t  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\t  const len = input.length;\n\t  if (len > max) {\n\t    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n\t  }\n\n\t  input = REPLACEMENTS[input] || input;\n\n\t  // create constants based on platform, for windows or posix\n\t  const {\n\t    DOT_LITERAL,\n\t    SLASH_LITERAL,\n\t    ONE_CHAR,\n\t    DOTS_SLASH,\n\t    NO_DOT,\n\t    NO_DOTS,\n\t    NO_DOTS_SLASH,\n\t    STAR,\n\t    START_ANCHOR\n\t  } = constants.globChars(opts.windows);\n\n\t  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n\t  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n\t  const capture = opts.capture ? '' : '?:';\n\t  const state = { negated: false, prefix: '' };\n\t  let star = opts.bash === true ? '.*?' : STAR;\n\n\t  if (opts.capture) {\n\t    star = `(${star})`;\n\t  }\n\n\t  const globstar = opts => {\n\t    if (opts.noglobstar === true) return star;\n\t    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n\t  };\n\n\t  const create = str => {\n\t    switch (str) {\n\t      case '*':\n\t        return `${nodot}${ONE_CHAR}${star}`;\n\n\t      case '.*':\n\t        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n\t      case '*.*':\n\t        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n\t      case '*/*':\n\t        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n\t      case '**':\n\t        return nodot + globstar(opts);\n\n\t      case '**/*':\n\t        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n\t      case '**/*.*':\n\t        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n\t      case '**/.*':\n\t        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n\t      default: {\n\t        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n\t        if (!match) return;\n\n\t        const source = create(match[1]);\n\t        if (!source) return;\n\n\t        return source + DOT_LITERAL + match[2];\n\t      }\n\t    }\n\t  };\n\n\t  const output = utils.removePrefix(input, state);\n\t  let source = create(output);\n\n\t  if (source && opts.strictSlashes !== true) {\n\t    source += `${SLASH_LITERAL}?`;\n\t  }\n\n\t  return source;\n\t};\n\n\tparse_1 = parse;\n\treturn parse_1;\n}\n\nvar picomatch_1$1;\nvar hasRequiredPicomatch$1;\n\nfunction requirePicomatch$1 () {\n\tif (hasRequiredPicomatch$1) return picomatch_1$1;\n\thasRequiredPicomatch$1 = 1;\n\n\tconst scan = /*@__PURE__*/ requireScan();\n\tconst parse = /*@__PURE__*/ requireParse();\n\tconst utils = /*@__PURE__*/ requireUtils();\n\tconst constants = /*@__PURE__*/ requireConstants();\n\tconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n\t/**\n\t * Creates a matcher function from one or more glob patterns. The\n\t * returned function takes a string to match as its first argument,\n\t * and returns true if the string is a match. The returned matcher\n\t * function also takes a boolean as the second argument that, when true,\n\t * returns an object with additional information.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * // picomatch(glob[, options]);\n\t *\n\t * const isMatch = picomatch('*.!(*a)');\n\t * console.log(isMatch('a.a')); //=> false\n\t * console.log(isMatch('a.b')); //=> true\n\t * ```\n\t * @name picomatch\n\t * @param {String|Array} `globs` One or more glob patterns.\n\t * @param {Object=} `options`\n\t * @return {Function=} Returns a matcher function.\n\t * @api public\n\t */\n\n\tconst picomatch = (glob, options, returnState = false) => {\n\t  if (Array.isArray(glob)) {\n\t    const fns = glob.map(input => picomatch(input, options, returnState));\n\t    const arrayMatcher = str => {\n\t      for (const isMatch of fns) {\n\t        const state = isMatch(str);\n\t        if (state) return state;\n\t      }\n\t      return false;\n\t    };\n\t    return arrayMatcher;\n\t  }\n\n\t  const isState = isObject(glob) && glob.tokens && glob.input;\n\n\t  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n\t    throw new TypeError('Expected pattern to be a non-empty string');\n\t  }\n\n\t  const opts = options || {};\n\t  const posix = opts.windows;\n\t  const regex = isState\n\t    ? picomatch.compileRe(glob, options)\n\t    : picomatch.makeRe(glob, options, false, true);\n\n\t  const state = regex.state;\n\t  delete regex.state;\n\n\t  let isIgnored = () => false;\n\t  if (opts.ignore) {\n\t    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n\t    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n\t  }\n\n\t  const matcher = (input, returnObject = false) => {\n\t    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n\t    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n\t    if (typeof opts.onResult === 'function') {\n\t      opts.onResult(result);\n\t    }\n\n\t    if (isMatch === false) {\n\t      result.isMatch = false;\n\t      return returnObject ? result : false;\n\t    }\n\n\t    if (isIgnored(input)) {\n\t      if (typeof opts.onIgnore === 'function') {\n\t        opts.onIgnore(result);\n\t      }\n\t      result.isMatch = false;\n\t      return returnObject ? result : false;\n\t    }\n\n\t    if (typeof opts.onMatch === 'function') {\n\t      opts.onMatch(result);\n\t    }\n\t    return returnObject ? result : true;\n\t  };\n\n\t  if (returnState) {\n\t    matcher.state = state;\n\t  }\n\n\t  return matcher;\n\t};\n\n\t/**\n\t * Test `input` with the given `regex`. This is used by the main\n\t * `picomatch()` function to test the input string.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * // picomatch.test(input, regex[, options]);\n\t *\n\t * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n\t * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n\t * ```\n\t * @param {String} `input` String to test.\n\t * @param {RegExp} `regex`\n\t * @return {Object} Returns an object with matching info.\n\t * @api public\n\t */\n\n\tpicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n\t  if (typeof input !== 'string') {\n\t    throw new TypeError('Expected input to be a string');\n\t  }\n\n\t  if (input === '') {\n\t    return { isMatch: false, output: '' };\n\t  }\n\n\t  const opts = options || {};\n\t  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n\t  let match = input === glob;\n\t  let output = (match && format) ? format(input) : input;\n\n\t  if (match === false) {\n\t    output = format ? format(input) : input;\n\t    match = output === glob;\n\t  }\n\n\t  if (match === false || opts.capture === true) {\n\t    if (opts.matchBase === true || opts.basename === true) {\n\t      match = picomatch.matchBase(input, regex, options, posix);\n\t    } else {\n\t      match = regex.exec(output);\n\t    }\n\t  }\n\n\t  return { isMatch: Boolean(match), match, output };\n\t};\n\n\t/**\n\t * Match the basename of a filepath.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * // picomatch.matchBase(input, glob[, options]);\n\t * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n\t * ```\n\t * @param {String} `input` String to test.\n\t * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n\t * @return {Boolean}\n\t * @api public\n\t */\n\n\tpicomatch.matchBase = (input, glob, options) => {\n\t  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n\t  return regex.test(utils.basename(input));\n\t};\n\n\t/**\n\t * Returns true if **any** of the given glob `patterns` match the specified `string`.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * // picomatch.isMatch(string, patterns[, options]);\n\t *\n\t * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n\t * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n\t * ```\n\t * @param {String|Array} str The string to test.\n\t * @param {String|Array} patterns One or more glob patterns to use for matching.\n\t * @param {Object} [options] See available [options](#options).\n\t * @return {Boolean} Returns true if any patterns match `str`\n\t * @api public\n\t */\n\n\tpicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n\t/**\n\t * Parse a glob pattern to create the source string for a regular\n\t * expression.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * const result = picomatch.parse(pattern[, options]);\n\t * ```\n\t * @param {String} `pattern`\n\t * @param {Object} `options`\n\t * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n\t * @api public\n\t */\n\n\tpicomatch.parse = (pattern, options) => {\n\t  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n\t  return parse(pattern, { ...options, fastpaths: false });\n\t};\n\n\t/**\n\t * Scan a glob pattern to separate the pattern into segments.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * // picomatch.scan(input[, options]);\n\t *\n\t * const result = picomatch.scan('!./foo/*.js');\n\t * console.log(result);\n\t * { prefix: '!./',\n\t *   input: '!./foo/*.js',\n\t *   start: 3,\n\t *   base: 'foo',\n\t *   glob: '*.js',\n\t *   isBrace: false,\n\t *   isBracket: false,\n\t *   isGlob: true,\n\t *   isExtglob: false,\n\t *   isGlobstar: false,\n\t *   negated: true }\n\t * ```\n\t * @param {String} `input` Glob pattern to scan.\n\t * @param {Object} `options`\n\t * @return {Object} Returns an object with\n\t * @api public\n\t */\n\n\tpicomatch.scan = (input, options) => scan(input, options);\n\n\t/**\n\t * Compile a regular expression from the `state` object returned by the\n\t * [parse()](#parse) method.\n\t *\n\t * @param {Object} `state`\n\t * @param {Object} `options`\n\t * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n\t * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n\t * @return {RegExp}\n\t * @api public\n\t */\n\n\tpicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n\t  if (returnOutput === true) {\n\t    return state.output;\n\t  }\n\n\t  const opts = options || {};\n\t  const prepend = opts.contains ? '' : '^';\n\t  const append = opts.contains ? '' : '$';\n\n\t  let source = `${prepend}(?:${state.output})${append}`;\n\t  if (state && state.negated === true) {\n\t    source = `^(?!${source}).*$`;\n\t  }\n\n\t  const regex = picomatch.toRegex(source, options);\n\t  if (returnState === true) {\n\t    regex.state = state;\n\t  }\n\n\t  return regex;\n\t};\n\n\t/**\n\t * Create a regular expression from a parsed glob pattern.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * const state = picomatch.parse('*.js');\n\t * // picomatch.compileRe(state[, options]);\n\t *\n\t * console.log(picomatch.compileRe(state));\n\t * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n\t * ```\n\t * @param {String} `state` The object returned from the `.parse` method.\n\t * @param {Object} `options`\n\t * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n\t * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n\t * @return {RegExp} Returns a regex created from the given pattern.\n\t * @api public\n\t */\n\n\tpicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n\t  if (!input || typeof input !== 'string') {\n\t    throw new TypeError('Expected a non-empty string');\n\t  }\n\n\t  let parsed = { negated: false, fastpaths: true };\n\n\t  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n\t    parsed.output = parse.fastpaths(input, options);\n\t  }\n\n\t  if (!parsed.output) {\n\t    parsed = parse(input, options);\n\t  }\n\n\t  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n\t};\n\n\t/**\n\t * Create a regular expression from the given regex source string.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * // picomatch.toRegex(source[, options]);\n\t *\n\t * const { output } = picomatch.parse('*.js');\n\t * console.log(picomatch.toRegex(output));\n\t * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n\t * ```\n\t * @param {String} `source` Regular expression source string.\n\t * @param {Object} `options`\n\t * @return {RegExp}\n\t * @api public\n\t */\n\n\tpicomatch.toRegex = (source, options) => {\n\t  try {\n\t    const opts = options || {};\n\t    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n\t  } catch (err) {\n\t    if (options && options.debug === true) throw err;\n\t    return /$^/;\n\t  }\n\t};\n\n\t/**\n\t * Picomatch constants.\n\t * @return {Object}\n\t */\n\n\tpicomatch.constants = constants;\n\n\t/**\n\t * Expose \"picomatch\"\n\t */\n\n\tpicomatch_1$1 = picomatch;\n\treturn picomatch_1$1;\n}\n\nvar picomatch_1;\nvar hasRequiredPicomatch;\n\nfunction requirePicomatch () {\n\tif (hasRequiredPicomatch) return picomatch_1;\n\thasRequiredPicomatch = 1;\n\n\tconst pico = /*@__PURE__*/ requirePicomatch$1();\n\tconst utils = /*@__PURE__*/ requireUtils();\n\n\tfunction picomatch(glob, options, returnState = false) {\n\t  // default to os.platform()\n\t  if (options && (options.windows === null || options.windows === undefined)) {\n\t    // don't mutate the original options object\n\t    options = { ...options, windows: utils.isWindows() };\n\t  }\n\n\t  return pico(glob, options, returnState);\n\t}\n\n\tObject.assign(picomatch, pico);\n\tpicomatch_1 = picomatch;\n\treturn picomatch_1;\n}\n\nvar picomatchExports = /*@__PURE__*/ requirePicomatch();\nconst pm = /*@__PURE__*/getDefaultExportFromCjs(picomatchExports);\n\nconst extractors = {\n    ArrayPattern(names, param) {\n        for (const element of param.elements) {\n            if (element)\n                extractors[element.type](names, element);\n        }\n    },\n    AssignmentPattern(names, param) {\n        extractors[param.left.type](names, param.left);\n    },\n    Identifier(names, param) {\n        names.push(param.name);\n    },\n    MemberExpression() { },\n    ObjectPattern(names, param) {\n        for (const prop of param.properties) {\n            // @ts-ignore Typescript reports that this is not a valid type\n            if (prop.type === 'RestElement') {\n                extractors.RestElement(names, prop);\n            }\n            else {\n                extractors[prop.value.type](names, prop.value);\n            }\n        }\n    },\n    RestElement(names, param) {\n        extractors[param.argument.type](names, param.argument);\n    }\n};\nconst extractAssignedNames = function extractAssignedNames(param) {\n    const names = [];\n    extractors[param.type](names, param);\n    return names;\n};\n\n// Helper since Typescript can't detect readonly arrays with Array.isArray\nfunction isArray(arg) {\n    return Array.isArray(arg);\n}\nfunction ensureArray$1(thing) {\n    if (isArray(thing))\n        return thing;\n    if (thing == null)\n        return [];\n    return [thing];\n}\n\nconst normalizePathRegExp = new RegExp(`\\\\${Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).sep}`, 'g');\nconst normalizePath = function normalizePath(filename) {\n    return filename.replace(normalizePathRegExp, Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).sep);\n};\n\nfunction getMatcherString(id, resolutionBase) {\n    if (resolutionBase === false || Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(id) || id.startsWith('**')) {\n        return normalizePath(id);\n    }\n    // resolve('') is valid and will default to process.cwd()\n    const basePath = normalizePath(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(resolutionBase || ''))\n        // escape all possible (posix + win) path characters that might interfere with regex\n        .replace(/[-^$*+?.()|[\\]{}]/g, '\\\\$&');\n    // Note that we use posix.join because:\n    // 1. the basePath has been normalized to use /\n    // 2. the incoming glob (id) matcher, also uses /\n    // otherwise Node will force backslash (\\) on windows\n    return Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).join(basePath, normalizePath(id));\n}\nconst createFilter = function createFilter(include, exclude, options) {\n    const resolutionBase = options && options.resolve;\n    const getMatcher = (id) => id instanceof RegExp\n        ? id\n        : {\n            test: (what) => {\n                // this refactor is a tad overly verbose but makes for easy debugging\n                const pattern = getMatcherString(id, resolutionBase);\n                const fn = pm(pattern, { dot: true });\n                const result = fn(what);\n                return result;\n            }\n        };\n    const includeMatchers = ensureArray$1(include).map(getMatcher);\n    const excludeMatchers = ensureArray$1(exclude).map(getMatcher);\n    if (!includeMatchers.length && !excludeMatchers.length)\n        return (id) => typeof id === 'string' && !id.includes('\\0');\n    return function result(id) {\n        if (typeof id !== 'string')\n            return false;\n        if (id.includes('\\0'))\n            return false;\n        const pathId = normalizePath(id);\n        for (let i = 0; i < excludeMatchers.length; ++i) {\n            const matcher = excludeMatchers[i];\n            if (matcher.test(pathId))\n                return false;\n        }\n        for (let i = 0; i < includeMatchers.length; ++i) {\n            const matcher = includeMatchers[i];\n            if (matcher.test(pathId))\n                return true;\n        }\n        return !includeMatchers.length;\n    };\n};\n\nconst reservedWords = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public';\nconst builtins = 'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl';\nconst forbiddenIdentifiers = new Set(`${reservedWords} ${builtins}`.split(' '));\nforbiddenIdentifiers.add('');\n\nclass ArrayPattern extends NodeBase {\n    addExportedVariables(variables, exportNamesByVariable) {\n        for (const element of this.elements) {\n            element?.addExportedVariables(variables, exportNamesByVariable);\n        }\n    }\n    declare(kind) {\n        const variables = [];\n        for (const element of this.elements) {\n            if (element !== null) {\n                variables.push(...element.declare(kind, UNKNOWN_EXPRESSION));\n            }\n        }\n        return variables;\n    }\n    // Patterns can only be deoptimized at the empty path at the moment\n    deoptimizePath() {\n        for (const element of this.elements) {\n            element?.deoptimizePath(EMPTY_PATH);\n        }\n    }\n    // Patterns are only checked at the empty path at the moment\n    hasEffectsOnInteractionAtPath(_path, interaction, context) {\n        for (const element of this.elements) {\n            if (element?.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context))\n                return true;\n        }\n        return false;\n    }\n    markDeclarationReached() {\n        for (const element of this.elements) {\n            element?.markDeclarationReached();\n        }\n    }\n}\n\nclass ArrowFunctionExpression extends FunctionBase {\n    constructor() {\n        super(...arguments);\n        this.objectEntity = null;\n    }\n    get expression() {\n        return isFlagSet(this.flags, 8388608 /* Flag.expression */);\n    }\n    set expression(value) {\n        this.flags = setFlag(this.flags, 8388608 /* Flag.expression */, value);\n    }\n    createScope(parentScope) {\n        this.scope = new ReturnValueScope(parentScope, false);\n    }\n    hasEffects() {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        return false;\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        if (super.hasEffectsOnInteractionAtPath(path, interaction, context)) {\n            return true;\n        }\n        if (this.annotationNoSideEffects) {\n            return false;\n        }\n        if (interaction.type === INTERACTION_CALLED) {\n            const { ignore, brokenFlow } = context;\n            context.ignore = {\n                breaks: false,\n                continues: false,\n                labels: new Set(),\n                returnYield: true,\n                this: false\n            };\n            if (this.body.hasEffects(context))\n                return true;\n            context.ignore = ignore;\n            context.brokenFlow = brokenFlow;\n        }\n        return false;\n    }\n    onlyFunctionCallUsed() {\n        const isIIFE = this.parent.type === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.CallExpression &&\n            this.parent.callee === this;\n        return isIIFE || super.onlyFunctionCallUsed();\n    }\n    include(context, includeChildrenRecursively) {\n        super.include(context, includeChildrenRecursively);\n        for (const parameter of this.params) {\n            if (!(parameter instanceof Identifier)) {\n                parameter.include(context, includeChildrenRecursively);\n            }\n        }\n    }\n    getObjectEntity() {\n        if (this.objectEntity !== null) {\n            return this.objectEntity;\n        }\n        return (this.objectEntity = new ObjectEntity([], OBJECT_PROTOTYPE));\n    }\n}\n\nclass ObjectPattern extends NodeBase {\n    addExportedVariables(variables, exportNamesByVariable) {\n        for (const property of this.properties) {\n            if (property.type === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.Property) {\n                property.value.addExportedVariables(variables, exportNamesByVariable);\n            }\n            else {\n                property.argument.addExportedVariables(variables, exportNamesByVariable);\n            }\n        }\n    }\n    declare(kind, init) {\n        const variables = [];\n        for (const property of this.properties) {\n            variables.push(...property.declare(kind, init));\n        }\n        return variables;\n    }\n    deoptimizePath(path) {\n        if (path.length === 0) {\n            for (const property of this.properties) {\n                property.deoptimizePath(path);\n            }\n        }\n    }\n    hasEffectsOnInteractionAtPath(\n    // At the moment, this is only triggered for assignment left-hand sides,\n    // where the path is empty\n    _path, interaction, context) {\n        for (const property of this.properties) {\n            if (property.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context))\n                return true;\n        }\n        return false;\n    }\n    markDeclarationReached() {\n        for (const property of this.properties) {\n            property.markDeclarationReached();\n        }\n    }\n}\n\nclass AssignmentExpression extends NodeBase {\n    hasEffects(context) {\n        const { deoptimized, left, operator, right } = this;\n        if (!deoptimized)\n            this.applyDeoptimizations();\n        // MemberExpressions do not access the property before assignments if the\n        // operator is '='.\n        return (right.hasEffects(context) || left.hasEffectsAsAssignmentTarget(context, operator !== '='));\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        return this.right.hasEffectsOnInteractionAtPath(path, interaction, context);\n    }\n    include(context, includeChildrenRecursively) {\n        const { deoptimized, left, right, operator } = this;\n        if (!deoptimized)\n            this.applyDeoptimizations();\n        this.included = true;\n        if (includeChildrenRecursively ||\n            operator !== '=' ||\n            left.included ||\n            left.hasEffectsAsAssignmentTarget(createHasEffectsContext(), false)) {\n            left.includeAsAssignmentTarget(context, includeChildrenRecursively, operator !== '=');\n        }\n        right.include(context, includeChildrenRecursively);\n    }\n    initialise() {\n        super.initialise();\n        if (this.left instanceof Identifier) {\n            const variable = this.scope.variables.get(this.left.name);\n            if (variable?.kind === 'const') {\n                this.scope.context.error((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logConstVariableReassignError)(), this.left.start);\n            }\n        }\n        this.left.setAssignedValue(this.right);\n    }\n    render(code, options, { preventASI, renderedParentType, renderedSurroundingElement } = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BLANK) {\n        const { left, right, start, end, parent } = this;\n        if (left.included) {\n            left.render(code, options);\n            right.render(code, options);\n        }\n        else {\n            const inclusionStart = findNonWhiteSpace(code.original, findFirstOccurrenceOutsideComment(code.original, '=', left.end) + 1);\n            code.remove(start, inclusionStart);\n            if (preventASI) {\n                removeLineBreaks(code, inclusionStart, right.start);\n            }\n            right.render(code, options, {\n                renderedParentType: renderedParentType || parent.type,\n                renderedSurroundingElement: renderedSurroundingElement || parent.type\n            });\n        }\n        if (options.format === 'system') {\n            if (left instanceof Identifier) {\n                const variable = left.variable;\n                const exportNames = options.exportNamesByVariable.get(variable);\n                if (exportNames) {\n                    if (exportNames.length === 1) {\n                        renderSystemExportExpression(variable, start, end, code, options);\n                    }\n                    else {\n                        renderSystemExportSequenceAfterExpression(variable, start, end, parent.type !== _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.ExpressionStatement, code, options);\n                    }\n                    return;\n                }\n            }\n            else {\n                const systemPatternExports = [];\n                left.addExportedVariables(systemPatternExports, options.exportNamesByVariable);\n                if (systemPatternExports.length > 0) {\n                    renderSystemExportFunction(systemPatternExports, start, end, renderedSurroundingElement === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.ExpressionStatement, code, options);\n                    return;\n                }\n            }\n        }\n        if (left.included &&\n            left instanceof ObjectPattern &&\n            (renderedSurroundingElement === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.ExpressionStatement ||\n                renderedSurroundingElement === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.ArrowFunctionExpression)) {\n            code.appendRight(start, '(');\n            code.prependLeft(end, ')');\n        }\n    }\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        this.left.deoptimizePath(EMPTY_PATH);\n        this.right.deoptimizePath(UNKNOWN_PATH);\n        this.scope.context.requestTreeshakingPass();\n    }\n}\n\nclass AssignmentPattern extends NodeBase {\n    addExportedVariables(variables, exportNamesByVariable) {\n        this.left.addExportedVariables(variables, exportNamesByVariable);\n    }\n    declare(kind, init) {\n        return this.left.declare(kind, init);\n    }\n    deoptimizePath(path) {\n        if (path.length === 0) {\n            this.left.deoptimizePath(path);\n        }\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        return (path.length > 0 || this.left.hasEffectsOnInteractionAtPath(EMPTY_PATH, interaction, context));\n    }\n    markDeclarationReached() {\n        this.left.markDeclarationReached();\n    }\n    render(code, options, { isShorthandProperty } = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BLANK) {\n        this.left.render(code, options, { isShorthandProperty });\n        this.right.render(code, options);\n    }\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        this.left.deoptimizePath(EMPTY_PATH);\n        this.right.deoptimizePath(UNKNOWN_PATH);\n        this.scope.context.requestTreeshakingPass();\n    }\n}\n\nclass AwaitExpression extends NodeBase {\n    hasEffects() {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        return true;\n    }\n    include(context, includeChildrenRecursively) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        if (!this.included) {\n            this.included = true;\n            checkTopLevelAwait: if (!this.scope.context.usesTopLevelAwait) {\n                let parent = this.parent;\n                do {\n                    if (parent instanceof FunctionNode || parent instanceof ArrowFunctionExpression)\n                        break checkTopLevelAwait;\n                } while ((parent = parent.parent));\n                this.scope.context.usesTopLevelAwait = true;\n            }\n        }\n        this.argument.include(context, includeChildrenRecursively);\n    }\n}\n\nconst binaryOperators = {\n    '!=': (left, right) => left != right,\n    '!==': (left, right) => left !== right,\n    '%': (left, right) => left % right,\n    '&': (left, right) => left & right,\n    '*': (left, right) => left * right,\n    // At the moment, \"**\" will be transpiled to Math.pow\n    '**': (left, right) => left ** right,\n    '+': (left, right) => left + right,\n    '-': (left, right) => left - right,\n    '/': (left, right) => left / right,\n    '<': (left, right) => left < right,\n    '<<': (left, right) => left << right,\n    '<=': (left, right) => left <= right,\n    '==': (left, right) => left == right,\n    '===': (left, right) => left === right,\n    '>': (left, right) => left > right,\n    '>=': (left, right) => left >= right,\n    '>>': (left, right) => left >> right,\n    '>>>': (left, right) => left >>> right,\n    '^': (left, right) => left ^ right,\n    '|': (left, right) => left | right\n    // We use the fallback for cases where we return something unknown\n    // in: () => UnknownValue,\n    // instanceof: () => UnknownValue,\n};\nclass BinaryExpression extends NodeBase {\n    deoptimizeCache() { }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        if (path.length > 0)\n            return UnknownValue;\n        const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);\n        if (typeof leftValue === 'symbol')\n            return UnknownValue;\n        const rightValue = this.right.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);\n        if (typeof rightValue === 'symbol')\n            return UnknownValue;\n        const operatorFunction = binaryOperators[this.operator];\n        if (!operatorFunction)\n            return UnknownValue;\n        return operatorFunction(leftValue, rightValue);\n    }\n    hasEffects(context) {\n        // support some implicit type coercion runtime errors\n        if (this.operator === '+' &&\n            this.parent instanceof ExpressionStatement &&\n            this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this) === '') {\n            return true;\n        }\n        return super.hasEffects(context);\n    }\n    hasEffectsOnInteractionAtPath(path, { type }) {\n        return type !== INTERACTION_ACCESSED || path.length > 1;\n    }\n    removeAnnotations(code) {\n        this.left.removeAnnotations(code);\n    }\n    render(code, options, { renderedSurroundingElement } = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BLANK) {\n        this.left.render(code, options, { renderedSurroundingElement });\n        this.right.render(code, options);\n    }\n}\n\nclass BreakStatement extends NodeBase {\n    hasEffects(context) {\n        if (this.label) {\n            if (!context.ignore.labels.has(this.label.name))\n                return true;\n            context.includedLabels.add(this.label.name);\n        }\n        else {\n            if (!context.ignore.breaks)\n                return true;\n            context.hasBreak = true;\n        }\n        context.brokenFlow = true;\n        return false;\n    }\n    include(context) {\n        this.included = true;\n        if (this.label) {\n            this.label.include();\n            context.includedLabels.add(this.label.name);\n        }\n        else {\n            context.hasBreak = true;\n        }\n        context.brokenFlow = true;\n    }\n}\n\nfunction renderCallArguments(code, options, node) {\n    if (node.arguments.length > 0) {\n        if (node.arguments[node.arguments.length - 1].included) {\n            for (const argument of node.arguments) {\n                argument.render(code, options);\n            }\n        }\n        else {\n            let lastIncludedIndex = node.arguments.length - 2;\n            while (lastIncludedIndex >= 0 && !node.arguments[lastIncludedIndex].included) {\n                lastIncludedIndex--;\n            }\n            if (lastIncludedIndex >= 0) {\n                for (let index = 0; index <= lastIncludedIndex; index++) {\n                    node.arguments[index].render(code, options);\n                }\n                code.remove(findFirstOccurrenceOutsideComment(code.original, ',', node.arguments[lastIncludedIndex].end), node.end - 1);\n            }\n            else {\n                code.remove(findFirstOccurrenceOutsideComment(code.original, '(', node.callee.end) + 1, node.end - 1);\n            }\n        }\n    }\n}\n\nclass CallExpressionBase extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.returnExpression = null;\n        this.deoptimizableDependentExpressions = [];\n        this.expressionsToBeDeoptimized = new Set();\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        const { args } = interaction;\n        const [returnExpression, isPure] = this.getReturnExpression(recursionTracker);\n        if (isPure)\n            return;\n        const deoptimizedExpressions = args.filter(expression => !!expression && expression !== UNKNOWN_EXPRESSION);\n        if (deoptimizedExpressions.length === 0)\n            return;\n        if (returnExpression === UNKNOWN_EXPRESSION) {\n            for (const expression of deoptimizedExpressions) {\n                expression.deoptimizePath(UNKNOWN_PATH);\n            }\n        }\n        else {\n            recursionTracker.withTrackedEntityAtPath(path, returnExpression, () => {\n                for (const expression of deoptimizedExpressions) {\n                    this.expressionsToBeDeoptimized.add(expression);\n                }\n                returnExpression.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n            }, null);\n        }\n    }\n    deoptimizeCache() {\n        if (this.returnExpression?.[0] !== UNKNOWN_EXPRESSION) {\n            this.returnExpression = UNKNOWN_RETURN_EXPRESSION;\n            const { deoptimizableDependentExpressions, expressionsToBeDeoptimized } = this;\n            this.expressionsToBeDeoptimized = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_SET;\n            this.deoptimizableDependentExpressions = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY;\n            for (const expression of deoptimizableDependentExpressions) {\n                expression.deoptimizeCache();\n            }\n            for (const expression of expressionsToBeDeoptimized) {\n                expression.deoptimizePath(UNKNOWN_PATH);\n            }\n        }\n    }\n    deoptimizePath(path) {\n        if (path.length === 0 ||\n            this.scope.context.deoptimizationTracker.trackEntityAtPathAndGetIfTracked(path, this)) {\n            return;\n        }\n        const [returnExpression] = this.getReturnExpression();\n        if (returnExpression !== UNKNOWN_EXPRESSION) {\n            returnExpression.deoptimizePath(path);\n        }\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        const [returnExpression] = this.getReturnExpression(recursionTracker);\n        if (returnExpression === UNKNOWN_EXPRESSION) {\n            return UnknownValue;\n        }\n        return recursionTracker.withTrackedEntityAtPath(path, returnExpression, () => {\n            this.deoptimizableDependentExpressions.push(origin);\n            return returnExpression.getLiteralValueAtPath(path, recursionTracker, origin);\n        }, UnknownValue);\n    }\n    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {\n        const returnExpression = this.getReturnExpression(recursionTracker);\n        if (returnExpression[0] === UNKNOWN_EXPRESSION) {\n            return returnExpression;\n        }\n        return recursionTracker.withTrackedEntityAtPath(path, returnExpression, () => {\n            this.deoptimizableDependentExpressions.push(origin);\n            const [expression, isPure] = returnExpression[0].getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);\n            return [expression, isPure || returnExpression[1]];\n        }, UNKNOWN_RETURN_EXPRESSION);\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        const { type } = interaction;\n        if (type === INTERACTION_CALLED) {\n            const { args, withNew } = interaction;\n            if ((withNew ? context.instantiated : context.called).trackEntityAtPathAndGetIfTracked(path, args, this)) {\n                return false;\n            }\n        }\n        else if ((type === INTERACTION_ASSIGNED\n            ? context.assigned\n            : context.accessed).trackEntityAtPathAndGetIfTracked(path, this)) {\n            return false;\n        }\n        const [returnExpression, isPure] = this.getReturnExpression();\n        return ((type === INTERACTION_ASSIGNED || !isPure) &&\n            returnExpression.hasEffectsOnInteractionAtPath(path, interaction, context));\n    }\n}\n\nclass CallExpression extends CallExpressionBase {\n    get optional() {\n        return isFlagSet(this.flags, 128 /* Flag.optional */);\n    }\n    set optional(value) {\n        this.flags = setFlag(this.flags, 128 /* Flag.optional */, value);\n    }\n    bind() {\n        super.bind();\n        if (this.callee instanceof Identifier) {\n            const variable = this.scope.findVariable(this.callee.name);\n            if (variable.isNamespace) {\n                this.scope.context.log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logCannotCallNamespace)(this.callee.name), this.start);\n            }\n            if (this.callee.name === 'eval') {\n                this.scope.context.log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logEval)(this.scope.context.module.id), this.start);\n            }\n        }\n        this.interaction = {\n            args: [\n                this.callee instanceof MemberExpression && !this.callee.variable\n                    ? this.callee.object\n                    : null,\n                ...this.arguments\n            ],\n            type: INTERACTION_CALLED,\n            withNew: false\n        };\n    }\n    getLiteralValueAtPathAsChainElement(path, recursionTracker, origin) {\n        return getChainElementLiteralValueAtPath(this, this.callee, path, recursionTracker, origin);\n    }\n    hasEffects(context) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        for (const argument of this.arguments) {\n            if (argument.hasEffects(context))\n                return true;\n        }\n        if (this.annotationPure) {\n            return false;\n        }\n        return (this.callee.hasEffects(context) ||\n            this.callee.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context));\n    }\n    hasEffectsAsChainElement(context) {\n        const calleeHasEffects = 'hasEffectsAsChainElement' in this.callee\n            ? this.callee.hasEffectsAsChainElement(context)\n            : this.callee.hasEffects(context);\n        if (calleeHasEffects === IS_SKIPPED_CHAIN)\n            return IS_SKIPPED_CHAIN;\n        if (this.optional &&\n            this.callee.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this) == null) {\n            return (!this.annotationPure && calleeHasEffects) || IS_SKIPPED_CHAIN;\n        }\n        // We only apply deoptimizations lazily once we know we are not skipping\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        for (const argument of this.arguments) {\n            if (argument.hasEffects(context))\n                return true;\n        }\n        return (!this.annotationPure &&\n            (calleeHasEffects ||\n                this.callee.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context)));\n    }\n    include(context, includeChildrenRecursively) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        if (includeChildrenRecursively) {\n            super.include(context, includeChildrenRecursively);\n            if (includeChildrenRecursively === INCLUDE_PARAMETERS &&\n                this.callee instanceof Identifier &&\n                this.callee.variable) {\n                this.callee.variable.markCalledFromTryStatement();\n            }\n        }\n        else {\n            this.included = true;\n            this.callee.include(context, false);\n        }\n        this.callee.includeCallArguments(context, this.arguments);\n    }\n    initialise() {\n        super.initialise();\n        if (this.annotations &&\n            this.scope.context.options.treeshake.annotations) {\n            this.annotationPure = this.annotations.some(comment => comment.type === 'pure');\n        }\n    }\n    render(code, options, { renderedSurroundingElement } = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BLANK) {\n        this.callee.render(code, options, {\n            isCalleeOfRenderedParent: true,\n            renderedSurroundingElement\n        });\n        renderCallArguments(code, options, this);\n    }\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        this.callee.deoptimizeArgumentsOnInteractionAtPath(this.interaction, EMPTY_PATH, SHARED_RECURSION_TRACKER);\n        this.scope.context.requestTreeshakingPass();\n    }\n    getReturnExpression(recursionTracker = SHARED_RECURSION_TRACKER) {\n        if (this.returnExpression === null) {\n            this.returnExpression = UNKNOWN_RETURN_EXPRESSION;\n            return (this.returnExpression = this.callee.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, this.interaction, recursionTracker, this));\n        }\n        return this.returnExpression;\n    }\n}\n\nclass CatchClause extends NodeBase {\n    createScope(parentScope) {\n        this.scope = new ParameterScope(parentScope, true);\n    }\n    parseNode(esTreeNode) {\n        const { body, param, type } = esTreeNode;\n        this.type = type;\n        if (param) {\n            this.param = new (this.scope.context.getNodeConstructor(param.type))(this, this.scope).parseNode(param);\n            this.param.declare('parameter', UNKNOWN_EXPRESSION);\n        }\n        this.body = new BlockStatement(this, this.scope.bodyScope).parseNode(body);\n        return super.parseNode(esTreeNode);\n    }\n}\nCatchClause.prototype.preventChildBlockScope = true;\n\nclass ChainExpression extends NodeBase {\n    // deoptimizations are not relevant as we are not caching values\n    deoptimizeCache() { }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        const literalValue = this.expression.getLiteralValueAtPathAsChainElement(path, recursionTracker, origin);\n        return literalValue === IS_SKIPPED_CHAIN ? undefined : literalValue;\n    }\n    hasEffects(context) {\n        return this.expression.hasEffectsAsChainElement(context) === true;\n    }\n    removeAnnotations(code) {\n        this.expression.removeAnnotations(code);\n    }\n    applyDeoptimizations() { }\n}\n\nclass ClassBodyScope extends ChildScope {\n    constructor(parent, classNode) {\n        const { context } = parent;\n        super(parent, context);\n        this.variables.set('this', (this.thisVariable = new LocalVariable('this', null, classNode, context, 'other')));\n        this.instanceScope = new ChildScope(this, context);\n        this.instanceScope.variables.set('this', new ThisVariable(context));\n    }\n    findLexicalBoundary() {\n        return this;\n    }\n}\n\nclass ClassBody extends NodeBase {\n    createScope(parentScope) {\n        this.scope = new ClassBodyScope(parentScope, this.parent);\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        this.scope.context.includeVariableInModule(this.scope.thisVariable);\n        for (const definition of this.body) {\n            definition.include(context, includeChildrenRecursively);\n        }\n    }\n    parseNode(esTreeNode) {\n        const body = (this.body = new Array(esTreeNode.body.length));\n        let index = 0;\n        for (const definition of esTreeNode.body) {\n            body[index++] = new (this.scope.context.getNodeConstructor(definition.type))(this, definition.static ? this.scope : this.scope.instanceScope).parseNode(definition);\n        }\n        return super.parseNode(esTreeNode);\n    }\n    applyDeoptimizations() { }\n}\n\nclass ClassExpression extends ClassNode {\n    render(code, options, { renderedSurroundingElement } = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BLANK) {\n        super.render(code, options);\n        if (renderedSurroundingElement === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.ExpressionStatement) {\n            code.appendRight(this.start, '(');\n            code.prependLeft(this.end, ')');\n        }\n    }\n}\n\nclass MultiExpression extends ExpressionEntity {\n    constructor(expressions) {\n        super();\n        this.expressions = expressions;\n    }\n    deoptimizePath(path) {\n        for (const expression of this.expressions) {\n            expression.deoptimizePath(path);\n        }\n    }\n    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {\n        return [\n            new MultiExpression(this.expressions.map(expression => expression.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)[0])),\n            false\n        ];\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        for (const expression of this.expressions) {\n            if (expression.hasEffectsOnInteractionAtPath(path, interaction, context))\n                return true;\n        }\n        return false;\n    }\n}\n\nclass ConditionalExpression extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.expressionsToBeDeoptimized = [];\n        this.usedBranch = null;\n    }\n    get isBranchResolutionAnalysed() {\n        return isFlagSet(this.flags, 65536 /* Flag.isBranchResolutionAnalysed */);\n    }\n    set isBranchResolutionAnalysed(value) {\n        this.flags = setFlag(this.flags, 65536 /* Flag.isBranchResolutionAnalysed */, value);\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        this.consequent.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n        this.alternate.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n    }\n    deoptimizeCache() {\n        if (this.usedBranch !== null) {\n            const unusedBranch = this.usedBranch === this.consequent ? this.alternate : this.consequent;\n            this.usedBranch = null;\n            unusedBranch.deoptimizePath(UNKNOWN_PATH);\n            const { expressionsToBeDeoptimized } = this;\n            this.expressionsToBeDeoptimized = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY;\n            for (const expression of expressionsToBeDeoptimized) {\n                expression.deoptimizeCache();\n            }\n        }\n    }\n    deoptimizePath(path) {\n        const usedBranch = this.getUsedBranch();\n        if (usedBranch) {\n            usedBranch.deoptimizePath(path);\n        }\n        else {\n            this.consequent.deoptimizePath(path);\n            this.alternate.deoptimizePath(path);\n        }\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        const usedBranch = this.getUsedBranch();\n        if (!usedBranch)\n            return UnknownValue;\n        this.expressionsToBeDeoptimized.push(origin);\n        return usedBranch.getLiteralValueAtPath(path, recursionTracker, origin);\n    }\n    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {\n        const usedBranch = this.getUsedBranch();\n        if (!usedBranch)\n            return [\n                new MultiExpression([\n                    this.consequent.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)[0],\n                    this.alternate.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)[0]\n                ]),\n                false\n            ];\n        this.expressionsToBeDeoptimized.push(origin);\n        return usedBranch.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);\n    }\n    hasEffects(context) {\n        if (this.test.hasEffects(context))\n            return true;\n        const usedBranch = this.getUsedBranch();\n        if (!usedBranch) {\n            return this.consequent.hasEffects(context) || this.alternate.hasEffects(context);\n        }\n        return usedBranch.hasEffects(context);\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        const usedBranch = this.getUsedBranch();\n        if (!usedBranch) {\n            return (this.consequent.hasEffectsOnInteractionAtPath(path, interaction, context) ||\n                this.alternate.hasEffectsOnInteractionAtPath(path, interaction, context));\n        }\n        return usedBranch.hasEffectsOnInteractionAtPath(path, interaction, context);\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        const usedBranch = this.getUsedBranch();\n        if (includeChildrenRecursively || this.test.shouldBeIncluded(context) || usedBranch === null) {\n            this.test.include(context, includeChildrenRecursively);\n            this.consequent.include(context, includeChildrenRecursively);\n            this.alternate.include(context, includeChildrenRecursively);\n        }\n        else {\n            usedBranch.include(context, includeChildrenRecursively);\n        }\n    }\n    includeCallArguments(context, parameters) {\n        const usedBranch = this.getUsedBranch();\n        if (usedBranch) {\n            usedBranch.includeCallArguments(context, parameters);\n        }\n        else {\n            this.consequent.includeCallArguments(context, parameters);\n            this.alternate.includeCallArguments(context, parameters);\n        }\n    }\n    removeAnnotations(code) {\n        this.test.removeAnnotations(code);\n    }\n    render(code, options, { isCalleeOfRenderedParent, preventASI, renderedParentType, renderedSurroundingElement } = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BLANK) {\n        const usedBranch = this.getUsedBranch();\n        if (this.test.included) {\n            this.test.render(code, options, { renderedSurroundingElement });\n            this.consequent.render(code, options);\n            this.alternate.render(code, options);\n        }\n        else {\n            const colonPos = findFirstOccurrenceOutsideComment(code.original, ':', this.consequent.end);\n            const inclusionStart = findNonWhiteSpace(code.original, (this.consequent.included\n                ? findFirstOccurrenceOutsideComment(code.original, '?', this.test.end)\n                : colonPos) + 1);\n            if (preventASI) {\n                removeLineBreaks(code, inclusionStart, usedBranch.start);\n            }\n            code.remove(this.start, inclusionStart);\n            if (this.consequent.included) {\n                code.remove(colonPos, this.end);\n            }\n            this.test.removeAnnotations(code);\n            usedBranch.render(code, options, {\n                isCalleeOfRenderedParent,\n                preventASI: true,\n                renderedParentType: renderedParentType || this.parent.type,\n                renderedSurroundingElement: renderedSurroundingElement || this.parent.type\n            });\n        }\n    }\n    getUsedBranch() {\n        if (this.isBranchResolutionAnalysed) {\n            return this.usedBranch;\n        }\n        this.isBranchResolutionAnalysed = true;\n        const testValue = this.test.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);\n        return typeof testValue === 'symbol'\n            ? null\n            : (this.usedBranch = testValue ? this.consequent : this.alternate);\n    }\n}\n\nclass ContinueStatement extends NodeBase {\n    hasEffects(context) {\n        if (this.label) {\n            if (!context.ignore.labels.has(this.label.name))\n                return true;\n            context.includedLabels.add(this.label.name);\n        }\n        else {\n            if (!context.ignore.continues)\n                return true;\n            context.hasContinue = true;\n        }\n        context.brokenFlow = true;\n        return false;\n    }\n    include(context) {\n        this.included = true;\n        if (this.label) {\n            this.label.include();\n            context.includedLabels.add(this.label.name);\n        }\n        else {\n            context.hasContinue = true;\n        }\n        context.brokenFlow = true;\n    }\n}\n\nclass DebuggerStatement extends NodeBase {\n    hasEffects() {\n        return true;\n    }\n}\n\nclass Decorator extends NodeBase {\n    hasEffects(context) {\n        return (this.expression.hasEffects(context) ||\n            this.expression.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_CALL, context));\n    }\n}\n\nfunction hasLoopBodyEffects(context, body) {\n    const { brokenFlow, hasBreak, hasContinue, ignore } = context;\n    const { breaks, continues } = ignore;\n    ignore.breaks = true;\n    ignore.continues = true;\n    context.hasBreak = false;\n    context.hasContinue = false;\n    if (body.hasEffects(context))\n        return true;\n    ignore.breaks = breaks;\n    ignore.continues = continues;\n    context.hasBreak = hasBreak;\n    context.hasContinue = hasContinue;\n    context.brokenFlow = brokenFlow;\n    return false;\n}\nfunction includeLoopBody(context, body, includeChildrenRecursively) {\n    const { brokenFlow, hasBreak, hasContinue } = context;\n    context.hasBreak = false;\n    context.hasContinue = false;\n    body.include(context, includeChildrenRecursively, { asSingleStatement: true });\n    context.hasBreak = hasBreak;\n    context.hasContinue = hasContinue;\n    context.brokenFlow = brokenFlow;\n}\n\nclass DoWhileStatement extends NodeBase {\n    hasEffects(context) {\n        if (this.test.hasEffects(context))\n            return true;\n        return hasLoopBodyEffects(context, this.body);\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        this.test.include(context, includeChildrenRecursively);\n        includeLoopBody(context, this.body, includeChildrenRecursively);\n    }\n}\n\nclass EmptyStatement extends NodeBase {\n    hasEffects() {\n        return false;\n    }\n}\n\nclass ExportAllDeclaration extends NodeBase {\n    hasEffects() {\n        return false;\n    }\n    initialise() {\n        super.initialise();\n        this.scope.context.addExport(this);\n    }\n    render(code, _options, nodeRenderOptions) {\n        code.remove(nodeRenderOptions.start, nodeRenderOptions.end);\n    }\n    applyDeoptimizations() { }\n}\nExportAllDeclaration.prototype.needsBoundaries = true;\n\nclass ExportNamedDeclaration extends NodeBase {\n    bind() {\n        // Do not bind specifiers\n        this.declaration?.bind();\n    }\n    hasEffects(context) {\n        return !!this.declaration?.hasEffects(context);\n    }\n    initialise() {\n        super.initialise();\n        this.scope.context.addExport(this);\n    }\n    removeAnnotations(code) {\n        this.declaration?.removeAnnotations(code);\n    }\n    render(code, options, nodeRenderOptions) {\n        const { start, end } = nodeRenderOptions;\n        if (this.declaration === null) {\n            code.remove(start, end);\n        }\n        else {\n            code.remove(this.start, this.declaration.start);\n            this.declaration.render(code, options, { end, start });\n        }\n    }\n    applyDeoptimizations() { }\n}\nExportNamedDeclaration.prototype.needsBoundaries = true;\n\nclass ExportSpecifier extends NodeBase {\n    applyDeoptimizations() { }\n}\n\nclass ForInStatement extends NodeBase {\n    createScope(parentScope) {\n        this.scope = new BlockScope(parentScope);\n    }\n    hasEffects(context) {\n        const { body, deoptimized, left, right } = this;\n        if (!deoptimized)\n            this.applyDeoptimizations();\n        if (left.hasEffectsAsAssignmentTarget(context, false) || right.hasEffects(context))\n            return true;\n        return hasLoopBodyEffects(context, body);\n    }\n    include(context, includeChildrenRecursively) {\n        const { body, deoptimized, left, right } = this;\n        if (!deoptimized)\n            this.applyDeoptimizations();\n        this.included = true;\n        left.includeAsAssignmentTarget(context, includeChildrenRecursively || true, false);\n        right.include(context, includeChildrenRecursively);\n        includeLoopBody(context, body, includeChildrenRecursively);\n    }\n    initialise() {\n        super.initialise();\n        this.left.setAssignedValue(UNKNOWN_EXPRESSION);\n    }\n    render(code, options) {\n        this.left.render(code, options, NO_SEMICOLON);\n        this.right.render(code, options, NO_SEMICOLON);\n        // handle no space between \"in\" and the right side\n        if (code.original.charCodeAt(this.right.start - 1) === 110 /* n */) {\n            code.prependLeft(this.right.start, ' ');\n        }\n        this.body.render(code, options);\n    }\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        this.left.deoptimizePath(EMPTY_PATH);\n        this.scope.context.requestTreeshakingPass();\n    }\n}\n\nclass ForOfStatement extends NodeBase {\n    get await() {\n        return isFlagSet(this.flags, 131072 /* Flag.await */);\n    }\n    set await(value) {\n        this.flags = setFlag(this.flags, 131072 /* Flag.await */, value);\n    }\n    createScope(parentScope) {\n        this.scope = new BlockScope(parentScope);\n    }\n    hasEffects() {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        // Placeholder until proper Symbol.Iterator support\n        return true;\n    }\n    include(context, includeChildrenRecursively) {\n        const { body, deoptimized, left, right } = this;\n        if (!deoptimized)\n            this.applyDeoptimizations();\n        this.included = true;\n        left.includeAsAssignmentTarget(context, includeChildrenRecursively || true, false);\n        right.include(context, includeChildrenRecursively);\n        includeLoopBody(context, body, includeChildrenRecursively);\n    }\n    initialise() {\n        super.initialise();\n        this.left.setAssignedValue(UNKNOWN_EXPRESSION);\n    }\n    render(code, options) {\n        this.left.render(code, options, NO_SEMICOLON);\n        this.right.render(code, options, NO_SEMICOLON);\n        // handle no space between \"of\" and the right side\n        if (code.original.charCodeAt(this.right.start - 1) === 102 /* f */) {\n            code.prependLeft(this.right.start, ' ');\n        }\n        this.body.render(code, options);\n    }\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        this.left.deoptimizePath(EMPTY_PATH);\n        this.right.deoptimizePath(UNKNOWN_PATH);\n        this.scope.context.requestTreeshakingPass();\n    }\n}\n\nclass ForStatement extends NodeBase {\n    createScope(parentScope) {\n        this.scope = new BlockScope(parentScope);\n    }\n    hasEffects(context) {\n        if (this.init?.hasEffects(context) ||\n            this.test?.hasEffects(context) ||\n            this.update?.hasEffects(context)) {\n            return true;\n        }\n        return hasLoopBodyEffects(context, this.body);\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        this.init?.include(context, includeChildrenRecursively, { asSingleStatement: true });\n        this.test?.include(context, includeChildrenRecursively);\n        this.update?.include(context, includeChildrenRecursively);\n        includeLoopBody(context, this.body, includeChildrenRecursively);\n    }\n    render(code, options) {\n        this.init?.render(code, options, NO_SEMICOLON);\n        this.test?.render(code, options, NO_SEMICOLON);\n        this.update?.render(code, options, NO_SEMICOLON);\n        this.body.render(code, options);\n    }\n}\n\nclass FunctionExpression extends FunctionNode {\n    createScope(parentScope) {\n        super.createScope((this.idScope = new ChildScope(parentScope, parentScope.context)));\n    }\n    parseNode(esTreeNode) {\n        if (esTreeNode.id !== null) {\n            this.id = new Identifier(this, this.idScope).parseNode(esTreeNode.id);\n        }\n        return super.parseNode(esTreeNode);\n    }\n    onlyFunctionCallUsed() {\n        const isIIFE = this.parent.type === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.CallExpression &&\n            this.parent.callee === this &&\n            (this.id === null || this.id.variable.getOnlyFunctionCallUsed());\n        return isIIFE || super.onlyFunctionCallUsed();\n    }\n    render(code, options, { renderedSurroundingElement } = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BLANK) {\n        super.render(code, options);\n        if (renderedSurroundingElement === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.ExpressionStatement) {\n            code.appendRight(this.start, '(');\n            code.prependLeft(this.end, ')');\n        }\n    }\n}\n\nclass TrackingScope extends BlockScope {\n    constructor() {\n        super(...arguments);\n        this.hoistedDeclarations = [];\n    }\n    addDeclaration(identifier, context, init, kind) {\n        this.hoistedDeclarations.push(identifier);\n        return super.addDeclaration(identifier, context, init, kind);\n    }\n}\n\nconst unset = Symbol('unset');\nclass IfStatement extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.testValue = unset;\n    }\n    deoptimizeCache() {\n        this.testValue = UnknownValue;\n    }\n    hasEffects(context) {\n        if (this.test.hasEffects(context)) {\n            return true;\n        }\n        const testValue = this.getTestValue();\n        if (typeof testValue === 'symbol') {\n            const { brokenFlow } = context;\n            if (this.consequent.hasEffects(context))\n                return true;\n            const consequentBrokenFlow = context.brokenFlow;\n            context.brokenFlow = brokenFlow;\n            if (this.alternate === null)\n                return false;\n            if (this.alternate.hasEffects(context))\n                return true;\n            context.brokenFlow = context.brokenFlow && consequentBrokenFlow;\n            return false;\n        }\n        return testValue ? this.consequent.hasEffects(context) : !!this.alternate?.hasEffects(context);\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        if (includeChildrenRecursively) {\n            this.includeRecursively(includeChildrenRecursively, context);\n        }\n        else {\n            const testValue = this.getTestValue();\n            if (typeof testValue === 'symbol') {\n                this.includeUnknownTest(context);\n            }\n            else {\n                this.includeKnownTest(context, testValue);\n            }\n        }\n    }\n    parseNode(esTreeNode) {\n        this.consequent = new (this.scope.context.getNodeConstructor(esTreeNode.consequent.type))(this, (this.consequentScope = new TrackingScope(this.scope))).parseNode(esTreeNode.consequent);\n        if (esTreeNode.alternate) {\n            this.alternate = new (this.scope.context.getNodeConstructor(esTreeNode.alternate.type))(this, (this.alternateScope = new TrackingScope(this.scope))).parseNode(esTreeNode.alternate);\n        }\n        return super.parseNode(esTreeNode);\n    }\n    render(code, options) {\n        const { snippets: { getPropertyAccess } } = options;\n        // Note that unknown test values are always included\n        const testValue = this.getTestValue();\n        const hoistedDeclarations = [];\n        const includesIfElse = this.test.included;\n        const noTreeshake = !this.scope.context.options.treeshake;\n        if (includesIfElse) {\n            this.test.render(code, options);\n        }\n        else {\n            code.remove(this.start, this.consequent.start);\n        }\n        if (this.consequent.included && (noTreeshake || typeof testValue === 'symbol' || testValue)) {\n            this.consequent.render(code, options);\n        }\n        else {\n            code.overwrite(this.consequent.start, this.consequent.end, includesIfElse ? ';' : '');\n            hoistedDeclarations.push(...this.consequentScope.hoistedDeclarations);\n        }\n        if (this.alternate) {\n            if (this.alternate.included && (noTreeshake || typeof testValue === 'symbol' || !testValue)) {\n                if (includesIfElse) {\n                    if (code.original.charCodeAt(this.alternate.start - 1) === 101) {\n                        code.prependLeft(this.alternate.start, ' ');\n                    }\n                }\n                else {\n                    code.remove(this.consequent.end, this.alternate.start);\n                }\n                this.alternate.render(code, options);\n            }\n            else {\n                if (includesIfElse && this.shouldKeepAlternateBranch()) {\n                    code.overwrite(this.alternate.start, this.end, ';');\n                }\n                else {\n                    code.remove(this.consequent.end, this.end);\n                }\n                hoistedDeclarations.push(...this.alternateScope.hoistedDeclarations);\n            }\n        }\n        this.renderHoistedDeclarations(hoistedDeclarations, code, getPropertyAccess);\n    }\n    applyDeoptimizations() { }\n    getTestValue() {\n        if (this.testValue === unset) {\n            return (this.testValue = this.test.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this));\n        }\n        return this.testValue;\n    }\n    includeKnownTest(context, testValue) {\n        if (this.test.shouldBeIncluded(context)) {\n            this.test.include(context, false);\n        }\n        if (testValue && this.consequent.shouldBeIncluded(context)) {\n            this.consequent.include(context, false, { asSingleStatement: true });\n        }\n        if (!testValue && this.alternate?.shouldBeIncluded(context)) {\n            this.alternate.include(context, false, { asSingleStatement: true });\n        }\n    }\n    includeRecursively(includeChildrenRecursively, context) {\n        this.test.include(context, includeChildrenRecursively);\n        this.consequent.include(context, includeChildrenRecursively);\n        this.alternate?.include(context, includeChildrenRecursively);\n    }\n    includeUnknownTest(context) {\n        this.test.include(context, false);\n        const { brokenFlow } = context;\n        let consequentBrokenFlow = false;\n        if (this.consequent.shouldBeIncluded(context)) {\n            this.consequent.include(context, false, { asSingleStatement: true });\n            consequentBrokenFlow = context.brokenFlow;\n            context.brokenFlow = brokenFlow;\n        }\n        if (this.alternate?.shouldBeIncluded(context)) {\n            this.alternate.include(context, false, { asSingleStatement: true });\n            context.brokenFlow = context.brokenFlow && consequentBrokenFlow;\n        }\n    }\n    renderHoistedDeclarations(hoistedDeclarations, code, getPropertyAccess) {\n        const hoistedVariables = [\n            ...new Set(hoistedDeclarations.map(identifier => {\n                const variable = identifier.variable;\n                return variable.included ? variable.getName(getPropertyAccess) : '';\n            }))\n        ]\n            .filter(Boolean)\n            .join(', ');\n        if (hoistedVariables) {\n            const parentType = this.parent.type;\n            const needsBraces = parentType !== _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.Program && parentType !== _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BlockStatement;\n            code.prependRight(this.start, `${needsBraces ? '{ ' : ''}var ${hoistedVariables}; `);\n            if (needsBraces) {\n                code.appendLeft(this.end, ` }`);\n            }\n        }\n    }\n    shouldKeepAlternateBranch() {\n        let currentParent = this.parent;\n        do {\n            if (currentParent instanceof IfStatement && currentParent.alternate) {\n                return true;\n            }\n            if (currentParent instanceof BlockStatement) {\n                return false;\n            }\n            currentParent = currentParent.parent;\n        } while (currentParent);\n        return false;\n    }\n}\n\nclass ImportAttribute extends NodeBase {\n}\n\nclass ImportDeclaration extends NodeBase {\n    // Do not bind specifiers or attributes\n    bind() { }\n    hasEffects() {\n        return false;\n    }\n    initialise() {\n        super.initialise();\n        this.scope.context.addImport(this);\n    }\n    render(code, _options, nodeRenderOptions) {\n        code.remove(nodeRenderOptions.start, nodeRenderOptions.end);\n    }\n    applyDeoptimizations() { }\n}\nImportDeclaration.prototype.needsBoundaries = true;\n\nclass ImportDefaultSpecifier extends NodeBase {\n    applyDeoptimizations() { }\n}\n\nfunction isReassignedExportsMember(variable, exportNamesByVariable) {\n    return (variable.renderBaseName !== null && exportNamesByVariable.has(variable) && variable.isReassigned);\n}\n\nclass VariableDeclarator extends NodeBase {\n    declareDeclarator(kind, isUsingDeclaration) {\n        this.isUsingDeclaration = isUsingDeclaration;\n        this.id.declare(kind, this.init || UNDEFINED_EXPRESSION);\n    }\n    deoptimizePath(path) {\n        this.id.deoptimizePath(path);\n    }\n    hasEffects(context) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        const initEffect = this.init?.hasEffects(context);\n        this.id.markDeclarationReached();\n        return initEffect || this.id.hasEffects(context) || this.isUsingDeclaration;\n    }\n    include(context, includeChildrenRecursively) {\n        const { deoptimized, id, init } = this;\n        if (!deoptimized)\n            this.applyDeoptimizations();\n        this.included = true;\n        init?.include(context, includeChildrenRecursively);\n        id.markDeclarationReached();\n        if (includeChildrenRecursively || id.shouldBeIncluded(context)) {\n            id.include(context, includeChildrenRecursively);\n        }\n    }\n    removeAnnotations(code) {\n        this.init?.removeAnnotations(code);\n    }\n    render(code, options) {\n        const { exportNamesByVariable, snippets: { _, getPropertyAccess } } = options;\n        const { end, id, init, start } = this;\n        const renderId = id.included || this.isUsingDeclaration;\n        if (renderId) {\n            id.render(code, options);\n        }\n        else {\n            const operatorPos = findFirstOccurrenceOutsideComment(code.original, '=', id.end);\n            code.remove(start, findNonWhiteSpace(code.original, operatorPos + 1));\n        }\n        if (init) {\n            if (id instanceof Identifier && init instanceof ClassExpression && !init.id) {\n                const renderedVariable = id.variable.getName(getPropertyAccess);\n                if (renderedVariable !== id.name) {\n                    code.appendLeft(init.start + 5, ` ${id.name}`);\n                }\n            }\n            init.render(code, options, renderId ? _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BLANK : { renderedSurroundingElement: _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.ExpressionStatement });\n        }\n        else if (id instanceof Identifier &&\n            isReassignedExportsMember(id.variable, exportNamesByVariable)) {\n            code.appendLeft(end, `${_}=${_}void 0`);\n        }\n    }\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        const { id, init } = this;\n        if (init && id instanceof Identifier && init instanceof ClassExpression && !init.id) {\n            const { name, variable } = id;\n            for (const accessedVariable of init.scope.accessedOutsideVariables.values()) {\n                if (accessedVariable !== variable) {\n                    accessedVariable.forbidName(name);\n                }\n            }\n        }\n    }\n}\n\nclass ImportExpression extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.inlineNamespace = null;\n        this.attributes = null;\n        this.mechanism = null;\n        this.namespaceExportName = undefined;\n        this.resolution = null;\n        this.resolutionString = null;\n    }\n    // Do not bind attributes\n    bind() {\n        this.source.bind();\n    }\n    /**\n     * Get imported variables for deterministic usage, valid cases are:\n     *\n     * - `const { foo } = await import('bar')`.\n     * - `(await import('bar')).foo`\n     * - `import('bar').then(({ foo }) => {})`\n     *\n     * Returns empty array if it's side-effect only import.\n     * Returns undefined if it's not fully deterministic.\n     */\n    getDeterministicImportedNames() {\n        const parent1 = this.parent;\n        // Side-effect only: import('bar')\n        if (parent1 instanceof ExpressionStatement) {\n            return _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY;\n        }\n        if (parent1 instanceof AwaitExpression) {\n            const parent2 = parent1.parent;\n            // Side-effect only: await import('bar')\n            if (parent2 instanceof ExpressionStatement) {\n                return _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY;\n            }\n            // Case 1: const { foo } = await import('bar')\n            if (parent2 instanceof VariableDeclarator) {\n                const declaration = parent2.id;\n                return declaration instanceof ObjectPattern\n                    ? getDeterministicObjectDestructure(declaration)\n                    : undefined;\n            }\n            // Case 2: (await import('bar')).foo\n            if (parent2 instanceof MemberExpression) {\n                const id = parent2.property;\n                if (!parent2.computed && id instanceof Identifier) {\n                    return [id.name];\n                }\n            }\n            return;\n        }\n        // Case 3: import('bar').then(({ foo }) => {})\n        if (parent1 instanceof MemberExpression) {\n            const callExpression = parent1.parent;\n            const property = parent1.property;\n            if (!(callExpression instanceof CallExpression) || !(property instanceof Identifier)) {\n                return;\n            }\n            const memberName = property.name;\n            // side-effect only, when only chaining .catch or .finally\n            if (callExpression.parent instanceof ExpressionStatement &&\n                ['catch', 'finally'].includes(memberName)) {\n                return _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY;\n            }\n            if (memberName !== 'then')\n                return;\n            // Side-effect only: import('bar').then()\n            if (callExpression.arguments.length === 0) {\n                return _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY;\n            }\n            const argument = callExpression.arguments[0];\n            if (callExpression.arguments.length !== 1 ||\n                !(argument instanceof ArrowFunctionExpression || argument instanceof FunctionExpression)) {\n                return;\n            }\n            // Side-effect only: import('bar').then(() => {})\n            if (argument.params.length === 0) {\n                return _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY;\n            }\n            const declaration = argument.params[0];\n            if (argument.params.length === 1 && declaration instanceof ObjectPattern) {\n                return getDeterministicObjectDestructure(declaration);\n            }\n            return;\n        }\n    }\n    hasEffects() {\n        return true;\n    }\n    include(context, includeChildrenRecursively) {\n        if (!this.included) {\n            this.included = true;\n            this.scope.context.includeDynamicImport(this);\n            this.scope.addAccessedDynamicImport(this);\n        }\n        this.source.include(context, includeChildrenRecursively);\n    }\n    initialise() {\n        super.initialise();\n        this.scope.context.addDynamicImport(this);\n    }\n    parseNode(esTreeNode) {\n        this.sourceAstNode = esTreeNode.source;\n        return super.parseNode(esTreeNode);\n    }\n    render(code, options) {\n        const { snippets: { _, getDirectReturnFunction, getObject, getPropertyAccess } } = options;\n        if (this.inlineNamespace) {\n            const [left, right] = getDirectReturnFunction([], {\n                functionReturn: true,\n                lineBreakIndent: null,\n                name: null\n            });\n            code.overwrite(this.start, this.end, `Promise.resolve().then(${left}${this.inlineNamespace.getName(getPropertyAccess)}${right})`);\n            return;\n        }\n        if (this.mechanism) {\n            code.overwrite(this.start, findFirstOccurrenceOutsideComment(code.original, '(', this.start + 6) + 1, this.mechanism.left);\n            code.overwrite(this.end - 1, this.end, this.mechanism.right);\n        }\n        if (this.resolutionString) {\n            code.overwrite(this.source.start, this.source.end, this.resolutionString);\n            if (this.namespaceExportName) {\n                const [left, right] = getDirectReturnFunction(['n'], {\n                    functionReturn: true,\n                    lineBreakIndent: null,\n                    name: null\n                });\n                code.prependLeft(this.end, `.then(${left}n.${this.namespaceExportName}${right})`);\n            }\n        }\n        else {\n            this.source.render(code, options);\n        }\n        if (this.attributes !== true) {\n            if (this.options) {\n                code.overwrite(this.source.end, this.end - 1, '', { contentOnly: true });\n            }\n            if (this.attributes) {\n                code.appendLeft(this.end - 1, `,${_}${getObject([['assert', this.attributes]], {\n                    lineBreakIndent: null\n                })}`);\n            }\n        }\n    }\n    setExternalResolution(exportMode, resolution, options, snippets, pluginDriver, accessedGlobalsByScope, resolutionString, namespaceExportName, attributes) {\n        const { format } = options;\n        this.inlineNamespace = null;\n        this.resolution = resolution;\n        this.resolutionString = resolutionString;\n        this.namespaceExportName = namespaceExportName;\n        this.attributes = attributes;\n        const accessedGlobals = [...(accessedImportGlobals[format] || [])];\n        let helper;\n        ({ helper, mechanism: this.mechanism } = this.getDynamicImportMechanismAndHelper(resolution, exportMode, options, snippets, pluginDriver));\n        if (helper) {\n            accessedGlobals.push(helper);\n        }\n        if (accessedGlobals.length > 0) {\n            this.scope.addAccessedGlobals(accessedGlobals, accessedGlobalsByScope);\n        }\n    }\n    setInternalResolution(inlineNamespace) {\n        this.inlineNamespace = inlineNamespace;\n    }\n    applyDeoptimizations() { }\n    getDynamicImportMechanismAndHelper(resolution, exportMode, { compact, dynamicImportInCjs, format, generatedCode: { arrowFunctions }, interop }, { _, getDirectReturnFunction, getDirectReturnIifeLeft }, pluginDriver) {\n        const mechanism = pluginDriver.hookFirstSync('renderDynamicImport', [\n            {\n                customResolution: typeof this.resolution === 'string' ? this.resolution : null,\n                format,\n                moduleId: this.scope.context.module.id,\n                targetModuleId: this.resolution && typeof this.resolution !== 'string' ? this.resolution.id : null\n            }\n        ]);\n        if (mechanism) {\n            return { helper: null, mechanism };\n        }\n        const hasDynamicTarget = !this.resolution || typeof this.resolution === 'string';\n        switch (format) {\n            case 'cjs': {\n                if (dynamicImportInCjs &&\n                    (!resolution || typeof resolution === 'string' || resolution instanceof ExternalModule)) {\n                    return { helper: null, mechanism: null };\n                }\n                const helper = getInteropHelper(resolution, exportMode, interop);\n                let left = `require(`;\n                let right = `)`;\n                if (helper) {\n                    left = `/*#__PURE__*/${helper}(${left}`;\n                    right += ')';\n                }\n                const [functionLeft, functionRight] = getDirectReturnFunction([], {\n                    functionReturn: true,\n                    lineBreakIndent: null,\n                    name: null\n                });\n                left = `Promise.resolve().then(${functionLeft}${left}`;\n                right += `${functionRight})`;\n                if (!arrowFunctions && hasDynamicTarget) {\n                    left = getDirectReturnIifeLeft(['t'], `${left}t${right}`, {\n                        needsArrowReturnParens: false,\n                        needsWrappedFunction: true\n                    });\n                    right = ')';\n                }\n                return {\n                    helper,\n                    mechanism: { left, right }\n                };\n            }\n            case 'amd': {\n                const resolve = compact ? 'c' : 'resolve';\n                const reject = compact ? 'e' : 'reject';\n                const helper = getInteropHelper(resolution, exportMode, interop);\n                const [resolveLeft, resolveRight] = getDirectReturnFunction(['m'], {\n                    functionReturn: false,\n                    lineBreakIndent: null,\n                    name: null\n                });\n                const resolveNamespace = helper\n                    ? `${resolveLeft}${resolve}(/*#__PURE__*/${helper}(m))${resolveRight}`\n                    : resolve;\n                const [handlerLeft, handlerRight] = getDirectReturnFunction([resolve, reject], {\n                    functionReturn: false,\n                    lineBreakIndent: null,\n                    name: null\n                });\n                let left = `new Promise(${handlerLeft}require([`;\n                let right = `],${_}${resolveNamespace},${_}${reject})${handlerRight})`;\n                if (!arrowFunctions && hasDynamicTarget) {\n                    left = getDirectReturnIifeLeft(['t'], `${left}t${right}`, {\n                        needsArrowReturnParens: false,\n                        needsWrappedFunction: true\n                    });\n                    right = ')';\n                }\n                return {\n                    helper,\n                    mechanism: { left, right }\n                };\n            }\n            case 'system': {\n                return {\n                    helper: null,\n                    mechanism: {\n                        left: 'module.import(',\n                        right: ')'\n                    }\n                };\n            }\n        }\n        return { helper: null, mechanism: null };\n    }\n}\nfunction getInteropHelper(resolution, exportMode, interop) {\n    return exportMode === 'external'\n        ? namespaceInteropHelpersByInteropType[interop(resolution instanceof ExternalModule ? resolution.id : null)]\n        : exportMode === 'default'\n            ? INTEROP_NAMESPACE_DEFAULT_ONLY_VARIABLE\n            : null;\n}\nconst accessedImportGlobals = {\n    amd: ['require'],\n    cjs: ['require'],\n    system: ['module']\n};\nfunction getDeterministicObjectDestructure(objectPattern) {\n    const variables = [];\n    for (const property of objectPattern.properties) {\n        if (property.type === 'RestElement' || property.computed || property.key.type !== 'Identifier')\n            return;\n        variables.push(property.key.name);\n    }\n    return variables;\n}\n\nclass ImportNamespaceSpecifier extends NodeBase {\n    applyDeoptimizations() { }\n}\n\nclass ImportSpecifier extends NodeBase {\n    applyDeoptimizations() { }\n}\n\nclass JSXIdentifier extends IdentifierBase {\n    constructor() {\n        super(...arguments);\n        this.isNativeElement = false;\n    }\n    bind() {\n        const type = this.getType();\n        if (type === 0 /* IdentifierType.Reference */) {\n            this.variable = this.scope.findVariable(this.name);\n            this.variable.addReference(this);\n        }\n        else if (type === 1 /* IdentifierType.NativeElementName */) {\n            this.isNativeElement = true;\n        }\n    }\n    render(code, { snippets: { getPropertyAccess }, useOriginalName }) {\n        if (this.variable) {\n            const name = this.variable.getName(getPropertyAccess, useOriginalName);\n            if (name !== this.name) {\n                code.overwrite(this.start, this.end, name, {\n                    contentOnly: true,\n                    storeName: true\n                });\n            }\n        }\n        else if (this.isNativeElement &&\n            this.scope.context.options.jsx.mode !== 'preserve') {\n            code.update(this.start, this.end, JSON.stringify(this.name));\n        }\n    }\n    getType() {\n        switch (this.parent.type) {\n            case 'JSXOpeningElement':\n            case 'JSXClosingElement': {\n                return this.name.startsWith(this.name.charAt(0).toUpperCase())\n                    ? 0 /* IdentifierType.Reference */\n                    : 1 /* IdentifierType.NativeElementName */;\n            }\n            case 'JSXMemberExpression': {\n                return this.parent.object === this\n                    ? 0 /* IdentifierType.Reference */\n                    : 2 /* IdentifierType.Other */;\n            }\n            case 'JSXAttribute':\n            case 'JSXNamespacedName': {\n                return 2 /* IdentifierType.Other */;\n            }\n            default: {\n                /* istanbul ignore next */\n                throw new Error(`Unexpected parent node type for JSXIdentifier: ${this.parent.type}`);\n            }\n        }\n    }\n}\n\nclass JSXAttribute extends NodeBase {\n    render(code, options, { jsxMode } = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BLANK) {\n        super.render(code, options);\n        if (['classic', 'automatic'].includes(jsxMode)) {\n            const { name, value } = this;\n            const key = name instanceof JSXIdentifier ? name.name : `${name.namespace.name}:${name.name.name}`;\n            if (!(jsxMode === 'automatic' && key === 'key')) {\n                const safeKey = stringifyObjectKeyIfNeeded(key);\n                if (key !== safeKey) {\n                    code.overwrite(name.start, name.end, safeKey, { contentOnly: true });\n                }\n                if (value) {\n                    code.overwrite(name.end, value.start, ': ', { contentOnly: true });\n                }\n                else {\n                    code.appendLeft(name.end, ': true');\n                }\n            }\n        }\n    }\n}\n\nclass JSXClosingBase extends NodeBase {\n    render(code, options) {\n        const { mode } = this.scope.context.options.jsx;\n        if (mode !== 'preserve') {\n            code.overwrite(this.start, this.end, ')', { contentOnly: true });\n        }\n        else {\n            super.render(code, options);\n        }\n    }\n}\n\nclass JSXClosingElement extends JSXClosingBase {\n}\n\nclass JSXClosingFragment extends JSXClosingBase {\n}\n\nclass JSXSpreadAttribute extends NodeBase {\n    render(code, options) {\n        this.argument.render(code, options);\n        const { mode } = this.scope.context.options.jsx;\n        if (mode !== 'preserve') {\n            code.overwrite(this.start, this.argument.start, '', { contentOnly: true });\n            code.overwrite(this.argument.end, this.end, '', { contentOnly: true });\n        }\n    }\n}\n\nclass JSXEmptyExpression extends NodeBase {\n}\n\nclass JSXExpressionContainer extends NodeBase {\n    render(code, options) {\n        const { mode } = this.scope.context.options.jsx;\n        if (mode !== 'preserve') {\n            code.remove(this.start, this.expression.start);\n            code.remove(this.expression.end, this.end);\n        }\n        this.expression.render(code, options);\n    }\n}\n\nfunction getRenderedJsxChildren(children) {\n    let renderedChildren = 0;\n    for (const child of children) {\n        if (!(child instanceof JSXExpressionContainer && child.expression instanceof JSXEmptyExpression)) {\n            renderedChildren++;\n        }\n    }\n    return renderedChildren;\n}\n\nfunction getAndIncludeFactoryVariable(factory, preserve, importSource, node) {\n    const [baseName, nestedName] = factory.split('.');\n    let factoryVariable;\n    if (importSource) {\n        factoryVariable = node.scope.context.getImportedJsxFactoryVariable(nestedName ? 'default' : baseName, node.start, importSource);\n        if (preserve) {\n            // This pretends we are accessing an included global variable of the same name\n            const globalVariable = node.scope.findGlobal(baseName);\n            globalVariable.include();\n            // This excludes this variable from renaming\n            factoryVariable.globalName = baseName;\n        }\n    }\n    else {\n        factoryVariable = node.scope.findGlobal(baseName);\n    }\n    node.scope.context.includeVariableInModule(factoryVariable);\n    if (factoryVariable instanceof LocalVariable) {\n        factoryVariable.consolidateInitializers();\n        factoryVariable.addUsedPlace(node);\n        node.scope.context.requestTreeshakingPass();\n    }\n    return factoryVariable;\n}\n\nclass JSXElementBase extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.factoryVariable = null;\n        this.factory = null;\n    }\n    initialise() {\n        super.initialise();\n        const { importSource } = (this.jsxMode = this.getRenderingMode());\n        if (importSource) {\n            this.scope.context.addImportSource(importSource);\n        }\n    }\n    include(context, includeChildrenRecursively) {\n        if (!this.included) {\n            const { factory, importSource, mode } = this.jsxMode;\n            if (factory) {\n                this.factory = factory;\n                this.factoryVariable = getAndIncludeFactoryVariable(factory, mode === 'preserve', importSource, this);\n            }\n        }\n        super.include(context, includeChildrenRecursively);\n    }\n    applyDeoptimizations() { }\n    getRenderingMode() {\n        const jsx = this.scope.context.options.jsx;\n        const { mode, factory, importSource } = jsx;\n        if (mode === 'automatic') {\n            return {\n                factory: getRenderedJsxChildren(this.children) > 1 ? 'jsxs' : 'jsx',\n                importSource: jsx.jsxImportSource,\n                mode\n            };\n        }\n        return { factory, importSource, mode };\n    }\n    renderChildren(code, options, openingEnd) {\n        const { children } = this;\n        let hasMultipleChildren = false;\n        let childrenEnd = openingEnd;\n        let firstChild = null;\n        for (const child of children) {\n            if (child instanceof JSXExpressionContainer &&\n                child.expression instanceof JSXEmptyExpression) {\n                code.remove(childrenEnd, child.end);\n            }\n            else {\n                code.appendLeft(childrenEnd, ', ');\n                child.render(code, options);\n                if (firstChild) {\n                    hasMultipleChildren = true;\n                }\n                else {\n                    firstChild = child;\n                }\n            }\n            childrenEnd = child.end;\n        }\n        return { childrenEnd, firstChild, hasMultipleChildren };\n    }\n}\n\nclass JSXElement extends JSXElementBase {\n    render(code, options) {\n        switch (this.jsxMode.mode) {\n            case 'classic': {\n                this.renderClassicMode(code, options);\n                break;\n            }\n            case 'automatic': {\n                this.renderAutomaticMode(code, options);\n                break;\n            }\n            default: {\n                super.render(code, options);\n            }\n        }\n    }\n    getRenderingMode() {\n        const jsx = this.scope.context.options.jsx;\n        const { mode, factory, importSource } = jsx;\n        if (mode === 'automatic') {\n            // In the case there is a key after a spread attribute, we fall back to\n            // classic mode, see https://github.com/facebook/react/issues/20031#issuecomment-710346866\n            // for reasoning.\n            let hasSpread = false;\n            for (const attribute of this.openingElement.attributes) {\n                if (attribute instanceof JSXSpreadAttribute) {\n                    hasSpread = true;\n                }\n                else if (hasSpread && attribute.name.name === 'key') {\n                    return { factory, importSource, mode: 'classic' };\n                }\n            }\n        }\n        return super.getRenderingMode();\n    }\n    renderClassicMode(code, options) {\n        const { snippets: { getPropertyAccess }, useOriginalName } = options;\n        const { closingElement, end, factory, factoryVariable, openingElement: { end: openingEnd, selfClosing } } = this;\n        const [, ...nestedName] = factory.split('.');\n        const { firstAttribute, hasAttributes, hasSpread, inObject, previousEnd } = this.renderAttributes(code, options, [factoryVariable.getName(getPropertyAccess, useOriginalName), ...nestedName].join('.'), false);\n        this.wrapAttributes(code, inObject, hasAttributes, hasSpread, firstAttribute, 'null', previousEnd);\n        this.renderChildren(code, options, openingEnd);\n        if (selfClosing) {\n            code.appendLeft(end, ')');\n        }\n        else {\n            closingElement.render(code, options);\n        }\n    }\n    renderAutomaticMode(code, options) {\n        const { snippets: { getPropertyAccess }, useOriginalName } = options;\n        const { closingElement, end, factoryVariable, openingElement: { end: openindEnd, selfClosing } } = this;\n        let { firstAttribute, hasAttributes, hasSpread, inObject, keyAttribute, previousEnd } = this.renderAttributes(code, options, factoryVariable.getName(getPropertyAccess, useOriginalName), true);\n        const { firstChild, hasMultipleChildren, childrenEnd } = this.renderChildren(code, options, openindEnd);\n        if (firstChild) {\n            code.prependRight(firstChild.start, `children: ${hasMultipleChildren ? '[' : ''}`);\n            if (!inObject) {\n                code.prependRight(firstChild.start, '{ ');\n                inObject = true;\n            }\n            previousEnd = closingElement.start;\n            if (hasMultipleChildren) {\n                code.appendLeft(previousEnd, ']');\n            }\n        }\n        this.wrapAttributes(code, inObject, hasAttributes || !!firstChild, hasSpread, firstAttribute || firstChild, '{}', childrenEnd);\n        if (keyAttribute) {\n            const { value } = keyAttribute;\n            // This will appear to the left of the moved code...\n            code.appendLeft(childrenEnd, ', ');\n            if (value) {\n                code.move(value.start, value.end, childrenEnd);\n            }\n            else {\n                code.appendLeft(childrenEnd, 'true');\n            }\n        }\n        if (selfClosing) {\n            // Moving the key attribute will also move the parenthesis to the right position\n            code.appendLeft(keyAttribute?.value?.end || end, ')');\n        }\n        else {\n            closingElement.render(code, options);\n        }\n    }\n    renderAttributes(code, options, factoryName, extractKeyAttribute) {\n        const { jsxMode: { mode }, openingElement } = this;\n        const { attributes, end: openingEnd, start: openingStart, name: { start: nameStart, end: nameEnd } } = openingElement;\n        code.update(openingStart, nameStart, `/*#__PURE__*/${factoryName}(`);\n        openingElement.render(code, options, { jsxMode: mode });\n        let keyAttribute = null;\n        let hasSpread = false;\n        let inObject = false;\n        let previousEnd = nameEnd;\n        let hasAttributes = false;\n        let firstAttribute = null;\n        for (const attribute of attributes) {\n            if (attribute instanceof JSXAttribute) {\n                if (extractKeyAttribute && attribute.name.name === 'key') {\n                    keyAttribute = attribute;\n                    code.remove(previousEnd, attribute.value?.start || attribute.end);\n                    continue;\n                }\n                code.appendLeft(previousEnd, ',');\n                if (!inObject) {\n                    code.prependRight(attribute.start, '{ ');\n                    inObject = true;\n                }\n                hasAttributes = true;\n            }\n            else {\n                if (inObject) {\n                    if (hasAttributes) {\n                        code.appendLeft(previousEnd, ' ');\n                    }\n                    code.appendLeft(previousEnd, '},');\n                    inObject = false;\n                }\n                else {\n                    code.appendLeft(previousEnd, ',');\n                }\n                hasSpread = true;\n            }\n            previousEnd = attribute.end;\n            if (!firstAttribute) {\n                firstAttribute = attribute;\n            }\n        }\n        code.remove(attributes.at(-1)?.end || previousEnd, openingEnd);\n        return { firstAttribute, hasAttributes, hasSpread, inObject, keyAttribute, previousEnd };\n    }\n    wrapAttributes(code, inObject, hasAttributes, hasSpread, firstAttribute, missingAttributesFallback, attributesEnd) {\n        if (inObject) {\n            code.appendLeft(attributesEnd, ' }');\n        }\n        if (hasSpread) {\n            if (hasAttributes) {\n                const { start } = firstAttribute;\n                if (firstAttribute instanceof JSXSpreadAttribute) {\n                    code.prependRight(start, '{}, ');\n                }\n                code.prependRight(start, 'Object.assign(');\n                code.appendLeft(attributesEnd, ')');\n            }\n        }\n        else if (!hasAttributes) {\n            code.appendLeft(attributesEnd, `, ${missingAttributesFallback}`);\n        }\n    }\n}\n\nclass JSXFragment extends JSXElementBase {\n    render(code, options) {\n        switch (this.jsxMode.mode) {\n            case 'classic': {\n                this.renderClassicMode(code, options);\n                break;\n            }\n            case 'automatic': {\n                this.renderAutomaticMode(code, options);\n                break;\n            }\n            default: {\n                super.render(code, options);\n            }\n        }\n    }\n    renderClassicMode(code, options) {\n        const { snippets: { getPropertyAccess }, useOriginalName } = options;\n        const { closingFragment, factory, factoryVariable, openingFragment, start } = this;\n        const [, ...nestedName] = factory.split('.');\n        openingFragment.render(code, options);\n        code.prependRight(start, `/*#__PURE__*/${[\n            factoryVariable.getName(getPropertyAccess, useOriginalName),\n            ...nestedName\n        ].join('.')}(`);\n        code.appendLeft(openingFragment.end, ', null');\n        this.renderChildren(code, options, openingFragment.end);\n        closingFragment.render(code, options);\n    }\n    renderAutomaticMode(code, options) {\n        const { snippets: { getPropertyAccess }, useOriginalName } = options;\n        const { closingFragment, factoryVariable, openingFragment, start } = this;\n        openingFragment.render(code, options);\n        code.prependRight(start, `/*#__PURE__*/${factoryVariable.getName(getPropertyAccess, useOriginalName)}(`);\n        const { firstChild, hasMultipleChildren, childrenEnd } = this.renderChildren(code, options, openingFragment.end);\n        if (firstChild) {\n            code.prependRight(firstChild.start, `{ children: ${hasMultipleChildren ? '[' : ''}`);\n            if (hasMultipleChildren) {\n                code.appendLeft(closingFragment.start, ']');\n            }\n            code.appendLeft(childrenEnd, ' }');\n        }\n        else {\n            code.appendLeft(openingFragment.end, ', {}');\n        }\n        closingFragment.render(code, options);\n    }\n}\n\nclass JSXMemberExpression extends NodeBase {\n}\n\nclass JSXNamespacedName extends NodeBase {\n}\n\nclass JSXOpeningElement extends NodeBase {\n    render(code, options, { jsxMode = this.scope.context.options.jsx.mode } = {}) {\n        this.name.render(code, options);\n        for (const attribute of this.attributes) {\n            attribute.render(code, options, { jsxMode });\n        }\n    }\n}\n\nclass JSXOpeningFragment extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.fragment = null;\n        this.fragmentVariable = null;\n    }\n    include(context, includeChildrenRecursively) {\n        if (!this.included) {\n            const jsx = this.scope.context.options.jsx;\n            if (jsx.mode === 'automatic') {\n                this.fragment = 'Fragment';\n                this.fragmentVariable = getAndIncludeFactoryVariable('Fragment', false, jsx.jsxImportSource, this);\n            }\n            else {\n                const { fragment, importSource, mode } = jsx;\n                if (fragment != null) {\n                    this.fragment = fragment;\n                    this.fragmentVariable = getAndIncludeFactoryVariable(fragment, mode === 'preserve', importSource, this);\n                }\n            }\n        }\n        super.include(context, includeChildrenRecursively);\n    }\n    render(code, options) {\n        const { mode } = this.scope.context.options.jsx;\n        if (mode !== 'preserve') {\n            const { snippets: { getPropertyAccess }, useOriginalName } = options;\n            const [, ...nestedFragment] = this.fragment.split('.');\n            const fragment = [\n                this.fragmentVariable.getName(getPropertyAccess, useOriginalName),\n                ...nestedFragment\n            ].join('.');\n            code.update(this.start, this.end, fragment);\n        }\n    }\n}\n\nclass JSXSpreadChild extends NodeBase {\n    render(code, options) {\n        super.render(code, options);\n        const { mode } = this.scope.context.options.jsx;\n        if (mode !== 'preserve') {\n            code.overwrite(this.start, this.expression.start, '...', { contentOnly: true });\n            code.overwrite(this.expression.end, this.end, '', { contentOnly: true });\n        }\n    }\n}\n\nclass JSXText extends NodeBase {\n    render(code) {\n        const { mode } = this.scope.context.options.jsx;\n        if (mode !== 'preserve') {\n            code.overwrite(this.start, this.end, JSON.stringify(this.value), {\n                contentOnly: true\n            });\n        }\n    }\n}\n\nclass LabeledStatement extends NodeBase {\n    hasEffects(context) {\n        const { brokenFlow, includedLabels } = context;\n        context.ignore.labels.add(this.label.name);\n        context.includedLabels = new Set();\n        let bodyHasEffects = false;\n        if (this.body.hasEffects(context)) {\n            bodyHasEffects = true;\n        }\n        else {\n            context.ignore.labels.delete(this.label.name);\n            if (context.includedLabels.has(this.label.name)) {\n                context.includedLabels.delete(this.label.name);\n                context.brokenFlow = brokenFlow;\n            }\n        }\n        context.includedLabels = new Set([...includedLabels, ...context.includedLabels]);\n        return bodyHasEffects;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        const { brokenFlow, includedLabels } = context;\n        context.includedLabels = new Set();\n        this.body.include(context, includeChildrenRecursively);\n        if (includeChildrenRecursively || context.includedLabels.has(this.label.name)) {\n            this.label.include();\n            context.includedLabels.delete(this.label.name);\n            context.brokenFlow = brokenFlow;\n        }\n        context.includedLabels = new Set([...includedLabels, ...context.includedLabels]);\n    }\n    render(code, options) {\n        if (this.label.included) {\n            this.label.render(code, options);\n        }\n        else {\n            code.remove(this.start, findNonWhiteSpace(code.original, findFirstOccurrenceOutsideComment(code.original, ':', this.label.end) + 1));\n        }\n        this.body.render(code, options);\n    }\n}\n\nclass LogicalExpression extends NodeBase {\n    constructor() {\n        super(...arguments);\n        // We collect deoptimization information if usedBranch !== null\n        this.expressionsToBeDeoptimized = [];\n        this.usedBranch = null;\n    }\n    //private isBranchResolutionAnalysed = false;\n    get isBranchResolutionAnalysed() {\n        return isFlagSet(this.flags, 65536 /* Flag.isBranchResolutionAnalysed */);\n    }\n    set isBranchResolutionAnalysed(value) {\n        this.flags = setFlag(this.flags, 65536 /* Flag.isBranchResolutionAnalysed */, value);\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        this.left.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n        this.right.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n    }\n    deoptimizeCache() {\n        if (this.usedBranch) {\n            const unusedBranch = this.usedBranch === this.left ? this.right : this.left;\n            this.usedBranch = null;\n            unusedBranch.deoptimizePath(UNKNOWN_PATH);\n            const { scope: { context }, expressionsToBeDeoptimized } = this;\n            this.expressionsToBeDeoptimized = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY;\n            for (const expression of expressionsToBeDeoptimized) {\n                expression.deoptimizeCache();\n            }\n            // Request another pass because we need to ensure \"include\" runs again if\n            // it is rendered\n            context.requestTreeshakingPass();\n        }\n    }\n    deoptimizePath(path) {\n        const usedBranch = this.getUsedBranch();\n        if (usedBranch) {\n            usedBranch.deoptimizePath(path);\n        }\n        else {\n            this.left.deoptimizePath(path);\n            this.right.deoptimizePath(path);\n        }\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        const usedBranch = this.getUsedBranch();\n        if (!usedBranch)\n            return UnknownValue;\n        this.expressionsToBeDeoptimized.push(origin);\n        return usedBranch.getLiteralValueAtPath(path, recursionTracker, origin);\n    }\n    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {\n        const usedBranch = this.getUsedBranch();\n        if (!usedBranch)\n            return [\n                new MultiExpression([\n                    this.left.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)[0],\n                    this.right.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)[0]\n                ]),\n                false\n            ];\n        this.expressionsToBeDeoptimized.push(origin);\n        return usedBranch.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);\n    }\n    hasEffects(context) {\n        if (this.left.hasEffects(context)) {\n            return true;\n        }\n        if (this.getUsedBranch() !== this.left) {\n            return this.right.hasEffects(context);\n        }\n        return false;\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        const usedBranch = this.getUsedBranch();\n        if (!usedBranch) {\n            return (this.left.hasEffectsOnInteractionAtPath(path, interaction, context) ||\n                this.right.hasEffectsOnInteractionAtPath(path, interaction, context));\n        }\n        return usedBranch.hasEffectsOnInteractionAtPath(path, interaction, context);\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        const usedBranch = this.getUsedBranch();\n        if (includeChildrenRecursively ||\n            (usedBranch === this.right && this.left.shouldBeIncluded(context)) ||\n            !usedBranch) {\n            this.left.include(context, includeChildrenRecursively);\n            this.right.include(context, includeChildrenRecursively);\n        }\n        else {\n            usedBranch.include(context, includeChildrenRecursively);\n        }\n    }\n    removeAnnotations(code) {\n        this.left.removeAnnotations(code);\n    }\n    render(code, options, { isCalleeOfRenderedParent, preventASI, renderedParentType, renderedSurroundingElement } = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BLANK) {\n        if (!this.left.included || !this.right.included) {\n            const operatorPos = findFirstOccurrenceOutsideComment(code.original, this.operator, this.left.end);\n            if (this.right.included) {\n                const removePos = findNonWhiteSpace(code.original, operatorPos + 2);\n                code.remove(this.start, removePos);\n                if (preventASI) {\n                    removeLineBreaks(code, removePos, this.right.start);\n                }\n                this.left.removeAnnotations(code);\n            }\n            else {\n                code.remove(findLastWhiteSpaceReverse(code.original, this.left.end, operatorPos), this.end);\n            }\n            this.getUsedBranch().render(code, options, {\n                isCalleeOfRenderedParent,\n                preventASI,\n                renderedParentType: renderedParentType || this.parent.type,\n                renderedSurroundingElement: renderedSurroundingElement || this.parent.type\n            });\n        }\n        else {\n            this.left.render(code, options, {\n                preventASI,\n                renderedSurroundingElement\n            });\n            this.right.render(code, options);\n        }\n    }\n    getUsedBranch() {\n        if (!this.isBranchResolutionAnalysed) {\n            this.isBranchResolutionAnalysed = true;\n            const leftValue = this.left.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);\n            if (typeof leftValue === 'symbol') {\n                return null;\n            }\n            else {\n                this.usedBranch =\n                    (this.operator === '||' && leftValue) ||\n                        (this.operator === '&&' && !leftValue) ||\n                        (this.operator === '??' && leftValue != null)\n                        ? this.left\n                        : this.right;\n            }\n        }\n        return this.usedBranch;\n    }\n}\n\nclass NewExpression extends NodeBase {\n    hasEffects(context) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        for (const argument of this.arguments) {\n            if (argument.hasEffects(context))\n                return true;\n        }\n        if (this.annotationPure) {\n            return false;\n        }\n        return (this.callee.hasEffects(context) ||\n            this.callee.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context));\n    }\n    hasEffectsOnInteractionAtPath(path, { type }) {\n        return path.length > 0 || type !== INTERACTION_ACCESSED;\n    }\n    include(context, includeChildrenRecursively) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        if (includeChildrenRecursively) {\n            super.include(context, includeChildrenRecursively);\n        }\n        else {\n            this.included = true;\n            this.callee.include(context, false);\n        }\n        this.callee.includeCallArguments(context, this.arguments);\n    }\n    initialise() {\n        super.initialise();\n        this.interaction = {\n            args: [null, ...this.arguments],\n            type: INTERACTION_CALLED,\n            withNew: true\n        };\n        if (this.annotations &&\n            this.scope.context.options.treeshake.annotations) {\n            this.annotationPure = this.annotations.some(comment => comment.type === 'pure');\n        }\n    }\n    render(code, options) {\n        this.callee.render(code, options);\n        renderCallArguments(code, options, this);\n    }\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        this.callee.deoptimizeArgumentsOnInteractionAtPath(this.interaction, EMPTY_PATH, SHARED_RECURSION_TRACKER);\n        this.scope.context.requestTreeshakingPass();\n    }\n}\n\nclass ObjectExpression extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.objectEntity = null;\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        this.getObjectEntity().deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n    }\n    deoptimizeCache() {\n        this.getObjectEntity().deoptimizeAllProperties();\n    }\n    deoptimizePath(path) {\n        this.getObjectEntity().deoptimizePath(path);\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        return this.getObjectEntity().getLiteralValueAtPath(path, recursionTracker, origin);\n    }\n    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {\n        return this.getObjectEntity().getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin);\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        return this.getObjectEntity().hasEffectsOnInteractionAtPath(path, interaction, context);\n    }\n    render(code, options, { renderedSurroundingElement } = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BLANK) {\n        super.render(code, options);\n        if (renderedSurroundingElement === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.ExpressionStatement ||\n            renderedSurroundingElement === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.ArrowFunctionExpression) {\n            code.appendRight(this.start, '(');\n            code.prependLeft(this.end, ')');\n        }\n    }\n    applyDeoptimizations() { }\n    getObjectEntity() {\n        if (this.objectEntity !== null) {\n            return this.objectEntity;\n        }\n        let prototype = OBJECT_PROTOTYPE;\n        const properties = [];\n        for (const property of this.properties) {\n            if (property instanceof SpreadElement) {\n                properties.push({ key: UnknownKey, kind: 'init', property });\n                continue;\n            }\n            let key;\n            if (property.computed) {\n                const keyValue = property.key.getLiteralValueAtPath(EMPTY_PATH, SHARED_RECURSION_TRACKER, this);\n                if (typeof keyValue === 'symbol') {\n                    properties.push({ key: UnknownKey, kind: property.kind, property });\n                    continue;\n                }\n                else {\n                    key = String(keyValue);\n                }\n            }\n            else {\n                key =\n                    property.key instanceof Identifier\n                        ? property.key.name\n                        : String(property.key.value);\n                if (key === '__proto__' && property.kind === 'init') {\n                    prototype =\n                        property.value instanceof Literal && property.value.value === null\n                            ? null\n                            : property.value;\n                    continue;\n                }\n            }\n            properties.push({ key, kind: property.kind, property });\n        }\n        return (this.objectEntity = new ObjectEntity(properties, prototype));\n    }\n}\n\nclass PanicError extends NodeBase {\n    initialise() {\n        const id = this.scope.context.module.id;\n        // This simulates the current nested error structure. We could also just\n        // replace it with a flat error.\n        const parseError = (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.getRollupError)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logParseError)(this.message));\n        const moduleParseError = (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logModuleParseError)(parseError, id);\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)(moduleParseError);\n    }\n}\n\nclass ParseError extends NodeBase {\n    initialise() {\n        const pos = this.start;\n        const id = this.scope.context.module.id;\n        // This simulates the current nested error structure. We could also just\n        // replace it with a flat error.\n        const parseError = (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.getRollupError)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logParseError)(this.message, pos));\n        const moduleParseError = (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logModuleParseError)(parseError, id);\n        this.scope.context.error(moduleParseError, pos);\n    }\n}\n\nclass PrivateIdentifier extends NodeBase {\n}\n\nclass Program extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.hasCachedEffect = null;\n        this.hasLoggedEffect = false;\n    }\n    hasCachedEffects() {\n        if (!this.included) {\n            return false;\n        }\n        return this.hasCachedEffect === null\n            ? (this.hasCachedEffect = this.hasEffects(createHasEffectsContext()))\n            : this.hasCachedEffect;\n    }\n    hasEffects(context) {\n        for (const node of this.body) {\n            if (node.hasEffects(context)) {\n                if (this.scope.context.options.experimentalLogSideEffects && !this.hasLoggedEffect) {\n                    this.hasLoggedEffect = true;\n                    const { code, log, module } = this.scope.context;\n                    log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_INFO, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logFirstSideEffect)(code, module.id, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.locate)(code, node.start, { offsetLine: 1 })), node.start);\n                }\n                return (this.hasCachedEffect = true);\n            }\n        }\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        for (const node of this.body) {\n            if (includeChildrenRecursively || node.shouldBeIncluded(context)) {\n                node.include(context, includeChildrenRecursively);\n            }\n        }\n    }\n    initialise() {\n        super.initialise();\n        if (this.invalidAnnotations)\n            for (const { start, end, type } of this.invalidAnnotations) {\n                this.scope.context.magicString.remove(start, end);\n                if (type === 'pure' || type === 'noSideEffects') {\n                    this.scope.context.log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidAnnotation)(this.scope.context.code.slice(start, end), this.scope.context.module.id, type), start);\n                }\n            }\n    }\n    render(code, options) {\n        let start = this.start;\n        if (code.original.startsWith('#!')) {\n            start = Math.min(code.original.indexOf('\\n') + 1, this.end);\n            code.remove(0, start);\n        }\n        if (this.body.length > 0) {\n            // Keep all consecutive lines that start with a comment\n            while (code.original[start] === '/' && /[*/]/.test(code.original[start + 1])) {\n                const firstLineBreak = findFirstLineBreakOutsideComment(code.original.slice(start, this.body[0].start));\n                if (firstLineBreak[0] === -1) {\n                    break;\n                }\n                start += firstLineBreak[1];\n            }\n            renderStatementList(this.body, code, start, this.end, options);\n        }\n        else {\n            super.render(code, options);\n        }\n    }\n    applyDeoptimizations() { }\n}\n\nclass Property extends MethodBase {\n    constructor() {\n        super(...arguments);\n        this.declarationInit = null;\n    }\n    //declare method: boolean;\n    get method() {\n        return isFlagSet(this.flags, 262144 /* Flag.method */);\n    }\n    set method(value) {\n        this.flags = setFlag(this.flags, 262144 /* Flag.method */, value);\n    }\n    //declare shorthand: boolean;\n    get shorthand() {\n        return isFlagSet(this.flags, 524288 /* Flag.shorthand */);\n    }\n    set shorthand(value) {\n        this.flags = setFlag(this.flags, 524288 /* Flag.shorthand */, value);\n    }\n    declare(kind, init) {\n        this.declarationInit = init;\n        return this.value.declare(kind, UNKNOWN_EXPRESSION);\n    }\n    hasEffects(context) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        const propertyReadSideEffects = this.scope.context.options.treeshake.propertyReadSideEffects;\n        return ((this.parent.type === 'ObjectPattern' && propertyReadSideEffects === 'always') ||\n            this.key.hasEffects(context) ||\n            this.value.hasEffects(context));\n    }\n    markDeclarationReached() {\n        this.value.markDeclarationReached();\n    }\n    render(code, options) {\n        if (!this.shorthand) {\n            this.key.render(code, options);\n        }\n        this.value.render(code, options, { isShorthandProperty: this.shorthand });\n    }\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        if (this.declarationInit !== null) {\n            this.declarationInit.deoptimizePath([UnknownKey, UnknownKey]);\n            this.scope.context.requestTreeshakingPass();\n        }\n    }\n}\n\nclass PropertyDefinition extends NodeBase {\n    get computed() {\n        return isFlagSet(this.flags, 1024 /* Flag.computed */);\n    }\n    set computed(value) {\n        this.flags = setFlag(this.flags, 1024 /* Flag.computed */, value);\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        this.value?.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n    }\n    deoptimizePath(path) {\n        this.value?.deoptimizePath(path);\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        return this.value\n            ? this.value.getLiteralValueAtPath(path, recursionTracker, origin)\n            : UnknownValue;\n    }\n    getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin) {\n        return this.value\n            ? this.value.getReturnExpressionWhenCalledAtPath(path, interaction, recursionTracker, origin)\n            : UNKNOWN_RETURN_EXPRESSION;\n    }\n    hasEffects(context) {\n        return (this.key.hasEffects(context) ||\n            (this.static && !!this.value?.hasEffects(context)) ||\n            checkEffectForNodes(this.decorators, context));\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        return !this.value || this.value.hasEffectsOnInteractionAtPath(path, interaction, context);\n    }\n    applyDeoptimizations() { }\n}\n\nclass ReturnStatement extends NodeBase {\n    hasEffects(context) {\n        if (!context.ignore.returnYield || this.argument?.hasEffects(context))\n            return true;\n        context.brokenFlow = true;\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        this.argument?.include(context, includeChildrenRecursively);\n        context.brokenFlow = true;\n    }\n    initialise() {\n        super.initialise();\n        this.scope.addReturnExpression(this.argument || UNKNOWN_EXPRESSION);\n    }\n    render(code, options) {\n        if (this.argument) {\n            this.argument.render(code, options, { preventASI: true });\n            if (this.argument.start === this.start + 6 /* 'return'.length */) {\n                code.prependLeft(this.start + 6, ' ');\n            }\n        }\n    }\n}\n\nclass SequenceExpression extends NodeBase {\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        this.expressions[this.expressions.length - 1].deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n    }\n    deoptimizePath(path) {\n        this.expressions[this.expressions.length - 1].deoptimizePath(path);\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        return this.expressions[this.expressions.length - 1].getLiteralValueAtPath(path, recursionTracker, origin);\n    }\n    hasEffects(context) {\n        for (const expression of this.expressions) {\n            if (expression.hasEffects(context))\n                return true;\n        }\n        return false;\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        return this.expressions[this.expressions.length - 1].hasEffectsOnInteractionAtPath(path, interaction, context);\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        const lastExpression = this.expressions[this.expressions.length - 1];\n        for (const expression of this.expressions) {\n            if (includeChildrenRecursively ||\n                (expression === lastExpression && !(this.parent instanceof ExpressionStatement)) ||\n                expression.shouldBeIncluded(context))\n                expression.include(context, includeChildrenRecursively);\n        }\n    }\n    removeAnnotations(code) {\n        this.expressions[0].removeAnnotations(code);\n    }\n    render(code, options, { renderedParentType, isCalleeOfRenderedParent, preventASI } = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BLANK) {\n        let includedNodes = 0;\n        let lastSeparatorPos = null;\n        const lastNode = this.expressions[this.expressions.length - 1];\n        for (const { node, separator, start, end } of getCommaSeparatedNodesWithBoundaries(this.expressions, code, this.start, this.end)) {\n            if (!node.included) {\n                treeshakeNode(node, code, start, end);\n                continue;\n            }\n            includedNodes++;\n            lastSeparatorPos = separator;\n            if (includedNodes === 1 && preventASI) {\n                removeLineBreaks(code, start, node.start);\n            }\n            if (includedNodes === 1) {\n                const parentType = renderedParentType || this.parent.type;\n                node.render(code, options, {\n                    isCalleeOfRenderedParent: isCalleeOfRenderedParent && node === lastNode,\n                    renderedParentType: parentType,\n                    renderedSurroundingElement: parentType\n                });\n            }\n            else {\n                node.render(code, options);\n            }\n        }\n        if (lastSeparatorPos) {\n            code.remove(lastSeparatorPos, this.end);\n        }\n    }\n}\n\nclass Super extends NodeBase {\n    bind() {\n        this.variable = this.scope.findVariable('this');\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        this.variable.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n    }\n    deoptimizePath(path) {\n        this.variable.deoptimizePath(path);\n    }\n    include() {\n        if (!this.included) {\n            this.included = true;\n            this.scope.context.includeVariableInModule(this.variable);\n        }\n    }\n}\n\nclass SwitchCase extends NodeBase {\n    hasEffects(context) {\n        if (this.test?.hasEffects(context))\n            return true;\n        for (const node of this.consequent) {\n            if (context.brokenFlow)\n                break;\n            if (node.hasEffects(context))\n                return true;\n        }\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        this.test?.include(context, includeChildrenRecursively);\n        for (const node of this.consequent) {\n            if (includeChildrenRecursively || node.shouldBeIncluded(context))\n                node.include(context, includeChildrenRecursively);\n        }\n    }\n    render(code, options, nodeRenderOptions) {\n        if (this.consequent.length > 0) {\n            if (this.test) {\n                this.test.render(code, options);\n            }\n            const testEnd = this.test\n                ? this.test.end\n                : findFirstOccurrenceOutsideComment(code.original, 'default', this.start) + 7;\n            const consequentStart = findFirstOccurrenceOutsideComment(code.original, ':', testEnd) + 1;\n            renderStatementList(this.consequent, code, consequentStart, nodeRenderOptions.end, options);\n        }\n        else {\n            super.render(code, options);\n        }\n    }\n}\nSwitchCase.prototype.needsBoundaries = true;\n\nclass SwitchStatement extends NodeBase {\n    createScope(parentScope) {\n        this.parentScope = parentScope;\n        this.scope = new BlockScope(parentScope);\n    }\n    hasEffects(context) {\n        if (this.discriminant.hasEffects(context))\n            return true;\n        const { brokenFlow, hasBreak, ignore } = context;\n        const { breaks } = ignore;\n        ignore.breaks = true;\n        context.hasBreak = false;\n        let onlyHasBrokenFlow = true;\n        for (const switchCase of this.cases) {\n            if (switchCase.hasEffects(context))\n                return true;\n            onlyHasBrokenFlow &&= context.brokenFlow && !context.hasBreak;\n            context.hasBreak = false;\n            context.brokenFlow = brokenFlow;\n        }\n        if (this.defaultCase !== null) {\n            context.brokenFlow = onlyHasBrokenFlow;\n        }\n        ignore.breaks = breaks;\n        context.hasBreak = hasBreak;\n        return false;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        this.discriminant.include(context, includeChildrenRecursively);\n        const { brokenFlow, hasBreak } = context;\n        context.hasBreak = false;\n        let onlyHasBrokenFlow = true;\n        let isCaseIncluded = includeChildrenRecursively ||\n            (this.defaultCase !== null && this.defaultCase < this.cases.length - 1);\n        for (let caseIndex = this.cases.length - 1; caseIndex >= 0; caseIndex--) {\n            const switchCase = this.cases[caseIndex];\n            if (switchCase.included) {\n                isCaseIncluded = true;\n            }\n            if (!isCaseIncluded) {\n                const hasEffectsContext = createHasEffectsContext();\n                hasEffectsContext.ignore.breaks = true;\n                isCaseIncluded = switchCase.hasEffects(hasEffectsContext);\n            }\n            if (isCaseIncluded) {\n                switchCase.include(context, includeChildrenRecursively);\n                onlyHasBrokenFlow &&= context.brokenFlow && !context.hasBreak;\n                context.hasBreak = false;\n                context.brokenFlow = brokenFlow;\n            }\n            else {\n                onlyHasBrokenFlow = brokenFlow;\n            }\n        }\n        if (isCaseIncluded && this.defaultCase !== null) {\n            context.brokenFlow = onlyHasBrokenFlow;\n        }\n        context.hasBreak = hasBreak;\n    }\n    initialise() {\n        super.initialise();\n        for (let caseIndex = 0; caseIndex < this.cases.length; caseIndex++) {\n            if (this.cases[caseIndex].test === null) {\n                this.defaultCase = caseIndex;\n                return;\n            }\n        }\n        this.defaultCase = null;\n    }\n    parseNode(esTreeNode) {\n        this.discriminant = new (this.scope.context.getNodeConstructor(esTreeNode.discriminant.type))(this, this.parentScope).parseNode(esTreeNode.discriminant);\n        return super.parseNode(esTreeNode);\n    }\n    render(code, options) {\n        this.discriminant.render(code, options);\n        if (this.cases.length > 0) {\n            renderStatementList(this.cases, code, this.cases[0].start, this.end - 1, options);\n        }\n    }\n}\n\nclass TaggedTemplateExpression extends CallExpressionBase {\n    bind() {\n        super.bind();\n        if (this.tag.type === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.Identifier) {\n            const name = this.tag.name;\n            const variable = this.scope.findVariable(name);\n            if (variable.isNamespace) {\n                this.scope.context.log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logCannotCallNamespace)(name), this.start);\n            }\n        }\n    }\n    hasEffects(context) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        for (const argument of this.quasi.expressions) {\n            if (argument.hasEffects(context))\n                return true;\n        }\n        return (this.tag.hasEffects(context) ||\n            this.tag.hasEffectsOnInteractionAtPath(EMPTY_PATH, this.interaction, context));\n    }\n    include(context, includeChildrenRecursively) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        if (includeChildrenRecursively) {\n            super.include(context, includeChildrenRecursively);\n        }\n        else {\n            this.included = true;\n            this.tag.include(context, includeChildrenRecursively);\n            this.quasi.include(context, includeChildrenRecursively);\n        }\n        this.tag.includeCallArguments(context, this.args);\n        const [returnExpression] = this.getReturnExpression();\n        if (!returnExpression.included) {\n            returnExpression.include(context, false);\n        }\n    }\n    initialise() {\n        super.initialise();\n        this.args = [UNKNOWN_EXPRESSION, ...this.quasi.expressions];\n        this.interaction = {\n            args: [\n                this.tag instanceof MemberExpression && !this.tag.variable ? this.tag.object : null,\n                ...this.args\n            ],\n            type: INTERACTION_CALLED,\n            withNew: false\n        };\n    }\n    render(code, options) {\n        this.tag.render(code, options, { isCalleeOfRenderedParent: true });\n        this.quasi.render(code, options);\n    }\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        this.tag.deoptimizeArgumentsOnInteractionAtPath(this.interaction, EMPTY_PATH, SHARED_RECURSION_TRACKER);\n        this.scope.context.requestTreeshakingPass();\n    }\n    getReturnExpression(recursionTracker = SHARED_RECURSION_TRACKER) {\n        if (this.returnExpression === null) {\n            this.returnExpression = UNKNOWN_RETURN_EXPRESSION;\n            return (this.returnExpression = this.tag.getReturnExpressionWhenCalledAtPath(EMPTY_PATH, this.interaction, recursionTracker, this));\n        }\n        return this.returnExpression;\n    }\n}\n\nclass TemplateElement extends NodeBase {\n    get tail() {\n        return isFlagSet(this.flags, 1048576 /* Flag.tail */);\n    }\n    set tail(value) {\n        this.flags = setFlag(this.flags, 1048576 /* Flag.tail */, value);\n    }\n    // Do not try to bind value\n    bind() { }\n    hasEffects() {\n        return false;\n    }\n    include() {\n        this.included = true;\n    }\n    parseNode(esTreeNode) {\n        this.value = esTreeNode.value;\n        return super.parseNode(esTreeNode);\n    }\n    render() { }\n}\n\nclass TemplateLiteral extends NodeBase {\n    deoptimizeArgumentsOnInteractionAtPath() { }\n    getLiteralValueAtPath(path) {\n        if (path.length > 0 || this.quasis.length !== 1) {\n            return UnknownValue;\n        }\n        return this.quasis[0].value.cooked;\n    }\n    getReturnExpressionWhenCalledAtPath(path) {\n        if (path.length !== 1) {\n            return UNKNOWN_RETURN_EXPRESSION;\n        }\n        return getMemberReturnExpressionWhenCalled(literalStringMembers, path[0]);\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        if (interaction.type === INTERACTION_ACCESSED) {\n            return path.length > 1;\n        }\n        if (interaction.type === INTERACTION_CALLED && path.length === 1) {\n            return hasMemberEffectWhenCalled(literalStringMembers, path[0], interaction, context);\n        }\n        return true;\n    }\n    render(code, options) {\n        code.indentExclusionRanges.push([this.start, this.end]);\n        super.render(code, options);\n    }\n}\n\nclass ModuleScope extends ChildScope {\n    constructor(parent, context) {\n        super(parent, context);\n        this.variables.set('this', new LocalVariable('this', null, UNDEFINED_EXPRESSION, context, 'other'));\n    }\n    addDeclaration(identifier, context, init, kind) {\n        if (this.context.module.importDescriptions.has(identifier.name)) {\n            context.error((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logRedeclarationError)(identifier.name), identifier.start);\n        }\n        return super.addDeclaration(identifier, context, init, kind);\n    }\n    addExportDefaultDeclaration(name, exportDefaultDeclaration, context) {\n        const variable = new ExportDefaultVariable(name, exportDefaultDeclaration, context);\n        this.variables.set('default', variable);\n        return variable;\n    }\n    addNamespaceMemberAccess() { }\n    deconflict(format, exportNamesByVariable, accessedGlobalsByScope) {\n        // all module level variables are already deconflicted when deconflicting the chunk\n        for (const scope of this.children)\n            scope.deconflict(format, exportNamesByVariable, accessedGlobalsByScope);\n    }\n    findLexicalBoundary() {\n        return this;\n    }\n    findVariable(name) {\n        const knownVariable = this.variables.get(name) || this.accessedOutsideVariables.get(name);\n        if (knownVariable) {\n            return knownVariable;\n        }\n        const variable = this.context.traceVariable(name) || this.parent.findVariable(name);\n        if (variable instanceof GlobalVariable) {\n            this.accessedOutsideVariables.set(name, variable);\n        }\n        return variable;\n    }\n}\n\nclass ThisExpression extends NodeBase {\n    bind() {\n        this.variable = this.scope.findVariable('this');\n    }\n    deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker) {\n        this.variable.deoptimizeArgumentsOnInteractionAtPath(interaction, path, recursionTracker);\n    }\n    deoptimizePath(path) {\n        this.variable.deoptimizePath(path);\n    }\n    hasEffectsOnInteractionAtPath(path, interaction, context) {\n        if (path.length === 0) {\n            return interaction.type !== INTERACTION_ACCESSED;\n        }\n        return this.variable.hasEffectsOnInteractionAtPath(path, interaction, context);\n    }\n    include() {\n        if (!this.included) {\n            this.included = true;\n            this.scope.context.includeVariableInModule(this.variable);\n        }\n    }\n    initialise() {\n        super.initialise();\n        this.alias =\n            this.scope.findLexicalBoundary() instanceof ModuleScope\n                ? this.scope.context.moduleContext\n                : null;\n        if (this.alias === 'undefined') {\n            this.scope.context.log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logThisIsUndefined)(), this.start);\n        }\n    }\n    render(code) {\n        if (this.alias !== null) {\n            code.overwrite(this.start, this.end, this.alias, {\n                contentOnly: false,\n                storeName: true\n            });\n        }\n    }\n}\n\nclass ThrowStatement extends NodeBase {\n    hasEffects() {\n        return true;\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        this.argument.include(context, includeChildrenRecursively);\n        context.brokenFlow = true;\n    }\n    render(code, options) {\n        this.argument.render(code, options, { preventASI: true });\n        if (this.argument.start === this.start + 5 /* 'throw'.length */) {\n            code.prependLeft(this.start + 5, ' ');\n        }\n    }\n}\n\nclass TryStatement extends NodeBase {\n    constructor() {\n        super(...arguments);\n        this.directlyIncluded = false;\n        this.includedLabelsAfterBlock = null;\n    }\n    hasEffects(context) {\n        return ((this.scope.context.options.treeshake.tryCatchDeoptimization\n            ? this.block.body.length > 0\n            : this.block.hasEffects(context)) || !!this.finalizer?.hasEffects(context));\n    }\n    include(context, includeChildrenRecursively) {\n        const tryCatchDeoptimization = this.scope.context.options.treeshake?.tryCatchDeoptimization;\n        const { brokenFlow, includedLabels } = context;\n        if (!this.directlyIncluded || !tryCatchDeoptimization) {\n            this.included = true;\n            this.directlyIncluded = true;\n            this.block.include(context, tryCatchDeoptimization ? INCLUDE_PARAMETERS : includeChildrenRecursively);\n            if (includedLabels.size > 0) {\n                this.includedLabelsAfterBlock = [...includedLabels];\n            }\n            context.brokenFlow = brokenFlow;\n        }\n        else if (this.includedLabelsAfterBlock) {\n            for (const label of this.includedLabelsAfterBlock) {\n                includedLabels.add(label);\n            }\n        }\n        if (this.handler !== null) {\n            this.handler.include(context, includeChildrenRecursively);\n            context.brokenFlow = brokenFlow;\n        }\n        this.finalizer?.include(context, includeChildrenRecursively);\n    }\n}\n\nconst unaryOperators = {\n    '!': value => !value,\n    '+': value => +value,\n    '-': value => -value,\n    delete: () => UnknownValue,\n    typeof: value => typeof value,\n    void: () => undefined,\n    '~': value => ~value\n};\nclass UnaryExpression extends NodeBase {\n    get prefix() {\n        return isFlagSet(this.flags, 2097152 /* Flag.prefix */);\n    }\n    set prefix(value) {\n        this.flags = setFlag(this.flags, 2097152 /* Flag.prefix */, value);\n    }\n    getLiteralValueAtPath(path, recursionTracker, origin) {\n        if (path.length > 0)\n            return UnknownValue;\n        const argumentValue = this.argument.getLiteralValueAtPath(EMPTY_PATH, recursionTracker, origin);\n        if (typeof argumentValue === 'symbol')\n            return UnknownValue;\n        return unaryOperators[this.operator](argumentValue);\n    }\n    hasEffects(context) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        if (this.operator === 'typeof' && this.argument instanceof Identifier)\n            return false;\n        return (this.argument.hasEffects(context) ||\n            (this.operator === 'delete' &&\n                this.argument.hasEffectsOnInteractionAtPath(EMPTY_PATH, NODE_INTERACTION_UNKNOWN_ASSIGNMENT, context)));\n    }\n    hasEffectsOnInteractionAtPath(path, { type }) {\n        return type !== INTERACTION_ACCESSED || path.length > (this.operator === 'void' ? 0 : 1);\n    }\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        if (this.operator === 'delete') {\n            this.argument.deoptimizePath(EMPTY_PATH);\n            this.scope.context.requestTreeshakingPass();\n        }\n    }\n}\n\nclass UpdateExpression extends NodeBase {\n    hasEffects(context) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        return this.argument.hasEffectsAsAssignmentTarget(context, true);\n    }\n    hasEffectsOnInteractionAtPath(path, { type }) {\n        return path.length > 1 || type !== INTERACTION_ACCESSED;\n    }\n    include(context, includeChildrenRecursively) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        this.included = true;\n        this.argument.includeAsAssignmentTarget(context, includeChildrenRecursively, true);\n    }\n    initialise() {\n        super.initialise();\n        this.argument.setAssignedValue(UNKNOWN_EXPRESSION);\n    }\n    render(code, options) {\n        const { exportNamesByVariable, format, snippets: { _ } } = options;\n        this.argument.render(code, options);\n        if (format === 'system') {\n            const variable = this.argument.variable;\n            const exportNames = exportNamesByVariable.get(variable);\n            if (exportNames) {\n                if (this.prefix) {\n                    if (exportNames.length === 1) {\n                        renderSystemExportExpression(variable, this.start, this.end, code, options);\n                    }\n                    else {\n                        renderSystemExportSequenceAfterExpression(variable, this.start, this.end, this.parent.type !== _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.ExpressionStatement, code, options);\n                    }\n                }\n                else {\n                    const operator = this.operator[0];\n                    renderSystemExportSequenceBeforeExpression(variable, this.start, this.end, this.parent.type !== _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.ExpressionStatement, code, options, `${_}${operator}${_}1`);\n                }\n            }\n        }\n    }\n    applyDeoptimizations() {\n        this.deoptimized = true;\n        this.argument.deoptimizePath(EMPTY_PATH);\n        if (this.argument instanceof Identifier) {\n            const variable = this.scope.findVariable(this.argument.name);\n            variable.markReassigned();\n        }\n        this.scope.context.requestTreeshakingPass();\n    }\n}\n\nfunction areAllDeclarationsIncludedAndNotExported(declarations, exportNamesByVariable) {\n    for (const declarator of declarations) {\n        if (!declarator.id.included)\n            return false;\n        if (declarator.id.type === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.Identifier) {\n            if (exportNamesByVariable.has(declarator.id.variable))\n                return false;\n        }\n        else {\n            const exportedVariables = [];\n            declarator.id.addExportedVariables(exportedVariables, exportNamesByVariable);\n            if (exportedVariables.length > 0)\n                return false;\n        }\n    }\n    return true;\n}\nclass VariableDeclaration extends NodeBase {\n    deoptimizePath() {\n        for (const declarator of this.declarations) {\n            declarator.deoptimizePath(EMPTY_PATH);\n        }\n    }\n    hasEffectsOnInteractionAtPath() {\n        return false;\n    }\n    include(context, includeChildrenRecursively, { asSingleStatement } = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BLANK) {\n        this.included = true;\n        for (const declarator of this.declarations) {\n            if (includeChildrenRecursively || declarator.shouldBeIncluded(context))\n                declarator.include(context, includeChildrenRecursively);\n            const { id, init } = declarator;\n            if (asSingleStatement) {\n                id.include(context, includeChildrenRecursively);\n            }\n            if (init &&\n                id.included &&\n                !init.included &&\n                (id instanceof ObjectPattern || id instanceof ArrayPattern)) {\n                init.include(context, includeChildrenRecursively);\n            }\n        }\n    }\n    initialise() {\n        super.initialise();\n        this.isUsingDeclaration = this.kind === 'await using' || this.kind === 'using';\n        for (const declarator of this.declarations) {\n            declarator.declareDeclarator(this.kind, this.isUsingDeclaration);\n        }\n    }\n    removeAnnotations(code) {\n        this.declarations[0].removeAnnotations(code);\n    }\n    render(code, options, nodeRenderOptions = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BLANK) {\n        if (this.isUsingDeclaration ||\n            areAllDeclarationsIncludedAndNotExported(this.declarations, options.exportNamesByVariable)) {\n            for (const declarator of this.declarations) {\n                declarator.render(code, options);\n            }\n            if (!nodeRenderOptions.isNoStatement &&\n                code.original.charCodeAt(this.end - 1) !== 59 /*\";\"*/) {\n                code.appendLeft(this.end, ';');\n            }\n        }\n        else {\n            this.renderReplacedDeclarations(code, options);\n        }\n    }\n    applyDeoptimizations() { }\n    renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, systemPatternExports, options) {\n        if (code.original.charCodeAt(this.end - 1) === 59 /*\";\"*/) {\n            code.remove(this.end - 1, this.end);\n        }\n        separatorString += ';';\n        if (lastSeparatorPos === null) {\n            code.appendLeft(renderedContentEnd, separatorString);\n        }\n        else {\n            if (code.original.charCodeAt(actualContentEnd - 1) === 10 /*\"\\n\"*/ &&\n                (code.original.charCodeAt(this.end) === 10 /*\"\\n\"*/ ||\n                    code.original.charCodeAt(this.end) === 13) /*\"\\r\"*/) {\n                actualContentEnd--;\n                if (code.original.charCodeAt(actualContentEnd) === 13 /*\"\\r\"*/) {\n                    actualContentEnd--;\n                }\n            }\n            if (actualContentEnd === lastSeparatorPos + 1) {\n                code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString);\n            }\n            else {\n                code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);\n                code.remove(actualContentEnd, renderedContentEnd);\n            }\n        }\n        if (systemPatternExports.length > 0) {\n            code.appendLeft(renderedContentEnd, ` ${getSystemExportStatement(systemPatternExports, options)};`);\n        }\n    }\n    renderReplacedDeclarations(code, options) {\n        const separatedNodes = getCommaSeparatedNodesWithBoundaries(this.declarations, code, this.start + this.kind.length, this.end - (code.original.charCodeAt(this.end - 1) === 59 /*\";\"*/ ? 1 : 0));\n        let actualContentEnd, renderedContentEnd;\n        renderedContentEnd = findNonWhiteSpace(code.original, this.start + this.kind.length);\n        let lastSeparatorPos = renderedContentEnd - 1;\n        code.remove(this.start, lastSeparatorPos);\n        let isInDeclaration = false;\n        let hasRenderedContent = false;\n        let separatorString = '', leadingString, nextSeparatorString;\n        const aggregatedSystemExports = [];\n        const singleSystemExport = gatherSystemExportsAndGetSingleExport(separatedNodes, options, aggregatedSystemExports);\n        for (const { node, start, separator, contentEnd, end } of separatedNodes) {\n            if (!node.included) {\n                code.remove(start, end);\n                node.removeAnnotations(code);\n                continue;\n            }\n            node.render(code, options);\n            leadingString = '';\n            nextSeparatorString = '';\n            if (!node.id.included ||\n                (node.id instanceof Identifier &&\n                    isReassignedExportsMember(node.id.variable, options.exportNamesByVariable))) {\n                if (hasRenderedContent) {\n                    separatorString += ';';\n                }\n                isInDeclaration = false;\n            }\n            else {\n                if (singleSystemExport && singleSystemExport === node.id.variable) {\n                    const operatorPos = findFirstOccurrenceOutsideComment(code.original, '=', node.id.end);\n                    renderSystemExportExpression(singleSystemExport, findNonWhiteSpace(code.original, operatorPos + 1), separator === null ? contentEnd : separator, code, options);\n                }\n                if (isInDeclaration) {\n                    separatorString += ',';\n                }\n                else {\n                    if (hasRenderedContent) {\n                        separatorString += ';';\n                    }\n                    leadingString += `${this.kind} `;\n                    isInDeclaration = true;\n                }\n            }\n            if (renderedContentEnd === lastSeparatorPos + 1) {\n                code.overwrite(lastSeparatorPos, renderedContentEnd, separatorString + leadingString);\n            }\n            else {\n                code.overwrite(lastSeparatorPos, lastSeparatorPos + 1, separatorString);\n                code.appendLeft(renderedContentEnd, leadingString);\n            }\n            actualContentEnd = contentEnd;\n            renderedContentEnd = end;\n            hasRenderedContent = true;\n            lastSeparatorPos = separator;\n            separatorString = nextSeparatorString;\n        }\n        this.renderDeclarationEnd(code, separatorString, lastSeparatorPos, actualContentEnd, renderedContentEnd, aggregatedSystemExports, options);\n    }\n}\nfunction gatherSystemExportsAndGetSingleExport(separatedNodes, options, aggregatedSystemExports) {\n    let singleSystemExport = null;\n    if (options.format === 'system') {\n        for (const { node } of separatedNodes) {\n            if (node.id instanceof Identifier &&\n                node.init &&\n                aggregatedSystemExports.length === 0 &&\n                options.exportNamesByVariable.get(node.id.variable)?.length === 1) {\n                singleSystemExport = node.id.variable;\n                aggregatedSystemExports.push(singleSystemExport);\n            }\n            else {\n                node.id.addExportedVariables(aggregatedSystemExports, options.exportNamesByVariable);\n            }\n        }\n        if (aggregatedSystemExports.length > 1) {\n            singleSystemExport = null;\n        }\n        else if (singleSystemExport) {\n            aggregatedSystemExports.length = 0;\n        }\n    }\n    return singleSystemExport;\n}\n\nclass WhileStatement extends NodeBase {\n    hasEffects(context) {\n        if (this.test.hasEffects(context))\n            return true;\n        return hasLoopBodyEffects(context, this.body);\n    }\n    include(context, includeChildrenRecursively) {\n        this.included = true;\n        this.test.include(context, includeChildrenRecursively);\n        includeLoopBody(context, this.body, includeChildrenRecursively);\n    }\n}\n\nclass YieldExpression extends NodeBase {\n    hasEffects(context) {\n        if (!this.deoptimized)\n            this.applyDeoptimizations();\n        return !(context.ignore.returnYield && !this.argument?.hasEffects(context));\n    }\n    render(code, options) {\n        if (this.argument) {\n            this.argument.render(code, options, { preventASI: true });\n            if (this.argument.start === this.start + 5 /* 'yield'.length */) {\n                code.prependLeft(this.start + 5, ' ');\n            }\n        }\n    }\n}\n\n// This file is generated by scripts/generate-buffer-parsers.js.\n// Do not edit this file directly.\nfunction convertProgram(buffer, parent, parentScope) {\n    return convertNode(parent, parentScope, 0, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.getAstBuffer)(buffer));\n}\nconst nodeTypeStrings = [\n    'PanicError',\n    'ParseError',\n    'ArrayExpression',\n    'ArrayPattern',\n    'ArrowFunctionExpression',\n    'AssignmentExpression',\n    'AssignmentPattern',\n    'AwaitExpression',\n    'BinaryExpression',\n    'BlockStatement',\n    'BreakStatement',\n    'CallExpression',\n    'CatchClause',\n    'ChainExpression',\n    'ClassBody',\n    'ClassDeclaration',\n    'ClassExpression',\n    'ConditionalExpression',\n    'ContinueStatement',\n    'DebuggerStatement',\n    'Decorator',\n    'ExpressionStatement',\n    'DoWhileStatement',\n    'EmptyStatement',\n    'ExportAllDeclaration',\n    'ExportDefaultDeclaration',\n    'ExportNamedDeclaration',\n    'ExportSpecifier',\n    'ExpressionStatement',\n    'ForInStatement',\n    'ForOfStatement',\n    'ForStatement',\n    'FunctionDeclaration',\n    'FunctionExpression',\n    'Identifier',\n    'IfStatement',\n    'ImportAttribute',\n    'ImportDeclaration',\n    'ImportDefaultSpecifier',\n    'ImportExpression',\n    'ImportNamespaceSpecifier',\n    'ImportSpecifier',\n    'JSXAttribute',\n    'JSXClosingElement',\n    'JSXClosingFragment',\n    'JSXElement',\n    'JSXEmptyExpression',\n    'JSXExpressionContainer',\n    'JSXFragment',\n    'JSXIdentifier',\n    'JSXMemberExpression',\n    'JSXNamespacedName',\n    'JSXOpeningElement',\n    'JSXOpeningFragment',\n    'JSXSpreadAttribute',\n    'JSXSpreadChild',\n    'JSXText',\n    'LabeledStatement',\n    'Literal',\n    'Literal',\n    'Literal',\n    'Literal',\n    'Literal',\n    'Literal',\n    'LogicalExpression',\n    'MemberExpression',\n    'MetaProperty',\n    'MethodDefinition',\n    'NewExpression',\n    'ObjectExpression',\n    'ObjectPattern',\n    'PrivateIdentifier',\n    'Program',\n    'Property',\n    'PropertyDefinition',\n    'RestElement',\n    'ReturnStatement',\n    'SequenceExpression',\n    'SpreadElement',\n    'StaticBlock',\n    'Super',\n    'SwitchCase',\n    'SwitchStatement',\n    'TaggedTemplateExpression',\n    'TemplateElement',\n    'TemplateLiteral',\n    'ThisExpression',\n    'ThrowStatement',\n    'TryStatement',\n    'UnaryExpression',\n    'UpdateExpression',\n    'VariableDeclaration',\n    'VariableDeclarator',\n    'WhileStatement',\n    'YieldExpression'\n];\nconst nodeConstructors$1 = [\n    PanicError,\n    ParseError,\n    ArrayExpression,\n    ArrayPattern,\n    ArrowFunctionExpression,\n    AssignmentExpression,\n    AssignmentPattern,\n    AwaitExpression,\n    BinaryExpression,\n    BlockStatement,\n    BreakStatement,\n    CallExpression,\n    CatchClause,\n    ChainExpression,\n    ClassBody,\n    ClassDeclaration,\n    ClassExpression,\n    ConditionalExpression,\n    ContinueStatement,\n    DebuggerStatement,\n    Decorator,\n    ExpressionStatement,\n    DoWhileStatement,\n    EmptyStatement,\n    ExportAllDeclaration,\n    ExportDefaultDeclaration,\n    ExportNamedDeclaration,\n    ExportSpecifier,\n    ExpressionStatement,\n    ForInStatement,\n    ForOfStatement,\n    ForStatement,\n    FunctionDeclaration,\n    FunctionExpression,\n    Identifier,\n    IfStatement,\n    ImportAttribute,\n    ImportDeclaration,\n    ImportDefaultSpecifier,\n    ImportExpression,\n    ImportNamespaceSpecifier,\n    ImportSpecifier,\n    JSXAttribute,\n    JSXClosingElement,\n    JSXClosingFragment,\n    JSXElement,\n    JSXEmptyExpression,\n    JSXExpressionContainer,\n    JSXFragment,\n    JSXIdentifier,\n    JSXMemberExpression,\n    JSXNamespacedName,\n    JSXOpeningElement,\n    JSXOpeningFragment,\n    JSXSpreadAttribute,\n    JSXSpreadChild,\n    JSXText,\n    LabeledStatement,\n    Literal,\n    Literal,\n    Literal,\n    Literal,\n    Literal,\n    Literal,\n    LogicalExpression,\n    MemberExpression,\n    MetaProperty,\n    MethodDefinition,\n    NewExpression,\n    ObjectExpression,\n    ObjectPattern,\n    PrivateIdentifier,\n    Program,\n    Property,\n    PropertyDefinition,\n    RestElement,\n    ReturnStatement,\n    SequenceExpression,\n    SpreadElement,\n    StaticBlock,\n    Super,\n    SwitchCase,\n    SwitchStatement,\n    TaggedTemplateExpression,\n    TemplateElement,\n    TemplateLiteral,\n    ThisExpression,\n    ThrowStatement,\n    TryStatement,\n    UnaryExpression,\n    UpdateExpression,\n    VariableDeclaration,\n    VariableDeclarator,\n    WhileStatement,\n    YieldExpression\n];\nconst bufferParsers = [\n    function panicError(node, position, buffer) {\n        node.message = buffer.convertString(buffer[position]);\n    },\n    function parseError(node, position, buffer) {\n        node.message = buffer.convertString(buffer[position]);\n    },\n    function arrayExpression(node, position, buffer) {\n        const { scope } = node;\n        node.elements = convertNodeList(node, scope, buffer[position], buffer);\n    },\n    function arrayPattern(node, position, buffer) {\n        const { scope } = node;\n        node.elements = convertNodeList(node, scope, buffer[position], buffer);\n    },\n    function arrowFunctionExpression(node, position, buffer) {\n        const { scope } = node;\n        const flags = buffer[position];\n        node.async = (flags & 1) === 1;\n        node.expression = (flags & 2) === 2;\n        node.generator = (flags & 4) === 4;\n        const annotations = (node.annotations = (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.convertAnnotations)(buffer[position + 1], buffer));\n        node.annotationNoSideEffects = annotations.some(comment => comment.type === 'noSideEffects');\n        const parameters = (node.params = convertNodeList(node, scope, buffer[position + 2], buffer));\n        scope.addParameterVariables(parameters.map(parameter => parameter.declare('parameter', UNKNOWN_EXPRESSION)), parameters[parameters.length - 1] instanceof RestElement);\n        node.body = convertNode(node, scope.bodyScope, buffer[position + 3], buffer);\n    },\n    function assignmentExpression(node, position, buffer) {\n        const { scope } = node;\n        node.operator = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.FIXED_STRINGS[buffer[position]];\n        node.left = convertNode(node, scope, buffer[position + 1], buffer);\n        node.right = convertNode(node, scope, buffer[position + 2], buffer);\n    },\n    function assignmentPattern(node, position, buffer) {\n        const { scope } = node;\n        node.left = convertNode(node, scope, buffer[position], buffer);\n        node.right = convertNode(node, scope, buffer[position + 1], buffer);\n    },\n    function awaitExpression(node, position, buffer) {\n        const { scope } = node;\n        node.argument = convertNode(node, scope, buffer[position], buffer);\n    },\n    function binaryExpression(node, position, buffer) {\n        const { scope } = node;\n        node.operator = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.FIXED_STRINGS[buffer[position]];\n        node.left = convertNode(node, scope, buffer[position + 1], buffer);\n        node.right = convertNode(node, scope, buffer[position + 2], buffer);\n    },\n    function blockStatement(node, position, buffer) {\n        const { scope } = node;\n        node.body = convertNodeList(node, scope, buffer[position], buffer);\n    },\n    function breakStatement(node, position, buffer) {\n        const { scope } = node;\n        const labelPosition = buffer[position];\n        node.label = labelPosition === 0 ? null : convertNode(node, scope, labelPosition, buffer);\n    },\n    function callExpression(node, position, buffer) {\n        const { scope } = node;\n        const flags = buffer[position];\n        node.optional = (flags & 1) === 1;\n        node.annotations = (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.convertAnnotations)(buffer[position + 1], buffer);\n        node.callee = convertNode(node, scope, buffer[position + 2], buffer);\n        node.arguments = convertNodeList(node, scope, buffer[position + 3], buffer);\n    },\n    function catchClause(node, position, buffer) {\n        const { scope } = node;\n        const parameterPosition = buffer[position];\n        const parameter = (node.param =\n            parameterPosition === 0 ? null : convertNode(node, scope, parameterPosition, buffer));\n        parameter?.declare('parameter', UNKNOWN_EXPRESSION);\n        node.body = convertNode(node, scope.bodyScope, buffer[position + 1], buffer);\n    },\n    function chainExpression(node, position, buffer) {\n        const { scope } = node;\n        node.expression = convertNode(node, scope, buffer[position], buffer);\n    },\n    function classBody(node, position, buffer) {\n        const { scope } = node;\n        const bodyPosition = buffer[position];\n        if (bodyPosition) {\n            const length = buffer[bodyPosition];\n            const body = (node.body = new Array(length));\n            for (let index = 0; index < length; index++) {\n                const nodePosition = buffer[bodyPosition + 1 + index];\n                body[index] = convertNode(node, (buffer[nodePosition + 3] & 1) === 0 ? scope.instanceScope : scope, nodePosition, buffer);\n            }\n        }\n        else {\n            node.body = [];\n        }\n    },\n    function classDeclaration(node, position, buffer) {\n        const { scope } = node;\n        node.decorators = convertNodeList(node, scope, buffer[position], buffer);\n        const idPosition = buffer[position + 1];\n        node.id =\n            idPosition === 0 ? null : convertNode(node, scope.parent, idPosition, buffer);\n        const superClassPosition = buffer[position + 2];\n        node.superClass =\n            superClassPosition === 0 ? null : convertNode(node, scope, superClassPosition, buffer);\n        node.body = convertNode(node, scope, buffer[position + 3], buffer);\n    },\n    function classExpression(node, position, buffer) {\n        const { scope } = node;\n        node.decorators = convertNodeList(node, scope, buffer[position], buffer);\n        const idPosition = buffer[position + 1];\n        node.id = idPosition === 0 ? null : convertNode(node, scope, idPosition, buffer);\n        const superClassPosition = buffer[position + 2];\n        node.superClass =\n            superClassPosition === 0 ? null : convertNode(node, scope, superClassPosition, buffer);\n        node.body = convertNode(node, scope, buffer[position + 3], buffer);\n    },\n    function conditionalExpression(node, position, buffer) {\n        const { scope } = node;\n        node.test = convertNode(node, scope, buffer[position], buffer);\n        node.consequent = convertNode(node, scope, buffer[position + 1], buffer);\n        node.alternate = convertNode(node, scope, buffer[position + 2], buffer);\n    },\n    function continueStatement(node, position, buffer) {\n        const { scope } = node;\n        const labelPosition = buffer[position];\n        node.label = labelPosition === 0 ? null : convertNode(node, scope, labelPosition, buffer);\n    },\n    function debuggerStatement() { },\n    function decorator(node, position, buffer) {\n        const { scope } = node;\n        node.expression = convertNode(node, scope, buffer[position], buffer);\n    },\n    function directive(node, position, buffer) {\n        const { scope } = node;\n        node.directive = buffer.convertString(buffer[position]);\n        node.expression = convertNode(node, scope, buffer[position + 1], buffer);\n    },\n    function doWhileStatement(node, position, buffer) {\n        const { scope } = node;\n        node.body = convertNode(node, scope, buffer[position], buffer);\n        node.test = convertNode(node, scope, buffer[position + 1], buffer);\n    },\n    function emptyStatement() { },\n    function exportAllDeclaration(node, position, buffer) {\n        const { scope } = node;\n        const exportedPosition = buffer[position];\n        node.exported =\n            exportedPosition === 0 ? null : convertNode(node, scope, exportedPosition, buffer);\n        node.source = convertNode(node, scope, buffer[position + 1], buffer);\n        node.attributes = convertNodeList(node, scope, buffer[position + 2], buffer);\n    },\n    function exportDefaultDeclaration(node, position, buffer) {\n        const { scope } = node;\n        node.declaration = convertNode(node, scope, buffer[position], buffer);\n    },\n    function exportNamedDeclaration(node, position, buffer) {\n        const { scope } = node;\n        node.specifiers = convertNodeList(node, scope, buffer[position], buffer);\n        const sourcePosition = buffer[position + 1];\n        node.source = sourcePosition === 0 ? null : convertNode(node, scope, sourcePosition, buffer);\n        node.attributes = convertNodeList(node, scope, buffer[position + 2], buffer);\n        const declarationPosition = buffer[position + 3];\n        node.declaration =\n            declarationPosition === 0 ? null : convertNode(node, scope, declarationPosition, buffer);\n    },\n    function exportSpecifier(node, position, buffer) {\n        const { scope } = node;\n        node.local = convertNode(node, scope, buffer[position], buffer);\n        const exportedPosition = buffer[position + 1];\n        node.exported =\n            exportedPosition === 0 ? node.local : convertNode(node, scope, exportedPosition, buffer);\n    },\n    function expressionStatement(node, position, buffer) {\n        const { scope } = node;\n        node.expression = convertNode(node, scope, buffer[position], buffer);\n    },\n    function forInStatement(node, position, buffer) {\n        const { scope } = node;\n        node.left = convertNode(node, scope, buffer[position], buffer);\n        node.right = convertNode(node, scope, buffer[position + 1], buffer);\n        node.body = convertNode(node, scope, buffer[position + 2], buffer);\n    },\n    function forOfStatement(node, position, buffer) {\n        const { scope } = node;\n        const flags = buffer[position];\n        node.await = (flags & 1) === 1;\n        node.left = convertNode(node, scope, buffer[position + 1], buffer);\n        node.right = convertNode(node, scope, buffer[position + 2], buffer);\n        node.body = convertNode(node, scope, buffer[position + 3], buffer);\n    },\n    function forStatement(node, position, buffer) {\n        const { scope } = node;\n        const initPosition = buffer[position];\n        node.init = initPosition === 0 ? null : convertNode(node, scope, initPosition, buffer);\n        const testPosition = buffer[position + 1];\n        node.test = testPosition === 0 ? null : convertNode(node, scope, testPosition, buffer);\n        const updatePosition = buffer[position + 2];\n        node.update = updatePosition === 0 ? null : convertNode(node, scope, updatePosition, buffer);\n        node.body = convertNode(node, scope, buffer[position + 3], buffer);\n    },\n    function functionDeclaration(node, position, buffer) {\n        const { scope } = node;\n        const flags = buffer[position];\n        node.async = (flags & 1) === 1;\n        node.generator = (flags & 2) === 2;\n        const annotations = (node.annotations = (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.convertAnnotations)(buffer[position + 1], buffer));\n        node.annotationNoSideEffects = annotations.some(comment => comment.type === 'noSideEffects');\n        const idPosition = buffer[position + 2];\n        node.id =\n            idPosition === 0 ? null : convertNode(node, scope.parent, idPosition, buffer);\n        const parameters = (node.params = convertNodeList(node, scope, buffer[position + 3], buffer));\n        scope.addParameterVariables(parameters.map(parameter => parameter.declare('parameter', UNKNOWN_EXPRESSION)), parameters[parameters.length - 1] instanceof RestElement);\n        node.body = convertNode(node, scope.bodyScope, buffer[position + 4], buffer);\n    },\n    function functionExpression(node, position, buffer) {\n        const { scope } = node;\n        const flags = buffer[position];\n        node.async = (flags & 1) === 1;\n        node.generator = (flags & 2) === 2;\n        const annotations = (node.annotations = (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.convertAnnotations)(buffer[position + 1], buffer));\n        node.annotationNoSideEffects = annotations.some(comment => comment.type === 'noSideEffects');\n        const idPosition = buffer[position + 2];\n        node.id = idPosition === 0 ? null : convertNode(node, node.idScope, idPosition, buffer);\n        const parameters = (node.params = convertNodeList(node, scope, buffer[position + 3], buffer));\n        scope.addParameterVariables(parameters.map(parameter => parameter.declare('parameter', UNKNOWN_EXPRESSION)), parameters[parameters.length - 1] instanceof RestElement);\n        node.body = convertNode(node, scope.bodyScope, buffer[position + 4], buffer);\n    },\n    function identifier(node, position, buffer) {\n        node.name = buffer.convertString(buffer[position]);\n    },\n    function ifStatement(node, position, buffer) {\n        const { scope } = node;\n        node.test = convertNode(node, scope, buffer[position], buffer);\n        node.consequent = convertNode(node, (node.consequentScope = new TrackingScope(scope)), buffer[position + 1], buffer);\n        const alternatePosition = buffer[position + 2];\n        node.alternate =\n            alternatePosition === 0\n                ? null\n                : convertNode(node, (node.alternateScope = new TrackingScope(scope)), alternatePosition, buffer);\n    },\n    function importAttribute(node, position, buffer) {\n        const { scope } = node;\n        node.key = convertNode(node, scope, buffer[position], buffer);\n        node.value = convertNode(node, scope, buffer[position + 1], buffer);\n    },\n    function importDeclaration(node, position, buffer) {\n        const { scope } = node;\n        node.specifiers = convertNodeList(node, scope, buffer[position], buffer);\n        node.source = convertNode(node, scope, buffer[position + 1], buffer);\n        node.attributes = convertNodeList(node, scope, buffer[position + 2], buffer);\n    },\n    function importDefaultSpecifier(node, position, buffer) {\n        const { scope } = node;\n        node.local = convertNode(node, scope, buffer[position], buffer);\n    },\n    function importExpression(node, position, buffer) {\n        const { scope } = node;\n        node.source = convertNode(node, scope, buffer[position], buffer);\n        node.sourceAstNode = (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.convertNode)(buffer[position], buffer);\n        const optionsPosition = buffer[position + 1];\n        node.options = optionsPosition === 0 ? null : convertNode(node, scope, optionsPosition, buffer);\n    },\n    function importNamespaceSpecifier(node, position, buffer) {\n        const { scope } = node;\n        node.local = convertNode(node, scope, buffer[position], buffer);\n    },\n    function importSpecifier(node, position, buffer) {\n        const { scope } = node;\n        const importedPosition = buffer[position];\n        node.local = convertNode(node, scope, buffer[position + 1], buffer);\n        node.imported =\n            importedPosition === 0 ? node.local : convertNode(node, scope, importedPosition, buffer);\n    },\n    function jsxAttribute(node, position, buffer) {\n        const { scope } = node;\n        node.name = convertNode(node, scope, buffer[position], buffer);\n        const valuePosition = buffer[position + 1];\n        node.value = valuePosition === 0 ? null : convertNode(node, scope, valuePosition, buffer);\n    },\n    function jsxClosingElement(node, position, buffer) {\n        const { scope } = node;\n        node.name = convertNode(node, scope, buffer[position], buffer);\n    },\n    function jsxClosingFragment() { },\n    function jsxElement(node, position, buffer) {\n        const { scope } = node;\n        node.openingElement = convertNode(node, scope, buffer[position], buffer);\n        node.children = convertNodeList(node, scope, buffer[position + 1], buffer);\n        const closingElementPosition = buffer[position + 2];\n        node.closingElement =\n            closingElementPosition === 0\n                ? null\n                : convertNode(node, scope, closingElementPosition, buffer);\n    },\n    function jsxEmptyExpression() { },\n    function jsxExpressionContainer(node, position, buffer) {\n        const { scope } = node;\n        node.expression = convertNode(node, scope, buffer[position], buffer);\n    },\n    function jsxFragment(node, position, buffer) {\n        const { scope } = node;\n        node.openingFragment = convertNode(node, scope, buffer[position], buffer);\n        node.children = convertNodeList(node, scope, buffer[position + 1], buffer);\n        node.closingFragment = convertNode(node, scope, buffer[position + 2], buffer);\n    },\n    function jsxIdentifier(node, position, buffer) {\n        node.name = buffer.convertString(buffer[position]);\n    },\n    function jsxMemberExpression(node, position, buffer) {\n        const { scope } = node;\n        node.object = convertNode(node, scope, buffer[position], buffer);\n        node.property = convertNode(node, scope, buffer[position + 1], buffer);\n    },\n    function jsxNamespacedName(node, position, buffer) {\n        const { scope } = node;\n        node.namespace = convertNode(node, scope, buffer[position], buffer);\n        node.name = convertNode(node, scope, buffer[position + 1], buffer);\n    },\n    function jsxOpeningElement(node, position, buffer) {\n        const { scope } = node;\n        const flags = buffer[position];\n        node.selfClosing = (flags & 1) === 1;\n        node.name = convertNode(node, scope, buffer[position + 1], buffer);\n        node.attributes = convertNodeList(node, scope, buffer[position + 2], buffer);\n    },\n    function jsxOpeningFragment(node) {\n        node.attributes = [];\n        node.selfClosing = false;\n    },\n    function jsxSpreadAttribute(node, position, buffer) {\n        const { scope } = node;\n        node.argument = convertNode(node, scope, buffer[position], buffer);\n    },\n    function jsxSpreadChild(node, position, buffer) {\n        const { scope } = node;\n        node.expression = convertNode(node, scope, buffer[position], buffer);\n    },\n    function jsxText(node, position, buffer) {\n        node.value = buffer.convertString(buffer[position]);\n        node.raw = buffer.convertString(buffer[position + 1]);\n    },\n    function labeledStatement(node, position, buffer) {\n        const { scope } = node;\n        node.label = convertNode(node, scope, buffer[position], buffer);\n        node.body = convertNode(node, scope, buffer[position + 1], buffer);\n    },\n    function literalBigInt(node, position, buffer) {\n        const bigint = (node.bigint = buffer.convertString(buffer[position]));\n        node.raw = buffer.convertString(buffer[position + 1]);\n        node.value = BigInt(bigint);\n    },\n    function literalBoolean(node, position, buffer) {\n        const flags = buffer[position];\n        const value = (node.value = (flags & 1) === 1);\n        node.raw = value ? 'true' : 'false';\n    },\n    function literalNull(node) {\n        node.value = null;\n    },\n    function literalNumber(node, position, buffer) {\n        const rawPosition = buffer[position];\n        node.raw = rawPosition === 0 ? undefined : buffer.convertString(rawPosition);\n        node.value = new DataView(buffer.buffer).getFloat64((position + 1) << 2, true);\n    },\n    function literalRegExp(node, position, buffer) {\n        const flags = buffer.convertString(buffer[position]);\n        const pattern = buffer.convertString(buffer[position + 1]);\n        node.raw = `/${pattern}/${flags}`;\n        node.regex = { flags, pattern };\n        node.value = new RegExp(pattern, flags);\n    },\n    function literalString(node, position, buffer) {\n        node.value = buffer.convertString(buffer[position]);\n        const rawPosition = buffer[position + 1];\n        node.raw = rawPosition === 0 ? undefined : buffer.convertString(rawPosition);\n    },\n    function logicalExpression(node, position, buffer) {\n        const { scope } = node;\n        node.operator = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.FIXED_STRINGS[buffer[position]];\n        node.left = convertNode(node, scope, buffer[position + 1], buffer);\n        node.right = convertNode(node, scope, buffer[position + 2], buffer);\n    },\n    function memberExpression(node, position, buffer) {\n        const { scope } = node;\n        const flags = buffer[position];\n        node.computed = (flags & 1) === 1;\n        node.optional = (flags & 2) === 2;\n        node.object = convertNode(node, scope, buffer[position + 1], buffer);\n        node.property = convertNode(node, scope, buffer[position + 2], buffer);\n    },\n    function metaProperty(node, position, buffer) {\n        const { scope } = node;\n        node.meta = convertNode(node, scope, buffer[position], buffer);\n        node.property = convertNode(node, scope, buffer[position + 1], buffer);\n    },\n    function methodDefinition(node, position, buffer) {\n        const { scope } = node;\n        const flags = buffer[position];\n        node.static = (flags & 1) === 1;\n        node.computed = (flags & 2) === 2;\n        node.decorators = convertNodeList(node, scope, buffer[position + 1], buffer);\n        node.key = convertNode(node, scope, buffer[position + 2], buffer);\n        node.value = convertNode(node, scope, buffer[position + 3], buffer);\n        node.kind = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.FIXED_STRINGS[buffer[position + 4]];\n    },\n    function newExpression(node, position, buffer) {\n        const { scope } = node;\n        node.annotations = (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.convertAnnotations)(buffer[position], buffer);\n        node.callee = convertNode(node, scope, buffer[position + 1], buffer);\n        node.arguments = convertNodeList(node, scope, buffer[position + 2], buffer);\n    },\n    function objectExpression(node, position, buffer) {\n        const { scope } = node;\n        node.properties = convertNodeList(node, scope, buffer[position], buffer);\n    },\n    function objectPattern(node, position, buffer) {\n        const { scope } = node;\n        node.properties = convertNodeList(node, scope, buffer[position], buffer);\n    },\n    function privateIdentifier(node, position, buffer) {\n        node.name = buffer.convertString(buffer[position]);\n    },\n    function program(node, position, buffer) {\n        const { scope } = node;\n        node.body = convertNodeList(node, scope, buffer[position], buffer);\n        node.invalidAnnotations = (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.convertAnnotations)(buffer[position + 1], buffer);\n    },\n    function property(node, position, buffer) {\n        const { scope } = node;\n        const flags = buffer[position];\n        node.method = (flags & 1) === 1;\n        node.shorthand = (flags & 2) === 2;\n        node.computed = (flags & 4) === 4;\n        const keyPosition = buffer[position + 1];\n        node.value = convertNode(node, scope, buffer[position + 2], buffer);\n        node.kind = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.FIXED_STRINGS[buffer[position + 3]];\n        node.key = keyPosition === 0 ? node.value : convertNode(node, scope, keyPosition, buffer);\n    },\n    function propertyDefinition(node, position, buffer) {\n        const { scope } = node;\n        const flags = buffer[position];\n        node.static = (flags & 1) === 1;\n        node.computed = (flags & 2) === 2;\n        node.decorators = convertNodeList(node, scope, buffer[position + 1], buffer);\n        node.key = convertNode(node, scope, buffer[position + 2], buffer);\n        const valuePosition = buffer[position + 3];\n        node.value = valuePosition === 0 ? null : convertNode(node, scope, valuePosition, buffer);\n    },\n    function restElement(node, position, buffer) {\n        const { scope } = node;\n        node.argument = convertNode(node, scope, buffer[position], buffer);\n    },\n    function returnStatement(node, position, buffer) {\n        const { scope } = node;\n        const argumentPosition = buffer[position];\n        node.argument =\n            argumentPosition === 0 ? null : convertNode(node, scope, argumentPosition, buffer);\n    },\n    function sequenceExpression(node, position, buffer) {\n        const { scope } = node;\n        node.expressions = convertNodeList(node, scope, buffer[position], buffer);\n    },\n    function spreadElement(node, position, buffer) {\n        const { scope } = node;\n        node.argument = convertNode(node, scope, buffer[position], buffer);\n    },\n    function staticBlock(node, position, buffer) {\n        const { scope } = node;\n        node.body = convertNodeList(node, scope, buffer[position], buffer);\n    },\n    function superElement() { },\n    function switchCase(node, position, buffer) {\n        const { scope } = node;\n        const testPosition = buffer[position];\n        node.test = testPosition === 0 ? null : convertNode(node, scope, testPosition, buffer);\n        node.consequent = convertNodeList(node, scope, buffer[position + 1], buffer);\n    },\n    function switchStatement(node, position, buffer) {\n        const { scope } = node;\n        node.discriminant = convertNode(node, node.parentScope, buffer[position], buffer);\n        node.cases = convertNodeList(node, scope, buffer[position + 1], buffer);\n    },\n    function taggedTemplateExpression(node, position, buffer) {\n        const { scope } = node;\n        node.tag = convertNode(node, scope, buffer[position], buffer);\n        node.quasi = convertNode(node, scope, buffer[position + 1], buffer);\n    },\n    function templateElement(node, position, buffer) {\n        const flags = buffer[position];\n        node.tail = (flags & 1) === 1;\n        const cookedPosition = buffer[position + 1];\n        const cooked = cookedPosition === 0 ? undefined : buffer.convertString(cookedPosition);\n        const raw = buffer.convertString(buffer[position + 2]);\n        node.value = { cooked, raw };\n    },\n    function templateLiteral(node, position, buffer) {\n        const { scope } = node;\n        node.quasis = convertNodeList(node, scope, buffer[position], buffer);\n        node.expressions = convertNodeList(node, scope, buffer[position + 1], buffer);\n    },\n    function thisExpression() { },\n    function throwStatement(node, position, buffer) {\n        const { scope } = node;\n        node.argument = convertNode(node, scope, buffer[position], buffer);\n    },\n    function tryStatement(node, position, buffer) {\n        const { scope } = node;\n        node.block = convertNode(node, scope, buffer[position], buffer);\n        const handlerPosition = buffer[position + 1];\n        node.handler = handlerPosition === 0 ? null : convertNode(node, scope, handlerPosition, buffer);\n        const finalizerPosition = buffer[position + 2];\n        node.finalizer =\n            finalizerPosition === 0 ? null : convertNode(node, scope, finalizerPosition, buffer);\n    },\n    function unaryExpression(node, position, buffer) {\n        const { scope } = node;\n        node.operator = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.FIXED_STRINGS[buffer[position]];\n        node.argument = convertNode(node, scope, buffer[position + 1], buffer);\n    },\n    function updateExpression(node, position, buffer) {\n        const { scope } = node;\n        const flags = buffer[position];\n        node.prefix = (flags & 1) === 1;\n        node.operator = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.FIXED_STRINGS[buffer[position + 1]];\n        node.argument = convertNode(node, scope, buffer[position + 2], buffer);\n    },\n    function variableDeclaration(node, position, buffer) {\n        const { scope } = node;\n        node.kind = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.FIXED_STRINGS[buffer[position]];\n        node.declarations = convertNodeList(node, scope, buffer[position + 1], buffer);\n    },\n    function variableDeclarator(node, position, buffer) {\n        const { scope } = node;\n        node.id = convertNode(node, scope, buffer[position], buffer);\n        const initPosition = buffer[position + 1];\n        node.init = initPosition === 0 ? null : convertNode(node, scope, initPosition, buffer);\n    },\n    function whileStatement(node, position, buffer) {\n        const { scope } = node;\n        node.test = convertNode(node, scope, buffer[position], buffer);\n        node.body = convertNode(node, scope, buffer[position + 1], buffer);\n    },\n    function yieldExpression(node, position, buffer) {\n        const { scope } = node;\n        const flags = buffer[position];\n        node.delegate = (flags & 1) === 1;\n        const argumentPosition = buffer[position + 1];\n        node.argument =\n            argumentPosition === 0 ? null : convertNode(node, scope, argumentPosition, buffer);\n    }\n];\nfunction convertNode(parent, parentScope, position, buffer) {\n    const nodeType = buffer[position];\n    const NodeConstructor = nodeConstructors$1[nodeType];\n    /* istanbul ignore if: This should never be executed but is a safeguard against faulty buffers */\n    if (!NodeConstructor) {\n        console.trace();\n        throw new Error(`Unknown node type: ${nodeType}`);\n    }\n    const node = new NodeConstructor(parent, parentScope);\n    node.type = nodeTypeStrings[nodeType];\n    node.start = buffer[position + 1];\n    node.end = buffer[position + 2];\n    bufferParsers[nodeType](node, position + 3, buffer);\n    node.initialise();\n    return node;\n}\nfunction convertNodeList(parent, parentScope, position, buffer) {\n    if (position === 0)\n        return _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY;\n    const length = buffer[position++];\n    const list = new Array(length);\n    for (let index = 0; index < length; index++) {\n        const nodePosition = buffer[position++];\n        list[index] = nodePosition ? convertNode(parent, parentScope, nodePosition, buffer) : null;\n    }\n    return list;\n}\n\nclass UnknownNode extends NodeBase {\n    hasEffects() {\n        return true;\n    }\n    include(context) {\n        super.include(context, true);\n    }\n}\n\n// This file is generated by scripts/generate-node-index.js.\n// Do not edit this file directly.\nconst nodeConstructors = {\n    ArrayExpression,\n    ArrayPattern,\n    ArrowFunctionExpression,\n    AssignmentExpression,\n    AssignmentPattern,\n    AwaitExpression,\n    BinaryExpression,\n    BlockStatement,\n    BreakStatement,\n    CallExpression,\n    CatchClause,\n    ChainExpression,\n    ClassBody,\n    ClassDeclaration,\n    ClassExpression,\n    ConditionalExpression,\n    ContinueStatement,\n    DebuggerStatement,\n    Decorator,\n    DoWhileStatement,\n    EmptyStatement,\n    ExportAllDeclaration,\n    ExportDefaultDeclaration,\n    ExportNamedDeclaration,\n    ExportSpecifier,\n    ExpressionStatement,\n    ForInStatement,\n    ForOfStatement,\n    ForStatement,\n    FunctionDeclaration,\n    FunctionExpression,\n    Identifier,\n    IfStatement,\n    ImportAttribute,\n    ImportDeclaration,\n    ImportDefaultSpecifier,\n    ImportExpression,\n    ImportNamespaceSpecifier,\n    ImportSpecifier,\n    JSXAttribute,\n    JSXClosingElement,\n    JSXClosingFragment,\n    JSXElement,\n    JSXEmptyExpression,\n    JSXExpressionContainer,\n    JSXFragment,\n    JSXIdentifier,\n    JSXMemberExpression,\n    JSXNamespacedName,\n    JSXOpeningElement,\n    JSXOpeningFragment,\n    JSXSpreadAttribute,\n    JSXSpreadChild,\n    JSXText,\n    LabeledStatement,\n    Literal,\n    LogicalExpression,\n    MemberExpression,\n    MetaProperty,\n    MethodDefinition,\n    NewExpression,\n    ObjectExpression,\n    ObjectPattern,\n    PanicError,\n    ParseError,\n    PrivateIdentifier,\n    Program,\n    Property,\n    PropertyDefinition,\n    RestElement,\n    ReturnStatement,\n    SequenceExpression,\n    SpreadElement,\n    StaticBlock,\n    Super,\n    SwitchCase,\n    SwitchStatement,\n    TaggedTemplateExpression,\n    TemplateElement,\n    TemplateLiteral,\n    ThisExpression,\n    ThrowStatement,\n    TryStatement,\n    UnaryExpression,\n    UnknownNode,\n    UpdateExpression,\n    VariableDeclaration,\n    VariableDeclarator,\n    WhileStatement,\n    YieldExpression\n};\n\nclass ExportShimVariable extends Variable {\n    constructor(module) {\n        super(MISSING_EXPORT_SHIM_VARIABLE);\n        this.module = module;\n    }\n    include() {\n        super.include();\n        this.module.needsExportShim = true;\n    }\n}\n\nvar BuildPhase;\n(function (BuildPhase) {\n    BuildPhase[BuildPhase[\"LOAD_AND_PARSE\"] = 0] = \"LOAD_AND_PARSE\";\n    BuildPhase[BuildPhase[\"ANALYSE\"] = 1] = \"ANALYSE\";\n    BuildPhase[BuildPhase[\"GENERATE\"] = 2] = \"GENERATE\";\n})(BuildPhase || (BuildPhase = {}));\n\nconst sourceMapCache = new WeakMap();\n/**\n * This clears the decoded array and falls back to the encoded string form.\n * Sourcemap mappings arrays can be very large and holding on to them for longer\n * than is necessary leads to poor heap utilization.\n */\nfunction resetCacheToEncoded(cache) {\n    if (cache.encodedMappings === undefined && cache.decodedMappings) {\n        cache.encodedMappings = encode(cache.decodedMappings);\n    }\n    cache.decodedMappings = undefined;\n}\nfunction resetSourcemapCache(map, sourcemapChain) {\n    if (map) {\n        const cache = sourceMapCache.get(map);\n        if (cache) {\n            resetCacheToEncoded(cache);\n        }\n    }\n    if (!sourcemapChain) {\n        return;\n    }\n    for (const map of sourcemapChain) {\n        if (map.missing)\n            continue;\n        resetSourcemapCache(map);\n    }\n}\nfunction decodedSourcemap(map) {\n    if (!map)\n        return null;\n    if (typeof map === 'string') {\n        map = JSON.parse(map);\n    }\n    if (!map.mappings) {\n        return {\n            mappings: [],\n            names: [],\n            sources: [],\n            version: 3\n        };\n    }\n    const originalMappings = map.mappings;\n    const isAlreadyDecoded = Array.isArray(originalMappings);\n    const cache = {\n        decodedMappings: isAlreadyDecoded ? originalMappings : undefined,\n        encodedMappings: isAlreadyDecoded ? undefined : originalMappings\n    };\n    const decodedMap = {\n        ...map,\n        // By moving mappings behind an accessor, we can avoid unneeded computation for cases\n        // where the mappings field is never actually accessed. This appears to greatly reduce\n        // the overhead of sourcemap decoding in terms of both compute time and memory usage.\n        get mappings() {\n            if (cache.decodedMappings) {\n                return cache.decodedMappings;\n            }\n            // If decodedMappings doesn't exist then encodedMappings should.\n            // The only scenario where cache.encodedMappings should be undefined is if the map\n            // this was constructed from was already decoded, or if mappings was set to a new\n            // decoded string. In either case, this line shouldn't get hit.\n            cache.decodedMappings = cache.encodedMappings ? decode(cache.encodedMappings) : [];\n            cache.encodedMappings = undefined;\n            return cache.decodedMappings;\n        }\n    };\n    sourceMapCache.set(decodedMap, cache);\n    return decodedMap;\n}\n\nfunction getId(m) {\n    return m.id;\n}\n\nfunction getOriginalLocation(sourcemapChain, location) {\n    const filteredSourcemapChain = sourcemapChain.filter((sourcemap) => !sourcemap.missing);\n    traceSourcemap: while (filteredSourcemapChain.length > 0) {\n        const sourcemap = filteredSourcemapChain.pop();\n        const line = sourcemap.mappings[location.line - 1];\n        if (line) {\n            const filteredLine = line.filter((segment) => segment.length > 1);\n            const lastSegment = filteredLine[filteredLine.length - 1];\n            for (const segment of filteredLine) {\n                if (segment[0] >= location.column || segment === lastSegment) {\n                    location = {\n                        column: segment[3],\n                        line: segment[2] + 1\n                    };\n                    continue traceSourcemap;\n                }\n            }\n        }\n        throw new Error(\"Can't resolve original location of error.\");\n    }\n    return location;\n}\n\nconst ATTRIBUTE_KEYWORDS = new Set(['assert', 'with']);\nfunction getAttributesFromImportExpression(node) {\n    const { scope: { context }, options, start } = node;\n    if (!(options instanceof ObjectExpression)) {\n        if (options) {\n            context.module.log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logImportAttributeIsInvalid)(context.module.id), start);\n        }\n        return _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJECT;\n    }\n    const assertProperty = options.properties.find((property) => ATTRIBUTE_KEYWORDS.has(getPropertyKey(property)))?.value;\n    if (!assertProperty) {\n        return _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJECT;\n    }\n    if (!(assertProperty instanceof ObjectExpression)) {\n        context.module.log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logImportOptionsAreInvalid)(context.module.id), start);\n        return _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJECT;\n    }\n    const assertFields = assertProperty.properties\n        .map(property => {\n        const key = getPropertyKey(property);\n        if (typeof key === 'string' &&\n            typeof property.value.value === 'string') {\n            return [key, property.value.value];\n        }\n        context.module.log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logImportAttributeIsInvalid)(context.module.id), property.start);\n        return null;\n    })\n        .filter((property) => !!property);\n    if (assertFields.length > 0) {\n        return Object.fromEntries(assertFields);\n    }\n    return _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJECT;\n}\nconst getPropertyKey = (property) => {\n    const key = property.key;\n    return (key &&\n        !property.computed &&\n        (key.name || key.value));\n};\nfunction getAttributesFromImportExportDeclaration(attributes) {\n    return attributes?.length\n        ? Object.fromEntries(attributes.map(assertion => [getPropertyKey(assertion), assertion.value.value]))\n        : _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJECT;\n}\nfunction doAttributesDiffer(assertionA, assertionB) {\n    const keysA = Object.keys(assertionA);\n    return (keysA.length !== Object.keys(assertionB).length ||\n        keysA.some(key => assertionA[key] !== assertionB[key]));\n}\n\nlet timers = new Map();\nfunction getPersistedLabel(label, level) {\n    switch (level) {\n        case 1: {\n            return `# ${label}`;\n        }\n        case 2: {\n            return `## ${label}`;\n        }\n        case 3: {\n            return label;\n        }\n        default: {\n            return `- ${label}`;\n        }\n    }\n}\nfunction timeStartImpl(label, level = 3) {\n    label = getPersistedLabel(label, level);\n    const startMemory = node_process__WEBPACK_IMPORTED_MODULE_4__.memoryUsage().heapUsed;\n    const startTime = node_perf_hooks__WEBPACK_IMPORTED_MODULE_5__.performance.now();\n    const timer = timers.get(label);\n    if (timer === undefined) {\n        timers.set(label, {\n            memory: 0,\n            startMemory,\n            startTime,\n            time: 0,\n            totalMemory: 0\n        });\n    }\n    else {\n        timer.startMemory = startMemory;\n        timer.startTime = startTime;\n    }\n}\nfunction timeEndImpl(label, level = 3) {\n    label = getPersistedLabel(label, level);\n    const timer = timers.get(label);\n    if (timer !== undefined) {\n        const currentMemory = node_process__WEBPACK_IMPORTED_MODULE_4__.memoryUsage().heapUsed;\n        timer.memory += currentMemory - timer.startMemory;\n        timer.time += node_perf_hooks__WEBPACK_IMPORTED_MODULE_5__.performance.now() - timer.startTime;\n        timer.totalMemory = Math.max(timer.totalMemory, currentMemory);\n    }\n}\nfunction getTimings() {\n    const newTimings = {};\n    for (const [label, { memory, time, totalMemory }] of timers) {\n        newTimings[label] = [time, memory, totalMemory];\n    }\n    return newTimings;\n}\nlet timeStart = doNothing;\nlet timeEnd = doNothing;\nconst TIMED_PLUGIN_HOOKS = [\n    'augmentChunkHash',\n    'buildEnd',\n    'buildStart',\n    'generateBundle',\n    'load',\n    'moduleParsed',\n    'options',\n    'outputOptions',\n    'renderChunk',\n    'renderDynamicImport',\n    'renderStart',\n    'resolveDynamicImport',\n    'resolveFileUrl',\n    'resolveId',\n    'resolveImportMeta',\n    'shouldTransformCachedModule',\n    'transform',\n    'writeBundle'\n];\nfunction getPluginWithTimers(plugin, index) {\n    if (plugin._hasTimer)\n        return plugin;\n    plugin._hasTimer = true;\n    for (const hook of TIMED_PLUGIN_HOOKS) {\n        if (hook in plugin) {\n            let timerLabel = `plugin ${index}`;\n            if (plugin.name) {\n                timerLabel += ` (${plugin.name})`;\n            }\n            timerLabel += ` - ${hook}`;\n            const handler = function (...parameters) {\n                timeStart(timerLabel, 4);\n                const result = hookFunction.apply(this, parameters);\n                timeEnd(timerLabel, 4);\n                return result;\n            };\n            let hookFunction;\n            if (typeof plugin[hook].handler === 'function') {\n                hookFunction = plugin[hook].handler;\n                plugin[hook].handler = handler;\n            }\n            else {\n                hookFunction = plugin[hook];\n                plugin[hook] = handler;\n            }\n        }\n    }\n    return plugin;\n}\nfunction initialiseTimers(inputOptions) {\n    if (inputOptions.perf) {\n        timers = new Map();\n        timeStart = timeStartImpl;\n        timeEnd = timeEndImpl;\n        inputOptions.plugins = inputOptions.plugins.map(getPluginWithTimers);\n    }\n    else {\n        timeStart = doNothing;\n        timeEnd = doNothing;\n    }\n}\n\nconst MISSING_EXPORT_SHIM_DESCRIPTION = {\n    identifier: null,\n    localName: MISSING_EXPORT_SHIM_VARIABLE\n};\nfunction getVariableForExportNameRecursive(target, name, importerForSideEffects, isExportAllSearch, searchedNamesAndModules = new Map()) {\n    const searchedModules = searchedNamesAndModules.get(name);\n    if (searchedModules) {\n        if (searchedModules.has(target)) {\n            return isExportAllSearch ? [null] : (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logCircularReexport)(name, target.id));\n        }\n        searchedModules.add(target);\n    }\n    else {\n        searchedNamesAndModules.set(name, new Set([target]));\n    }\n    return target.getVariableForExportName(name, {\n        importerForSideEffects,\n        isExportAllSearch,\n        searchedNamesAndModules\n    });\n}\nfunction getAndExtendSideEffectModules(variable, module) {\n    const sideEffectModules = getOrCreate(module.sideEffectDependenciesByVariable, variable, (getNewSet));\n    let currentVariable = variable;\n    const referencedVariables = new Set([currentVariable]);\n    while (true) {\n        const importingModule = currentVariable.module;\n        currentVariable =\n            currentVariable instanceof ExportDefaultVariable\n                ? currentVariable.getDirectOriginalVariable()\n                : currentVariable instanceof SyntheticNamedExportVariable\n                    ? currentVariable.syntheticNamespace\n                    : null;\n        if (!currentVariable || referencedVariables.has(currentVariable)) {\n            break;\n        }\n        referencedVariables.add(currentVariable);\n        sideEffectModules.add(importingModule);\n        const originalSideEffects = importingModule.sideEffectDependenciesByVariable.get(currentVariable);\n        if (originalSideEffects) {\n            for (const module of originalSideEffects) {\n                sideEffectModules.add(module);\n            }\n        }\n    }\n    return sideEffectModules;\n}\nclass Module {\n    constructor(graph, id, options, isEntry, moduleSideEffects, syntheticNamedExports, meta, attributes) {\n        this.graph = graph;\n        this.id = id;\n        this.options = options;\n        this.alternativeReexportModules = new Map();\n        this.chunkFileNames = new Set();\n        this.chunkNames = [];\n        this.cycles = new Set();\n        this.dependencies = new Set();\n        this.dynamicDependencies = new Set();\n        this.dynamicImporters = [];\n        this.dynamicImports = [];\n        this.execIndex = Infinity;\n        this.hasTreeShakingPassStarted = false;\n        this.implicitlyLoadedAfter = new Set();\n        this.implicitlyLoadedBefore = new Set();\n        this.importDescriptions = new Map();\n        this.importMetas = [];\n        this.importedFromNotTreeshaken = false;\n        this.importers = [];\n        this.includedDynamicImporters = [];\n        this.includedImports = new Set();\n        this.isExecuted = false;\n        this.isUserDefinedEntryPoint = false;\n        this.needsExportShim = false;\n        this.sideEffectDependenciesByVariable = new Map();\n        this.sourcesWithAttributes = new Map();\n        this.allExportNames = null;\n        this.ast = null;\n        this.exportAllModules = [];\n        this.exportAllSources = new Set();\n        this.exportNamesByVariable = null;\n        this.exportShimVariable = new ExportShimVariable(this);\n        this.exports = new Map();\n        this.namespaceReexportsByName = new Map();\n        this.reexportDescriptions = new Map();\n        this.relevantDependencies = null;\n        this.syntheticExports = new Map();\n        this.syntheticNamespace = null;\n        this.transformDependencies = [];\n        this.transitiveReexports = null;\n        this.excludeFromSourcemap = /\\0/.test(id);\n        this.context = options.moduleContext(id);\n        this.preserveSignature = this.options.preserveEntrySignatures;\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const module = this;\n        const { dynamicImports, dynamicImporters, exportAllSources, exports, implicitlyLoadedAfter, implicitlyLoadedBefore, importers, reexportDescriptions, sourcesWithAttributes } = this;\n        this.info = {\n            ast: null,\n            attributes,\n            code: null,\n            get dynamicallyImportedIdResolutions() {\n                return dynamicImports\n                    .map(({ argument }) => typeof argument === 'string' && module.resolvedIds[argument])\n                    .filter(Boolean);\n            },\n            get dynamicallyImportedIds() {\n                // We cannot use this.dynamicDependencies because this is needed before\n                // dynamicDependencies are populated\n                return dynamicImports.map(({ id }) => id).filter((id) => id != null);\n            },\n            get dynamicImporters() {\n                return dynamicImporters.sort();\n            },\n            get exportedBindings() {\n                const exportBindings = { '.': [...exports.keys()] };\n                for (const [name, { source }] of reexportDescriptions) {\n                    (exportBindings[source] ??= []).push(name);\n                }\n                for (const source of exportAllSources) {\n                    (exportBindings[source] ??= []).push('*');\n                }\n                return exportBindings;\n            },\n            get exports() {\n                return [\n                    ...exports.keys(),\n                    ...reexportDescriptions.keys(),\n                    ...[...exportAllSources].map(() => '*')\n                ];\n            },\n            get hasDefaultExport() {\n                // This information is only valid after parsing\n                if (!module.ast) {\n                    return null;\n                }\n                return module.exports.has('default') || reexportDescriptions.has('default');\n            },\n            id,\n            get implicitlyLoadedAfterOneOf() {\n                return Array.from(implicitlyLoadedAfter, getId).sort();\n            },\n            get implicitlyLoadedBefore() {\n                return Array.from(implicitlyLoadedBefore, getId).sort();\n            },\n            get importedIdResolutions() {\n                return Array.from(sourcesWithAttributes.keys(), source => module.resolvedIds[source]).filter(Boolean);\n            },\n            get importedIds() {\n                // We cannot use this.dependencies because this is needed before\n                // dependencies are populated\n                return Array.from(sourcesWithAttributes.keys(), source => module.resolvedIds[source]?.id).filter(Boolean);\n            },\n            get importers() {\n                return importers.sort();\n            },\n            isEntry,\n            isExternal: false,\n            get isIncluded() {\n                if (graph.phase !== BuildPhase.GENERATE) {\n                    return null;\n                }\n                return module.isIncluded();\n            },\n            meta: { ...meta },\n            moduleSideEffects,\n            syntheticNamedExports\n        };\n    }\n    basename() {\n        const base = (0,node_path__WEBPACK_IMPORTED_MODULE_1__.basename)(this.id);\n        const extension = (0,node_path__WEBPACK_IMPORTED_MODULE_1__.extname)(this.id);\n        return makeLegal(extension ? base.slice(0, -extension.length) : base);\n    }\n    bindReferences() {\n        this.ast.bind();\n    }\n    cacheInfoGetters() {\n        cacheObjectGetters(this.info, [\n            'dynamicallyImportedIdResolutions',\n            'dynamicallyImportedIds',\n            'dynamicImporters',\n            'exportedBindings',\n            'exports',\n            'hasDefaultExport',\n            'implicitlyLoadedAfterOneOf',\n            'implicitlyLoadedBefore',\n            'importedIdResolutions',\n            'importedIds',\n            'importers'\n        ]);\n    }\n    error(properties, pos) {\n        if (pos !== undefined) {\n            this.addLocationToLogProps(properties, pos);\n        }\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)(properties);\n    }\n    // sum up the length of all ast nodes that are included\n    estimateSize() {\n        let size = 0;\n        for (const node of this.ast.body) {\n            if (node.included) {\n                size += node.end - node.start;\n            }\n        }\n        return size;\n    }\n    getAllExportNames() {\n        if (this.allExportNames) {\n            return this.allExportNames;\n        }\n        this.allExportNames = new Set([...this.exports.keys(), ...this.reexportDescriptions.keys()]);\n        for (const module of this.exportAllModules) {\n            if (module instanceof ExternalModule) {\n                this.allExportNames.add(`*${module.id}`);\n                continue;\n            }\n            for (const name of module.getAllExportNames()) {\n                if (name !== 'default')\n                    this.allExportNames.add(name);\n            }\n        }\n        // We do not count the synthetic namespace as a regular export to hide it\n        // from entry signatures and namespace objects\n        if (typeof this.info.syntheticNamedExports === 'string') {\n            this.allExportNames.delete(this.info.syntheticNamedExports);\n        }\n        return this.allExportNames;\n    }\n    getDependenciesToBeIncluded() {\n        if (this.relevantDependencies)\n            return this.relevantDependencies;\n        this.relevantDependencies = new Set();\n        const necessaryDependencies = new Set();\n        const alwaysCheckedDependencies = new Set();\n        const dependencyVariables = new Set(this.includedImports);\n        if (this.info.isEntry ||\n            this.includedDynamicImporters.length > 0 ||\n            this.namespace.included ||\n            this.implicitlyLoadedAfter.size > 0) {\n            for (const exportName of [...this.getReexports(), ...this.getExports()]) {\n                const [exportedVariable] = this.getVariableForExportName(exportName);\n                if (exportedVariable?.included) {\n                    dependencyVariables.add(exportedVariable);\n                }\n            }\n        }\n        for (let variable of dependencyVariables) {\n            const sideEffectDependencies = this.sideEffectDependenciesByVariable.get(variable);\n            if (sideEffectDependencies) {\n                for (const module of sideEffectDependencies) {\n                    alwaysCheckedDependencies.add(module);\n                }\n            }\n            if (variable instanceof SyntheticNamedExportVariable) {\n                variable = variable.getBaseVariable();\n            }\n            else if (variable instanceof ExportDefaultVariable) {\n                variable = variable.getOriginalVariable();\n            }\n            necessaryDependencies.add(variable.module);\n        }\n        if (!this.options.treeshake || this.info.moduleSideEffects === 'no-treeshake') {\n            for (const dependency of this.dependencies) {\n                this.relevantDependencies.add(dependency);\n            }\n        }\n        else {\n            this.addRelevantSideEffectDependencies(this.relevantDependencies, necessaryDependencies, alwaysCheckedDependencies);\n        }\n        for (const dependency of necessaryDependencies) {\n            this.relevantDependencies.add(dependency);\n        }\n        return this.relevantDependencies;\n    }\n    getExportNamesByVariable() {\n        if (this.exportNamesByVariable) {\n            return this.exportNamesByVariable;\n        }\n        const exportNamesByVariable = new Map();\n        for (const exportName of this.getAllExportNames()) {\n            let [tracedVariable] = this.getVariableForExportName(exportName);\n            if (tracedVariable instanceof ExportDefaultVariable) {\n                tracedVariable = tracedVariable.getOriginalVariable();\n            }\n            if (!tracedVariable ||\n                !(tracedVariable.included || tracedVariable instanceof ExternalVariable)) {\n                continue;\n            }\n            const existingExportNames = exportNamesByVariable.get(tracedVariable);\n            if (existingExportNames) {\n                existingExportNames.push(exportName);\n            }\n            else {\n                exportNamesByVariable.set(tracedVariable, [exportName]);\n            }\n        }\n        return (this.exportNamesByVariable = exportNamesByVariable);\n    }\n    getExports() {\n        return [...this.exports.keys()];\n    }\n    getReexports() {\n        if (this.transitiveReexports) {\n            return this.transitiveReexports;\n        }\n        // to avoid infinite recursion when using circular `export * from X`\n        this.transitiveReexports = [];\n        const reexports = new Set(this.reexportDescriptions.keys());\n        for (const module of this.exportAllModules) {\n            if (module instanceof ExternalModule) {\n                reexports.add(`*${module.id}`);\n            }\n            else {\n                for (const name of [...module.getReexports(), ...module.getExports()]) {\n                    if (name !== 'default')\n                        reexports.add(name);\n                }\n            }\n        }\n        return (this.transitiveReexports = [...reexports]);\n    }\n    getRenderedExports() {\n        // only direct exports are counted here, not reexports at all\n        const renderedExports = [];\n        const removedExports = [];\n        for (const exportName of this.exports.keys()) {\n            const [variable] = this.getVariableForExportName(exportName);\n            (variable?.included ? renderedExports : removedExports).push(exportName);\n        }\n        return { removedExports, renderedExports };\n    }\n    getSyntheticNamespace() {\n        if (this.syntheticNamespace === null) {\n            this.syntheticNamespace = undefined;\n            [this.syntheticNamespace] = this.getVariableForExportName(typeof this.info.syntheticNamedExports === 'string'\n                ? this.info.syntheticNamedExports\n                : 'default', { onlyExplicit: true });\n        }\n        if (!this.syntheticNamespace) {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logSyntheticNamedExportsNeedNamespaceExport)(this.id, this.info.syntheticNamedExports));\n        }\n        return this.syntheticNamespace;\n    }\n    getVariableForExportName(name, { importerForSideEffects, isExportAllSearch, onlyExplicit, searchedNamesAndModules } = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJECT) {\n        if (name[0] === '*') {\n            if (name.length === 1) {\n                // export * from './other'\n                return [this.namespace];\n            }\n            // export * from 'external'\n            const module = this.graph.modulesById.get(name.slice(1));\n            return module.getVariableForExportName('*');\n        }\n        // export { foo } from './other'\n        const reexportDeclaration = this.reexportDescriptions.get(name);\n        if (reexportDeclaration) {\n            const [variable] = getVariableForExportNameRecursive(reexportDeclaration.module, reexportDeclaration.localName, importerForSideEffects, false, searchedNamesAndModules);\n            if (!variable) {\n                return this.error((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logMissingExport)(reexportDeclaration.localName, this.id, reexportDeclaration.module.id), reexportDeclaration.start);\n            }\n            if (importerForSideEffects) {\n                setAlternativeExporterIfCyclic(variable, importerForSideEffects, this);\n                if (this.info.moduleSideEffects) {\n                    getOrCreate(importerForSideEffects.sideEffectDependenciesByVariable, variable, (getNewSet)).add(this);\n                }\n            }\n            return [variable];\n        }\n        const exportDeclaration = this.exports.get(name);\n        if (exportDeclaration) {\n            if (exportDeclaration === MISSING_EXPORT_SHIM_DESCRIPTION) {\n                return [this.exportShimVariable];\n            }\n            const name = exportDeclaration.localName;\n            const variable = this.traceVariable(name, {\n                importerForSideEffects,\n                searchedNamesAndModules\n            });\n            if (importerForSideEffects) {\n                setAlternativeExporterIfCyclic(variable, importerForSideEffects, this);\n                getOrCreate(importerForSideEffects.sideEffectDependenciesByVariable, variable, (getNewSet)).add(this);\n            }\n            return [variable];\n        }\n        if (onlyExplicit) {\n            return [null];\n        }\n        if (name !== 'default') {\n            const foundNamespaceReexport = this.namespaceReexportsByName.get(name) ??\n                this.getVariableFromNamespaceReexports(name, importerForSideEffects, searchedNamesAndModules);\n            this.namespaceReexportsByName.set(name, foundNamespaceReexport);\n            if (foundNamespaceReexport[0]) {\n                return foundNamespaceReexport;\n            }\n        }\n        if (this.info.syntheticNamedExports) {\n            return [\n                getOrCreate(this.syntheticExports, name, () => new SyntheticNamedExportVariable(this.astContext, name, this.getSyntheticNamespace()))\n            ];\n        }\n        // we don't want to create shims when we are just\n        // probing export * modules for exports\n        if (!isExportAllSearch && this.options.shimMissingExports) {\n            this.shimMissingExport(name);\n            return [this.exportShimVariable];\n        }\n        return [null];\n    }\n    hasEffects() {\n        return this.info.moduleSideEffects === 'no-treeshake' || this.ast.hasCachedEffects();\n    }\n    include() {\n        const context = createInclusionContext();\n        if (this.ast.shouldBeIncluded(context))\n            this.ast.include(context, false);\n    }\n    includeAllExports(includeNamespaceMembers) {\n        if (!this.isExecuted) {\n            markModuleAndImpureDependenciesAsExecuted(this);\n            this.graph.needsTreeshakingPass = true;\n        }\n        for (const exportName of this.exports.keys()) {\n            if (includeNamespaceMembers || exportName !== this.info.syntheticNamedExports) {\n                const variable = this.getVariableForExportName(exportName)[0];\n                if (!variable) {\n                    return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logMissingEntryExport)(exportName, this.id));\n                }\n                variable.deoptimizePath(UNKNOWN_PATH);\n                if (!variable.included) {\n                    this.includeVariable(variable);\n                }\n            }\n        }\n        for (const name of this.getReexports()) {\n            const [variable] = this.getVariableForExportName(name);\n            if (variable) {\n                variable.deoptimizePath(UNKNOWN_PATH);\n                if (!variable.included) {\n                    this.includeVariable(variable);\n                }\n                if (variable instanceof ExternalVariable) {\n                    variable.module.reexported = true;\n                }\n            }\n        }\n        if (includeNamespaceMembers) {\n            this.namespace.setMergedNamespaces(this.includeAndGetAdditionalMergedNamespaces());\n        }\n    }\n    includeAllInBundle() {\n        this.ast.include(createInclusionContext(), true);\n        this.includeAllExports(false);\n    }\n    includeExportsByNames(names) {\n        if (!this.isExecuted) {\n            markModuleAndImpureDependenciesAsExecuted(this);\n            this.graph.needsTreeshakingPass = true;\n        }\n        let includeNamespaceMembers = false;\n        for (const name of names) {\n            const variable = this.getVariableForExportName(name)[0];\n            if (variable) {\n                variable.deoptimizePath(UNKNOWN_PATH);\n                if (!variable.included) {\n                    this.includeVariable(variable);\n                }\n            }\n            if (!this.exports.has(name) && !this.reexportDescriptions.has(name)) {\n                includeNamespaceMembers = true;\n            }\n        }\n        if (includeNamespaceMembers) {\n            this.namespace.setMergedNamespaces(this.includeAndGetAdditionalMergedNamespaces());\n        }\n    }\n    isIncluded() {\n        // Modules where this.ast is missing have been loaded via this.load and are\n        // not yet fully processed, hence they cannot be included.\n        return (this.ast &&\n            (this.ast.included ||\n                this.namespace.included ||\n                this.importedFromNotTreeshaken ||\n                this.exportShimVariable.included));\n    }\n    linkImports() {\n        this.addModulesToImportDescriptions(this.importDescriptions);\n        this.addModulesToImportDescriptions(this.reexportDescriptions);\n        const externalExportAllModules = [];\n        for (const source of this.exportAllSources) {\n            const module = this.graph.modulesById.get(this.resolvedIds[source].id);\n            if (module instanceof ExternalModule) {\n                externalExportAllModules.push(module);\n                continue;\n            }\n            this.exportAllModules.push(module);\n        }\n        this.exportAllModules.push(...externalExportAllModules);\n    }\n    log(level, properties, pos) {\n        this.addLocationToLogProps(properties, pos);\n        this.options.onLog(level, properties);\n    }\n    render(options) {\n        const source = this.magicString.clone();\n        this.ast.render(source, options);\n        source.trim();\n        const { usesTopLevelAwait } = this.astContext;\n        if (usesTopLevelAwait && options.format !== 'es' && options.format !== 'system') {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidFormatForTopLevelAwait)(this.id, options.format));\n        }\n        return { source, usesTopLevelAwait };\n    }\n    async setSource({ ast, code, customTransformCache, originalCode, originalSourcemap, resolvedIds, sourcemapChain, transformDependencies, transformFiles, ...moduleOptions }) {\n        timeStart('generate ast', 3);\n        if (code.startsWith('#!')) {\n            const shebangEndPosition = code.indexOf('\\n');\n            this.shebang = code.slice(2, shebangEndPosition);\n        }\n        this.info.code = code;\n        this.originalCode = originalCode;\n        // We need to call decodedSourcemap on the input in case they were hydrated from json in the cache and don't\n        // have the lazy evaluation cache configured. Right now this isn't enforced by the type system because the\n        // RollupCache stores `ExistingDecodedSourcemap` instead of `ExistingRawSourcemap`\n        this.originalSourcemap = decodedSourcemap(originalSourcemap);\n        this.sourcemapChain = sourcemapChain.map(mapOrMissing => mapOrMissing.missing ? mapOrMissing : decodedSourcemap(mapOrMissing));\n        // If coming from cache and this value is already fully decoded, we want to re-encode here to save memory.\n        resetSourcemapCache(this.originalSourcemap, this.sourcemapChain);\n        if (transformFiles) {\n            this.transformFiles = transformFiles;\n        }\n        this.transformDependencies = transformDependencies;\n        this.customTransformCache = customTransformCache;\n        this.updateOptions(moduleOptions);\n        this.resolvedIds = resolvedIds ?? Object.create(null);\n        // By default, `id` is the file name. Custom resolvers and loaders\n        // can change that, but it makes sense to use it for the source file name\n        const fileName = this.id;\n        this.magicString = new MagicString(code, {\n            filename: (this.excludeFromSourcemap ? null : fileName), // don't include plugin helpers in sourcemap\n            indentExclusionRanges: []\n        });\n        this.astContext = {\n            addDynamicImport: this.addDynamicImport.bind(this),\n            addExport: this.addExport.bind(this),\n            addImport: this.addImport.bind(this),\n            addImportMeta: this.addImportMeta.bind(this),\n            addImportSource: this.addImportSource.bind(this),\n            code, // Only needed for debugging\n            deoptimizationTracker: this.graph.deoptimizationTracker,\n            error: this.error.bind(this),\n            fileName, // Needed for warnings\n            getExports: this.getExports.bind(this),\n            getImportedJsxFactoryVariable: this.getImportedJsxFactoryVariable.bind(this),\n            getModuleExecIndex: () => this.execIndex,\n            getModuleName: this.basename.bind(this),\n            getNodeConstructor: (name) => nodeConstructors[name] || nodeConstructors.UnknownNode,\n            getReexports: this.getReexports.bind(this),\n            importDescriptions: this.importDescriptions,\n            includeAllExports: () => this.includeAllExports(true),\n            includeDynamicImport: this.includeDynamicImport.bind(this),\n            includeVariableInModule: this.includeVariableInModule.bind(this),\n            log: this.log.bind(this),\n            magicString: this.magicString,\n            manualPureFunctions: this.graph.pureFunctions,\n            module: this,\n            moduleContext: this.context,\n            options: this.options,\n            requestTreeshakingPass: () => (this.graph.needsTreeshakingPass = true),\n            traceExport: (name) => this.getVariableForExportName(name)[0],\n            traceVariable: this.traceVariable.bind(this),\n            usesTopLevelAwait: false\n        };\n        this.scope = new ModuleScope(this.graph.scope, this.astContext);\n        this.namespace = new NamespaceVariable(this.astContext);\n        const programParent = { context: this.astContext, type: 'Module' };\n        if (ast) {\n            this.ast = new nodeConstructors[ast.type](programParent, this.scope).parseNode(ast);\n            this.info.ast = ast;\n        }\n        else {\n            // Measuring asynchronous code does not provide reasonable results\n            timeEnd('generate ast', 3);\n            const astBuffer = await (0,_native_js__WEBPACK_IMPORTED_MODULE_3__.parseAsync)(code, false, this.options.jsx !== false);\n            timeStart('generate ast', 3);\n            this.ast = convertProgram(astBuffer, programParent, this.scope);\n            // Make lazy and apply LRU cache to not hog the memory\n            Object.defineProperty(this.info, 'ast', {\n                get: () => {\n                    if (this.graph.astLru.has(fileName)) {\n                        return this.graph.astLru.get(fileName);\n                    }\n                    else {\n                        const parsedAst = this.tryParse();\n                        // If the cache is not disabled, we need to keep the AST in memory\n                        // until the end when the cache is generated\n                        if (this.options.cache !== false) {\n                            Object.defineProperty(this.info, 'ast', {\n                                value: parsedAst\n                            });\n                            return parsedAst;\n                        }\n                        // Otherwise, we keep it in a small LRU cache to not hog too much\n                        // memory but allow the same AST to be requested several times.\n                        this.graph.astLru.set(fileName, parsedAst);\n                        return parsedAst;\n                    }\n                }\n            });\n        }\n        timeEnd('generate ast', 3);\n    }\n    toJSON() {\n        return {\n            ast: this.info.ast,\n            attributes: this.info.attributes,\n            code: this.info.code,\n            customTransformCache: this.customTransformCache,\n            dependencies: Array.from(this.dependencies, getId),\n            id: this.id,\n            meta: this.info.meta,\n            moduleSideEffects: this.info.moduleSideEffects,\n            originalCode: this.originalCode,\n            originalSourcemap: this.originalSourcemap,\n            resolvedIds: this.resolvedIds,\n            sourcemapChain: this.sourcemapChain,\n            syntheticNamedExports: this.info.syntheticNamedExports,\n            transformDependencies: this.transformDependencies,\n            transformFiles: this.transformFiles\n        };\n    }\n    traceVariable(name, { importerForSideEffects, isExportAllSearch, searchedNamesAndModules } = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJECT) {\n        const localVariable = this.scope.variables.get(name);\n        if (localVariable) {\n            return localVariable;\n        }\n        const importDescription = this.importDescriptions.get(name);\n        if (importDescription) {\n            const otherModule = importDescription.module;\n            if (otherModule instanceof Module && importDescription.name === '*') {\n                return otherModule.namespace;\n            }\n            const [declaration] = getVariableForExportNameRecursive(otherModule, importDescription.name, importerForSideEffects || this, isExportAllSearch, searchedNamesAndModules);\n            if (!declaration) {\n                return this.error((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logMissingExport)(importDescription.name, this.id, otherModule.id), importDescription.start);\n            }\n            return declaration;\n        }\n        return null;\n    }\n    updateOptions({ meta, moduleSideEffects, syntheticNamedExports }) {\n        if (moduleSideEffects != null) {\n            this.info.moduleSideEffects = moduleSideEffects;\n        }\n        if (syntheticNamedExports != null) {\n            this.info.syntheticNamedExports = syntheticNamedExports;\n        }\n        if (meta != null) {\n            Object.assign(this.info.meta, meta);\n        }\n    }\n    addDynamicImport(node) {\n        let argument = node.sourceAstNode;\n        if (argument.type === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.TemplateLiteral) {\n            if (argument.quasis.length === 1 &&\n                typeof argument.quasis[0].value.cooked === 'string') {\n                argument = argument.quasis[0].value.cooked;\n            }\n        }\n        else if (argument.type === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.Literal &&\n            typeof argument.value === 'string') {\n            argument = argument.value;\n        }\n        this.dynamicImports.push({ argument, id: null, node, resolution: null });\n    }\n    assertUniqueExportName(name, nodeStart) {\n        if (this.exports.has(name) || this.reexportDescriptions.has(name)) {\n            this.error((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logDuplicateExportError)(name), nodeStart);\n        }\n    }\n    addExport(node) {\n        if (node instanceof ExportDefaultDeclaration) {\n            // export default foo;\n            this.assertUniqueExportName('default', node.start);\n            this.exports.set('default', {\n                identifier: node.variable.getAssignedVariableName(),\n                localName: 'default'\n            });\n        }\n        else if (node instanceof ExportAllDeclaration) {\n            const source = node.source.value;\n            this.addSource(source, node);\n            if (node.exported) {\n                // export * as name from './other'\n                const name = node.exported instanceof Literal ? node.exported.value : node.exported.name;\n                this.assertUniqueExportName(name, node.exported.start);\n                this.reexportDescriptions.set(name, {\n                    localName: '*',\n                    module: null, // filled in later,\n                    source,\n                    start: node.start\n                });\n            }\n            else {\n                // export * from './other'\n                this.exportAllSources.add(source);\n            }\n        }\n        else if (node.source instanceof Literal) {\n            // export { name } from './other'\n            const source = node.source.value;\n            this.addSource(source, node);\n            for (const { exported, local, start } of node.specifiers) {\n                const name = exported instanceof Literal ? exported.value : exported.name;\n                this.assertUniqueExportName(name, start);\n                this.reexportDescriptions.set(name, {\n                    localName: local instanceof Literal ? local.value : local.name,\n                    module: null, // filled in later,\n                    source,\n                    start\n                });\n            }\n        }\n        else if (node.declaration) {\n            const declaration = node.declaration;\n            if (declaration instanceof VariableDeclaration) {\n                // export var { foo, bar } = ...\n                // export var foo = 1, bar = 2;\n                for (const declarator of declaration.declarations) {\n                    for (const localName of extractAssignedNames(declarator.id)) {\n                        this.assertUniqueExportName(localName, declarator.id.start);\n                        this.exports.set(localName, { identifier: null, localName });\n                    }\n                }\n            }\n            else {\n                // export function foo () {}\n                const localName = declaration.id.name;\n                this.assertUniqueExportName(localName, declaration.id.start);\n                this.exports.set(localName, { identifier: null, localName });\n            }\n        }\n        else {\n            // export { foo, bar, baz }\n            for (const { local, exported } of node.specifiers) {\n                // except for reexports, local must be an Identifier\n                const localName = local.name;\n                const exportedName = exported instanceof Identifier ? exported.name : exported.value;\n                this.assertUniqueExportName(exportedName, exported.start);\n                this.exports.set(exportedName, { identifier: null, localName });\n            }\n        }\n    }\n    addImport(node) {\n        const source = node.source.value;\n        this.addSource(source, node);\n        for (const specifier of node.specifiers) {\n            const localName = specifier.local.name;\n            if (this.scope.variables.has(localName) || this.importDescriptions.has(localName)) {\n                this.error((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logRedeclarationError)(localName), specifier.local.start);\n            }\n            const name = specifier instanceof ImportDefaultSpecifier\n                ? 'default'\n                : specifier instanceof ImportNamespaceSpecifier\n                    ? '*'\n                    : specifier.imported instanceof Identifier\n                        ? specifier.imported.name\n                        : specifier.imported.value;\n            this.importDescriptions.set(localName, {\n                module: null, // filled in later\n                name,\n                source,\n                start: specifier.start\n            });\n        }\n    }\n    addImportSource(importSource) {\n        if (importSource && !this.sourcesWithAttributes.has(importSource)) {\n            this.sourcesWithAttributes.set(importSource, _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJECT);\n        }\n    }\n    addImportMeta(node) {\n        this.importMetas.push(node);\n    }\n    addLocationToLogProps(properties, pos) {\n        properties.id = this.id;\n        properties.pos = pos;\n        let code = this.info.code;\n        const location = (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.locate)(code, pos, { offsetLine: 1 });\n        if (location) {\n            let { column, line } = location;\n            try {\n                ({ column, line } = getOriginalLocation(this.sourcemapChain, { column, line }));\n                code = this.originalCode;\n            }\n            catch (error_) {\n                this.options.onLog(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidSourcemapForError)(error_, this.id, column, line, pos));\n            }\n            (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.augmentCodeLocation)(properties, { column, line }, code, this.id);\n        }\n    }\n    addModulesToImportDescriptions(importDescription) {\n        for (const specifier of importDescription.values()) {\n            const { id } = this.resolvedIds[specifier.source];\n            specifier.module = this.graph.modulesById.get(id);\n        }\n    }\n    addRelevantSideEffectDependencies(relevantDependencies, necessaryDependencies, alwaysCheckedDependencies) {\n        const handledDependencies = new Set();\n        const addSideEffectDependencies = (possibleDependencies) => {\n            for (const dependency of possibleDependencies) {\n                if (handledDependencies.has(dependency)) {\n                    continue;\n                }\n                handledDependencies.add(dependency);\n                if (necessaryDependencies.has(dependency)) {\n                    relevantDependencies.add(dependency);\n                    continue;\n                }\n                if (!(dependency.info.moduleSideEffects || alwaysCheckedDependencies.has(dependency))) {\n                    continue;\n                }\n                if (dependency instanceof ExternalModule || dependency.hasEffects()) {\n                    relevantDependencies.add(dependency);\n                    continue;\n                }\n                addSideEffectDependencies(dependency.dependencies);\n            }\n        };\n        addSideEffectDependencies(this.dependencies);\n        addSideEffectDependencies(alwaysCheckedDependencies);\n    }\n    addSource(source, declaration) {\n        const parsedAttributes = getAttributesFromImportExportDeclaration(declaration.attributes);\n        const existingAttributes = this.sourcesWithAttributes.get(source);\n        if (existingAttributes) {\n            if (doAttributesDiffer(existingAttributes, parsedAttributes)) {\n                this.log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInconsistentImportAttributes)(existingAttributes, parsedAttributes, source, this.id), declaration.start);\n            }\n        }\n        else {\n            this.sourcesWithAttributes.set(source, parsedAttributes);\n        }\n    }\n    getImportedJsxFactoryVariable(baseName, nodeStart, importSource) {\n        const { id } = this.resolvedIds[importSource];\n        const module = this.graph.modulesById.get(id);\n        const [variable] = module.getVariableForExportName(baseName);\n        if (!variable) {\n            return this.error((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logMissingJsxExport)(baseName, id, this.id), nodeStart);\n        }\n        return variable;\n    }\n    getVariableFromNamespaceReexports(name, importerForSideEffects, searchedNamesAndModules) {\n        let foundSyntheticDeclaration = null;\n        const foundInternalDeclarations = new Map();\n        const foundExternalDeclarations = new Set();\n        for (const module of this.exportAllModules) {\n            // Synthetic namespaces should not hide \"regular\" exports of the same name\n            if (module.info.syntheticNamedExports === name) {\n                continue;\n            }\n            const [variable, indirectExternal] = getVariableForExportNameRecursive(module, name, importerForSideEffects, true, \n            // We are creating a copy to handle the case where the same binding is\n            // imported through different namespace reexports gracefully\n            copyNameToModulesMap(searchedNamesAndModules));\n            if (module instanceof ExternalModule || indirectExternal) {\n                foundExternalDeclarations.add(variable);\n            }\n            else if (variable instanceof SyntheticNamedExportVariable) {\n                if (!foundSyntheticDeclaration) {\n                    foundSyntheticDeclaration = variable;\n                }\n            }\n            else if (variable) {\n                foundInternalDeclarations.set(variable, module);\n            }\n        }\n        if (foundInternalDeclarations.size > 0) {\n            const foundDeclarationList = [...foundInternalDeclarations];\n            const usedDeclaration = foundDeclarationList[0][0];\n            if (foundDeclarationList.length === 1) {\n                return [usedDeclaration];\n            }\n            this.options.onLog(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logNamespaceConflict)(name, this.id, foundDeclarationList.map(([, module]) => module.id)));\n            // TODO we are pretending it was not found while it should behave like \"undefined\"\n            return [null];\n        }\n        if (foundExternalDeclarations.size > 0) {\n            const foundDeclarationList = [...foundExternalDeclarations];\n            const usedDeclaration = foundDeclarationList[0];\n            if (foundDeclarationList.length > 1) {\n                this.options.onLog(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logAmbiguousExternalNamespaces)(name, this.id, usedDeclaration.module.id, foundDeclarationList.map(declaration => declaration.module.id)));\n            }\n            return [usedDeclaration, true];\n        }\n        if (foundSyntheticDeclaration) {\n            return [foundSyntheticDeclaration];\n        }\n        return [null];\n    }\n    includeAndGetAdditionalMergedNamespaces() {\n        const externalNamespaces = new Set();\n        const syntheticNamespaces = new Set();\n        for (const module of [this, ...this.exportAllModules]) {\n            if (module instanceof ExternalModule) {\n                const [externalVariable] = module.getVariableForExportName('*');\n                externalVariable.include();\n                this.includedImports.add(externalVariable);\n                externalNamespaces.add(externalVariable);\n            }\n            else if (module.info.syntheticNamedExports) {\n                const syntheticNamespace = module.getSyntheticNamespace();\n                syntheticNamespace.include();\n                this.includedImports.add(syntheticNamespace);\n                syntheticNamespaces.add(syntheticNamespace);\n            }\n        }\n        return [...syntheticNamespaces, ...externalNamespaces];\n    }\n    includeDynamicImport(node) {\n        const resolution = this.dynamicImports.find(dynamicImport => dynamicImport.node === node).resolution;\n        if (resolution instanceof Module) {\n            resolution.includedDynamicImporters.push(this);\n            const importedNames = this.options.treeshake\n                ? node.getDeterministicImportedNames()\n                : undefined;\n            if (importedNames) {\n                resolution.includeExportsByNames(importedNames);\n            }\n            else {\n                resolution.includeAllExports(true);\n            }\n        }\n    }\n    includeVariable(variable) {\n        const variableModule = variable.module;\n        if (variable.included) {\n            if (variableModule instanceof Module && variableModule !== this) {\n                getAndExtendSideEffectModules(variable, this);\n            }\n        }\n        else {\n            variable.include();\n            this.graph.needsTreeshakingPass = true;\n            if (variableModule instanceof Module) {\n                if (!variableModule.isExecuted) {\n                    markModuleAndImpureDependenciesAsExecuted(variableModule);\n                }\n                if (variableModule !== this) {\n                    const sideEffectModules = getAndExtendSideEffectModules(variable, this);\n                    for (const module of sideEffectModules) {\n                        if (!module.isExecuted) {\n                            markModuleAndImpureDependenciesAsExecuted(module);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    includeVariableInModule(variable) {\n        this.includeVariable(variable);\n        const variableModule = variable.module;\n        if (variableModule && variableModule !== this) {\n            this.includedImports.add(variable);\n        }\n    }\n    shimMissingExport(name) {\n        this.options.onLog(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logShimmedExport)(this.id, name));\n        this.exports.set(name, MISSING_EXPORT_SHIM_DESCRIPTION);\n    }\n    tryParse() {\n        try {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.parseAst)(this.info.code, { jsx: this.options.jsx !== false });\n        }\n        catch (error_) {\n            return this.error((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logModuleParseError)(error_, this.id), error_.pos);\n        }\n    }\n}\n// if there is a cyclic import in the reexport chain, we should not\n// import from the original module but from the cyclic module to not\n// mess up execution order.\nfunction setAlternativeExporterIfCyclic(variable, importer, reexporter) {\n    if (variable.module instanceof Module && variable.module !== reexporter) {\n        const exporterCycles = variable.module.cycles;\n        if (exporterCycles.size > 0) {\n            const importerCycles = reexporter.cycles;\n            for (const cycleSymbol of importerCycles) {\n                if (exporterCycles.has(cycleSymbol)) {\n                    importer.alternativeReexportModules.set(variable, reexporter);\n                    break;\n                }\n            }\n        }\n    }\n}\nconst copyNameToModulesMap = (searchedNamesAndModules) => searchedNamesAndModules &&\n    new Map(Array.from(searchedNamesAndModules, ([name, modules]) => [name, new Set(modules)]));\n\nconst concatSeparator = (out, next) => (next ? `${out}\\n${next}` : out);\nconst concatDblSeparator = (out, next) => (next ? `${out}\\n\\n${next}` : out);\nasync function createAddons(options, outputPluginDriver, chunk) {\n    try {\n        let [banner, footer, intro, outro] = await Promise.all([\n            outputPluginDriver.hookReduceValue('banner', options.banner(chunk), [chunk], concatSeparator),\n            outputPluginDriver.hookReduceValue('footer', options.footer(chunk), [chunk], concatSeparator),\n            outputPluginDriver.hookReduceValue('intro', options.intro(chunk), [chunk], concatDblSeparator),\n            outputPluginDriver.hookReduceValue('outro', options.outro(chunk), [chunk], concatDblSeparator)\n        ]);\n        if (intro)\n            intro += '\\n\\n';\n        if (outro)\n            outro = `\\n\\n${outro}`;\n        if (banner)\n            banner += '\\n';\n        if (footer)\n            footer = '\\n' + footer;\n        return { banner, footer, intro, outro };\n    }\n    catch (error_) {\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logAddonNotGenerated)(error_.message, error_.hook, error_.plugin));\n    }\n}\n\nconst DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT = {\n    amd: deconflictImportsOther,\n    cjs: deconflictImportsOther,\n    es: deconflictImportsEsmOrSystem,\n    iife: deconflictImportsOther,\n    system: deconflictImportsEsmOrSystem,\n    umd: deconflictImportsOther\n};\nfunction deconflictChunk(modules, dependenciesToBeDeconflicted, imports, usedNames, format, interop, preserveModules, externalLiveBindings, chunkByModule, externalChunkByModule, syntheticExports, exportNamesByVariable, accessedGlobalsByScope, includedNamespaces) {\n    const reversedModules = [...modules].reverse();\n    for (const module of reversedModules) {\n        module.scope.addUsedOutsideNames(usedNames, format, exportNamesByVariable, accessedGlobalsByScope);\n    }\n    deconflictTopLevelVariables(usedNames, reversedModules, includedNamespaces);\n    DECONFLICT_IMPORTED_VARIABLES_BY_FORMAT[format](usedNames, imports, dependenciesToBeDeconflicted, interop, preserveModules, externalLiveBindings, chunkByModule, externalChunkByModule, syntheticExports);\n    for (const module of reversedModules) {\n        module.scope.deconflict(format, exportNamesByVariable, accessedGlobalsByScope);\n    }\n}\nfunction deconflictImportsEsmOrSystem(usedNames, imports, dependenciesToBeDeconflicted, _interop, preserveModules, _externalLiveBindings, chunkByModule, externalChunkByModule, syntheticExports) {\n    // This is needed for namespace reexports\n    for (const dependency of dependenciesToBeDeconflicted.dependencies) {\n        if (preserveModules || dependency instanceof ExternalChunk) {\n            dependency.variableName = getSafeName(dependency.suggestedVariableName, usedNames, null);\n        }\n    }\n    for (const variable of imports) {\n        const module = variable.module;\n        const name = variable.name;\n        if (variable.isNamespace && (preserveModules || module instanceof ExternalModule)) {\n            variable.setRenderNames(null, (module instanceof ExternalModule\n                ? externalChunkByModule.get(module)\n                : chunkByModule.get(module)).variableName);\n        }\n        else if (module instanceof ExternalModule && name === 'default') {\n            variable.setRenderNames(null, getSafeName([...module.exportedVariables].some(([exportedVariable, exportedName]) => exportedName === '*' && exportedVariable.included)\n                ? module.suggestedVariableName + '__default'\n                : module.suggestedVariableName, usedNames, variable.forbiddenNames));\n        }\n        else {\n            variable.setRenderNames(null, getSafeName(makeLegal(name), usedNames, variable.forbiddenNames));\n        }\n    }\n    for (const variable of syntheticExports) {\n        variable.setRenderNames(null, getSafeName(variable.name, usedNames, variable.forbiddenNames));\n    }\n}\nfunction deconflictImportsOther(usedNames, imports, { deconflictedDefault, deconflictedNamespace, dependencies }, interop, preserveModules, externalLiveBindings, chunkByModule, externalChunkByModule) {\n    for (const chunk of dependencies) {\n        chunk.variableName = getSafeName(chunk.suggestedVariableName, usedNames, null);\n    }\n    for (const chunk of deconflictedNamespace) {\n        chunk.namespaceVariableName = getSafeName(`${chunk.suggestedVariableName}__namespace`, usedNames, null);\n    }\n    for (const externalModule of deconflictedDefault) {\n        externalModule.defaultVariableName =\n            deconflictedNamespace.has(externalModule) &&\n                canDefaultBeTakenFromNamespace(interop(externalModule.id), externalLiveBindings)\n                ? externalModule.namespaceVariableName\n                : getSafeName(`${externalModule.suggestedVariableName}__default`, usedNames, null);\n    }\n    for (const variable of imports) {\n        const module = variable.module;\n        if (module instanceof ExternalModule) {\n            const chunk = externalChunkByModule.get(module);\n            const name = variable.name;\n            if (name === 'default') {\n                const moduleInterop = interop(module.id);\n                const variableName = defaultInteropHelpersByInteropType[moduleInterop]\n                    ? chunk.defaultVariableName\n                    : chunk.variableName;\n                if (isDefaultAProperty(moduleInterop, externalLiveBindings)) {\n                    variable.setRenderNames(variableName, 'default');\n                }\n                else {\n                    variable.setRenderNames(null, variableName);\n                }\n            }\n            else if (name === '*') {\n                variable.setRenderNames(null, namespaceInteropHelpersByInteropType[interop(module.id)]\n                    ? chunk.namespaceVariableName\n                    : chunk.variableName);\n            }\n            else {\n                // if the second parameter is `null`, it uses its \"name\" for the property name\n                variable.setRenderNames(chunk.variableName, null);\n            }\n        }\n        else {\n            const chunk = chunkByModule.get(module);\n            if (preserveModules && variable.isNamespace) {\n                variable.setRenderNames(null, chunk.exportMode === 'default' ? chunk.namespaceVariableName : chunk.variableName);\n            }\n            else if (chunk.exportMode === 'default') {\n                variable.setRenderNames(null, chunk.variableName);\n            }\n            else {\n                variable.setRenderNames(chunk.variableName, chunk.getVariableExportName(variable));\n            }\n        }\n    }\n}\nfunction deconflictTopLevelVariables(usedNames, modules, includedNamespaces) {\n    for (const module of modules) {\n        for (const variable of module.scope.variables.values()) {\n            if (variable.included &&\n                // this will only happen for exports in some formats\n                !(variable.renderBaseName ||\n                    (variable instanceof ExportDefaultVariable && variable.getOriginalVariable() !== variable))) {\n                variable.setRenderNames(null, getSafeName(variable.name, usedNames, variable.forbiddenNames));\n            }\n        }\n        if (includedNamespaces.has(module)) {\n            const namespace = module.namespace;\n            namespace.setRenderNames(null, getSafeName(namespace.name, usedNames, namespace.forbiddenNames));\n        }\n    }\n}\n\nfunction assignExportsToMangledNames(exports, exportsByName, exportNamesByVariable) {\n    let nameIndex = 0;\n    for (const variable of exports) {\n        let [exportName] = variable.name;\n        if (exportsByName.has(exportName)) {\n            do {\n                exportName = toBase64(++nameIndex);\n                // skip past leading number identifiers\n                if (exportName.charCodeAt(0) === 49 /* '1' */) {\n                    nameIndex += 9 * 64 ** (exportName.length - 1);\n                    exportName = toBase64(nameIndex);\n                }\n            } while (RESERVED_NAMES.has(exportName) || exportsByName.has(exportName));\n        }\n        exportsByName.set(exportName, variable);\n        exportNamesByVariable.set(variable, [exportName]);\n    }\n}\nfunction assignExportsToNames(exports, exportsByName, exportNamesByVariable) {\n    for (const variable of exports) {\n        let nameIndex = 0;\n        let exportName = variable.name;\n        while (exportsByName.has(exportName)) {\n            exportName = variable.name + '$' + ++nameIndex;\n        }\n        exportsByName.set(exportName, variable);\n        exportNamesByVariable.set(variable, [exportName]);\n    }\n}\n\nfunction getExportMode(chunk, { exports: exportMode, name, format }, facadeModuleId, log) {\n    const exportKeys = chunk.getExportNames();\n    if (exportMode === 'default') {\n        if (exportKeys.length !== 1 || exportKeys[0] !== 'default') {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logIncompatibleExportOptionValue)('default', exportKeys, facadeModuleId));\n        }\n    }\n    else if (exportMode === 'none' && exportKeys.length > 0) {\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logIncompatibleExportOptionValue)('none', exportKeys, facadeModuleId));\n    }\n    if (exportMode === 'auto') {\n        if (exportKeys.length === 0) {\n            exportMode = 'none';\n        }\n        else if (exportKeys.length === 1 && exportKeys[0] === 'default') {\n            exportMode = 'default';\n        }\n        else {\n            if (format !== 'es' && format !== 'system' && exportKeys.includes('default')) {\n                log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logMixedExport)(facadeModuleId, name));\n            }\n            exportMode = 'named';\n        }\n    }\n    return exportMode;\n}\n\nfunction guessIndentString(code) {\n    const lines = code.split('\\n');\n    const tabbed = lines.filter(line => /^\\t+/.test(line));\n    const spaced = lines.filter(line => /^ {2,}/.test(line));\n    if (tabbed.length === 0 && spaced.length === 0) {\n        return null;\n    }\n    // More lines tabbed than spaced? Assume tabs, and\n    // default to tabs in the case of a tie (or nothing\n    // to go on)\n    if (tabbed.length >= spaced.length) {\n        return '\\t';\n    }\n    // Otherwise, we need to guess the multiple\n    const min = spaced.reduce((previous, current) => {\n        const numberSpaces = /^ +/.exec(current)[0].length;\n        return Math.min(numberSpaces, previous);\n    }, Infinity);\n    return ' '.repeat(min);\n}\nfunction getIndentString(modules, options) {\n    if (options.indent !== true)\n        return options.indent;\n    for (const module of modules) {\n        const indent = guessIndentString(module.originalCode);\n        if (indent !== null)\n            return indent;\n    }\n    return '\\t';\n}\n\nfunction getStaticDependencies(chunk, orderedModules, chunkByModule, externalChunkByModule) {\n    const staticDependencyBlocks = [];\n    const handledDependencies = new Set();\n    for (let modulePos = orderedModules.length - 1; modulePos >= 0; modulePos--) {\n        const module = orderedModules[modulePos];\n        if (!handledDependencies.has(module)) {\n            const staticDependencies = [];\n            addStaticDependencies(module, staticDependencies, handledDependencies, chunk, chunkByModule, externalChunkByModule);\n            staticDependencyBlocks.unshift(staticDependencies);\n        }\n    }\n    const dependencies = new Set();\n    for (const block of staticDependencyBlocks) {\n        for (const dependency of block) {\n            dependencies.add(dependency);\n        }\n    }\n    return dependencies;\n}\nfunction addStaticDependencies(module, staticDependencies, handledModules, chunk, chunkByModule, externalChunkByModule) {\n    const dependencies = module.getDependenciesToBeIncluded();\n    for (const dependency of dependencies) {\n        if (dependency instanceof ExternalModule) {\n            staticDependencies.push(externalChunkByModule.get(dependency));\n            continue;\n        }\n        const dependencyChunk = chunkByModule.get(dependency);\n        if (dependencyChunk !== chunk) {\n            staticDependencies.push(dependencyChunk);\n            continue;\n        }\n        if (!handledModules.has(dependency)) {\n            handledModules.add(dependency);\n            addStaticDependencies(dependency, staticDependencies, handledModules, chunk, chunkByModule, externalChunkByModule);\n        }\n    }\n}\n\n// Four random characters from the private use area to minimize risk of\n// conflicts\nconst hashPlaceholderLeft = '!~{';\nconst hashPlaceholderRight = '}~';\nconst hashPlaceholderOverhead = hashPlaceholderLeft.length + hashPlaceholderRight.length;\n// This is the size of a 128-bits xxhash with base64url encoding\nconst MAX_HASH_SIZE = 22;\nconst DEFAULT_HASH_SIZE = 8;\nconst getHashPlaceholderGenerator = () => {\n    let nextIndex = 0;\n    return (optionName, hashSize) => {\n        if (hashSize > MAX_HASH_SIZE) {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logFailedValidation)(`Hashes cannot be longer than ${MAX_HASH_SIZE} characters, received ${hashSize}. Check the \"${optionName}\" option.`));\n        }\n        const placeholder = `${hashPlaceholderLeft}${toBase64(++nextIndex).padStart(hashSize - hashPlaceholderOverhead, '0')}${hashPlaceholderRight}`;\n        if (placeholder.length > hashSize) {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logFailedValidation)(`To generate hashes for this number of chunks (currently ${nextIndex}), you need a minimum hash size of ${placeholder.length}, received ${hashSize}. Check the \"${optionName}\" option.`));\n        }\n        return placeholder;\n    };\n};\nconst REPLACER_REGEX = new RegExp(`${hashPlaceholderLeft}[0-9a-zA-Z_$]{1,${MAX_HASH_SIZE - hashPlaceholderOverhead}}${hashPlaceholderRight}`, 'g');\nconst replacePlaceholders = (code, hashesByPlaceholder) => code.replace(REPLACER_REGEX, placeholder => hashesByPlaceholder.get(placeholder) || placeholder);\nconst replaceSinglePlaceholder = (code, placeholder, value) => code.replace(REPLACER_REGEX, match => (match === placeholder ? value : match));\nconst replacePlaceholdersWithDefaultAndGetContainedPlaceholders = (code, placeholders) => {\n    const containedPlaceholders = new Set();\n    const transformedCode = code.replace(REPLACER_REGEX, placeholder => {\n        if (placeholders.has(placeholder)) {\n            containedPlaceholders.add(placeholder);\n            return `${hashPlaceholderLeft}${'0'.repeat(placeholder.length - hashPlaceholderOverhead)}${hashPlaceholderRight}`;\n        }\n        return placeholder;\n    });\n    return { containedPlaceholders, transformedCode };\n};\n\nconst lowercaseBundleKeys = Symbol('bundleKeys');\nconst FILE_PLACEHOLDER = {\n    type: 'placeholder'\n};\nconst getOutputBundle = (outputBundleBase) => {\n    const reservedLowercaseBundleKeys = new Set();\n    return new Proxy(outputBundleBase, {\n        deleteProperty(target, key) {\n            if (typeof key === 'string') {\n                reservedLowercaseBundleKeys.delete(key.toLowerCase());\n            }\n            return Reflect.deleteProperty(target, key);\n        },\n        get(target, key) {\n            if (key === lowercaseBundleKeys) {\n                return reservedLowercaseBundleKeys;\n            }\n            return Reflect.get(target, key);\n        },\n        set(target, key, value) {\n            if (typeof key === 'string') {\n                reservedLowercaseBundleKeys.add(key.toLowerCase());\n            }\n            return Reflect.set(target, key, value);\n        }\n    });\n};\nconst removeUnreferencedAssets = (outputBundle) => {\n    const unreferencedAssets = new Set();\n    const bundleEntries = Object.values(outputBundle);\n    for (const asset of bundleEntries) {\n        if (asset.type === 'asset' && asset.needsCodeReference) {\n            unreferencedAssets.add(asset.fileName);\n        }\n    }\n    for (const chunk of bundleEntries) {\n        if (chunk.type === 'chunk') {\n            for (const referencedFile of chunk.referencedFiles) {\n                if (unreferencedAssets.has(referencedFile)) {\n                    unreferencedAssets.delete(referencedFile);\n                }\n            }\n        }\n    }\n    for (const file of unreferencedAssets) {\n        delete outputBundle[file];\n    }\n};\n\nfunction renderNamePattern(pattern, patternName, replacements) {\n    if ((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.isPathFragment)(pattern))\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logFailedValidation)(`Invalid pattern \"${pattern}\" for \"${patternName}\", patterns can be neither absolute nor relative paths. If you want your files to be stored in a subdirectory, write its name without a leading slash like this: subdirectory/pattern.`));\n    return pattern.replace(/\\[(\\w+)(:\\d+)?]/g, (_match, type, size) => {\n        if (!replacements.hasOwnProperty(type) || (size && type !== 'hash')) {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logFailedValidation)(`\"[${type}${size || ''}]\" is not a valid placeholder in the \"${patternName}\" pattern.`));\n        }\n        const replacement = replacements[type](size && Number.parseInt(size.slice(1)));\n        if ((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.isPathFragment)(replacement))\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logFailedValidation)(`Invalid substitution \"${replacement}\" for placeholder \"[${type}]\" in \"${patternName}\" pattern, can be neither absolute nor relative path.`));\n        return replacement;\n    });\n}\nfunction makeUnique(name, { [lowercaseBundleKeys]: reservedLowercaseBundleKeys }) {\n    if (!reservedLowercaseBundleKeys.has(name.toLowerCase()))\n        return name;\n    const extension = (0,node_path__WEBPACK_IMPORTED_MODULE_1__.extname)(name);\n    name = name.slice(0, Math.max(0, name.length - extension.length));\n    let uniqueName, uniqueIndex = 1;\n    while (reservedLowercaseBundleKeys.has((uniqueName = name + ++uniqueIndex + extension).toLowerCase()))\n        ;\n    return uniqueName;\n}\n\nconst NON_ASSET_EXTENSIONS = new Set([\n    '.js',\n    '.jsx',\n    '.ts',\n    '.tsx',\n    '.mjs',\n    '.mts',\n    '.cjs',\n    '.cts'\n]);\nfunction getGlobalName(chunk, globals, hasExports, log) {\n    const globalName = typeof globals === 'function' ? globals(chunk.id) : globals[chunk.id];\n    if (globalName) {\n        return globalName;\n    }\n    if (hasExports) {\n        log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logMissingGlobalName)(chunk.id, chunk.variableName));\n        return chunk.variableName;\n    }\n}\nclass Chunk {\n    constructor(orderedModules, inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, externalChunkByModule, facadeChunkByModule, includedNamespaces, manualChunkAlias, getPlaceholder, bundle, inputBase, snippets) {\n        this.orderedModules = orderedModules;\n        this.inputOptions = inputOptions;\n        this.outputOptions = outputOptions;\n        this.unsetOptions = unsetOptions;\n        this.pluginDriver = pluginDriver;\n        this.modulesById = modulesById;\n        this.chunkByModule = chunkByModule;\n        this.externalChunkByModule = externalChunkByModule;\n        this.facadeChunkByModule = facadeChunkByModule;\n        this.includedNamespaces = includedNamespaces;\n        this.manualChunkAlias = manualChunkAlias;\n        this.getPlaceholder = getPlaceholder;\n        this.bundle = bundle;\n        this.inputBase = inputBase;\n        this.snippets = snippets;\n        this.entryModules = [];\n        this.exportMode = 'named';\n        this.facadeModule = null;\n        this.namespaceVariableName = '';\n        this.variableName = '';\n        this.accessedGlobalsByScope = new Map();\n        this.dependencies = new Set();\n        this.dynamicEntryModules = [];\n        this.dynamicName = null;\n        this.exportNamesByVariable = new Map();\n        this.exports = new Set();\n        this.exportsByName = new Map();\n        this.fileName = null;\n        this.implicitEntryModules = [];\n        this.implicitlyLoadedBefore = new Set();\n        this.imports = new Set();\n        this.includedDynamicImports = null;\n        this.includedReexportsByModule = new Map();\n        // This may be updated in the constructor\n        this.isEmpty = true;\n        this.name = null;\n        this.needsExportsShim = false;\n        this.preRenderedChunkInfo = null;\n        this.preliminaryFileName = null;\n        this.preliminarySourcemapFileName = null;\n        this.renderedChunkInfo = null;\n        this.renderedDependencies = null;\n        this.renderedModules = Object.create(null);\n        this.sortedExportNames = null;\n        this.strictFacade = false;\n        this.execIndex = orderedModules.length > 0 ? orderedModules[0].execIndex : Infinity;\n        const chunkModules = new Set(orderedModules);\n        for (const module of orderedModules) {\n            chunkByModule.set(module, this);\n            if (module.namespace.included && !outputOptions.preserveModules) {\n                includedNamespaces.add(module);\n            }\n            if (this.isEmpty && module.isIncluded()) {\n                this.isEmpty = false;\n            }\n            if (module.info.isEntry || outputOptions.preserveModules) {\n                this.entryModules.push(module);\n            }\n            for (const importer of module.includedDynamicImporters) {\n                if (!chunkModules.has(importer)) {\n                    this.dynamicEntryModules.push(module);\n                    // Modules with synthetic exports need an artificial namespace for dynamic imports\n                    if (module.info.syntheticNamedExports) {\n                        includedNamespaces.add(module);\n                        this.exports.add(module.namespace);\n                    }\n                }\n            }\n            if (module.implicitlyLoadedAfter.size > 0) {\n                this.implicitEntryModules.push(module);\n            }\n        }\n        this.suggestedVariableName = makeLegal(this.generateVariableName());\n    }\n    static generateFacade(inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, externalChunkByModule, facadeChunkByModule, includedNamespaces, facadedModule, facadeName, getPlaceholder, bundle, inputBase, snippets) {\n        const chunk = new Chunk([], inputOptions, outputOptions, unsetOptions, pluginDriver, modulesById, chunkByModule, externalChunkByModule, facadeChunkByModule, includedNamespaces, null, getPlaceholder, bundle, inputBase, snippets);\n        chunk.assignFacadeName(facadeName, facadedModule);\n        if (!facadeChunkByModule.has(facadedModule)) {\n            facadeChunkByModule.set(facadedModule, chunk);\n        }\n        for (const dependency of facadedModule.getDependenciesToBeIncluded()) {\n            chunk.dependencies.add(dependency instanceof Module\n                ? chunkByModule.get(dependency)\n                : externalChunkByModule.get(dependency));\n        }\n        if (!chunk.dependencies.has(chunkByModule.get(facadedModule)) &&\n            facadedModule.info.moduleSideEffects &&\n            facadedModule.hasEffects()) {\n            chunk.dependencies.add(chunkByModule.get(facadedModule));\n        }\n        chunk.ensureReexportsAreAvailableForModule(facadedModule);\n        chunk.facadeModule = facadedModule;\n        chunk.strictFacade = true;\n        return chunk;\n    }\n    canModuleBeFacade(module, exposedVariables) {\n        const moduleExportNamesByVariable = module.getExportNamesByVariable();\n        // All exports of this chunk need to be exposed by the candidate module\n        for (const exposedVariable of this.exports) {\n            if (!moduleExportNamesByVariable.has(exposedVariable)) {\n                return false;\n            }\n        }\n        // Additionally, we need to expose namespaces of dynamic entries that are not the facade module and exports from other entry modules\n        for (const exposedVariable of exposedVariables) {\n            if (!(exposedVariable.module === module ||\n                moduleExportNamesByVariable.has(exposedVariable) ||\n                (exposedVariable instanceof SyntheticNamedExportVariable &&\n                    moduleExportNamesByVariable.has(exposedVariable.getBaseVariable())))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    finalizeChunk(code, map, sourcemapFileName, hashesByPlaceholder) {\n        const renderedChunkInfo = this.getRenderedChunkInfo();\n        const finalize = (code) => replacePlaceholders(code, hashesByPlaceholder);\n        const preliminaryFileName = renderedChunkInfo.fileName;\n        const fileName = (this.fileName = finalize(preliminaryFileName));\n        return {\n            ...renderedChunkInfo,\n            code,\n            dynamicImports: renderedChunkInfo.dynamicImports.map(finalize),\n            fileName,\n            implicitlyLoadedBefore: renderedChunkInfo.implicitlyLoadedBefore.map(finalize),\n            importedBindings: Object.fromEntries(Object.entries(renderedChunkInfo.importedBindings).map(([fileName, bindings]) => [\n                finalize(fileName),\n                bindings\n            ])),\n            imports: renderedChunkInfo.imports.map(finalize),\n            map,\n            preliminaryFileName,\n            referencedFiles: renderedChunkInfo.referencedFiles.map(finalize),\n            sourcemapFileName\n        };\n    }\n    generateExports() {\n        this.sortedExportNames = null;\n        const remainingExports = new Set(this.exports);\n        if (this.facadeModule !== null &&\n            (this.facadeModule.preserveSignature !== false || this.strictFacade)) {\n            const exportNamesByVariable = this.facadeModule.getExportNamesByVariable();\n            for (const [variable, exportNames] of exportNamesByVariable) {\n                this.exportNamesByVariable.set(variable, [...exportNames]);\n                for (const exportName of exportNames) {\n                    this.exportsByName.set(exportName, variable);\n                }\n                remainingExports.delete(variable);\n            }\n        }\n        if (this.outputOptions.minifyInternalExports) {\n            assignExportsToMangledNames(remainingExports, this.exportsByName, this.exportNamesByVariable);\n        }\n        else {\n            assignExportsToNames(remainingExports, this.exportsByName, this.exportNamesByVariable);\n        }\n        if (this.outputOptions.preserveModules || (this.facadeModule && this.facadeModule.info.isEntry))\n            this.exportMode = getExportMode(this, this.outputOptions, this.facadeModule.id, this.inputOptions.onLog);\n    }\n    generateFacades() {\n        const facades = [];\n        const entryModules = new Set([...this.entryModules, ...this.implicitEntryModules]);\n        const exposedVariables = new Set(this.dynamicEntryModules.map(({ namespace }) => namespace));\n        for (const module of entryModules) {\n            if (module.preserveSignature) {\n                for (const exportedVariable of module.getExportNamesByVariable().keys()) {\n                    // We need to expose all entry exports from this chunk\n                    if (this.chunkByModule.get(exportedVariable.module) === this) {\n                        exposedVariables.add(exportedVariable);\n                    }\n                }\n            }\n        }\n        for (const module of entryModules) {\n            const requiredFacades = Array.from(new Set(module.chunkNames.filter(({ isUserDefined }) => isUserDefined).map(({ name }) => name)), \n            // mapping must run after Set 'name' dedupe\n            name => ({\n                name\n            }));\n            if (requiredFacades.length === 0 && module.isUserDefinedEntryPoint) {\n                requiredFacades.push({});\n            }\n            requiredFacades.push(...Array.from(module.chunkFileNames, fileName => ({ fileName })));\n            if (requiredFacades.length === 0) {\n                requiredFacades.push({});\n            }\n            if (!this.facadeModule) {\n                const needsStrictFacade = !this.outputOptions.preserveModules &&\n                    (module.preserveSignature === 'strict' ||\n                        (module.preserveSignature === 'exports-only' &&\n                            module.getExportNamesByVariable().size > 0));\n                if (!needsStrictFacade || this.canModuleBeFacade(module, exposedVariables)) {\n                    this.facadeModule = module;\n                    this.facadeChunkByModule.set(module, this);\n                    if (module.preserveSignature) {\n                        this.strictFacade = needsStrictFacade;\n                    }\n                    this.assignFacadeName(requiredFacades.shift(), module, this.outputOptions.preserveModules);\n                }\n            }\n            for (const facadeName of requiredFacades) {\n                facades.push(Chunk.generateFacade(this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.modulesById, this.chunkByModule, this.externalChunkByModule, this.facadeChunkByModule, this.includedNamespaces, module, facadeName, this.getPlaceholder, this.bundle, this.inputBase, this.snippets));\n            }\n        }\n        for (const module of this.dynamicEntryModules) {\n            if (module.info.syntheticNamedExports)\n                continue;\n            if (!this.facadeModule && this.canModuleBeFacade(module, exposedVariables)) {\n                this.facadeModule = module;\n                this.facadeChunkByModule.set(module, this);\n                this.strictFacade = true;\n                this.dynamicName = getChunkNameFromModule(module);\n            }\n            else if (this.facadeModule === module &&\n                !this.strictFacade &&\n                this.canModuleBeFacade(module, exposedVariables)) {\n                this.strictFacade = true;\n            }\n            else if (!this.facadeChunkByModule.get(module)?.strictFacade) {\n                this.includedNamespaces.add(module);\n                this.exports.add(module.namespace);\n            }\n        }\n        if (!this.outputOptions.preserveModules) {\n            this.addNecessaryImportsForFacades();\n        }\n        return facades;\n    }\n    getChunkName() {\n        return (this.name ??= this.outputOptions.sanitizeFileName(this.getFallbackChunkName()));\n    }\n    getExportNames() {\n        return (this.sortedExportNames ??= [...this.exportsByName.keys()].sort());\n    }\n    getFileName() {\n        return this.fileName || this.getPreliminaryFileName().fileName;\n    }\n    getImportPath(importer) {\n        return escapeId((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.getImportPath)(importer, this.getFileName(), this.outputOptions.format === 'amd' && !this.outputOptions.amd.forceJsExtensionForImports, true));\n    }\n    getPreliminaryFileName() {\n        if (this.preliminaryFileName) {\n            return this.preliminaryFileName;\n        }\n        let fileName;\n        let hashPlaceholder = null;\n        const { chunkFileNames, entryFileNames, file, format, preserveModules } = this.outputOptions;\n        if (file) {\n            fileName = (0,node_path__WEBPACK_IMPORTED_MODULE_1__.basename)(file);\n        }\n        else if (this.fileName === null) {\n            const [pattern, patternName] = preserveModules || this.facadeModule?.isUserDefinedEntryPoint\n                ? [entryFileNames, 'output.entryFileNames']\n                : [chunkFileNames, 'output.chunkFileNames'];\n            fileName = renderNamePattern(typeof pattern === 'function' ? pattern(this.getPreRenderedChunkInfo()) : pattern, patternName, {\n                format: () => format,\n                hash: size => hashPlaceholder ||\n                    (hashPlaceholder = this.getPlaceholder(patternName, size || DEFAULT_HASH_SIZE)),\n                name: () => this.getChunkName()\n            });\n            if (!hashPlaceholder) {\n                fileName = makeUnique(fileName, this.bundle);\n            }\n        }\n        else {\n            fileName = this.fileName;\n        }\n        if (!hashPlaceholder) {\n            this.bundle[fileName] = FILE_PLACEHOLDER;\n        }\n        // Caching is essential to not conflict with the file name reservation above\n        return (this.preliminaryFileName = { fileName, hashPlaceholder });\n    }\n    getPreliminarySourcemapFileName() {\n        if (this.preliminarySourcemapFileName) {\n            return this.preliminarySourcemapFileName;\n        }\n        let sourcemapFileName = null;\n        let hashPlaceholder = null;\n        const { sourcemapFileNames, format } = this.outputOptions;\n        if (sourcemapFileNames) {\n            const [pattern, patternName] = [sourcemapFileNames, 'output.sourcemapFileNames'];\n            sourcemapFileName = renderNamePattern(typeof pattern === 'function' ? pattern(this.getPreRenderedChunkInfo()) : pattern, patternName, {\n                chunkhash: () => this.getPreliminaryFileName().hashPlaceholder || '',\n                format: () => format,\n                hash: size => hashPlaceholder ||\n                    (hashPlaceholder = this.getPlaceholder(patternName, size || DEFAULT_HASH_SIZE)),\n                name: () => this.getChunkName()\n            });\n            if (!hashPlaceholder) {\n                sourcemapFileName = makeUnique(sourcemapFileName, this.bundle);\n            }\n        }\n        else {\n            return null;\n        }\n        return (this.preliminarySourcemapFileName = { fileName: sourcemapFileName, hashPlaceholder });\n    }\n    getRenderedChunkInfo() {\n        if (this.renderedChunkInfo) {\n            return this.renderedChunkInfo;\n        }\n        return (this.renderedChunkInfo = {\n            ...this.getPreRenderedChunkInfo(),\n            dynamicImports: this.getDynamicDependencies().map(resolveFileName),\n            fileName: this.getFileName(),\n            implicitlyLoadedBefore: Array.from(this.implicitlyLoadedBefore, resolveFileName),\n            importedBindings: getImportedBindingsPerDependency(this.getRenderedDependencies(), resolveFileName),\n            imports: Array.from(this.dependencies, resolveFileName),\n            modules: this.renderedModules,\n            referencedFiles: this.getReferencedFiles()\n        });\n    }\n    getVariableExportName(variable) {\n        if (this.outputOptions.preserveModules && variable instanceof NamespaceVariable) {\n            return '*';\n        }\n        return this.exportNamesByVariable.get(variable)[0];\n    }\n    link() {\n        this.dependencies = getStaticDependencies(this, this.orderedModules, this.chunkByModule, this.externalChunkByModule);\n        for (const module of this.orderedModules) {\n            this.addImplicitlyLoadedBeforeFromModule(module);\n            this.setUpChunkImportsAndExportsForModule(module);\n        }\n    }\n    async render() {\n        const { dependencies, exportMode, facadeModule, inputOptions: { onLog }, outputOptions, pluginDriver, snippets } = this;\n        const { format, hoistTransitiveImports, preserveModules } = outputOptions;\n        // for static and dynamic entry points, add transitive dependencies to this\n        // chunk's dependencies to avoid loading latency\n        if (hoistTransitiveImports && !preserveModules && facadeModule !== null) {\n            for (const dep of dependencies) {\n                if (dep instanceof Chunk)\n                    this.inlineChunkDependencies(dep);\n            }\n        }\n        const preliminaryFileName = this.getPreliminaryFileName();\n        const preliminarySourcemapFileName = this.getPreliminarySourcemapFileName();\n        const { accessedGlobals, indent, magicString, renderedSource, usedModules, usesTopLevelAwait } = this.renderModules(preliminaryFileName.fileName);\n        const renderedDependencies = [...this.getRenderedDependencies().values()];\n        const renderedExports = exportMode === 'none' ? [] : this.getChunkExportDeclarations(format);\n        let hasExports = renderedExports.length > 0;\n        let hasDefaultExport = false;\n        for (const renderedDependency of renderedDependencies) {\n            const { reexports } = renderedDependency;\n            if (reexports?.length) {\n                hasExports = true;\n                if (!hasDefaultExport && reexports.some(reexport => reexport.reexported === 'default')) {\n                    hasDefaultExport = true;\n                }\n                if (format === 'es') {\n                    renderedDependency.reexports = reexports.filter(({ reexported }) => !renderedExports.find(({ exported }) => exported === reexported));\n                }\n            }\n        }\n        if (!hasDefaultExport) {\n            for (const { exported } of renderedExports) {\n                if (exported === 'default') {\n                    hasDefaultExport = true;\n                    break;\n                }\n            }\n        }\n        const { intro, outro, banner, footer } = await createAddons(outputOptions, pluginDriver, this.getRenderedChunkInfo());\n        finalisers[format](renderedSource, {\n            accessedGlobals,\n            dependencies: renderedDependencies,\n            exports: renderedExports,\n            hasDefaultExport,\n            hasExports,\n            id: preliminaryFileName.fileName,\n            indent,\n            intro,\n            isEntryFacade: preserveModules || (facadeModule !== null && facadeModule.info.isEntry),\n            isModuleFacade: facadeModule !== null,\n            log: onLog,\n            namedExportsMode: exportMode !== 'default',\n            outro,\n            snippets,\n            usesTopLevelAwait\n        }, outputOptions);\n        if (banner)\n            magicString.prepend(banner);\n        if (format === 'es' || format === 'cjs') {\n            const shebang = facadeModule !== null && facadeModule.info.isEntry && facadeModule.shebang;\n            if (shebang) {\n                magicString.prepend(`#!${shebang}\\n`);\n            }\n        }\n        if (footer)\n            magicString.append(footer);\n        return {\n            chunk: this,\n            magicString,\n            preliminaryFileName,\n            preliminarySourcemapFileName,\n            usedModules\n        };\n    }\n    addImplicitlyLoadedBeforeFromModule(baseModule) {\n        const { chunkByModule, implicitlyLoadedBefore } = this;\n        for (const module of baseModule.implicitlyLoadedBefore) {\n            const chunk = chunkByModule.get(module);\n            if (chunk && chunk !== this) {\n                implicitlyLoadedBefore.add(chunk);\n            }\n        }\n    }\n    addNecessaryImportsForFacades() {\n        for (const [module, variables] of this.includedReexportsByModule) {\n            if (this.includedNamespaces.has(module)) {\n                for (const variable of variables) {\n                    this.imports.add(variable);\n                }\n            }\n        }\n    }\n    assignFacadeName({ fileName, name }, facadedModule, preservePath) {\n        if (fileName) {\n            this.fileName = fileName;\n        }\n        else {\n            this.name = this.outputOptions.sanitizeFileName(name ||\n                (preservePath\n                    ? this.getPreserveModulesChunkNameFromModule(facadedModule)\n                    : getChunkNameFromModule(facadedModule)));\n        }\n    }\n    checkCircularDependencyImport(variable, importingModule) {\n        const variableModule = variable.module;\n        if (variableModule instanceof Module) {\n            const exportChunk = this.chunkByModule.get(variableModule);\n            let alternativeReexportModule;\n            do {\n                alternativeReexportModule = importingModule.alternativeReexportModules.get(variable);\n                if (alternativeReexportModule) {\n                    const exportingChunk = this.chunkByModule.get(alternativeReexportModule);\n                    if (exportingChunk !== exportChunk) {\n                        this.inputOptions.onLog(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logCyclicCrossChunkReexport)(\n                        // Namespaces do not have an export name\n                        variableModule.getExportNamesByVariable().get(variable)?.[0] || '*', variableModule.id, alternativeReexportModule.id, importingModule.id, this.outputOptions.preserveModules));\n                    }\n                    importingModule = alternativeReexportModule;\n                }\n            } while (alternativeReexportModule);\n        }\n    }\n    ensureReexportsAreAvailableForModule(module) {\n        const includedReexports = [];\n        const map = module.getExportNamesByVariable();\n        for (const exportedVariable of map.keys()) {\n            const isSynthetic = exportedVariable instanceof SyntheticNamedExportVariable;\n            const importedVariable = isSynthetic ? exportedVariable.getBaseVariable() : exportedVariable;\n            this.checkCircularDependencyImport(importedVariable, module);\n            // When preserving modules, we do not create namespace objects but directly\n            // use the actual namespaces, which would be broken by this logic.\n            if (!(importedVariable instanceof NamespaceVariable && this.outputOptions.preserveModules)) {\n                const exportingModule = importedVariable.module;\n                if (exportingModule instanceof Module) {\n                    const chunk = this.chunkByModule.get(exportingModule);\n                    if (chunk && chunk !== this) {\n                        chunk.exports.add(importedVariable);\n                        includedReexports.push(importedVariable);\n                        if (isSynthetic) {\n                            this.imports.add(importedVariable);\n                        }\n                    }\n                }\n            }\n        }\n        if (includedReexports.length > 0) {\n            this.includedReexportsByModule.set(module, includedReexports);\n        }\n    }\n    generateVariableName() {\n        if (this.manualChunkAlias) {\n            return this.manualChunkAlias;\n        }\n        const moduleForNaming = this.entryModules[0] ||\n            this.implicitEntryModules[0] ||\n            this.dynamicEntryModules[0] ||\n            this.orderedModules[this.orderedModules.length - 1];\n        if (moduleForNaming) {\n            return getChunkNameFromModule(moduleForNaming);\n        }\n        return 'chunk';\n    }\n    getChunkExportDeclarations(format) {\n        const exports = [];\n        for (const exportName of this.getExportNames()) {\n            if (exportName[0] === '*')\n                continue;\n            const variable = this.exportsByName.get(exportName);\n            if (!(variable instanceof SyntheticNamedExportVariable)) {\n                const module = variable.module;\n                if (module) {\n                    const chunk = this.chunkByModule.get(module);\n                    if (chunk !== this) {\n                        if (!chunk || format !== 'es') {\n                            continue;\n                        }\n                        const chunkDep = this.renderedDependencies.get(chunk);\n                        if (!chunkDep) {\n                            continue;\n                        }\n                        const { imports, reexports } = chunkDep;\n                        const importedByReexported = reexports?.find(({ reexported }) => reexported === exportName);\n                        const isImported = imports?.find(({ imported }) => imported === importedByReexported?.imported);\n                        if (!isImported) {\n                            continue;\n                        }\n                    }\n                }\n            }\n            let expression = null;\n            let hoisted = false;\n            let local = variable.getName(this.snippets.getPropertyAccess);\n            if (variable instanceof LocalVariable) {\n                for (const declaration of variable.declarations) {\n                    if (declaration.parent instanceof FunctionDeclaration ||\n                        (declaration instanceof ExportDefaultDeclaration &&\n                            declaration.declaration instanceof FunctionDeclaration)) {\n                        hoisted = true;\n                        break;\n                    }\n                }\n            }\n            else if (variable instanceof SyntheticNamedExportVariable) {\n                expression = local;\n                if (format === 'es') {\n                    local = variable.renderName;\n                }\n            }\n            exports.push({\n                exported: exportName,\n                expression,\n                hoisted,\n                local\n            });\n        }\n        return exports;\n    }\n    getDependenciesToBeDeconflicted(addNonNamespacesAndInteropHelpers, addDependenciesWithoutBindings, interop) {\n        const dependencies = new Set();\n        const deconflictedDefault = new Set();\n        const deconflictedNamespace = new Set();\n        for (const variable of [...this.exportNamesByVariable.keys(), ...this.imports]) {\n            if (addNonNamespacesAndInteropHelpers || variable.isNamespace) {\n                const module = variable.module;\n                if (module instanceof ExternalModule) {\n                    const chunk = this.externalChunkByModule.get(module);\n                    dependencies.add(chunk);\n                    if (addNonNamespacesAndInteropHelpers) {\n                        if (variable.name === 'default') {\n                            if (defaultInteropHelpersByInteropType[interop(module.id)]) {\n                                deconflictedDefault.add(chunk);\n                            }\n                        }\n                        else if (variable.isNamespace &&\n                            namespaceInteropHelpersByInteropType[interop(module.id)] &&\n                            (this.imports.has(variable) ||\n                                !this.exportNamesByVariable.get(variable)?.every(name => name.startsWith('*')))) {\n                            // We only need to deconflict it if the namespace is actually\n                            // created as a variable, i.e. because it is used internally or\n                            // because it is reexported as an object\n                            deconflictedNamespace.add(chunk);\n                        }\n                    }\n                }\n                else {\n                    const chunk = this.chunkByModule.get(module);\n                    if (chunk !== this) {\n                        dependencies.add(chunk);\n                        if (addNonNamespacesAndInteropHelpers &&\n                            chunk.exportMode === 'default' &&\n                            variable.isNamespace) {\n                            deconflictedNamespace.add(chunk);\n                        }\n                    }\n                }\n            }\n        }\n        if (addDependenciesWithoutBindings) {\n            for (const dependency of this.dependencies) {\n                dependencies.add(dependency);\n            }\n        }\n        return { deconflictedDefault, deconflictedNamespace, dependencies };\n    }\n    getDynamicDependencies() {\n        return this.getIncludedDynamicImports()\n            .map(resolvedDynamicImport => resolvedDynamicImport.facadeChunk ||\n            resolvedDynamicImport.chunk ||\n            resolvedDynamicImport.externalChunk ||\n            resolvedDynamicImport.resolution)\n            .filter((resolution) => resolution !== this &&\n            (resolution instanceof Chunk || resolution instanceof ExternalChunk));\n    }\n    getDynamicImportStringAndAttributes(resolution, fileName) {\n        if (resolution instanceof ExternalModule) {\n            const chunk = this.externalChunkByModule.get(resolution);\n            return [`'${chunk.getImportPath(fileName)}'`, chunk.getImportAttributes(this.snippets)];\n        }\n        return [\n            resolution || '',\n            (this.outputOptions.format === 'es' && this.outputOptions.externalImportAttributes) || null\n        ];\n    }\n    getFallbackChunkName() {\n        if (this.manualChunkAlias) {\n            return this.manualChunkAlias;\n        }\n        if (this.dynamicName) {\n            return this.dynamicName;\n        }\n        if (this.fileName) {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.getAliasName)(this.fileName);\n        }\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.getAliasName)(this.orderedModules[this.orderedModules.length - 1].id);\n    }\n    getImportSpecifiers() {\n        const { interop } = this.outputOptions;\n        const importsByDependency = new Map();\n        for (const variable of this.imports) {\n            const module = variable.module;\n            let dependency;\n            let imported;\n            if (module instanceof ExternalModule) {\n                dependency = this.externalChunkByModule.get(module);\n                imported = variable.name;\n                if (imported !== 'default' && imported !== '*' && interop(module.id) === 'defaultOnly') {\n                    return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logUnexpectedNamedImport)(module.id, imported, false));\n                }\n            }\n            else {\n                dependency = this.chunkByModule.get(module);\n                imported = dependency.getVariableExportName(variable);\n            }\n            getOrCreate(importsByDependency, dependency, getNewArray).push({\n                imported,\n                local: variable.getName(this.snippets.getPropertyAccess)\n            });\n        }\n        return importsByDependency;\n    }\n    getIncludedDynamicImports() {\n        if (this.includedDynamicImports) {\n            return this.includedDynamicImports;\n        }\n        const includedDynamicImports = [];\n        for (const module of this.orderedModules) {\n            for (const { node, resolution } of module.dynamicImports) {\n                if (!node.included) {\n                    continue;\n                }\n                includedDynamicImports.push(resolution instanceof Module\n                    ? {\n                        chunk: this.chunkByModule.get(resolution),\n                        externalChunk: null,\n                        facadeChunk: this.facadeChunkByModule.get(resolution),\n                        node,\n                        resolution\n                    }\n                    : resolution instanceof ExternalModule\n                        ? {\n                            chunk: null,\n                            externalChunk: this.externalChunkByModule.get(resolution),\n                            facadeChunk: null,\n                            node,\n                            resolution\n                        }\n                        : { chunk: null, externalChunk: null, facadeChunk: null, node, resolution });\n            }\n        }\n        return (this.includedDynamicImports = includedDynamicImports);\n    }\n    getPreRenderedChunkInfo() {\n        if (this.preRenderedChunkInfo) {\n            return this.preRenderedChunkInfo;\n        }\n        const { dynamicEntryModules, facadeModule, implicitEntryModules, orderedModules } = this;\n        return (this.preRenderedChunkInfo = {\n            exports: this.getExportNames(),\n            facadeModuleId: facadeModule && facadeModule.id,\n            isDynamicEntry: dynamicEntryModules.length > 0,\n            isEntry: !!facadeModule?.info.isEntry,\n            isImplicitEntry: implicitEntryModules.length > 0,\n            moduleIds: orderedModules.map(({ id }) => id),\n            name: this.getChunkName(),\n            type: 'chunk'\n        });\n    }\n    getPreserveModulesChunkNameFromModule(module) {\n        const predefinedChunkName = getPredefinedChunkNameFromModule(module);\n        if (predefinedChunkName)\n            return predefinedChunkName;\n        const { preserveModulesRoot, sanitizeFileName } = this.outputOptions;\n        const sanitizedId = sanitizeFileName((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.normalize)(module.id.split(QUERY_HASH_REGEX, 1)[0]));\n        const extensionName = (0,node_path__WEBPACK_IMPORTED_MODULE_1__.extname)(sanitizedId);\n        const idWithoutExtension = NON_ASSET_EXTENSIONS.has(extensionName)\n            ? sanitizedId.slice(0, -extensionName.length)\n            : sanitizedId;\n        if ((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.isAbsolute)(idWithoutExtension)) {\n            if (preserveModulesRoot && (0,node_path__WEBPACK_IMPORTED_MODULE_1__.resolve)(idWithoutExtension).startsWith(preserveModulesRoot)) {\n                return idWithoutExtension.slice(preserveModulesRoot.length).replace(/^[/\\\\]/, '');\n            }\n            else {\n                // handle edge case in Windows\n                if (this.inputBase === '/' && !idWithoutExtension.startsWith('/')) {\n                    return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.relative)(this.inputBase, idWithoutExtension.replace(/^[a-zA-Z]:[/\\\\]/, '/'));\n                }\n                return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.relative)(this.inputBase, idWithoutExtension);\n            }\n        }\n        else {\n            return (this.outputOptions.virtualDirname.replace(/\\/$/, '') + '/' + (0,node_path__WEBPACK_IMPORTED_MODULE_1__.basename)(idWithoutExtension));\n        }\n    }\n    getReexportSpecifiers() {\n        const { externalLiveBindings, interop } = this.outputOptions;\n        const reexportSpecifiers = new Map();\n        for (let exportName of this.getExportNames()) {\n            let dependency;\n            let imported;\n            let needsLiveBinding = false;\n            if (exportName[0] === '*') {\n                const id = exportName.slice(1);\n                if (interop(id) === 'defaultOnly') {\n                    this.inputOptions.onLog(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logUnexpectedNamespaceReexport)(id));\n                }\n                needsLiveBinding = externalLiveBindings;\n                dependency = this.externalChunkByModule.get(this.modulesById.get(id));\n                imported = exportName = '*';\n            }\n            else {\n                const variable = this.exportsByName.get(exportName);\n                if (variable instanceof SyntheticNamedExportVariable)\n                    continue;\n                const module = variable.module;\n                if (module instanceof Module) {\n                    dependency = this.chunkByModule.get(module);\n                    if (dependency === this)\n                        continue;\n                    imported = dependency.getVariableExportName(variable);\n                    needsLiveBinding = variable.isReassigned;\n                }\n                else {\n                    dependency = this.externalChunkByModule.get(module);\n                    imported = variable.name;\n                    if (imported !== 'default' && imported !== '*' && interop(module.id) === 'defaultOnly') {\n                        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logUnexpectedNamedImport)(module.id, imported, true));\n                    }\n                    needsLiveBinding =\n                        externalLiveBindings &&\n                            (imported !== 'default' || isDefaultAProperty(interop(module.id), true));\n                }\n            }\n            getOrCreate(reexportSpecifiers, dependency, getNewArray).push({\n                imported,\n                needsLiveBinding,\n                reexported: exportName\n            });\n        }\n        return reexportSpecifiers;\n    }\n    getReferencedFiles() {\n        const referencedFiles = new Set();\n        for (const module of this.orderedModules) {\n            for (const meta of module.importMetas) {\n                const fileName = meta.getReferencedFileName(this.pluginDriver);\n                if (fileName) {\n                    referencedFiles.add(fileName);\n                }\n            }\n        }\n        return [...referencedFiles];\n    }\n    getRenderedDependencies() {\n        if (this.renderedDependencies) {\n            return this.renderedDependencies;\n        }\n        const importSpecifiers = this.getImportSpecifiers();\n        const reexportSpecifiers = this.getReexportSpecifiers();\n        const renderedDependencies = new Map();\n        const fileName = this.getFileName();\n        for (const dependency of this.dependencies) {\n            const imports = importSpecifiers.get(dependency) || null;\n            const reexports = reexportSpecifiers.get(dependency) || null;\n            const namedExportsMode = dependency instanceof ExternalChunk || dependency.exportMode !== 'default';\n            const importPath = dependency.getImportPath(fileName);\n            renderedDependencies.set(dependency, {\n                attributes: dependency instanceof ExternalChunk\n                    ? dependency.getImportAttributes(this.snippets)\n                    : null,\n                defaultVariableName: dependency.defaultVariableName,\n                globalName: dependency instanceof ExternalChunk &&\n                    (this.outputOptions.format === 'umd' || this.outputOptions.format === 'iife') &&\n                    getGlobalName(dependency, this.outputOptions.globals, (imports || reexports) !== null, this.inputOptions.onLog),\n                importPath,\n                imports,\n                isChunk: dependency instanceof Chunk,\n                name: dependency.variableName,\n                namedExportsMode,\n                namespaceVariableName: dependency.namespaceVariableName,\n                reexports\n            });\n        }\n        return (this.renderedDependencies = renderedDependencies);\n    }\n    inlineChunkDependencies(chunk) {\n        for (const dep of chunk.dependencies) {\n            if (this.dependencies.has(dep))\n                continue;\n            this.dependencies.add(dep);\n            if (dep instanceof Chunk) {\n                this.inlineChunkDependencies(dep);\n            }\n        }\n    }\n    // This method changes properties on the AST before rendering and must not be async\n    renderModules(fileName) {\n        const { accessedGlobalsByScope, dependencies, exportNamesByVariable, includedNamespaces, inputOptions: { onLog }, isEmpty, orderedModules, outputOptions, pluginDriver, renderedModules, snippets } = this;\n        const { compact, format, freeze, generatedCode: { symbols } } = outputOptions;\n        const { _, cnst, n } = snippets;\n        this.setDynamicImportResolutions(fileName);\n        this.setImportMetaResolutions(fileName);\n        this.setIdentifierRenderResolutions();\n        const magicString = new Bundle$1({ separator: `${n}${n}` });\n        const indent = getIndentString(orderedModules, outputOptions);\n        const usedModules = [];\n        let hoistedSource = '';\n        const accessedGlobals = new Set();\n        const renderedModuleSources = new Map();\n        const renderOptions = {\n            accessedDocumentCurrentScript: false,\n            exportNamesByVariable,\n            format,\n            freeze,\n            indent,\n            pluginDriver,\n            snippets,\n            symbols,\n            useOriginalName: null\n        };\n        let usesTopLevelAwait = false;\n        for (const module of orderedModules) {\n            let renderedLength = 0;\n            let source;\n            if (module.isIncluded() || includedNamespaces.has(module)) {\n                const rendered = module.render(renderOptions);\n                if (!renderOptions.accessedDocumentCurrentScript &&\n                    formatsMaybeAccessDocumentCurrentScript.includes(format)) {\n                    this.accessedGlobalsByScope.get(module.scope)?.delete(DOCUMENT_CURRENT_SCRIPT);\n                }\n                renderOptions.accessedDocumentCurrentScript = false;\n                ({ source } = rendered);\n                usesTopLevelAwait ||= rendered.usesTopLevelAwait;\n                renderedLength = source.length();\n                if (renderedLength) {\n                    if (compact && source.lastLine().includes('//'))\n                        source.append('\\n');\n                    renderedModuleSources.set(module, source);\n                    magicString.addSource(source);\n                    usedModules.push(module);\n                }\n                const namespace = module.namespace;\n                if (includedNamespaces.has(module)) {\n                    const rendered = namespace.renderBlock(renderOptions);\n                    if (namespace.renderFirst())\n                        hoistedSource += n + rendered;\n                    else\n                        magicString.addSource(new MagicString(rendered));\n                }\n                const accessedGlobalVariables = accessedGlobalsByScope.get(module.scope);\n                if (accessedGlobalVariables) {\n                    for (const name of accessedGlobalVariables) {\n                        accessedGlobals.add(name);\n                    }\n                }\n            }\n            const { renderedExports, removedExports } = module.getRenderedExports();\n            renderedModules[module.id] = {\n                get code() {\n                    return source?.toString() ?? null;\n                },\n                originalLength: module.originalCode.length,\n                removedExports,\n                renderedExports,\n                renderedLength\n            };\n        }\n        if (hoistedSource)\n            magicString.prepend(hoistedSource + n + n);\n        if (this.needsExportsShim) {\n            magicString.prepend(`${n}${cnst} ${MISSING_EXPORT_SHIM_VARIABLE}${_}=${_}void 0;${n}${n}`);\n        }\n        const renderedSource = compact ? magicString : magicString.trim();\n        if (isEmpty && this.getExportNames().length === 0 && dependencies.size === 0) {\n            onLog(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logEmptyChunk)(this.getChunkName()));\n        }\n        return { accessedGlobals, indent, magicString, renderedSource, usedModules, usesTopLevelAwait };\n    }\n    setDynamicImportResolutions(fileName) {\n        const { accessedGlobalsByScope, outputOptions, pluginDriver, snippets } = this;\n        for (const resolvedDynamicImport of this.getIncludedDynamicImports()) {\n            if (resolvedDynamicImport.chunk) {\n                const { chunk, facadeChunk, node, resolution } = resolvedDynamicImport;\n                if (chunk === this) {\n                    node.setInternalResolution(resolution.namespace);\n                }\n                else {\n                    node.setExternalResolution((facadeChunk || chunk).exportMode, resolution, outputOptions, snippets, pluginDriver, accessedGlobalsByScope, `'${(facadeChunk || chunk).getImportPath(fileName)}'`, !facadeChunk?.strictFacade && chunk.exportNamesByVariable.get(resolution.namespace)[0], null);\n                }\n            }\n            else {\n                const { node, resolution } = resolvedDynamicImport;\n                const [resolutionString, attributes] = this.getDynamicImportStringAndAttributes(resolution, fileName);\n                node.setExternalResolution('external', resolution, outputOptions, snippets, pluginDriver, accessedGlobalsByScope, resolutionString, false, attributes);\n            }\n        }\n    }\n    setIdentifierRenderResolutions() {\n        const { format, generatedCode: { symbols }, interop, preserveModules, externalLiveBindings } = this.outputOptions;\n        const syntheticExports = new Set();\n        for (const exportName of this.getExportNames()) {\n            const exportVariable = this.exportsByName.get(exportName);\n            if (format !== 'es' &&\n                format !== 'system' &&\n                exportVariable.isReassigned &&\n                !exportVariable.isId) {\n                exportVariable.setRenderNames('exports', exportName);\n            }\n            else if (exportVariable instanceof SyntheticNamedExportVariable) {\n                syntheticExports.add(exportVariable);\n            }\n            else {\n                exportVariable.setRenderNames(null, null);\n            }\n        }\n        for (const module of this.orderedModules) {\n            if (module.needsExportShim) {\n                this.needsExportsShim = true;\n                break;\n            }\n        }\n        const usedNames = new Set(['Object', 'Promise']);\n        if (this.needsExportsShim) {\n            usedNames.add(MISSING_EXPORT_SHIM_VARIABLE);\n        }\n        if (symbols) {\n            usedNames.add('Symbol');\n        }\n        switch (format) {\n            case 'system': {\n                usedNames.add('module').add('exports');\n                break;\n            }\n            case 'es': {\n                break;\n            }\n            case 'cjs': {\n                usedNames.add('module').add('require').add('__filename').add('__dirname');\n            }\n            // fallthrough\n            default: {\n                usedNames.add('exports');\n                for (const helper of HELPER_NAMES) {\n                    usedNames.add(helper);\n                }\n            }\n        }\n        deconflictChunk(this.orderedModules, this.getDependenciesToBeDeconflicted(format !== 'es' && format !== 'system', format === 'amd' || format === 'umd' || format === 'iife', interop), this.imports, usedNames, format, interop, preserveModules, externalLiveBindings, this.chunkByModule, this.externalChunkByModule, syntheticExports, this.exportNamesByVariable, this.accessedGlobalsByScope, this.includedNamespaces);\n    }\n    setImportMetaResolutions(fileName) {\n        const { accessedGlobalsByScope, includedNamespaces, orderedModules, outputOptions: { format } } = this;\n        for (const module of orderedModules) {\n            for (const importMeta of module.importMetas) {\n                importMeta.setResolution(format, accessedGlobalsByScope, fileName);\n            }\n            if (includedNamespaces.has(module)) {\n                module.namespace.prepare(accessedGlobalsByScope);\n            }\n        }\n    }\n    setUpChunkImportsAndExportsForModule(module) {\n        const moduleImports = new Set(module.includedImports);\n        // when we are not preserving modules, we need to make all namespace variables available for\n        // rendering the namespace object\n        if (!this.outputOptions.preserveModules && this.includedNamespaces.has(module)) {\n            const memberVariables = module.namespace.getMemberVariables();\n            for (const variable of Object.values(memberVariables)) {\n                if (variable.included) {\n                    moduleImports.add(variable);\n                }\n            }\n        }\n        for (let variable of moduleImports) {\n            if (variable instanceof ExportDefaultVariable) {\n                variable = variable.getOriginalVariable();\n            }\n            if (variable instanceof SyntheticNamedExportVariable) {\n                variable = variable.getBaseVariable();\n            }\n            const chunk = this.chunkByModule.get(variable.module);\n            if (chunk !== this) {\n                this.imports.add(variable);\n                if (variable.module instanceof Module) {\n                    this.checkCircularDependencyImport(variable, module);\n                    // When preserving modules, we do not create namespace objects but directly\n                    // use the actual namespaces, which would be broken by this logic.\n                    if (!(variable instanceof NamespaceVariable && this.outputOptions.preserveModules)) {\n                        chunk.exports.add(variable);\n                    }\n                }\n            }\n        }\n        if (this.includedNamespaces.has(module) ||\n            (module.info.isEntry && module.preserveSignature !== false) ||\n            module.includedDynamicImporters.some(importer => this.chunkByModule.get(importer) !== this)) {\n            this.ensureReexportsAreAvailableForModule(module);\n        }\n        for (const { node, resolution } of module.dynamicImports) {\n            if (node.included &&\n                resolution instanceof Module &&\n                this.chunkByModule.get(resolution) === this &&\n                !this.includedNamespaces.has(resolution)) {\n                this.includedNamespaces.add(resolution);\n                this.ensureReexportsAreAvailableForModule(resolution);\n            }\n        }\n    }\n}\nfunction getChunkNameFromModule(module) {\n    return getPredefinedChunkNameFromModule(module) ?? (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.getAliasName)(module.id);\n}\nfunction getPredefinedChunkNameFromModule(module) {\n    return (module.chunkNames.find(({ isUserDefined }) => isUserDefined)?.name ?? module.chunkNames[0]?.name);\n}\nfunction getImportedBindingsPerDependency(renderedDependencies, resolveFileName) {\n    const importedBindingsPerDependency = {};\n    for (const [dependency, declaration] of renderedDependencies) {\n        const specifiers = new Set();\n        if (declaration.imports) {\n            for (const { imported } of declaration.imports) {\n                specifiers.add(imported);\n            }\n        }\n        if (declaration.reexports) {\n            for (const { imported } of declaration.reexports) {\n                specifiers.add(imported);\n            }\n        }\n        importedBindingsPerDependency[resolveFileName(dependency)] = [...specifiers];\n    }\n    return importedBindingsPerDependency;\n}\nconst QUERY_HASH_REGEX = /[#?]/;\nconst resolveFileName = (dependency) => dependency.getFileName();\n\n/**\n * Concatenate a number of iterables to a new iterable without fully evaluating\n * their iterators. Useful when e.g. working with large sets or lists and when\n * there is a chance that the iterators will not be fully exhausted.\n */\nfunction* concatLazy(iterables) {\n    for (const iterable of iterables) {\n        yield* iterable;\n    }\n}\n\n/**\n * At its core, the algorithm first starts from each static or dynamic entry\n * point and then assigns that entry point to all modules than can be reached\n * via static imports. We call this the *dependent entry points* of that\n * module.\n *\n * Then we group all modules with the same dependent entry points into chunks\n * as those modules will always be loaded together.\n *\n * One non-trivial optimization we can apply is that dynamic entries are\n * different from static entries in so far as when a dynamic import occurs,\n * some modules are already in memory. If some of these modules are also\n * dependencies of the dynamic entry, then it does not make sense to create a\n * separate chunk for them. Instead, the dynamic import target can load them\n * from the importing chunk.\n *\n * With regard to chunking, if B is implicitly loaded after A, then this can be\n * handled the same way as if there was a dynamic import A => B.\n *\n * Example:\n * Assume A -> B (A imports B), A => C (A dynamically imports C) and C -> B.\n * Then the initial algorithm would assign A into the A chunk, C into the C\n * chunk and B into the AC chunk, i.e. the chunk with the dependent entry\n * points A and C.\n * However we know that C can only be loaded from A, so A and its dependency B\n * must already be in memory when C is loaded. So it is enough to create only\n * two chunks A containing [AB] and C containing [C].\n *\n * So we do not assign the dynamic entry C as dependent entry point to modules\n * that are already loaded.\n *\n * In a more complex example, let us assume that we have entry points X and Y.\n * Further, let us assume\n * X -> A, X -> B, X -> C,\n * Y -> A, Y -> B,\n * A => D,\n * D -> B, D -> C\n * So without dynamic import optimization, the dependent entry points are\n * A: XY, B: DXY, C: DX, D: D, X: X, Y: Y, so we would for now create six\n * chunks.\n *\n * Now D is loaded only after A is loaded. But A is loaded if either X is\n * loaded or Y is loaded. So the modules that are already in memory when D is\n * loaded are the intersection of all modules that X depends on with all\n * modules that Y depends on, which in this case are the modules A and B.\n * We could also say they are all modules that have both X and Y as dependent\n * entry points.\n *\n * So we can remove D as dependent entry point from A and B, which means they\n * both now have only XY as dependent entry points and can be merged into the\n * same chunk.\n *\n * Now let us extend this to the most general case where we have several\n * dynamic importers for one dynamic entry point.\n *\n * In the most general form, it works like this:\n * For each dynamic entry point, we have a number of dynamic importers, which\n * are the modules importing it. Using the previous ideas, we can determine\n * the modules already in memory for each dynamic importer by looking for all\n * modules that have all the dependent entry points of the dynamic importer as\n * dependent entry points.\n * So the modules that are guaranteed to be in memory when the dynamic entry\n * point is loaded are the intersection of the modules already in memory for\n * each dynamic importer.\n *\n * Assuming that A => D and B => D and A has dependent entry points XY and B\n * has dependent entry points YZ, then the modules guaranteed to be in memory\n * are all modules that have at least XYZ as dependent entry points.\n * We call XYZ the *dynamically dependent entry points* of D.\n *\n * Now there is one last case to consider: If one of the dynamically dependent\n * entries is itself a dynamic entry, then any module is in memory that either\n * is a dependency of that dynamic entry or again has the dynamic dependent\n * entries of that dynamic entry as dependent entry points.\n *\n * A naive algorithm for this proved to be costly as it contained an O(n^3)\n * complexity with regard to dynamic entries that blew up for very large\n * projects.\n *\n * If we have an efficient way to do Set operations, an alternative approach\n * would be to instead collect already loaded modules per dynamic entry. And as\n * all chunks from the initial grouping would behave the same, we can instead\n * collect already loaded chunks for a performance improvement.\n *\n * To do that efficiently, need\n * - a Map of dynamic imports per dynamic entry, which contains all dynamic\n *   imports that can be triggered by a dynamic entry\n * - a Map of static dependencies per entry\n * - a Map of already loaded chunks per entry that we initially populate with\n *   empty Sets for static entries and Sets containing all entries for dynamic\n *   entries\n *\n * For efficient operations, we assign each entry a numerical index and\n * represent Sets of Chunks as BigInt values where each chunk corresponds to a\n * bit index. Then the last two maps can be represented as arrays of BigInt\n * values.\n *\n * Then we iterate through each dynamic entry. We set the already loaded modules\n * to the intersection of the previously already loaded modules with the union\n * of the already loaded modules of that chunk with its static dependencies.\n *\n * If the already loaded modules changed, then we use the Map of dynamic imports\n * per dynamic entry to marks all dynamic entry dependencies as \"dirty\" and put\n * them back into the iteration. As an additional optimization, we note for\n * each dynamic entry which dynamic dependent entries have changed and only\n * intersect those entries again on subsequent interations.\n *\n * Then we remove the dynamic entries from the list of dependent entries for\n * those chunks that are already loaded for that dynamic entry and create\n * another round of chunks.\n */\nfunction getChunkAssignments(entries, manualChunkAliasByEntry, minChunkSize, log) {\n    const { chunkDefinitions, modulesInManualChunks } = getChunkDefinitionsFromManualChunks(manualChunkAliasByEntry);\n    const { allEntries, dependentEntriesByModule, dynamicallyDependentEntriesByDynamicEntry, dynamicImportsByEntry } = analyzeModuleGraph(entries);\n    // Each chunk is identified by its position in this array\n    const chunkAtoms = getChunksWithSameDependentEntries(getModulesWithDependentEntries(dependentEntriesByModule, modulesInManualChunks));\n    const staticDependencyAtomsByEntry = getStaticDependencyAtomsByEntry(allEntries, chunkAtoms);\n    // Warning: This will consume dynamicallyDependentEntriesByDynamicEntry.\n    // If we no longer want this, we should make a copy here.\n    const alreadyLoadedAtomsByEntry = getAlreadyLoadedAtomsByEntry(staticDependencyAtomsByEntry, dynamicallyDependentEntriesByDynamicEntry, dynamicImportsByEntry, allEntries);\n    // This mutates the dependentEntries in chunkAtoms\n    removeUnnecessaryDependentEntries(chunkAtoms, alreadyLoadedAtomsByEntry);\n    const { chunks, sideEffectAtoms, sizeByAtom } = getChunksWithSameDependentEntriesAndCorrelatedAtoms(chunkAtoms, staticDependencyAtomsByEntry, alreadyLoadedAtomsByEntry, minChunkSize);\n    chunkDefinitions.push(...getOptimizedChunks(chunks, minChunkSize, sideEffectAtoms, sizeByAtom, log).map(({ modules }) => ({\n        alias: null,\n        modules\n    })));\n    return chunkDefinitions;\n}\nfunction getChunkDefinitionsFromManualChunks(manualChunkAliasByEntry) {\n    const modulesInManualChunks = new Set(manualChunkAliasByEntry.keys());\n    const manualChunkModulesByAlias = Object.create(null);\n    for (const [entry, alias] of manualChunkAliasByEntry) {\n        addStaticDependenciesToManualChunk(entry, (manualChunkModulesByAlias[alias] ||= []), modulesInManualChunks);\n    }\n    const manualChunks = Object.entries(manualChunkModulesByAlias);\n    const chunkDefinitions = new Array(manualChunks.length);\n    let index = 0;\n    for (const [alias, modules] of manualChunks) {\n        chunkDefinitions[index++] = { alias, modules };\n    }\n    return { chunkDefinitions, modulesInManualChunks };\n}\nfunction addStaticDependenciesToManualChunk(entry, manualChunkModules, modulesInManualChunks) {\n    const modulesToHandle = new Set([entry]);\n    for (const module of modulesToHandle) {\n        modulesInManualChunks.add(module);\n        manualChunkModules.push(module);\n        for (const dependency of module.dependencies) {\n            if (!(dependency instanceof ExternalModule || modulesInManualChunks.has(dependency))) {\n                modulesToHandle.add(dependency);\n            }\n        }\n    }\n}\nfunction analyzeModuleGraph(entries) {\n    const dynamicEntryModules = new Set();\n    const dependentEntriesByModule = new Map();\n    const allEntriesSet = new Set(entries);\n    const dynamicImportModulesByEntry = new Array(allEntriesSet.size);\n    let entryIndex = 0;\n    for (const currentEntry of allEntriesSet) {\n        const dynamicImportsForCurrentEntry = new Set();\n        dynamicImportModulesByEntry[entryIndex] = dynamicImportsForCurrentEntry;\n        const modulesToHandle = new Set([currentEntry]);\n        for (const module of modulesToHandle) {\n            getOrCreate(dependentEntriesByModule, module, (getNewSet)).add(entryIndex);\n            for (const dependency of module.getDependenciesToBeIncluded()) {\n                if (!(dependency instanceof ExternalModule)) {\n                    modulesToHandle.add(dependency);\n                }\n            }\n            for (const { resolution } of module.dynamicImports) {\n                if (resolution instanceof Module &&\n                    resolution.includedDynamicImporters.length > 0 &&\n                    !allEntriesSet.has(resolution)) {\n                    dynamicEntryModules.add(resolution);\n                    allEntriesSet.add(resolution);\n                    dynamicImportsForCurrentEntry.add(resolution);\n                }\n            }\n            for (const dependency of module.implicitlyLoadedBefore) {\n                if (!allEntriesSet.has(dependency)) {\n                    dynamicEntryModules.add(dependency);\n                    allEntriesSet.add(dependency);\n                }\n            }\n        }\n        entryIndex++;\n    }\n    const allEntries = [...allEntriesSet];\n    const { dynamicEntries, dynamicImportsByEntry } = getDynamicEntries(allEntries, dynamicEntryModules, dynamicImportModulesByEntry);\n    return {\n        allEntries,\n        dependentEntriesByModule,\n        dynamicallyDependentEntriesByDynamicEntry: getDynamicallyDependentEntriesByDynamicEntry(dependentEntriesByModule, dynamicEntries, allEntries),\n        dynamicImportsByEntry\n    };\n}\nfunction getDynamicEntries(allEntries, dynamicEntryModules, dynamicImportModulesByEntry) {\n    const entryIndexByModule = new Map();\n    const dynamicEntries = new Set();\n    for (const [entryIndex, entry] of allEntries.entries()) {\n        entryIndexByModule.set(entry, entryIndex);\n        if (dynamicEntryModules.has(entry)) {\n            dynamicEntries.add(entryIndex);\n        }\n    }\n    const dynamicImportsByEntry = new Array(dynamicImportModulesByEntry.length);\n    let index = 0;\n    for (const dynamicImportModules of dynamicImportModulesByEntry) {\n        const dynamicImports = new Set();\n        for (const dynamicEntry of dynamicImportModules) {\n            dynamicImports.add(entryIndexByModule.get(dynamicEntry));\n        }\n        dynamicImportsByEntry[index++] = dynamicImports;\n    }\n    return { dynamicEntries, dynamicImportsByEntry };\n}\nfunction getDynamicallyDependentEntriesByDynamicEntry(dependentEntriesByModule, dynamicEntries, allEntries) {\n    const dynamicallyDependentEntriesByDynamicEntry = new Map();\n    for (const dynamicEntryIndex of dynamicEntries) {\n        const dynamicallyDependentEntries = getOrCreate(dynamicallyDependentEntriesByDynamicEntry, dynamicEntryIndex, (getNewSet));\n        const dynamicEntry = allEntries[dynamicEntryIndex];\n        for (const importer of concatLazy([\n            dynamicEntry.includedDynamicImporters,\n            dynamicEntry.implicitlyLoadedAfter\n        ])) {\n            for (const entry of dependentEntriesByModule.get(importer)) {\n                dynamicallyDependentEntries.add(entry);\n            }\n        }\n    }\n    return dynamicallyDependentEntriesByDynamicEntry;\n}\nfunction getChunksWithSameDependentEntries(modulesWithDependentEntries) {\n    const chunkModules = Object.create(null);\n    for (const { dependentEntries, modules } of modulesWithDependentEntries) {\n        let chunkSignature = 0n;\n        for (const entryIndex of dependentEntries) {\n            chunkSignature |= 1n << BigInt(entryIndex);\n        }\n        (chunkModules[String(chunkSignature)] ||= {\n            dependentEntries: new Set(dependentEntries),\n            modules: []\n        }).modules.push(...modules);\n    }\n    return Object.values(chunkModules);\n}\nfunction* getModulesWithDependentEntries(dependentEntriesByModule, modulesInManualChunks) {\n    for (const [module, dependentEntries] of dependentEntriesByModule) {\n        if (!modulesInManualChunks.has(module)) {\n            yield { dependentEntries, modules: [module] };\n        }\n    }\n}\nfunction getStaticDependencyAtomsByEntry(allEntries, chunkAtoms) {\n    // The indices correspond to the indices in allEntries. The atoms correspond\n    // to bits in the bigint values where chunk 0 is the lowest bit.\n    const staticDependencyAtomsByEntry = allEntries.map(() => 0n);\n    // This toggles the bits for each atom that is a dependency of an entry\n    let atomMask = 1n;\n    for (const { dependentEntries } of chunkAtoms) {\n        for (const entryIndex of dependentEntries) {\n            staticDependencyAtomsByEntry[entryIndex] |= atomMask;\n        }\n        atomMask <<= 1n;\n    }\n    return staticDependencyAtomsByEntry;\n}\n// Warning: This will consume dynamicallyDependentEntriesByDynamicEntry.\nfunction getAlreadyLoadedAtomsByEntry(staticDependencyAtomsByEntry, dynamicallyDependentEntriesByDynamicEntry, dynamicImportsByEntry, allEntries) {\n    // Dynamic entries have all atoms as already loaded initially because we then\n    // intersect with the static dependency atoms of all dynamic importers.\n    // Static entries cannot have already loaded atoms.\n    const alreadyLoadedAtomsByEntry = allEntries.map((_entry, entryIndex) => dynamicallyDependentEntriesByDynamicEntry.has(entryIndex) ? -1n : 0n);\n    for (const [dynamicEntryIndex, dynamicallyDependentEntries] of dynamicallyDependentEntriesByDynamicEntry) {\n        // We delete here so that they can be added again if necessary to be handled\n        // again by the loop\n        dynamicallyDependentEntriesByDynamicEntry.delete(dynamicEntryIndex);\n        const knownLoadedAtoms = alreadyLoadedAtomsByEntry[dynamicEntryIndex];\n        let updatedLoadedAtoms = knownLoadedAtoms;\n        for (const entryIndex of dynamicallyDependentEntries) {\n            updatedLoadedAtoms &=\n                staticDependencyAtomsByEntry[entryIndex] | alreadyLoadedAtomsByEntry[entryIndex];\n        }\n        // If the knownLoadedAtoms changed, all dependent dynamic entries need to be\n        // updated again\n        if (updatedLoadedAtoms !== knownLoadedAtoms) {\n            alreadyLoadedAtomsByEntry[dynamicEntryIndex] = updatedLoadedAtoms;\n            for (const dynamicImport of dynamicImportsByEntry[dynamicEntryIndex]) {\n                // If this adds an entry that was deleted before, it will be handled\n                // again. This is the reason why we delete every entry from this map\n                // that we processed.\n                getOrCreate(dynamicallyDependentEntriesByDynamicEntry, dynamicImport, (getNewSet)).add(dynamicEntryIndex);\n            }\n        }\n    }\n    return alreadyLoadedAtomsByEntry;\n}\n/**\n * This removes all unnecessary dynamic entries from the dependentEntries in its\n * first argument if a chunk is already loaded without that entry.\n */\nfunction removeUnnecessaryDependentEntries(chunkAtoms, alreadyLoadedAtomsByEntry) {\n    // Remove entries from dependent entries if a chunk is already loaded without\n    // that entry.\n    let chunkMask = 1n;\n    for (const { dependentEntries } of chunkAtoms) {\n        for (const entryIndex of dependentEntries) {\n            if ((alreadyLoadedAtomsByEntry[entryIndex] & chunkMask) === chunkMask) {\n                dependentEntries.delete(entryIndex);\n            }\n        }\n        chunkMask <<= 1n;\n    }\n}\nfunction getChunksWithSameDependentEntriesAndCorrelatedAtoms(chunkAtoms, staticDependencyAtomsByEntry, alreadyLoadedAtomsByEntry, minChunkSize) {\n    const chunksBySignature = Object.create(null);\n    const chunkByModule = new Map();\n    const sizeByAtom = new Array(chunkAtoms.length);\n    let sideEffectAtoms = 0n;\n    let atomMask = 1n;\n    let index = 0;\n    for (const { dependentEntries, modules } of chunkAtoms) {\n        let chunkSignature = 0n;\n        let correlatedAtoms = -1n;\n        for (const entryIndex of dependentEntries) {\n            chunkSignature |= 1n << BigInt(entryIndex);\n            // Correlated atoms are the atoms that are guaranteed to be loaded as\n            // well when a given atom is loaded. It is the intersection of the already\n            // loaded modules of each chunk merged with its static dependencies.\n            correlatedAtoms &=\n                staticDependencyAtomsByEntry[entryIndex] | alreadyLoadedAtomsByEntry[entryIndex];\n        }\n        const chunk = (chunksBySignature[String(chunkSignature)] ||= {\n            containedAtoms: 0n,\n            correlatedAtoms,\n            dependencies: new Set(),\n            dependentChunks: new Set(),\n            dependentEntries: new Set(dependentEntries),\n            modules: [],\n            pure: true,\n            size: 0\n        });\n        let atomSize = 0;\n        let pure = true;\n        for (const module of modules) {\n            chunkByModule.set(module, chunk);\n            // Unfortunately, we cannot take tree-shaking into account here because\n            // rendering did not happen yet, but we can detect empty modules\n            if (module.isIncluded()) {\n                pure &&= !module.hasEffects();\n                // we use a trivial size for the default minChunkSize to improve\n                // performance\n                atomSize += minChunkSize > 1 ? module.estimateSize() : 1;\n            }\n        }\n        if (!pure) {\n            sideEffectAtoms |= atomMask;\n        }\n        sizeByAtom[index++] = atomSize;\n        chunk.containedAtoms |= atomMask;\n        chunk.modules.push(...modules);\n        chunk.pure &&= pure;\n        chunk.size += atomSize;\n        atomMask <<= 1n;\n    }\n    const chunks = Object.values(chunksBySignature);\n    sideEffectAtoms |= addChunkDependenciesAndGetExternalSideEffectAtoms(chunks, chunkByModule, atomMask);\n    return { chunks, sideEffectAtoms, sizeByAtom };\n}\nfunction addChunkDependenciesAndGetExternalSideEffectAtoms(chunks, chunkByModule, nextAvailableAtomMask) {\n    const signatureByExternalModule = new Map();\n    let externalSideEffectAtoms = 0n;\n    for (const chunk of chunks) {\n        const { dependencies, modules } = chunk;\n        for (const module of modules) {\n            for (const dependency of module.getDependenciesToBeIncluded()) {\n                if (dependency instanceof ExternalModule) {\n                    if (dependency.info.moduleSideEffects) {\n                        const signature = getOrCreate(signatureByExternalModule, dependency, () => {\n                            const signature = nextAvailableAtomMask;\n                            nextAvailableAtomMask <<= 1n;\n                            externalSideEffectAtoms |= signature;\n                            return signature;\n                        });\n                        chunk.containedAtoms |= signature;\n                        chunk.correlatedAtoms |= signature;\n                    }\n                }\n                else {\n                    const dependencyChunk = chunkByModule.get(dependency);\n                    if (dependencyChunk && dependencyChunk !== chunk) {\n                        dependencies.add(dependencyChunk);\n                        dependencyChunk.dependentChunks.add(chunk);\n                    }\n                }\n            }\n        }\n    }\n    return externalSideEffectAtoms;\n}\n/**\n * This function tries to get rid of small chunks by merging them with other\n * chunks.\n *\n * We can only merge chunks safely if after the merge, loading any entry point\n * in any allowed order will not trigger side effects that should not have been\n * triggered. While side effects are usually things like global function calls,\n * global variable mutations or potentially thrown errors, details do not\n * matter here, and we just discern chunks without side effects (pure chunks)\n * from other chunks.\n *\n * As a first step, we assign each pre-generated chunk with side effects a\n * label. I.e. we have side effect \"A\" if the non-pure chunk \"A\" is loaded.\n *\n * Now to determine the side effects of loading a chunk, one also has to take\n * the side effects of its dependencies into account. So if A depends on B\n * (A -> B) and both have side effects, loading A triggers effects AB.\n *\n * Now from the previous step we know that each chunk is uniquely determine by\n * the entry points that depend on it and cause it to load, which we will call\n * its dependent entry points.\n *\n * E.g. if X -> A and Y -> A, then the dependent entry points of A are XY.\n * Starting from that idea, we can determine a set of chunks—and thus a set\n * of side effects—that must have been triggered if a certain chunk has been\n * loaded. Basically, it is the intersection of all chunks loaded by the\n * dependent entry points of a given chunk. We call the corresponding side\n * effects the correlated side effects of that chunk.\n *\n * Example:\n * X -> ABC, Y -> ADE, A-> F, B -> D\n * Then taking dependencies into account, X -> ABCDF, Y -> ADEF\n * The intersection is ADF. So we know that when A is loaded, D and F must also\n * be in memory even though neither D nor A is a dependency of the other.\n * If all have side effects, we call ADF the correlated side effects of A. The\n * correlated side effects need to remain constant when merging chunks.\n *\n * In contrast, we have the dependency side effects of A, which represents\n * the side effects we trigger if we directly load A. In this example, the\n * dependency side effects are AF.\n * For entry chunks, dependency and correlated side effects are the same.\n *\n * With these concepts, merging chunks is allowed if the correlated side\n * effects of each entry do not change. Thus, we are allowed to merge two\n * chunks if\n *\n * a) the dependency side effects of each chunk are a subset of the correlated\n *    side effects of the other chunk, so no additional side effects are\n *    triggered for any entry, or\n * b) The dependent entry points of chunk A are a subset of the dependent entry\n *    points of chunk B while the dependency side effects of A are a subset of\n *    the correlated side effects of B. Because in that scenario, whenever A is\n *    loaded, B is loaded as well. But there are cases when B is loaded where A\n *    is not loaded. So if we merge the chunks, all dependency side effects of\n *    A will be added to the correlated side effects of B, and as the latter is\n *    not allowed to change, the former need to be a subset of the latter.\n *\n * Another consideration when merging small chunks into other chunks is to\n * avoid\n * that too much additional code is loaded. This is achieved when the dependent\n * entries of the small chunk are a subset of the dependent entries of the\n * other\n * chunk. Because then when the small chunk is loaded, the other chunk was\n * loaded/in memory anyway, so at most when the other chunk is loaded, the\n * additional size of the small chunk is loaded unnecessarily.\n *\n * So the algorithm performs merges in two passes:\n *\n * 1. First we try to merge small chunks A only into other chunks B if the\n *    dependent entries of A are a subset of the dependent entries of B and the\n *    dependency side effects of A are a subset of the correlated side effects\n *    of B.\n * 2. Only then for all remaining small chunks, we look for arbitrary merges\n *    following the rule (a), starting with the smallest chunks to look for\n *    possible merge targets.\n */\nfunction getOptimizedChunks(chunks, minChunkSize, sideEffectAtoms, sizeByAtom, log) {\n    timeStart('optimize chunks', 3);\n    const chunkPartition = getPartitionedChunks(chunks, minChunkSize);\n    if (!chunkPartition) {\n        timeEnd('optimize chunks', 3);\n        return chunks; // the actual modules\n    }\n    if (minChunkSize > 1) {\n        log('info', (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logOptimizeChunkStatus)(chunks.length, chunkPartition.small.size, 'Initially'));\n    }\n    mergeChunks(chunkPartition, minChunkSize, sideEffectAtoms, sizeByAtom);\n    if (minChunkSize > 1) {\n        log('info', (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logOptimizeChunkStatus)(chunkPartition.small.size + chunkPartition.big.size, chunkPartition.small.size, 'After merging chunks'));\n    }\n    timeEnd('optimize chunks', 3);\n    return [...chunkPartition.small, ...chunkPartition.big];\n}\nfunction getPartitionedChunks(chunks, minChunkSize) {\n    const smallChunks = [];\n    const bigChunks = [];\n    for (const chunk of chunks) {\n        (chunk.size < minChunkSize ? smallChunks : bigChunks).push(chunk);\n    }\n    if (smallChunks.length === 0) {\n        return null;\n    }\n    smallChunks.sort(compareChunkSize);\n    bigChunks.sort(compareChunkSize);\n    return {\n        big: new Set(bigChunks),\n        small: new Set(smallChunks)\n    };\n}\nfunction compareChunkSize({ size: sizeA }, { size: sizeB }) {\n    return sizeA - sizeB;\n}\nfunction mergeChunks(chunkPartition, minChunkSize, sideEffectAtoms, sizeByAtom) {\n    const { small } = chunkPartition;\n    for (const mergedChunk of small) {\n        const bestTargetChunk = findBestMergeTarget(mergedChunk, chunkPartition, sideEffectAtoms, sizeByAtom, \n        // In the default case, we do not accept size increases\n        minChunkSize <= 1 ? 1 : Infinity);\n        if (bestTargetChunk) {\n            const { containedAtoms, correlatedAtoms, modules, pure, size } = mergedChunk;\n            small.delete(mergedChunk);\n            getChunksInPartition(bestTargetChunk, minChunkSize, chunkPartition).delete(bestTargetChunk);\n            bestTargetChunk.modules.push(...modules);\n            bestTargetChunk.size += size;\n            bestTargetChunk.pure &&= pure;\n            const { dependencies, dependentChunks, dependentEntries } = bestTargetChunk;\n            bestTargetChunk.correlatedAtoms &= correlatedAtoms;\n            bestTargetChunk.containedAtoms |= containedAtoms;\n            for (const entry of mergedChunk.dependentEntries) {\n                dependentEntries.add(entry);\n            }\n            for (const dependency of mergedChunk.dependencies) {\n                dependencies.add(dependency);\n                dependency.dependentChunks.delete(mergedChunk);\n                dependency.dependentChunks.add(bestTargetChunk);\n            }\n            for (const dependentChunk of mergedChunk.dependentChunks) {\n                dependentChunks.add(dependentChunk);\n                dependentChunk.dependencies.delete(mergedChunk);\n                dependentChunk.dependencies.add(bestTargetChunk);\n            }\n            dependencies.delete(bestTargetChunk);\n            dependentChunks.delete(bestTargetChunk);\n            getChunksInPartition(bestTargetChunk, minChunkSize, chunkPartition).add(bestTargetChunk);\n        }\n    }\n}\nfunction findBestMergeTarget(mergedChunk, { big, small }, sideEffectAtoms, sizeByAtom, smallestAdditionalSize) {\n    let bestTargetChunk = null;\n    // In the default case, we do not accept size increases\n    for (const targetChunk of concatLazy([small, big])) {\n        if (mergedChunk === targetChunk)\n            continue;\n        const additionalSizeAfterMerge = getAdditionalSizeAfterMerge(mergedChunk, targetChunk, smallestAdditionalSize, sideEffectAtoms, sizeByAtom);\n        if (additionalSizeAfterMerge < smallestAdditionalSize) {\n            bestTargetChunk = targetChunk;\n            if (additionalSizeAfterMerge === 0)\n                break;\n            smallestAdditionalSize = additionalSizeAfterMerge;\n        }\n    }\n    return bestTargetChunk;\n}\n/**\n * Determine the additional unused code size that would be added by merging the\n * two chunks. This is not an exact measurement but rather an upper bound. If\n * the merge produces cycles or adds non-correlated side effects, `Infinity`\n * is returned.\n * Merging will not produce cycles if none of the direct non-merged\n * dependencies of a chunk have the other chunk as a transitive dependency.\n */\nfunction getAdditionalSizeAfterMerge(mergedChunk, targetChunk, \n// The maximum additional unused code size allowed to be added by the merge,\n// taking dependencies into account, needs to be below this number\ncurrentAdditionalSize, sideEffectAtoms, sizeByAtom) {\n    const firstSize = getAdditionalSizeIfNoTransitiveDependencyOrNonCorrelatedSideEffect(mergedChunk, targetChunk, currentAdditionalSize, sideEffectAtoms, sizeByAtom);\n    return firstSize < currentAdditionalSize\n        ? firstSize +\n            getAdditionalSizeIfNoTransitiveDependencyOrNonCorrelatedSideEffect(targetChunk, mergedChunk, currentAdditionalSize - firstSize, sideEffectAtoms, sizeByAtom)\n        : Infinity;\n}\nfunction getAdditionalSizeIfNoTransitiveDependencyOrNonCorrelatedSideEffect(dependentChunk, dependencyChunk, currentAdditionalSize, sideEffectAtoms, sizeByAtom) {\n    const { correlatedAtoms } = dependencyChunk;\n    let dependencyAtoms = dependentChunk.containedAtoms;\n    const dependentContainedSideEffects = dependencyAtoms & sideEffectAtoms;\n    if ((correlatedAtoms & dependentContainedSideEffects) !== dependentContainedSideEffects) {\n        return Infinity;\n    }\n    const chunksToCheck = new Set(dependentChunk.dependencies);\n    for (const { dependencies, containedAtoms } of chunksToCheck) {\n        dependencyAtoms |= containedAtoms;\n        const containedSideEffects = containedAtoms & sideEffectAtoms;\n        if ((correlatedAtoms & containedSideEffects) !== containedSideEffects) {\n            return Infinity;\n        }\n        for (const dependency of dependencies) {\n            if (dependency === dependencyChunk) {\n                return Infinity;\n            }\n            chunksToCheck.add(dependency);\n        }\n    }\n    return getAtomsSizeIfBelowLimit(dependencyAtoms & ~correlatedAtoms, currentAdditionalSize, sizeByAtom);\n}\nfunction getAtomsSizeIfBelowLimit(atoms, currentAdditionalSize, sizeByAtom) {\n    let size = 0;\n    let atomIndex = 0;\n    let atomSignature = 1n;\n    const { length } = sizeByAtom;\n    for (; atomIndex < length; atomIndex++) {\n        if ((atoms & atomSignature) === atomSignature) {\n            size += sizeByAtom[atomIndex];\n        }\n        atomSignature <<= 1n;\n        if (size >= currentAdditionalSize) {\n            return Infinity;\n        }\n    }\n    return size;\n}\nfunction getChunksInPartition(chunk, minChunkSize, chunkPartition) {\n    return chunk.size < minChunkSize ? chunkPartition.small : chunkPartition.big;\n}\n\n// ported from https://github.com/substack/node-commondir\nfunction commondir(files) {\n    if (files.length === 0)\n        return '/';\n    if (files.length === 1)\n        return (0,node_path__WEBPACK_IMPORTED_MODULE_1__.dirname)(files[0]);\n    const commonSegments = files.slice(1).reduce((commonSegments, file) => {\n        const pathSegments = file.split(/\\/+|\\\\+/);\n        let index;\n        for (index = 0; commonSegments[index] === pathSegments[index] &&\n            index < Math.min(commonSegments.length, pathSegments.length); index++)\n            ;\n        return commonSegments.slice(0, index);\n    }, files[0].split(/\\/+|\\\\+/));\n    // Windows correctly handles paths with forward-slashes\n    return commonSegments.length > 1 ? commonSegments.join('/') : '/';\n}\n\nconst compareExecIndex = (unitA, unitB) => unitA.execIndex > unitB.execIndex ? 1 : -1;\nfunction sortByExecutionOrder(units) {\n    units.sort(compareExecIndex);\n}\n// This process is currently faulty in so far as it only takes the first entry\n// module into account and assumes that dynamic imports are imported in a\n// certain order.\n// A better algorithm would follow every possible execution path and mark which\n// modules are executed before or after which other modules. THen the chunking\n// would need to take care that in each chunk, all modules are always executed\n// in the same sequence.\nfunction analyseModuleExecution(entryModules) {\n    let nextExecIndex = 0;\n    const cyclePaths = [];\n    const analysedModules = new Set();\n    const dynamicImports = new Set();\n    const parents = new Map();\n    const orderedModules = [];\n    const analyseModule = (module) => {\n        if (module instanceof Module) {\n            for (const dependency of module.dependencies) {\n                if (parents.has(dependency)) {\n                    if (!analysedModules.has(dependency)) {\n                        cyclePaths.push(getCyclePath(dependency, module, parents));\n                    }\n                    continue;\n                }\n                parents.set(dependency, module);\n                analyseModule(dependency);\n            }\n            for (const dependency of module.implicitlyLoadedBefore) {\n                dynamicImports.add(dependency);\n            }\n            for (const { resolution } of module.dynamicImports) {\n                if (resolution instanceof Module) {\n                    dynamicImports.add(resolution);\n                }\n            }\n            orderedModules.push(module);\n        }\n        module.execIndex = nextExecIndex++;\n        analysedModules.add(module);\n    };\n    for (const currentEntry of entryModules) {\n        if (!parents.has(currentEntry)) {\n            parents.set(currentEntry, null);\n            analyseModule(currentEntry);\n        }\n    }\n    for (const currentEntry of dynamicImports) {\n        if (!parents.has(currentEntry)) {\n            parents.set(currentEntry, null);\n            analyseModule(currentEntry);\n        }\n    }\n    return { cyclePaths, orderedModules };\n}\nfunction getCyclePath(module, parent, parents) {\n    const cycleSymbol = Symbol(module.id);\n    const path = [module.id];\n    let nextModule = parent;\n    module.cycles.add(cycleSymbol);\n    while (nextModule !== module) {\n        nextModule.cycles.add(cycleSymbol);\n        path.push(nextModule.id);\n        nextModule = parents.get(nextModule);\n    }\n    path.push(path[0]);\n    path.reverse();\n    return path;\n}\n\nfunction getGenerateCodeSnippets({ compact, generatedCode: { arrowFunctions, constBindings, objectShorthand, reservedNamesAsProps } }) {\n    const { _, n, s } = compact ? { _: '', n: '', s: '' } : { _: ' ', n: '\\n', s: ';' };\n    const cnst = constBindings ? 'const' : 'var';\n    const getNonArrowFunctionIntro = (parameters, { isAsync, name }) => `${isAsync ? `async ` : ''}function${name ? ` ${name}` : ''}${_}(${parameters.join(`,${_}`)})${_}`;\n    const getFunctionIntro = arrowFunctions\n        ? (parameters, { isAsync, name }) => {\n            const singleParameter = parameters.length === 1;\n            const asyncString = isAsync ? `async${singleParameter ? ' ' : _}` : '';\n            return `${name ? `${cnst} ${name}${_}=${_}` : ''}${asyncString}${singleParameter ? parameters[0] : `(${parameters.join(`,${_}`)})`}${_}=>${_}`;\n        }\n        : getNonArrowFunctionIntro;\n    const getDirectReturnFunction = (parameters, { functionReturn, lineBreakIndent, name }) => [\n        `${getFunctionIntro(parameters, {\n            isAsync: false,\n            name\n        })}${arrowFunctions\n            ? lineBreakIndent\n                ? `${n}${lineBreakIndent.base}${lineBreakIndent.t}`\n                : ''\n            : `{${lineBreakIndent ? `${n}${lineBreakIndent.base}${lineBreakIndent.t}` : _}${functionReturn ? 'return ' : ''}`}`,\n        arrowFunctions\n            ? `${name ? ';' : ''}${lineBreakIndent ? `${n}${lineBreakIndent.base}` : ''}`\n            : `${s}${lineBreakIndent ? `${n}${lineBreakIndent.base}` : _}}`\n    ];\n    const isValidPropertyName = reservedNamesAsProps\n        ? (name) => VALID_IDENTIFIER_REGEXP.test(name)\n        : (name) => !RESERVED_NAMES.has(name) && VALID_IDENTIFIER_REGEXP.test(name);\n    return {\n        _,\n        cnst,\n        getDirectReturnFunction,\n        getDirectReturnIifeLeft: (parameters, returned, { needsArrowReturnParens, needsWrappedFunction }) => {\n            const [left, right] = getDirectReturnFunction(parameters, {\n                functionReturn: true,\n                lineBreakIndent: null,\n                name: null\n            });\n            return `${wrapIfNeeded(`${left}${wrapIfNeeded(returned, arrowFunctions && needsArrowReturnParens)}${right}`, arrowFunctions || needsWrappedFunction)}(`;\n        },\n        getFunctionIntro,\n        getNonArrowFunctionIntro,\n        getObject(fields, { lineBreakIndent }) {\n            const prefix = lineBreakIndent ? `${n}${lineBreakIndent.base}${lineBreakIndent.t}` : _;\n            return `{${fields\n                .map(([key, value]) => {\n                if (key === null)\n                    return `${prefix}${value}`;\n                const keyInObject = stringifyObjectKeyIfNeeded(key);\n                return key === value && objectShorthand && key === keyInObject\n                    ? prefix + key\n                    : `${prefix}${keyInObject}:${_}${value}`;\n            })\n                .join(`,`)}${fields.length === 0 ? '' : lineBreakIndent ? `${n}${lineBreakIndent.base}` : _}}`;\n        },\n        getPropertyAccess: (name) => isValidPropertyName(name) ? `.${name}` : `[${JSON.stringify(name)}]`,\n        n,\n        s\n    };\n}\nconst wrapIfNeeded = (code, needsParens) => needsParens ? `(${code})` : code;\n\nclass Source {\n    constructor(filename, content) {\n        this.isOriginal = true;\n        this.filename = filename;\n        this.content = content;\n    }\n    traceSegment(line, column, name) {\n        return { column, line, name, source: this };\n    }\n}\nclass Link {\n    constructor(map, sources) {\n        this.sources = sources;\n        this.names = map.names;\n        this.mappings = map.mappings;\n    }\n    traceMappings() {\n        const sources = [];\n        const sourceIndexMap = new Map();\n        const sourcesContent = [];\n        const names = [];\n        const nameIndexMap = new Map();\n        const mappings = [];\n        for (const line of this.mappings) {\n            const tracedLine = [];\n            for (const segment of line) {\n                if (segment.length === 1)\n                    continue;\n                const source = this.sources[segment[1]];\n                if (!source)\n                    continue;\n                const traced = source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : '');\n                if (traced) {\n                    const { column, line, name, source: { content, filename } } = traced;\n                    let sourceIndex = sourceIndexMap.get(filename);\n                    if (sourceIndex === undefined) {\n                        sourceIndex = sources.length;\n                        sources.push(filename);\n                        sourceIndexMap.set(filename, sourceIndex);\n                        sourcesContent[sourceIndex] = content;\n                    }\n                    else if (sourcesContent[sourceIndex] == null) {\n                        sourcesContent[sourceIndex] = content;\n                    }\n                    else if (content != null && sourcesContent[sourceIndex] !== content) {\n                        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logConflictingSourcemapSources)(filename));\n                    }\n                    const tracedSegment = [segment[0], sourceIndex, line, column];\n                    if (name) {\n                        let nameIndex = nameIndexMap.get(name);\n                        if (nameIndex === undefined) {\n                            nameIndex = names.length;\n                            names.push(name);\n                            nameIndexMap.set(name, nameIndex);\n                        }\n                        tracedSegment[4] = nameIndex;\n                    }\n                    tracedLine.push(tracedSegment);\n                }\n            }\n            mappings.push(tracedLine);\n        }\n        return { mappings, names, sources, sourcesContent };\n    }\n    traceSegment(line, column, name) {\n        const segments = this.mappings[line];\n        if (!segments)\n            return null;\n        // binary search through segments for the given column\n        let searchStart = 0;\n        let searchEnd = segments.length - 1;\n        while (searchStart <= searchEnd) {\n            const m = (searchStart + searchEnd) >> 1;\n            const segment = segments[m];\n            // If a sourcemap does not have sufficient resolution to contain a\n            // necessary mapping, e.g. because it only contains line information, we\n            // use the best approximation we could find\n            if (segment[0] === column || searchStart === searchEnd) {\n                if (segment.length == 1)\n                    return null;\n                const source = this.sources[segment[1]];\n                if (!source)\n                    return null;\n                return source.traceSegment(segment[2], segment[3], segment.length === 5 ? this.names[segment[4]] : name);\n            }\n            if (segment[0] > column) {\n                searchEnd = m - 1;\n            }\n            else {\n                searchStart = m + 1;\n            }\n        }\n        return null;\n    }\n}\nfunction getLinkMap(log) {\n    return function linkMap(source, map) {\n        if (!map.missing) {\n            return new Link(map, [source]);\n        }\n        log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logSourcemapBroken)(map.plugin));\n        return new Link({\n            mappings: [],\n            names: []\n        }, [source]);\n    };\n}\nfunction getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, linkMap) {\n    let source;\n    if (originalSourcemap) {\n        const sources = originalSourcemap.sources;\n        const sourcesContent = originalSourcemap.sourcesContent || [];\n        const directory = (0,node_path__WEBPACK_IMPORTED_MODULE_1__.dirname)(id) || '.';\n        const sourceRoot = originalSourcemap.sourceRoot || '.';\n        const baseSources = sources.map((source, index) => new Source((0,node_path__WEBPACK_IMPORTED_MODULE_1__.resolve)(directory, sourceRoot, source), sourcesContent[index]));\n        source = new Link(originalSourcemap, baseSources);\n    }\n    else {\n        source = new Source(id, originalCode);\n    }\n    return sourcemapChain.reduce(linkMap, source);\n}\nfunction collapseSourcemaps(file, map, modules, bundleSourcemapChain, excludeContent, log) {\n    const linkMap = getLinkMap(log);\n    const moduleSources = modules\n        .filter(module => !module.excludeFromSourcemap)\n        .map(module => getCollapsedSourcemap(module.id, module.originalCode, module.originalSourcemap, module.sourcemapChain, linkMap));\n    const link = new Link(map, moduleSources);\n    const source = bundleSourcemapChain.reduce(linkMap, link);\n    let { sources, sourcesContent, names, mappings } = source.traceMappings();\n    if (file) {\n        const directory = (0,node_path__WEBPACK_IMPORTED_MODULE_1__.dirname)(file);\n        sources = sources.map((source) => (0,node_path__WEBPACK_IMPORTED_MODULE_1__.relative)(directory, source));\n        file = (0,node_path__WEBPACK_IMPORTED_MODULE_1__.basename)(file);\n    }\n    sourcesContent = (excludeContent ? null : sourcesContent);\n    for (const module of modules) {\n        resetSourcemapCache(module.originalSourcemap, module.sourcemapChain);\n    }\n    return new SourceMap({ file, mappings, names, sources, sourcesContent });\n}\nfunction collapseSourcemap(id, originalCode, originalSourcemap, sourcemapChain, log) {\n    if (sourcemapChain.length === 0) {\n        return originalSourcemap;\n    }\n    const source = getCollapsedSourcemap(id, originalCode, originalSourcemap, sourcemapChain, getLinkMap(log));\n    const map = source.traceMappings();\n    return decodedSourcemap({ version: 3, ...map });\n}\n\nlet textEncoder;\nconst getHash64 = input => (0,_native_js__WEBPACK_IMPORTED_MODULE_3__.xxhashBase64Url)(ensureBuffer(input));\nconst getHash36 = input => (0,_native_js__WEBPACK_IMPORTED_MODULE_3__.xxhashBase36)(ensureBuffer(input));\nconst getHash16 = input => (0,_native_js__WEBPACK_IMPORTED_MODULE_3__.xxhashBase16)(ensureBuffer(input));\nconst hasherByType = {\n    base36: getHash36,\n    base64: getHash64,\n    hex: getHash16\n};\nfunction ensureBuffer(input) {\n    if (typeof input === 'string') {\n        if (typeof Buffer === 'undefined') {\n            textEncoder ??= new TextEncoder();\n            return textEncoder.encode(input);\n        }\n        return Buffer.from(input);\n    }\n    return input;\n}\n\n// this looks ridiculous, but it prevents sourcemap tooling from mistaking\n// this for an actual sourceMappingURL\nlet SOURCEMAPPING_URL = 'sourceMa';\nSOURCEMAPPING_URL += 'ppingURL';\n\nasync function renderChunks(chunks, bundle, pluginDriver, outputOptions, log) {\n    timeStart('render chunks', 2);\n    reserveEntryChunksInBundle(chunks);\n    const renderedChunks = await Promise.all(chunks.map(chunk => chunk.render()));\n    timeEnd('render chunks', 2);\n    timeStart('transform chunks', 2);\n    const getHash = hasherByType[outputOptions.hashCharacters];\n    const chunkGraph = getChunkGraph(chunks);\n    const { hashDependenciesByPlaceholder, initialHashesByPlaceholder, nonHashedChunksWithPlaceholders, placeholders, renderedChunksByPlaceholder } = await transformChunksAndGenerateContentHashes(renderedChunks, chunkGraph, outputOptions, pluginDriver, getHash, log);\n    const hashesByPlaceholder = generateFinalHashes(renderedChunksByPlaceholder, hashDependenciesByPlaceholder, initialHashesByPlaceholder, placeholders, bundle, getHash);\n    addChunksToBundle(renderedChunksByPlaceholder, hashesByPlaceholder, bundle, nonHashedChunksWithPlaceholders, pluginDriver, outputOptions);\n    timeEnd('transform chunks', 2);\n}\nfunction reserveEntryChunksInBundle(chunks) {\n    for (const chunk of chunks) {\n        if (chunk.facadeModule && chunk.facadeModule.isUserDefinedEntryPoint) {\n            // reserves name in bundle as side effect if it does not contain a hash\n            chunk.getPreliminaryFileName();\n        }\n    }\n}\nfunction getChunkGraph(chunks) {\n    return Object.fromEntries(chunks.map(chunk => {\n        const renderedChunkInfo = chunk.getRenderedChunkInfo();\n        return [renderedChunkInfo.fileName, renderedChunkInfo];\n    }));\n}\nasync function transformChunk(magicString, fileName, usedModules, chunkGraph, options, outputPluginDriver, log) {\n    let map = null;\n    const sourcemapChain = [];\n    let code = await outputPluginDriver.hookReduceArg0('renderChunk', [magicString.toString(), chunkGraph[fileName], options, { chunks: chunkGraph }], (code, result, plugin) => {\n        if (result == null)\n            return code;\n        if (typeof result === 'string')\n            result = {\n                code: result,\n                map: undefined\n            };\n        // strict null check allows 'null' maps to not be pushed to the chain, while 'undefined' gets the missing map warning\n        if (result.map !== null) {\n            const map = decodedSourcemap(result.map);\n            sourcemapChain.push(map || { missing: true, plugin: plugin.name });\n        }\n        return result.code;\n    });\n    const { compact, dir, file, sourcemap, sourcemapExcludeSources, sourcemapFile, sourcemapPathTransform, sourcemapIgnoreList } = options;\n    if (!compact && code[code.length - 1] !== '\\n')\n        code += '\\n';\n    if (sourcemap) {\n        timeStart('sourcemaps', 3);\n        let resultingFile;\n        if (file)\n            resultingFile = (0,node_path__WEBPACK_IMPORTED_MODULE_1__.resolve)(sourcemapFile || file);\n        else if (dir)\n            resultingFile = (0,node_path__WEBPACK_IMPORTED_MODULE_1__.resolve)(dir, fileName);\n        else\n            resultingFile = (0,node_path__WEBPACK_IMPORTED_MODULE_1__.resolve)(fileName);\n        const decodedMap = magicString.generateDecodedMap({});\n        map = collapseSourcemaps(resultingFile, decodedMap, usedModules, sourcemapChain, sourcemapExcludeSources, log);\n        for (let sourcesIndex = 0; sourcesIndex < map.sources.length; ++sourcesIndex) {\n            let sourcePath = map.sources[sourcesIndex];\n            const sourcemapPath = `${resultingFile}.map`;\n            const ignoreList = sourcemapIgnoreList(sourcePath, sourcemapPath);\n            if (typeof ignoreList !== 'boolean') {\n                (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logFailedValidation)('sourcemapIgnoreList function must return a boolean.'));\n            }\n            if (ignoreList) {\n                if (map.x_google_ignoreList === undefined) {\n                    map.x_google_ignoreList = [];\n                }\n                if (!map.x_google_ignoreList.includes(sourcesIndex)) {\n                    map.x_google_ignoreList.push(sourcesIndex);\n                }\n            }\n            if (sourcemapPathTransform) {\n                sourcePath = sourcemapPathTransform(sourcePath, sourcemapPath);\n                if (typeof sourcePath !== 'string') {\n                    (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logFailedValidation)(`sourcemapPathTransform function must return a string.`));\n                }\n            }\n            map.sources[sourcesIndex] = (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.normalize)(sourcePath);\n        }\n        timeEnd('sourcemaps', 3);\n    }\n    return {\n        code,\n        map\n    };\n}\nasync function transformChunksAndGenerateContentHashes(renderedChunks, chunkGraph, outputOptions, pluginDriver, getHash, log) {\n    const nonHashedChunksWithPlaceholders = [];\n    const renderedChunksByPlaceholder = new Map();\n    const hashDependenciesByPlaceholder = new Map();\n    const initialHashesByPlaceholder = new Map();\n    const placeholders = new Set();\n    for (const { preliminaryFileName: { hashPlaceholder } } of renderedChunks) {\n        if (hashPlaceholder)\n            placeholders.add(hashPlaceholder);\n    }\n    await Promise.all(renderedChunks.map(async ({ chunk, preliminaryFileName: { fileName, hashPlaceholder }, preliminarySourcemapFileName, magicString, usedModules }) => {\n        const transformedChunk = {\n            chunk,\n            fileName,\n            sourcemapFileName: preliminarySourcemapFileName?.fileName ?? null,\n            ...(await transformChunk(magicString, fileName, usedModules, chunkGraph, outputOptions, pluginDriver, log))\n        };\n        const { code, map } = transformedChunk;\n        if (hashPlaceholder) {\n            // To create a reproducible content-only hash, all placeholders are\n            // replaced with the same value before hashing\n            const { containedPlaceholders, transformedCode } = replacePlaceholdersWithDefaultAndGetContainedPlaceholders(code, placeholders);\n            let contentToHash = transformedCode;\n            const hashAugmentation = pluginDriver.hookReduceValueSync('augmentChunkHash', '', [chunk.getRenderedChunkInfo()], (augmentation, pluginHash) => {\n                if (pluginHash) {\n                    augmentation += pluginHash;\n                }\n                return augmentation;\n            });\n            if (hashAugmentation) {\n                contentToHash += hashAugmentation;\n            }\n            renderedChunksByPlaceholder.set(hashPlaceholder, transformedChunk);\n            hashDependenciesByPlaceholder.set(hashPlaceholder, {\n                containedPlaceholders,\n                contentHash: getHash(contentToHash)\n            });\n        }\n        else {\n            nonHashedChunksWithPlaceholders.push(transformedChunk);\n        }\n        const sourcemapHashPlaceholder = preliminarySourcemapFileName?.hashPlaceholder;\n        if (map && sourcemapHashPlaceholder) {\n            initialHashesByPlaceholder.set(preliminarySourcemapFileName.hashPlaceholder, getHash(map.toString()).slice(0, preliminarySourcemapFileName.hashPlaceholder.length));\n        }\n    }));\n    return {\n        hashDependenciesByPlaceholder,\n        initialHashesByPlaceholder,\n        nonHashedChunksWithPlaceholders,\n        placeholders,\n        renderedChunksByPlaceholder\n    };\n}\nfunction generateFinalHashes(renderedChunksByPlaceholder, hashDependenciesByPlaceholder, initialHashesByPlaceholder, placeholders, bundle, getHash) {\n    const hashesByPlaceholder = new Map(initialHashesByPlaceholder);\n    for (const placeholder of placeholders) {\n        const { fileName } = renderedChunksByPlaceholder.get(placeholder);\n        let contentToHash = '';\n        const hashDependencyPlaceholders = new Set([placeholder]);\n        for (const dependencyPlaceholder of hashDependencyPlaceholders) {\n            const { containedPlaceholders, contentHash } = hashDependenciesByPlaceholder.get(dependencyPlaceholder);\n            contentToHash += contentHash;\n            for (const containedPlaceholder of containedPlaceholders) {\n                // When looping over a map, setting an entry only causes a new iteration if the key is new\n                hashDependencyPlaceholders.add(containedPlaceholder);\n            }\n        }\n        let finalFileName;\n        let finalHash;\n        do {\n            // In case of a hash collision, create a hash of the hash\n            if (finalHash) {\n                contentToHash = finalHash;\n            }\n            finalHash = getHash(contentToHash).slice(0, placeholder.length);\n            finalFileName = replaceSinglePlaceholder(fileName, placeholder, finalHash);\n        } while (bundle[lowercaseBundleKeys].has(finalFileName.toLowerCase()));\n        bundle[finalFileName] = FILE_PLACEHOLDER;\n        hashesByPlaceholder.set(placeholder, finalHash);\n    }\n    return hashesByPlaceholder;\n}\nfunction addChunksToBundle(renderedChunksByPlaceholder, hashesByPlaceholder, bundle, nonHashedChunksWithPlaceholders, pluginDriver, options) {\n    for (const { chunk, code, fileName, sourcemapFileName, map } of renderedChunksByPlaceholder.values()) {\n        let updatedCode = replacePlaceholders(code, hashesByPlaceholder);\n        const finalFileName = replacePlaceholders(fileName, hashesByPlaceholder);\n        let finalSourcemapFileName = null;\n        if (map) {\n            if (options.sourcemapDebugIds) {\n                updatedCode += calculateDebugIdAndGetComment(updatedCode, map);\n            }\n            finalSourcemapFileName = sourcemapFileName\n                ? replacePlaceholders(sourcemapFileName, hashesByPlaceholder)\n                : `${finalFileName}.map`;\n            map.file = replacePlaceholders(map.file, hashesByPlaceholder);\n            updatedCode += emitSourceMapAndGetComment(finalSourcemapFileName, map, pluginDriver, options);\n        }\n        bundle[finalFileName] = chunk.finalizeChunk(updatedCode, map, finalSourcemapFileName, hashesByPlaceholder);\n    }\n    for (const { chunk, code, fileName, sourcemapFileName, map } of nonHashedChunksWithPlaceholders) {\n        let updatedCode = hashesByPlaceholder.size > 0 ? replacePlaceholders(code, hashesByPlaceholder) : code;\n        let finalSourcemapFileName = null;\n        if (map) {\n            if (options.sourcemapDebugIds) {\n                updatedCode += calculateDebugIdAndGetComment(updatedCode, map);\n            }\n            finalSourcemapFileName = sourcemapFileName\n                ? replacePlaceholders(sourcemapFileName, hashesByPlaceholder)\n                : `${fileName}.map`;\n            updatedCode += emitSourceMapAndGetComment(finalSourcemapFileName, map, pluginDriver, options);\n        }\n        bundle[fileName] = chunk.finalizeChunk(updatedCode, map, finalSourcemapFileName, hashesByPlaceholder);\n    }\n}\nfunction emitSourceMapAndGetComment(fileName, map, pluginDriver, { sourcemap, sourcemapBaseUrl }) {\n    let url;\n    if (sourcemap === 'inline') {\n        url = map.toUrl();\n    }\n    else {\n        const sourcemapFileName = (0,node_path__WEBPACK_IMPORTED_MODULE_1__.basename)(fileName);\n        url = sourcemapBaseUrl\n            ? new URL(sourcemapFileName, sourcemapBaseUrl).toString()\n            : sourcemapFileName;\n        pluginDriver.emitFile({\n            fileName,\n            originalFileName: null,\n            source: map.toString(),\n            type: 'asset'\n        });\n    }\n    return sourcemap === 'hidden' ? '' : `//# ${SOURCEMAPPING_URL}=${url}\\n`;\n}\nfunction calculateDebugIdAndGetComment(code, map) {\n    const hash = hasherByType.hex(code);\n    const debugId = [\n        hash.slice(0, 8),\n        hash.slice(8, 12),\n        '4' + hash.slice(12, 15),\n        ((parseInt(hash.slice(15, 16), 16) & 3) | 8).toString(16) + hash.slice(17, 20),\n        hash.slice(20, 32)\n    ].join('-');\n    map.debugId = debugId;\n    return '//# debugId=' + debugId + '\\n';\n}\n\nclass Bundle {\n    constructor(outputOptions, unsetOptions, inputOptions, pluginDriver, graph) {\n        this.outputOptions = outputOptions;\n        this.unsetOptions = unsetOptions;\n        this.inputOptions = inputOptions;\n        this.pluginDriver = pluginDriver;\n        this.graph = graph;\n        this.facadeChunkByModule = new Map();\n        this.includedNamespaces = new Set();\n    }\n    async generate(isWrite) {\n        timeStart('GENERATE', 1);\n        const outputBundleBase = Object.create(null);\n        const outputBundle = getOutputBundle(outputBundleBase);\n        this.pluginDriver.setOutputBundle(outputBundle, this.outputOptions);\n        try {\n            timeStart('initialize render', 2);\n            await this.pluginDriver.hookParallel('renderStart', [this.outputOptions, this.inputOptions]);\n            timeEnd('initialize render', 2);\n            timeStart('generate chunks', 2);\n            const getHashPlaceholder = getHashPlaceholderGenerator();\n            const chunks = await this.generateChunks(outputBundle, getHashPlaceholder);\n            if (chunks.length > 1) {\n                validateOptionsForMultiChunkOutput(this.outputOptions, this.inputOptions.onLog);\n            }\n            this.pluginDriver.setChunkInformation(this.facadeChunkByModule);\n            for (const chunk of chunks) {\n                chunk.generateExports();\n            }\n            timeEnd('generate chunks', 2);\n            await renderChunks(chunks, outputBundle, this.pluginDriver, this.outputOptions, this.inputOptions.onLog);\n        }\n        catch (error_) {\n            await this.pluginDriver.hookParallel('renderError', [error_]);\n            throw error_;\n        }\n        removeUnreferencedAssets(outputBundle);\n        timeStart('generate bundle', 2);\n        await this.pluginDriver.hookSeq('generateBundle', [\n            this.outputOptions,\n            outputBundle,\n            isWrite\n        ]);\n        this.finaliseAssets(outputBundle);\n        timeEnd('generate bundle', 2);\n        timeEnd('GENERATE', 1);\n        return outputBundleBase;\n    }\n    async addManualChunks(manualChunks) {\n        const manualChunkAliasByEntry = new Map();\n        const chunkEntries = await Promise.all(Object.entries(manualChunks).map(async ([alias, files]) => ({\n            alias,\n            entries: await this.graph.moduleLoader.addAdditionalModules(files, true)\n        })));\n        for (const { alias, entries } of chunkEntries) {\n            for (const entry of entries) {\n                addModuleToManualChunk(alias, entry, manualChunkAliasByEntry);\n            }\n        }\n        return manualChunkAliasByEntry;\n    }\n    assignManualChunks(getManualChunk) {\n        const manualChunkAliasesWithEntry = [];\n        const manualChunksApi = {\n            getModuleIds: () => this.graph.modulesById.keys(),\n            getModuleInfo: this.graph.getModuleInfo\n        };\n        for (const module of this.graph.modulesById.values()) {\n            if (module instanceof Module) {\n                const manualChunkAlias = getManualChunk(module.id, manualChunksApi);\n                if (typeof manualChunkAlias === 'string') {\n                    manualChunkAliasesWithEntry.push([manualChunkAlias, module]);\n                }\n            }\n        }\n        manualChunkAliasesWithEntry.sort(([aliasA], [aliasB]) => aliasA > aliasB ? 1 : aliasA < aliasB ? -1 : 0);\n        const manualChunkAliasByEntry = new Map();\n        for (const [alias, module] of manualChunkAliasesWithEntry) {\n            addModuleToManualChunk(alias, module, manualChunkAliasByEntry);\n        }\n        return manualChunkAliasByEntry;\n    }\n    finaliseAssets(bundle) {\n        if (this.outputOptions.validate) {\n            for (const file of Object.values(bundle)) {\n                if ('code' in file) {\n                    try {\n                        (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.parseAst)(file.code, { jsx: this.inputOptions.jsx !== false });\n                    }\n                    catch (error_) {\n                        this.inputOptions.onLog(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logChunkInvalid)(file, error_));\n                    }\n                }\n            }\n        }\n        this.pluginDriver.finaliseAssets();\n    }\n    async generateChunks(bundle, getHashPlaceholder) {\n        const { experimentalMinChunkSize, inlineDynamicImports, manualChunks, preserveModules } = this.outputOptions;\n        const manualChunkAliasByEntry = typeof manualChunks === 'object'\n            ? await this.addManualChunks(manualChunks)\n            : this.assignManualChunks(manualChunks);\n        const snippets = getGenerateCodeSnippets(this.outputOptions);\n        const includedModules = getIncludedModules(this.graph.modulesById);\n        const inputBase = commondir(getAbsoluteEntryModulePaths(includedModules, preserveModules));\n        const externalChunkByModule = getExternalChunkByModule(this.graph.modulesById, this.outputOptions, inputBase);\n        const executableModule = inlineDynamicImports\n            ? [{ alias: null, modules: includedModules }]\n            : preserveModules\n                ? includedModules.map(module => ({ alias: null, modules: [module] }))\n                : getChunkAssignments(this.graph.entryModules, manualChunkAliasByEntry, experimentalMinChunkSize, this.inputOptions.onLog);\n        const chunks = new Array(executableModule.length);\n        const chunkByModule = new Map();\n        let index = 0;\n        for (const { alias, modules } of executableModule) {\n            sortByExecutionOrder(modules);\n            const chunk = new Chunk(modules, this.inputOptions, this.outputOptions, this.unsetOptions, this.pluginDriver, this.graph.modulesById, chunkByModule, externalChunkByModule, this.facadeChunkByModule, this.includedNamespaces, alias, getHashPlaceholder, bundle, inputBase, snippets);\n            chunks[index++] = chunk;\n        }\n        for (const chunk of chunks) {\n            chunk.link();\n        }\n        const facades = [];\n        for (const chunk of chunks) {\n            facades.push(...chunk.generateFacades());\n        }\n        return [...chunks, ...facades];\n    }\n}\nfunction validateOptionsForMultiChunkOutput(outputOptions, log) {\n    if (outputOptions.format === 'umd' || outputOptions.format === 'iife')\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('output.format', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_FORMAT, 'UMD and IIFE output formats are not supported for code-splitting builds', outputOptions.format));\n    if (typeof outputOptions.file === 'string')\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('output.file', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_DIR, 'when building multiple chunks, the \"output.dir\" option must be used, not \"output.file\". To inline dynamic imports, set the \"inlineDynamicImports\" option'));\n    if (outputOptions.sourcemapFile)\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('output.sourcemapFile', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_SOURCEMAPFILE, '\"output.sourcemapFile\" is only supported for single-file builds'));\n    if (!outputOptions.amd.autoId && outputOptions.amd.id)\n        log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('output.amd.id', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_AMD_ID, 'this option is only properly supported for single-file builds. Use \"output.amd.autoId\" and \"output.amd.basePath\" instead'));\n}\nfunction getIncludedModules(modulesById) {\n    const includedModules = [];\n    for (const module of modulesById.values()) {\n        if (module instanceof Module &&\n            (module.isIncluded() || module.info.isEntry || module.includedDynamicImporters.length > 0)) {\n            includedModules.push(module);\n        }\n    }\n    return includedModules;\n}\nfunction getAbsoluteEntryModulePaths(includedModules, preserveModules) {\n    const absoluteEntryModulePaths = [];\n    for (const module of includedModules) {\n        if ((module.info.isEntry || preserveModules) && (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.isAbsolute)(module.id)) {\n            absoluteEntryModulePaths.push(module.id);\n        }\n    }\n    return absoluteEntryModulePaths;\n}\nfunction getExternalChunkByModule(modulesById, outputOptions, inputBase) {\n    const externalChunkByModule = new Map();\n    for (const module of modulesById.values()) {\n        if (module instanceof ExternalModule) {\n            externalChunkByModule.set(module, new ExternalChunk(module, outputOptions, inputBase));\n        }\n    }\n    return externalChunkByModule;\n}\nfunction addModuleToManualChunk(alias, module, manualChunkAliasByEntry) {\n    const existingAlias = manualChunkAliasByEntry.get(module);\n    if (typeof existingAlias === 'string' && existingAlias !== alias) {\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logCannotAssignModuleToChunk)(module.id, alias, existingAlias));\n    }\n    manualChunkAliasByEntry.set(module, alias);\n}\n\nfunction flru (max) {\n\tvar num, curr, prev;\n\tvar limit = max;\n\n\tfunction keep(key, value) {\n\t\tif (++num > limit) {\n\t\t\tprev = curr;\n\t\t\treset(1);\n\t\t\t++num;\n\t\t}\n\t\tcurr[key] = value;\n\t}\n\n\tfunction reset(isPartial) {\n\t\tnum = 0;\n\t\tcurr = Object.create(null);\n\t\tisPartial || (prev=Object.create(null));\n\t}\n\n\treset();\n\n\treturn {\n\t\tclear: reset,\n\t\thas: function (key) {\n\t\t\treturn curr[key] !== void 0 || prev[key] !== void 0;\n\t\t},\n\t\tget: function (key) {\n\t\t\tvar val = curr[key];\n\t\t\tif (val !== void 0) return val;\n\t\t\tif ((val=prev[key]) !== void 0) {\n\t\t\t\tkeep(key, val);\n\t\t\t\treturn val;\n\t\t\t}\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif (curr[key] !== void 0) {\n\t\t\t\tcurr[key] = value;\n\t\t\t} else {\n\t\t\t\tkeep(key, value);\n\t\t\t}\n\t\t}\n\t};\n}\n\nclass GlobalScope extends Scope {\n    constructor() {\n        super();\n        this.parent = null;\n        this.variables.set('undefined', new UndefinedVariable());\n    }\n    findVariable(name) {\n        let variable = this.variables.get(name);\n        if (!variable) {\n            variable = new GlobalVariable(name);\n            this.variables.set(name, variable);\n        }\n        return variable;\n    }\n}\n\nfunction resolveIdViaPlugins(source, importer, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry, attributes) {\n    let skipped = null;\n    let replaceContext = null;\n    if (skip) {\n        skipped = new Set();\n        for (const skippedCall of skip) {\n            if (source === skippedCall.source && importer === skippedCall.importer) {\n                skipped.add(skippedCall.plugin);\n            }\n        }\n        replaceContext = (pluginContext, plugin) => ({\n            ...pluginContext,\n            resolve: (source, importer, { attributes, custom, isEntry, skipSelf } = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BLANK) => {\n                skipSelf ??= true;\n                return moduleLoaderResolveId(source, importer, custom, isEntry, attributes || _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJECT, skipSelf ? [...skip, { importer, plugin, source }] : skip);\n            }\n        });\n    }\n    return pluginDriver.hookFirstAndGetPlugin('resolveId', [source, importer, { attributes, custom: customOptions, isEntry }], replaceContext, skipped);\n}\n\nasync function resolveId(source, importer, preserveSymlinks, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry, attributes) {\n    const pluginResult = await resolveIdViaPlugins(source, importer, pluginDriver, moduleLoaderResolveId, skip, customOptions, isEntry, attributes);\n    if (pluginResult != null) {\n        const [resolveIdResult, plugin] = pluginResult;\n        if (typeof resolveIdResult === 'object' && !resolveIdResult.resolvedBy) {\n            return {\n                ...resolveIdResult,\n                resolvedBy: plugin.name\n            };\n        }\n        if (typeof resolveIdResult === 'string') {\n            return {\n                id: resolveIdResult,\n                resolvedBy: plugin.name\n            };\n        }\n        return resolveIdResult;\n    }\n    // external modules (non-entry modules that start with neither '.' or '/')\n    // are skipped at this stage.\n    if (importer !== undefined && !(0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.isAbsolute)(source) && source[0] !== '.')\n        return null;\n    // `resolve` processes paths from right to left, prepending them until an\n    // absolute path is created. Absolute importees therefore shortcircuit the\n    // resolve call and require no special handing on our part.\n    // See https://nodejs.org/api/path.html#path_path_resolve_paths\n    return addJsExtensionIfNecessary(importer ? (0,node_path__WEBPACK_IMPORTED_MODULE_1__.resolve)((0,node_path__WEBPACK_IMPORTED_MODULE_1__.dirname)(importer), source) : (0,node_path__WEBPACK_IMPORTED_MODULE_1__.resolve)(source), preserveSymlinks);\n}\nasync function addJsExtensionIfNecessary(file, preserveSymlinks) {\n    return ((await findFile(file, preserveSymlinks)) ??\n        (await findFile(file + '.mjs', preserveSymlinks)) ??\n        (await findFile(file + '.js', preserveSymlinks)));\n}\nasync function findFile(file, preserveSymlinks) {\n    try {\n        const stats = await (0,node_fs_promises__WEBPACK_IMPORTED_MODULE_6__.lstat)(file);\n        if (!preserveSymlinks && stats.isSymbolicLink())\n            return await findFile(await (0,node_fs_promises__WEBPACK_IMPORTED_MODULE_6__.realpath)(file), preserveSymlinks);\n        if ((preserveSymlinks && stats.isSymbolicLink()) || stats.isFile()) {\n            // check case\n            const name = (0,node_path__WEBPACK_IMPORTED_MODULE_1__.basename)(file);\n            const files = await (0,node_fs_promises__WEBPACK_IMPORTED_MODULE_6__.readdir)((0,node_path__WEBPACK_IMPORTED_MODULE_1__.dirname)(file));\n            if (files.includes(name))\n                return file;\n        }\n    }\n    catch {\n        // suppress\n    }\n}\n\nconst ANONYMOUS_PLUGIN_PREFIX = 'at position ';\nconst ANONYMOUS_OUTPUT_PLUGIN_PREFIX = 'at output position ';\n\nfunction createPluginCache(cache) {\n    return {\n        delete(id) {\n            return delete cache[id];\n        },\n        get(id) {\n            const item = cache[id];\n            if (!item)\n                return;\n            item[0] = 0;\n            return item[1];\n        },\n        has(id) {\n            const item = cache[id];\n            if (!item)\n                return false;\n            item[0] = 0;\n            return true;\n        },\n        set(id, value) {\n            cache[id] = [0, value];\n        }\n    };\n}\nfunction getTrackedPluginCache(pluginCache, onUse) {\n    return {\n        delete(id) {\n            onUse();\n            return pluginCache.delete(id);\n        },\n        get(id) {\n            onUse();\n            return pluginCache.get(id);\n        },\n        has(id) {\n            onUse();\n            return pluginCache.has(id);\n        },\n        set(id, value) {\n            onUse();\n            return pluginCache.set(id, value);\n        }\n    };\n}\nconst NO_CACHE = {\n    delete() {\n        return false;\n    },\n    get() {\n        return undefined;\n    },\n    has() {\n        return false;\n    },\n    set() { }\n};\nfunction uncacheablePluginError(pluginName) {\n    if (pluginName.startsWith(ANONYMOUS_PLUGIN_PREFIX) ||\n        pluginName.startsWith(ANONYMOUS_OUTPUT_PLUGIN_PREFIX)) {\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logAnonymousPluginCache)());\n    }\n    return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logDuplicatePluginName)(pluginName));\n}\nfunction getCacheForUncacheablePlugin(pluginName) {\n    return {\n        delete() {\n            return uncacheablePluginError(pluginName);\n        },\n        get() {\n            return uncacheablePluginError(pluginName);\n        },\n        has() {\n            return uncacheablePluginError(pluginName);\n        },\n        set() {\n            return uncacheablePluginError(pluginName);\n        }\n    };\n}\n\nasync function asyncFlatten(array) {\n    do {\n        array = (await Promise.all(array)).flat(Infinity);\n    } while (array.some((v) => v?.then));\n    return array;\n}\n\nconst getOnLog = (config, logLevel, printLog = defaultPrintLog) => {\n    const { onwarn, onLog } = config;\n    const defaultOnLog = getDefaultOnLog(printLog, onwarn);\n    if (onLog) {\n        const minimalPriority = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logLevelPriority[logLevel];\n        return (level, log) => onLog(level, addLogToString(log), (level, handledLog) => {\n            if (level === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_ERROR) {\n                return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)(normalizeLog(handledLog));\n            }\n            if (_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logLevelPriority[level] >= minimalPriority) {\n                defaultOnLog(level, normalizeLog(handledLog));\n            }\n        });\n    }\n    return defaultOnLog;\n};\nconst getDefaultOnLog = (printLog, onwarn) => onwarn\n    ? (level, log) => {\n        if (level === _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN) {\n            onwarn(addLogToString(log), warning => printLog(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, normalizeLog(warning)));\n        }\n        else {\n            printLog(level, log);\n        }\n    }\n    : printLog;\nconst addLogToString = (log) => {\n    Object.defineProperty(log, 'toString', {\n        value: () => log.message,\n        writable: true\n    });\n    return log;\n};\nconst normalizeLog = (log) => typeof log === 'string'\n    ? { message: log }\n    : typeof log === 'function'\n        ? normalizeLog(log())\n        : log;\nconst defaultPrintLog = (level, { message }) => {\n    switch (level) {\n        case _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN: {\n            return console.warn(message);\n        }\n        case _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_DEBUG: {\n            return console.debug(message);\n        }\n        default: {\n            return console.info(message);\n        }\n    }\n};\nfunction warnUnknownOptions(passedOptions, validOptions, optionType, log, ignoredKeys = /$./) {\n    const validOptionSet = new Set(validOptions);\n    const unknownOptions = Object.keys(passedOptions).filter(key => !(validOptionSet.has(key) || ignoredKeys.test(key)));\n    if (unknownOptions.length > 0) {\n        log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logUnknownOption)(optionType, unknownOptions, [...validOptionSet].sort()));\n    }\n}\nconst treeshakePresets = {\n    recommended: {\n        annotations: true,\n        correctVarValueBeforeDeclaration: false,\n        manualPureFunctions: _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY,\n        moduleSideEffects: () => true,\n        propertyReadSideEffects: true,\n        tryCatchDeoptimization: true,\n        unknownGlobalSideEffects: false\n    },\n    safest: {\n        annotations: true,\n        correctVarValueBeforeDeclaration: true,\n        manualPureFunctions: _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY,\n        moduleSideEffects: () => true,\n        propertyReadSideEffects: true,\n        tryCatchDeoptimization: true,\n        unknownGlobalSideEffects: true\n    },\n    smallest: {\n        annotations: true,\n        correctVarValueBeforeDeclaration: false,\n        manualPureFunctions: _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY,\n        moduleSideEffects: () => false,\n        propertyReadSideEffects: false,\n        tryCatchDeoptimization: false,\n        unknownGlobalSideEffects: false\n    }\n};\nconst jsxPresets = {\n    preserve: {\n        factory: null,\n        fragment: null,\n        importSource: null,\n        mode: 'preserve'\n    },\n    'preserve-react': {\n        factory: 'React.createElement',\n        fragment: 'React.Fragment',\n        importSource: 'react',\n        mode: 'preserve'\n    },\n    react: {\n        factory: 'React.createElement',\n        fragment: 'React.Fragment',\n        importSource: 'react',\n        mode: 'classic'\n    },\n    'react-jsx': {\n        factory: 'React.createElement',\n        importSource: 'react',\n        jsxImportSource: 'react/jsx-runtime',\n        mode: 'automatic'\n    }\n};\nconst generatedCodePresets = {\n    es2015: {\n        arrowFunctions: true,\n        constBindings: true,\n        objectShorthand: true,\n        reservedNamesAsProps: true,\n        symbols: true\n    },\n    es5: {\n        arrowFunctions: false,\n        constBindings: false,\n        objectShorthand: false,\n        reservedNamesAsProps: true,\n        symbols: false\n    }\n};\nconst objectifyOption = (value) => value && typeof value === 'object' ? value : {};\nconst objectifyOptionWithPresets = (presets, optionName, urlSnippet, additionalValues) => (value) => {\n    if (typeof value === 'string') {\n        const preset = presets[value];\n        if (preset) {\n            return preset;\n        }\n        (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)(optionName, urlSnippet, `valid values are ${additionalValues}${(0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.printQuotedStringList)(Object.keys(presets))}. You can also supply an object for more fine-grained control`, value));\n    }\n    return objectifyOption(value);\n};\nconst getOptionWithPreset = (value, presets, optionName, urlSnippet, additionalValues) => {\n    const presetName = value?.preset;\n    if (presetName) {\n        const preset = presets[presetName];\n        if (preset) {\n            return { ...preset, ...value };\n        }\n        else {\n            (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)(`${optionName}.preset`, urlSnippet, `valid values are ${(0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.printQuotedStringList)(Object.keys(presets))}`, presetName));\n        }\n    }\n    return objectifyOptionWithPresets(presets, optionName, urlSnippet, additionalValues)(value);\n};\nconst normalizePluginOption = async (plugins) => (await asyncFlatten([plugins])).filter(Boolean);\n\nasync function transform(source, module, pluginDriver, log) {\n    const id = module.id;\n    const sourcemapChain = [];\n    let originalSourcemap = source.map === null ? null : decodedSourcemap(source.map);\n    const originalCode = source.code;\n    let ast = source.ast;\n    const transformDependencies = [];\n    const emittedFiles = [];\n    let customTransformCache = false;\n    const useCustomTransformCache = () => (customTransformCache = true);\n    let pluginName = '';\n    let currentSource = source.code;\n    function transformReducer(previousCode, result, plugin) {\n        let code;\n        let map;\n        if (typeof result === 'string') {\n            code = result;\n        }\n        else if (result && typeof result === 'object') {\n            module.updateOptions(result);\n            if (result.code == null) {\n                if (result.map || result.ast) {\n                    log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logNoTransformMapOrAstWithoutCode)(plugin.name));\n                }\n                return previousCode;\n            }\n            ({ code, map, ast } = result);\n        }\n        else {\n            return previousCode;\n        }\n        // strict null check allows 'null' maps to not be pushed to the chain,\n        // while 'undefined' gets the missing map warning\n        if (map !== null) {\n            sourcemapChain.push(decodedSourcemap(typeof map === 'string' ? JSON.parse(map) : map) || {\n                missing: true,\n                plugin: plugin.name\n            });\n        }\n        currentSource = code;\n        return code;\n    }\n    const getLogHandler = (handler) => (log, pos) => {\n        log = normalizeLog(log);\n        if (pos)\n            (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.augmentCodeLocation)(log, pos, currentSource, id);\n        log.id = id;\n        log.hook = 'transform';\n        handler(log);\n    };\n    let code;\n    try {\n        code = await pluginDriver.hookReduceArg0('transform', [currentSource, id], transformReducer, (pluginContext, plugin) => {\n            pluginName = plugin.name;\n            return {\n                ...pluginContext,\n                addWatchFile(id) {\n                    transformDependencies.push(id);\n                    pluginContext.addWatchFile(id);\n                },\n                cache: customTransformCache\n                    ? pluginContext.cache\n                    : getTrackedPluginCache(pluginContext.cache, useCustomTransformCache),\n                debug: getLogHandler(pluginContext.debug),\n                emitFile(emittedFile) {\n                    emittedFiles.push(emittedFile);\n                    return pluginDriver.emitFile(emittedFile);\n                },\n                error(error_, pos) {\n                    if (typeof error_ === 'string')\n                        error_ = { message: error_ };\n                    if (pos)\n                        (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.augmentCodeLocation)(error_, pos, currentSource, id);\n                    error_.id = id;\n                    error_.hook = 'transform';\n                    return pluginContext.error(error_);\n                },\n                getCombinedSourcemap() {\n                    const combinedMap = collapseSourcemap(id, originalCode, originalSourcemap, sourcemapChain, log);\n                    if (!combinedMap) {\n                        const magicString = new MagicString(originalCode);\n                        return magicString.generateMap({ hires: true, includeContent: true, source: id });\n                    }\n                    if (originalSourcemap !== combinedMap) {\n                        originalSourcemap = combinedMap;\n                        sourcemapChain.length = 0;\n                    }\n                    return new SourceMap({\n                        ...combinedMap,\n                        file: null,\n                        sourcesContent: combinedMap.sourcesContent\n                    });\n                },\n                info: getLogHandler(pluginContext.info),\n                setAssetSource() {\n                    return this.error((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidSetAssetSourceCall)());\n                },\n                warn: getLogHandler(pluginContext.warn)\n            };\n        });\n    }\n    catch (error_) {\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logPluginError)(error_, pluginName, { hook: 'transform', id }));\n    }\n    if (!customTransformCache && // files emitted by a transform hook need to be emitted again if the hook is skipped\n        emittedFiles.length > 0)\n        module.transformFiles = emittedFiles;\n    return {\n        ast,\n        code,\n        customTransformCache,\n        originalCode,\n        originalSourcemap,\n        sourcemapChain,\n        transformDependencies\n    };\n}\n\nconst RESOLVE_DEPENDENCIES = 'resolveDependencies';\nclass ModuleLoader {\n    constructor(graph, modulesById, options, pluginDriver) {\n        this.graph = graph;\n        this.modulesById = modulesById;\n        this.options = options;\n        this.pluginDriver = pluginDriver;\n        this.implicitEntryModules = new Set();\n        this.indexedEntryModules = [];\n        this.latestLoadModulesPromise = Promise.resolve();\n        this.moduleLoadPromises = new Map();\n        this.modulesWithLoadedDependencies = new Set();\n        this.nextChunkNamePriority = 0;\n        this.nextEntryModuleIndex = 0;\n        this.resolveId = async (source, importer, customOptions, isEntry, attributes, skip = null) => this.getResolvedIdWithDefaults(this.getNormalizedResolvedIdWithoutDefaults(this.options.external(source, importer, false)\n            ? false\n            : await resolveId(source, importer, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, skip, customOptions, typeof isEntry === 'boolean' ? isEntry : !importer, attributes), importer, source), attributes);\n        this.hasModuleSideEffects = options.treeshake\n            ? options.treeshake.moduleSideEffects\n            : () => true;\n    }\n    async addAdditionalModules(unresolvedModules, isAddForManualChunks) {\n        const result = this.extendLoadModulesPromise(Promise.all(unresolvedModules.map(id => this.loadEntryModule(id, false, undefined, null, isAddForManualChunks))));\n        await this.awaitLoadModulesPromise();\n        return result;\n    }\n    async addEntryModules(unresolvedEntryModules, isUserDefined) {\n        const firstEntryModuleIndex = this.nextEntryModuleIndex;\n        this.nextEntryModuleIndex += unresolvedEntryModules.length;\n        const firstChunkNamePriority = this.nextChunkNamePriority;\n        this.nextChunkNamePriority += unresolvedEntryModules.length;\n        const newEntryModules = await this.extendLoadModulesPromise(Promise.all(unresolvedEntryModules.map(({ id, importer }) => this.loadEntryModule(id, true, importer, null))).then(entryModules => {\n            for (const [index, entryModule] of entryModules.entries()) {\n                entryModule.isUserDefinedEntryPoint =\n                    entryModule.isUserDefinedEntryPoint || isUserDefined;\n                addChunkNamesToModule(entryModule, unresolvedEntryModules[index], isUserDefined, firstChunkNamePriority + index);\n                const existingIndexedModule = this.indexedEntryModules.find(indexedModule => indexedModule.module === entryModule);\n                if (existingIndexedModule) {\n                    existingIndexedModule.index = Math.min(existingIndexedModule.index, firstEntryModuleIndex + index);\n                }\n                else {\n                    this.indexedEntryModules.push({\n                        index: firstEntryModuleIndex + index,\n                        module: entryModule\n                    });\n                }\n            }\n            this.indexedEntryModules.sort(({ index: indexA }, { index: indexB }) => indexA > indexB ? 1 : -1);\n            return entryModules;\n        }));\n        await this.awaitLoadModulesPromise();\n        return {\n            entryModules: this.indexedEntryModules.map(({ module }) => module),\n            implicitEntryModules: [...this.implicitEntryModules],\n            newEntryModules\n        };\n    }\n    async emitChunk({ fileName, id, importer, name, implicitlyLoadedAfterOneOf, preserveSignature }) {\n        const unresolvedModule = {\n            fileName: fileName || null,\n            id,\n            importer,\n            name: name || null\n        };\n        const module = implicitlyLoadedAfterOneOf\n            ? await this.addEntryWithImplicitDependants(unresolvedModule, implicitlyLoadedAfterOneOf)\n            : (await this.addEntryModules([unresolvedModule], false)).newEntryModules[0];\n        if (preserveSignature != null) {\n            module.preserveSignature = preserveSignature;\n        }\n        return module;\n    }\n    async preloadModule(resolvedId) {\n        const module = await this.fetchModule(this.getResolvedIdWithDefaults(resolvedId, _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJECT), undefined, false, resolvedId.resolveDependencies ? RESOLVE_DEPENDENCIES : true);\n        return module.info;\n    }\n    addEntryWithImplicitDependants(unresolvedModule, implicitlyLoadedAfter) {\n        const chunkNamePriority = this.nextChunkNamePriority++;\n        return this.extendLoadModulesPromise(this.loadEntryModule(unresolvedModule.id, false, unresolvedModule.importer, null).then(async (entryModule) => {\n            addChunkNamesToModule(entryModule, unresolvedModule, false, chunkNamePriority);\n            if (!entryModule.info.isEntry) {\n                const implicitlyLoadedAfterModules = await Promise.all(implicitlyLoadedAfter.map(id => this.loadEntryModule(id, false, unresolvedModule.importer, entryModule.id)));\n                // We need to check again if this is still an entry module as these\n                // changes need to be performed atomically to avoid race conditions\n                // if the same module is re-emitted as an entry module.\n                // The inverse changes happen in \"handleExistingModule\"\n                if (!entryModule.info.isEntry) {\n                    this.implicitEntryModules.add(entryModule);\n                    for (const module of implicitlyLoadedAfterModules) {\n                        entryModule.implicitlyLoadedAfter.add(module);\n                    }\n                    for (const dependant of entryModule.implicitlyLoadedAfter) {\n                        dependant.implicitlyLoadedBefore.add(entryModule);\n                    }\n                }\n            }\n            return entryModule;\n        }));\n    }\n    async addModuleSource(id, importer, module) {\n        let source;\n        try {\n            source = await this.graph.fileOperationQueue.run(async () => {\n                const content = await this.pluginDriver.hookFirst('load', [id]);\n                if (content !== null)\n                    return content;\n                this.graph.watchFiles[id] = true;\n                return await (0,node_fs_promises__WEBPACK_IMPORTED_MODULE_6__.readFile)(id, 'utf8');\n            });\n        }\n        catch (error_) {\n            let message = `Could not load ${id}`;\n            if (importer)\n                message += ` (imported by ${(0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.relativeId)(importer)})`;\n            message += `: ${error_.message}`;\n            error_.message = message;\n            throw error_;\n        }\n        const sourceDescription = typeof source === 'string'\n            ? { code: source }\n            : source != null && typeof source === 'object' && typeof source.code === 'string'\n                ? source\n                : (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logBadLoader)(id));\n        const code = sourceDescription.code;\n        if (code.charCodeAt(0) === 0xfe_ff) {\n            sourceDescription.code = code.slice(1);\n        }\n        const cachedModule = this.graph.cachedModules.get(id);\n        if (cachedModule &&\n            !cachedModule.customTransformCache &&\n            cachedModule.originalCode === sourceDescription.code &&\n            !(await this.pluginDriver.hookFirst('shouldTransformCachedModule', [\n                {\n                    ast: cachedModule.ast,\n                    code: cachedModule.code,\n                    id: cachedModule.id,\n                    meta: cachedModule.meta,\n                    moduleSideEffects: cachedModule.moduleSideEffects,\n                    resolvedSources: cachedModule.resolvedIds,\n                    syntheticNamedExports: cachedModule.syntheticNamedExports\n                }\n            ]))) {\n            if (cachedModule.transformFiles) {\n                for (const emittedFile of cachedModule.transformFiles)\n                    this.pluginDriver.emitFile(emittedFile);\n            }\n            await module.setSource(cachedModule);\n        }\n        else {\n            module.updateOptions(sourceDescription);\n            await module.setSource(await transform(sourceDescription, module, this.pluginDriver, this.options.onLog));\n        }\n    }\n    async awaitLoadModulesPromise() {\n        let startingPromise;\n        do {\n            startingPromise = this.latestLoadModulesPromise;\n            await startingPromise;\n        } while (startingPromise !== this.latestLoadModulesPromise);\n    }\n    extendLoadModulesPromise(loadNewModulesPromise) {\n        this.latestLoadModulesPromise = Promise.all([\n            loadNewModulesPromise,\n            this.latestLoadModulesPromise\n        ]);\n        this.latestLoadModulesPromise.catch(() => {\n            /* Avoid unhandled Promise rejections */\n        });\n        return loadNewModulesPromise;\n    }\n    async fetchDynamicDependencies(module, resolveDynamicImportPromises) {\n        const dependencies = await Promise.all(resolveDynamicImportPromises.map(resolveDynamicImportPromise => resolveDynamicImportPromise.then(async ([dynamicImport, resolvedId]) => {\n            if (resolvedId === null)\n                return null;\n            if (typeof resolvedId === 'string') {\n                dynamicImport.resolution = resolvedId;\n                return null;\n            }\n            return (dynamicImport.resolution = await this.fetchResolvedDependency((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.relativeId)(resolvedId.id), module.id, resolvedId));\n        })));\n        for (const dependency of dependencies) {\n            if (dependency) {\n                module.dynamicDependencies.add(dependency);\n                dependency.dynamicImporters.push(module.id);\n            }\n        }\n    }\n    // If this is a preload, then this method always waits for the dependencies of\n    // the module to be resolved.\n    // Otherwise, if the module does not exist, it waits for the module and all\n    // its dependencies to be loaded.\n    // Otherwise, it returns immediately.\n    async fetchModule({ attributes, id, meta, moduleSideEffects, syntheticNamedExports }, importer, isEntry, isPreload) {\n        const existingModule = this.modulesById.get(id);\n        if (existingModule instanceof Module) {\n            if (importer && doAttributesDiffer(attributes, existingModule.info.attributes)) {\n                this.options.onLog(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInconsistentImportAttributes)(existingModule.info.attributes, attributes, id, importer));\n            }\n            await this.handleExistingModule(existingModule, isEntry, isPreload);\n            return existingModule;\n        }\n        if (existingModule instanceof ExternalModule) {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logExternalModulesCannotBeTransformedToModules)(existingModule.id));\n        }\n        const module = new Module(this.graph, id, this.options, isEntry, moduleSideEffects, syntheticNamedExports, meta, attributes);\n        this.modulesById.set(id, module);\n        const loadPromise = this.addModuleSource(id, importer, module).then(() => [\n            this.getResolveStaticDependencyPromises(module),\n            this.getResolveDynamicImportPromises(module),\n            loadAndResolveDependenciesPromise\n        ]);\n        const loadAndResolveDependenciesPromise = waitForDependencyResolution(loadPromise).then(() => this.pluginDriver.hookParallel('moduleParsed', [module.info]));\n        loadAndResolveDependenciesPromise.catch(() => {\n            /* avoid unhandled promise rejections */\n        });\n        this.moduleLoadPromises.set(module, loadPromise);\n        const resolveDependencyPromises = await loadPromise;\n        if (!isPreload) {\n            await this.fetchModuleDependencies(module, ...resolveDependencyPromises);\n        }\n        else if (isPreload === RESOLVE_DEPENDENCIES) {\n            await loadAndResolveDependenciesPromise;\n        }\n        return module;\n    }\n    async fetchModuleDependencies(module, resolveStaticDependencyPromises, resolveDynamicDependencyPromises, loadAndResolveDependenciesPromise) {\n        if (this.modulesWithLoadedDependencies.has(module)) {\n            return;\n        }\n        this.modulesWithLoadedDependencies.add(module);\n        await Promise.all([\n            this.fetchStaticDependencies(module, resolveStaticDependencyPromises),\n            this.fetchDynamicDependencies(module, resolveDynamicDependencyPromises)\n        ]);\n        module.linkImports();\n        // To handle errors when resolving dependencies or in moduleParsed\n        await loadAndResolveDependenciesPromise;\n    }\n    fetchResolvedDependency(source, importer, resolvedId) {\n        if (resolvedId.external) {\n            const { attributes, external, id, moduleSideEffects, meta } = resolvedId;\n            let externalModule = this.modulesById.get(id);\n            if (!externalModule) {\n                externalModule = new ExternalModule(this.options, id, moduleSideEffects, meta, external !== 'absolute' && (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.isAbsolute)(id), attributes);\n                this.modulesById.set(id, externalModule);\n            }\n            else if (!(externalModule instanceof ExternalModule)) {\n                return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInternalIdCannotBeExternal)(source, importer));\n            }\n            else if (doAttributesDiffer(externalModule.info.attributes, attributes)) {\n                this.options.onLog(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInconsistentImportAttributes)(externalModule.info.attributes, attributes, source, importer));\n            }\n            return Promise.resolve(externalModule);\n        }\n        return this.fetchModule(resolvedId, importer, false, false);\n    }\n    async fetchStaticDependencies(module, resolveStaticDependencyPromises) {\n        for (const dependency of await Promise.all(resolveStaticDependencyPromises.map(resolveStaticDependencyPromise => resolveStaticDependencyPromise.then(([source, resolvedId]) => this.fetchResolvedDependency(source, module.id, resolvedId))))) {\n            module.dependencies.add(dependency);\n            dependency.importers.push(module.id);\n        }\n        if (!this.options.treeshake || module.info.moduleSideEffects === 'no-treeshake') {\n            for (const dependency of module.dependencies) {\n                if (dependency instanceof Module) {\n                    dependency.importedFromNotTreeshaken = true;\n                }\n            }\n        }\n    }\n    getNormalizedResolvedIdWithoutDefaults(resolveIdResult, importer, source) {\n        const { makeAbsoluteExternalsRelative } = this.options;\n        if (resolveIdResult) {\n            if (typeof resolveIdResult === 'object') {\n                const external = resolveIdResult.external || this.options.external(resolveIdResult.id, importer, true);\n                return {\n                    ...resolveIdResult,\n                    external: external &&\n                        (external === 'relative' ||\n                            !(0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.isAbsolute)(resolveIdResult.id) ||\n                            (external === true &&\n                                isNotAbsoluteExternal(resolveIdResult.id, source, makeAbsoluteExternalsRelative)) ||\n                            'absolute')\n                };\n            }\n            const external = this.options.external(resolveIdResult, importer, true);\n            return {\n                external: external &&\n                    (isNotAbsoluteExternal(resolveIdResult, source, makeAbsoluteExternalsRelative) ||\n                        'absolute'),\n                id: external && makeAbsoluteExternalsRelative\n                    ? normalizeRelativeExternalId(resolveIdResult, importer)\n                    : resolveIdResult\n            };\n        }\n        const id = makeAbsoluteExternalsRelative\n            ? normalizeRelativeExternalId(source, importer)\n            : source;\n        if (resolveIdResult !== false && !this.options.external(id, importer, true)) {\n            return null;\n        }\n        return {\n            external: isNotAbsoluteExternal(id, source, makeAbsoluteExternalsRelative) || 'absolute',\n            id\n        };\n    }\n    getResolveDynamicImportPromises(module) {\n        return module.dynamicImports.map(async (dynamicImport) => {\n            const resolvedId = await this.resolveDynamicImport(module, dynamicImport.argument, module.id, getAttributesFromImportExpression(dynamicImport.node));\n            if (resolvedId && typeof resolvedId === 'object') {\n                dynamicImport.id = resolvedId.id;\n            }\n            return [dynamicImport, resolvedId];\n        });\n    }\n    getResolveStaticDependencyPromises(module) {\n        return Array.from(module.sourcesWithAttributes, async ([source, attributes]) => [\n            source,\n            (module.resolvedIds[source] =\n                module.resolvedIds[source] ||\n                    this.handleInvalidResolvedId(await this.resolveId(source, module.id, _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJECT, false, attributes), source, module.id, attributes))\n        ]);\n    }\n    getResolvedIdWithDefaults(resolvedId, attributes) {\n        if (!resolvedId) {\n            return null;\n        }\n        const external = resolvedId.external || false;\n        return {\n            attributes: resolvedId.attributes || attributes,\n            external,\n            id: resolvedId.id,\n            meta: resolvedId.meta || {},\n            moduleSideEffects: resolvedId.moduleSideEffects ?? this.hasModuleSideEffects(resolvedId.id, !!external),\n            resolvedBy: resolvedId.resolvedBy ?? 'rollup',\n            syntheticNamedExports: resolvedId.syntheticNamedExports ?? false\n        };\n    }\n    async handleExistingModule(module, isEntry, isPreload) {\n        const loadPromise = this.moduleLoadPromises.get(module);\n        if (isPreload) {\n            return isPreload === RESOLVE_DEPENDENCIES\n                ? waitForDependencyResolution(loadPromise)\n                : loadPromise;\n        }\n        if (isEntry) {\n            // This reverts the changes in addEntryWithImplicitDependants and needs to\n            // be performed atomically\n            module.info.isEntry = true;\n            this.implicitEntryModules.delete(module);\n            for (const dependant of module.implicitlyLoadedAfter) {\n                dependant.implicitlyLoadedBefore.delete(module);\n            }\n            module.implicitlyLoadedAfter.clear();\n        }\n        return this.fetchModuleDependencies(module, ...(await loadPromise));\n    }\n    handleInvalidResolvedId(resolvedId, source, importer, attributes) {\n        if (resolvedId === null) {\n            if ((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.isRelative)(source)) {\n                return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logUnresolvedImport)(source, importer));\n            }\n            this.options.onLog(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logUnresolvedImportTreatedAsExternal)(source, importer));\n            return {\n                attributes,\n                external: true,\n                id: source,\n                meta: {},\n                moduleSideEffects: this.hasModuleSideEffects(source, true),\n                resolvedBy: 'rollup',\n                syntheticNamedExports: false\n            };\n        }\n        else if (resolvedId.external && resolvedId.syntheticNamedExports) {\n            this.options.onLog(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logExternalSyntheticExports)(source, importer));\n        }\n        return resolvedId;\n    }\n    async loadEntryModule(unresolvedId, isEntry, importer, implicitlyLoadedBefore, isLoadForManualChunks = false) {\n        const resolveIdResult = await resolveId(unresolvedId, importer, this.options.preserveSymlinks, this.pluginDriver, this.resolveId, null, _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJECT, true, _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJECT);\n        if (resolveIdResult == null) {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)(implicitlyLoadedBefore === null\n                ? (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logUnresolvedEntry)(unresolvedId)\n                : (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logUnresolvedImplicitDependant)(unresolvedId, implicitlyLoadedBefore));\n        }\n        const isExternalModules = typeof resolveIdResult === 'object' && resolveIdResult.external;\n        if (resolveIdResult === false || isExternalModules) {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)(implicitlyLoadedBefore === null\n                ? isExternalModules && isLoadForManualChunks\n                    ? (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logExternalModulesCannotBeIncludedInManualChunks)(unresolvedId)\n                    : (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logEntryCannotBeExternal)(unresolvedId)\n                : (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logImplicitDependantCannotBeExternal)(unresolvedId, implicitlyLoadedBefore));\n        }\n        return this.fetchModule(this.getResolvedIdWithDefaults(typeof resolveIdResult === 'object'\n            ? resolveIdResult\n            : { id: resolveIdResult }, _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJECT), undefined, isEntry, false);\n    }\n    async resolveDynamicImport(module, specifier, importer, attributes) {\n        const resolution = await this.pluginDriver.hookFirst('resolveDynamicImport', [\n            specifier,\n            importer,\n            { attributes }\n        ]);\n        if (typeof specifier !== 'string') {\n            if (typeof resolution === 'string') {\n                return resolution;\n            }\n            if (!resolution) {\n                return null;\n            }\n            return this.getResolvedIdWithDefaults(resolution, attributes);\n        }\n        if (resolution == null) {\n            const existingResolution = module.resolvedIds[specifier];\n            if (existingResolution) {\n                if (doAttributesDiffer(existingResolution.attributes, attributes)) {\n                    this.options.onLog(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInconsistentImportAttributes)(existingResolution.attributes, attributes, specifier, importer));\n                }\n                return existingResolution;\n            }\n            return (module.resolvedIds[specifier] = this.handleInvalidResolvedId(await this.resolveId(specifier, module.id, _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJECT, false, attributes), specifier, module.id, attributes));\n        }\n        return this.handleInvalidResolvedId(this.getResolvedIdWithDefaults(this.getNormalizedResolvedIdWithoutDefaults(resolution, importer, specifier), attributes), specifier, importer, attributes);\n    }\n}\nfunction normalizeRelativeExternalId(source, importer) {\n    return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.isRelative)(source)\n        ? importer\n            ? (0,node_path__WEBPACK_IMPORTED_MODULE_1__.resolve)(importer, '..', source)\n            : (0,node_path__WEBPACK_IMPORTED_MODULE_1__.resolve)(source)\n        : source;\n}\nfunction addChunkNamesToModule(module, { fileName, name }, isUserDefined, priority) {\n    if (fileName !== null) {\n        module.chunkFileNames.add(fileName);\n    }\n    else if (name !== null) {\n        // Always keep chunkNames sorted by priority\n        let namePosition = 0;\n        while (module.chunkNames[namePosition]?.priority < priority)\n            namePosition++;\n        module.chunkNames.splice(namePosition, 0, { isUserDefined, name, priority });\n    }\n}\nfunction isNotAbsoluteExternal(id, source, makeAbsoluteExternalsRelative) {\n    return (makeAbsoluteExternalsRelative === true ||\n        (makeAbsoluteExternalsRelative === 'ifRelativeSource' && (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.isRelative)(source)) ||\n        !(0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.isAbsolute)(id));\n}\nasync function waitForDependencyResolution(loadPromise) {\n    const [resolveStaticDependencyPromises, resolveDynamicImportPromises] = await loadPromise;\n    return Promise.all([...resolveStaticDependencyPromises, ...resolveDynamicImportPromises]);\n}\n\nfunction generateAssetFileName(name, names, source, originalFileName, originalFileNames, sourceHash, outputOptions, bundle, inputOptions) {\n    const emittedName = outputOptions.sanitizeFileName(name || 'asset');\n    return makeUnique(renderNamePattern(typeof outputOptions.assetFileNames === 'function'\n        ? outputOptions.assetFileNames({\n            // Additionally, this should be non-enumerable in the next major\n            get name() {\n                (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.warnDeprecation)('Accessing the \"name\" property of emitted assets when generating the file name is deprecated. Use the \"names\" property instead.', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_GENERATEBUNDLE, false, inputOptions);\n                return name;\n            },\n            names,\n            // Additionally, this should be non-enumerable in the next major\n            get originalFileName() {\n                (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.warnDeprecation)('Accessing the \"originalFileName\" property of emitted assets when generating the file name is deprecated. Use the \"originalFileNames\" property instead.', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_GENERATEBUNDLE, false, inputOptions);\n                return originalFileName;\n            },\n            originalFileNames,\n            source,\n            type: 'asset'\n        })\n        : outputOptions.assetFileNames, 'output.assetFileNames', {\n        ext: () => (0,node_path__WEBPACK_IMPORTED_MODULE_1__.extname)(emittedName).slice(1),\n        extname: () => (0,node_path__WEBPACK_IMPORTED_MODULE_1__.extname)(emittedName),\n        hash: size => sourceHash.slice(0, Math.max(0, size || DEFAULT_HASH_SIZE)),\n        name: () => emittedName.slice(0, Math.max(0, emittedName.length - (0,node_path__WEBPACK_IMPORTED_MODULE_1__.extname)(emittedName).length))\n    }), bundle);\n}\nfunction reserveFileNameInBundle(fileName, { bundle }, log) {\n    if (bundle[lowercaseBundleKeys].has(fileName.toLowerCase())) {\n        log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logFileNameConflict)(fileName));\n    }\n    else {\n        bundle[fileName] = FILE_PLACEHOLDER;\n    }\n}\nconst emittedFileTypes = new Set(['chunk', 'asset', 'prebuilt-chunk']);\nfunction hasValidType(emittedFile) {\n    return Boolean(emittedFile &&\n        emittedFileTypes.has(emittedFile.type));\n}\nfunction hasValidName(emittedFile) {\n    const validatedName = emittedFile.fileName || emittedFile.name;\n    return !validatedName || (typeof validatedName === 'string' && !(0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.isPathFragment)(validatedName));\n}\nfunction getValidSource(source, emittedFile, fileReferenceId) {\n    if (!(typeof source === 'string' || source instanceof Uint8Array)) {\n        const assetName = emittedFile.fileName || emittedFile.name || fileReferenceId;\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logFailedValidation)(`Could not set source for ${typeof assetName === 'string' ? `asset \"${assetName}\"` : 'unnamed asset'}, asset source needs to be a string, Uint8Array or Buffer.`));\n    }\n    return source;\n}\nfunction getAssetFileName(file, referenceId) {\n    if (typeof file.fileName !== 'string') {\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logAssetNotFinalisedForFileName)(file.name || referenceId));\n    }\n    return file.fileName;\n}\nfunction getChunkFileName(file, facadeChunkByModule) {\n    if (file.fileName) {\n        return file.fileName;\n    }\n    if (facadeChunkByModule) {\n        return facadeChunkByModule.get(file.module).getFileName();\n    }\n    return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logChunkNotGeneratedForFileName)(file.fileName || file.name));\n}\nclass FileEmitter {\n    constructor(graph, options, baseFileEmitter) {\n        this.graph = graph;\n        this.options = options;\n        this.facadeChunkByModule = null;\n        this.nextIdBase = 1;\n        this.output = null;\n        this.outputFileEmitters = [];\n        this.emitFile = (emittedFile) => {\n            if (!hasValidType(emittedFile)) {\n                return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logFailedValidation)(`Emitted files must be of type \"asset\", \"chunk\" or \"prebuilt-chunk\", received \"${emittedFile && emittedFile.type}\".`));\n            }\n            if (emittedFile.type === 'prebuilt-chunk') {\n                return this.emitPrebuiltChunk(emittedFile);\n            }\n            if (!hasValidName(emittedFile)) {\n                return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logFailedValidation)(`The \"fileName\" or \"name\" properties of emitted chunks and assets must be strings that are neither absolute nor relative paths, received \"${emittedFile.fileName || emittedFile.name}\".`));\n            }\n            if (emittedFile.type === 'chunk') {\n                return this.emitChunk(emittedFile);\n            }\n            return this.emitAsset(emittedFile);\n        };\n        this.finaliseAssets = () => {\n            for (const [referenceId, emittedFile] of this.filesByReferenceId) {\n                if (emittedFile.type === 'asset' && typeof emittedFile.fileName !== 'string')\n                    return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logNoAssetSourceSet)(emittedFile.name || referenceId));\n            }\n        };\n        this.getFileName = (fileReferenceId) => {\n            const emittedFile = this.filesByReferenceId.get(fileReferenceId);\n            if (!emittedFile)\n                return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logFileReferenceIdNotFoundForFilename)(fileReferenceId));\n            if (emittedFile.type === 'chunk') {\n                return getChunkFileName(emittedFile, this.facadeChunkByModule);\n            }\n            if (emittedFile.type === 'prebuilt-chunk') {\n                return emittedFile.fileName;\n            }\n            return getAssetFileName(emittedFile, fileReferenceId);\n        };\n        this.setAssetSource = (referenceId, requestedSource) => {\n            const consumedFile = this.filesByReferenceId.get(referenceId);\n            if (!consumedFile)\n                return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logAssetReferenceIdNotFoundForSetSource)(referenceId));\n            if (consumedFile.type !== 'asset') {\n                return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logFailedValidation)(`Asset sources can only be set for emitted assets but \"${referenceId}\" is an emitted chunk.`));\n            }\n            if (consumedFile.source !== undefined) {\n                return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logAssetSourceAlreadySet)(consumedFile.name || referenceId));\n            }\n            const source = getValidSource(requestedSource, consumedFile, referenceId);\n            if (this.output) {\n                this.finalizeAdditionalAsset(consumedFile, source, this.output);\n            }\n            else {\n                consumedFile.source = source;\n                for (const emitter of this.outputFileEmitters) {\n                    emitter.finalizeAdditionalAsset(consumedFile, source, emitter.output);\n                }\n            }\n        };\n        this.setChunkInformation = (facadeChunkByModule) => {\n            this.facadeChunkByModule = facadeChunkByModule;\n        };\n        this.setOutputBundle = (bundle, outputOptions) => {\n            const getHash = hasherByType[outputOptions.hashCharacters];\n            const output = (this.output = {\n                bundle,\n                fileNamesBySourceHash: new Map(),\n                getHash,\n                outputOptions\n            });\n            for (const emittedFile of this.filesByReferenceId.values()) {\n                if (emittedFile.fileName) {\n                    reserveFileNameInBundle(emittedFile.fileName, output, this.options.onLog);\n                }\n            }\n            const consumedAssetsByHash = new Map();\n            for (const consumedFile of this.filesByReferenceId.values()) {\n                if (consumedFile.type === 'asset' && consumedFile.source !== undefined) {\n                    if (consumedFile.fileName) {\n                        this.finalizeAdditionalAsset(consumedFile, consumedFile.source, output);\n                    }\n                    else {\n                        const sourceHash = getHash(consumedFile.source);\n                        getOrCreate(consumedAssetsByHash, sourceHash, () => []).push(consumedFile);\n                    }\n                }\n                else if (consumedFile.type === 'prebuilt-chunk') {\n                    this.output.bundle[consumedFile.fileName] = this.createPrebuiltChunk(consumedFile);\n                }\n            }\n            for (const [sourceHash, consumedFiles] of consumedAssetsByHash) {\n                this.finalizeAssetsWithSameSource(consumedFiles, sourceHash, output);\n            }\n        };\n        this.filesByReferenceId = baseFileEmitter\n            ? new Map(baseFileEmitter.filesByReferenceId)\n            : new Map();\n        baseFileEmitter?.addOutputFileEmitter(this);\n    }\n    addOutputFileEmitter(outputFileEmitter) {\n        this.outputFileEmitters.push(outputFileEmitter);\n    }\n    assignReferenceId(file, idBase) {\n        let referenceId = idBase;\n        do {\n            referenceId = getHash64(referenceId).slice(0, 8).replaceAll('-', '$');\n        } while (this.filesByReferenceId.has(referenceId) ||\n            this.outputFileEmitters.some(({ filesByReferenceId }) => filesByReferenceId.has(referenceId)));\n        file.referenceId = referenceId;\n        this.filesByReferenceId.set(referenceId, file);\n        for (const { filesByReferenceId } of this.outputFileEmitters) {\n            filesByReferenceId.set(referenceId, file);\n        }\n        return referenceId;\n    }\n    createPrebuiltChunk(prebuiltChunk) {\n        return {\n            code: prebuiltChunk.code,\n            dynamicImports: [],\n            exports: prebuiltChunk.exports || [],\n            facadeModuleId: null,\n            fileName: prebuiltChunk.fileName,\n            implicitlyLoadedBefore: [],\n            importedBindings: {},\n            imports: [],\n            isDynamicEntry: false,\n            isEntry: false,\n            isImplicitEntry: false,\n            map: prebuiltChunk.map || null,\n            moduleIds: [],\n            modules: {},\n            name: prebuiltChunk.fileName,\n            preliminaryFileName: prebuiltChunk.fileName,\n            referencedFiles: [],\n            sourcemapFileName: prebuiltChunk.sourcemapFileName || null,\n            type: 'chunk'\n        };\n    }\n    emitAsset(emittedAsset) {\n        const source = emittedAsset.source === undefined\n            ? undefined\n            : getValidSource(emittedAsset.source, emittedAsset, null);\n        const originalFileName = emittedAsset.originalFileName || null;\n        if (typeof originalFileName === 'string') {\n            this.graph.watchFiles[originalFileName] = true;\n        }\n        const consumedAsset = {\n            fileName: emittedAsset.fileName,\n            name: emittedAsset.name,\n            needsCodeReference: !!emittedAsset.needsCodeReference,\n            originalFileName,\n            referenceId: '',\n            source,\n            type: 'asset'\n        };\n        const referenceId = this.assignReferenceId(consumedAsset, emittedAsset.fileName || emittedAsset.name || String(this.nextIdBase++));\n        if (this.output) {\n            this.emitAssetWithReferenceId(consumedAsset, this.output);\n        }\n        else {\n            for (const fileEmitter of this.outputFileEmitters) {\n                fileEmitter.emitAssetWithReferenceId(consumedAsset, fileEmitter.output);\n            }\n        }\n        return referenceId;\n    }\n    emitAssetWithReferenceId(consumedAsset, output) {\n        const { fileName, source } = consumedAsset;\n        if (fileName) {\n            reserveFileNameInBundle(fileName, output, this.options.onLog);\n        }\n        if (source !== undefined) {\n            this.finalizeAdditionalAsset(consumedAsset, source, output);\n        }\n    }\n    emitChunk(emittedChunk) {\n        if (this.graph.phase > BuildPhase.LOAD_AND_PARSE) {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidRollupPhaseForChunkEmission)());\n        }\n        if (typeof emittedChunk.id !== 'string') {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logFailedValidation)(`Emitted chunks need to have a valid string id, received \"${emittedChunk.id}\"`));\n        }\n        const consumedChunk = {\n            fileName: emittedChunk.fileName,\n            module: null,\n            name: emittedChunk.name || emittedChunk.id,\n            referenceId: '',\n            type: 'chunk'\n        };\n        this.graph.moduleLoader\n            .emitChunk(emittedChunk)\n            .then(module => (consumedChunk.module = module))\n            .catch(() => {\n            // Avoid unhandled Promise rejection as the error will be thrown later\n            // once module loading has finished\n        });\n        return this.assignReferenceId(consumedChunk, emittedChunk.id);\n    }\n    emitPrebuiltChunk(emitPrebuiltChunk) {\n        if (typeof emitPrebuiltChunk.code !== 'string') {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logFailedValidation)(`Emitted prebuilt chunks need to have a valid string code, received \"${emitPrebuiltChunk.code}\".`));\n        }\n        if (typeof emitPrebuiltChunk.fileName !== 'string' ||\n            (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.isPathFragment)(emitPrebuiltChunk.fileName)) {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logFailedValidation)(`The \"fileName\" property of emitted prebuilt chunks must be strings that are neither absolute nor relative paths, received \"${emitPrebuiltChunk.fileName}\".`));\n        }\n        const consumedPrebuiltChunk = {\n            code: emitPrebuiltChunk.code,\n            exports: emitPrebuiltChunk.exports,\n            fileName: emitPrebuiltChunk.fileName,\n            map: emitPrebuiltChunk.map,\n            referenceId: '',\n            type: 'prebuilt-chunk'\n        };\n        const referenceId = this.assignReferenceId(consumedPrebuiltChunk, consumedPrebuiltChunk.fileName);\n        if (this.output) {\n            this.output.bundle[consumedPrebuiltChunk.fileName] =\n                this.createPrebuiltChunk(consumedPrebuiltChunk);\n        }\n        return referenceId;\n    }\n    finalizeAdditionalAsset(consumedFile, source, { bundle, fileNamesBySourceHash, getHash, outputOptions }) {\n        let { fileName, name, needsCodeReference, originalFileName, referenceId } = consumedFile;\n        // Deduplicate assets if an explicit fileName is not provided\n        if (!fileName) {\n            const sourceHash = getHash(source);\n            fileName = fileNamesBySourceHash.get(sourceHash);\n            if (!fileName) {\n                fileName = generateAssetFileName(name, name ? [name] : [], source, originalFileName, originalFileName ? [originalFileName] : [], sourceHash, outputOptions, bundle, this.options);\n                fileNamesBySourceHash.set(sourceHash, fileName);\n            }\n        }\n        // We must not modify the original assets to avoid interaction between outputs\n        const assetWithFileName = { ...consumedFile, fileName, source };\n        this.filesByReferenceId.set(referenceId, assetWithFileName);\n        const existingAsset = bundle[fileName];\n        if (existingAsset?.type === 'asset') {\n            existingAsset.needsCodeReference &&= needsCodeReference;\n            if (name) {\n                existingAsset.names.push(name);\n            }\n            if (originalFileName) {\n                existingAsset.originalFileNames.push(originalFileName);\n            }\n        }\n        else {\n            const { options } = this;\n            bundle[fileName] = {\n                fileName,\n                get name() {\n                    // Additionally, this should be non-enumerable in the next major\n                    (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.warnDeprecation)('Accessing the \"name\" property of emitted assets in the bundle is deprecated. Use the \"names\" property instead.', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_GENERATEBUNDLE, false, options);\n                    return name;\n                },\n                names: name ? [name] : [],\n                needsCodeReference,\n                get originalFileName() {\n                    // Additionally, this should be non-enumerable in the next major\n                    (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.warnDeprecation)('Accessing the \"originalFileName\" property of emitted assets in the bundle is deprecated. Use the \"originalFileNames\" property instead.', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_GENERATEBUNDLE, false, options);\n                    return originalFileName;\n                },\n                originalFileNames: originalFileName ? [originalFileName] : [],\n                source,\n                type: 'asset'\n            };\n        }\n    }\n    finalizeAssetsWithSameSource(consumedFiles, sourceHash, { bundle, fileNamesBySourceHash, outputOptions }) {\n        const { names, originalFileNames } = getNamesFromAssets(consumedFiles);\n        let fileName = '';\n        let usedConsumedFile;\n        let needsCodeReference = true;\n        for (const consumedFile of consumedFiles) {\n            needsCodeReference &&= consumedFile.needsCodeReference;\n            const assetFileName = generateAssetFileName(consumedFile.name, names, consumedFile.source, consumedFile.originalFileName, originalFileNames, sourceHash, outputOptions, bundle, this.options);\n            if (!fileName ||\n                assetFileName.length < fileName.length ||\n                (assetFileName.length === fileName.length && assetFileName < fileName)) {\n                fileName = assetFileName;\n                usedConsumedFile = consumedFile;\n            }\n        }\n        fileNamesBySourceHash.set(sourceHash, fileName);\n        for (const consumedFile of consumedFiles) {\n            // We must not modify the original assets to avoid interaction between outputs\n            const assetWithFileName = { ...consumedFile, fileName };\n            this.filesByReferenceId.set(consumedFile.referenceId, assetWithFileName);\n        }\n        const { options } = this;\n        bundle[fileName] = {\n            fileName,\n            get name() {\n                // Additionally, this should be non-enumerable in the next major\n                (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.warnDeprecation)('Accessing the \"name\" property of emitted assets in the bundle is deprecated. Use the \"names\" property instead.', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_GENERATEBUNDLE, false, options);\n                return usedConsumedFile.name;\n            },\n            names,\n            needsCodeReference,\n            get originalFileName() {\n                // Additionally, this should be non-enumerable in the next major\n                (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.warnDeprecation)('Accessing the \"originalFileName\" property of emitted assets in the bundle is deprecated. Use the \"originalFileNames\" property instead.', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_GENERATEBUNDLE, false, options);\n                return usedConsumedFile.originalFileName;\n            },\n            originalFileNames,\n            source: usedConsumedFile.source,\n            type: 'asset'\n        };\n    }\n}\nfunction getNamesFromAssets(consumedFiles) {\n    const names = [];\n    const originalFileNames = [];\n    for (const { name, originalFileName } of consumedFiles) {\n        if (typeof name === 'string') {\n            names.push(name);\n        }\n        if (originalFileName) {\n            originalFileNames.push(originalFileName);\n        }\n    }\n    originalFileNames.sort();\n    // Sort by length first and then alphabetically so that the order is stable\n    // and the shortest names come first\n    names.sort((a, b) => a.length - b.length || (a > b ? 1 : a === b ? 0 : -1));\n    return { names, originalFileNames };\n}\n\nfunction getLogHandler(level, code, logger, pluginName, logLevel) {\n    if (_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logLevelPriority[level] < _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logLevelPriority[logLevel]) {\n        return doNothing;\n    }\n    return (log, pos) => {\n        if (pos != null) {\n            logger(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidLogPosition)(pluginName));\n        }\n        log = normalizeLog(log);\n        if (log.code && !log.pluginCode) {\n            log.pluginCode = log.code;\n        }\n        log.code = code;\n        log.plugin = pluginName;\n        logger(level, log);\n    };\n}\n\nfunction getPluginContext(plugin, pluginCache, graph, options, fileEmitter, existingPluginNames) {\n    const { logLevel, onLog } = options;\n    let cacheable = true;\n    if (typeof plugin.cacheKey !== 'string') {\n        if (plugin.name.startsWith(ANONYMOUS_PLUGIN_PREFIX) ||\n            plugin.name.startsWith(ANONYMOUS_OUTPUT_PLUGIN_PREFIX) ||\n            existingPluginNames.has(plugin.name)) {\n            cacheable = false;\n        }\n        else {\n            existingPluginNames.add(plugin.name);\n        }\n    }\n    let cacheInstance;\n    if (!pluginCache) {\n        cacheInstance = NO_CACHE;\n    }\n    else if (cacheable) {\n        const cacheKey = plugin.cacheKey || plugin.name;\n        cacheInstance = createPluginCache(pluginCache[cacheKey] || (pluginCache[cacheKey] = Object.create(null)));\n    }\n    else {\n        cacheInstance = getCacheForUncacheablePlugin(plugin.name);\n    }\n    return {\n        addWatchFile(id) {\n            graph.watchFiles[id] = true;\n        },\n        cache: cacheInstance,\n        debug: getLogHandler(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_DEBUG, 'PLUGIN_LOG', onLog, plugin.name, logLevel),\n        emitFile: fileEmitter.emitFile.bind(fileEmitter),\n        error(error_) {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logPluginError)(normalizeLog(error_), plugin.name));\n        },\n        getFileName: fileEmitter.getFileName,\n        getModuleIds: () => graph.modulesById.keys(),\n        getModuleInfo: graph.getModuleInfo,\n        getWatchFiles: () => Object.keys(graph.watchFiles),\n        info: getLogHandler(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_INFO, 'PLUGIN_LOG', onLog, plugin.name, logLevel),\n        load(resolvedId) {\n            return graph.moduleLoader.preloadModule(resolvedId);\n        },\n        meta: {\n            rollupVersion: version,\n            watchMode: graph.watchMode\n        },\n        parse: _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.parseAst,\n        resolve(source, importer, { attributes, custom, isEntry, skipSelf } = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.BLANK) {\n            skipSelf ??= true;\n            return graph.moduleLoader.resolveId(source, importer, custom, isEntry, attributes || _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJECT, skipSelf ? [{ importer, plugin, source }] : null);\n        },\n        setAssetSource: fileEmitter.setAssetSource,\n        warn: getLogHandler(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, 'PLUGIN_WARNING', onLog, plugin.name, logLevel)\n    };\n}\n\n// This will make sure no input hook is omitted\nconst inputHookNames = {\n    buildEnd: 1,\n    buildStart: 1,\n    closeBundle: 1,\n    closeWatcher: 1,\n    load: 1,\n    moduleParsed: 1,\n    onLog: 1,\n    options: 1,\n    resolveDynamicImport: 1,\n    resolveId: 1,\n    shouldTransformCachedModule: 1,\n    transform: 1,\n    watchChange: 1\n};\nconst inputHooks = Object.keys(inputHookNames);\nclass PluginDriver {\n    constructor(graph, options, userPlugins, pluginCache, basePluginDriver) {\n        this.graph = graph;\n        this.options = options;\n        this.pluginCache = pluginCache;\n        this.sortedPlugins = new Map();\n        this.unfulfilledActions = new Set();\n        this.fileEmitter = new FileEmitter(graph, options, basePluginDriver && basePluginDriver.fileEmitter);\n        this.emitFile = this.fileEmitter.emitFile.bind(this.fileEmitter);\n        this.getFileName = this.fileEmitter.getFileName.bind(this.fileEmitter);\n        this.finaliseAssets = this.fileEmitter.finaliseAssets.bind(this.fileEmitter);\n        this.setChunkInformation = this.fileEmitter.setChunkInformation.bind(this.fileEmitter);\n        this.setOutputBundle = this.fileEmitter.setOutputBundle.bind(this.fileEmitter);\n        this.plugins = [...(basePluginDriver ? basePluginDriver.plugins : []), ...userPlugins];\n        const existingPluginNames = new Set();\n        this.pluginContexts = new Map(this.plugins.map(plugin => [\n            plugin,\n            getPluginContext(plugin, pluginCache, graph, options, this.fileEmitter, existingPluginNames)\n        ]));\n        if (basePluginDriver) {\n            for (const plugin of userPlugins) {\n                for (const hook of inputHooks) {\n                    if (hook in plugin) {\n                        options.onLog(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInputHookInOutputPlugin)(plugin.name, hook));\n                    }\n                }\n            }\n        }\n    }\n    createOutputPluginDriver(plugins) {\n        return new PluginDriver(this.graph, this.options, plugins, this.pluginCache, this);\n    }\n    getUnfulfilledHookActions() {\n        return this.unfulfilledActions;\n    }\n    // chains, first non-null result stops and returns\n    hookFirst(hookName, parameters, replaceContext, skipped) {\n        return this.hookFirstAndGetPlugin(hookName, parameters, replaceContext, skipped).then(result => result && result[0]);\n    }\n    // chains, first non-null result stops and returns result and last plugin\n    async hookFirstAndGetPlugin(hookName, parameters, replaceContext, skipped) {\n        for (const plugin of this.getSortedPlugins(hookName)) {\n            if (skipped?.has(plugin))\n                continue;\n            const result = await this.runHook(hookName, parameters, plugin, replaceContext);\n            if (result != null)\n                return [result, plugin];\n        }\n        return null;\n    }\n    // chains synchronously, first non-null result stops and returns\n    hookFirstSync(hookName, parameters, replaceContext) {\n        for (const plugin of this.getSortedPlugins(hookName)) {\n            const result = this.runHookSync(hookName, parameters, plugin, replaceContext);\n            if (result != null)\n                return result;\n        }\n        return null;\n    }\n    // parallel, ignores returns\n    async hookParallel(hookName, parameters, replaceContext) {\n        const parallelPromises = [];\n        for (const plugin of this.getSortedPlugins(hookName)) {\n            if (plugin[hookName].sequential) {\n                await Promise.all(parallelPromises);\n                parallelPromises.length = 0;\n                await this.runHook(hookName, parameters, plugin, replaceContext);\n            }\n            else {\n                parallelPromises.push(this.runHook(hookName, parameters, plugin, replaceContext));\n            }\n        }\n        await Promise.all(parallelPromises);\n    }\n    // chains, reduces returned value, handling the reduced value as the first hook argument\n    hookReduceArg0(hookName, [argument0, ...rest], reduce, replaceContext) {\n        let promise = Promise.resolve(argument0);\n        for (const plugin of this.getSortedPlugins(hookName)) {\n            promise = promise.then(argument0 => this.runHook(hookName, [argument0, ...rest], plugin, replaceContext).then(result => reduce.call(this.pluginContexts.get(plugin), argument0, result, plugin)));\n        }\n        return promise;\n    }\n    // chains synchronously, reduces returned value, handling the reduced value as the first hook argument\n    hookReduceArg0Sync(hookName, [argument0, ...rest], reduce, replaceContext) {\n        for (const plugin of this.getSortedPlugins(hookName)) {\n            const parameters = [argument0, ...rest];\n            const result = this.runHookSync(hookName, parameters, plugin, replaceContext);\n            argument0 = reduce.call(this.pluginContexts.get(plugin), argument0, result, plugin);\n        }\n        return argument0;\n    }\n    // chains, reduces returned value to type string, handling the reduced value separately. permits hooks as values.\n    async hookReduceValue(hookName, initialValue, parameters, reducer) {\n        const results = [];\n        const parallelResults = [];\n        for (const plugin of this.getSortedPlugins(hookName, validateAddonPluginHandler)) {\n            if (plugin[hookName].sequential) {\n                results.push(...(await Promise.all(parallelResults)));\n                parallelResults.length = 0;\n                results.push(await this.runHook(hookName, parameters, plugin));\n            }\n            else {\n                parallelResults.push(this.runHook(hookName, parameters, plugin));\n            }\n        }\n        results.push(...(await Promise.all(parallelResults)));\n        return results.reduce(reducer, await initialValue);\n    }\n    // chains synchronously, reduces returned value to type T, handling the reduced value separately. permits hooks as values.\n    hookReduceValueSync(hookName, initialValue, parameters, reduce, replaceContext) {\n        let accumulator = initialValue;\n        for (const plugin of this.getSortedPlugins(hookName)) {\n            const result = this.runHookSync(hookName, parameters, plugin, replaceContext);\n            accumulator = reduce.call(this.pluginContexts.get(plugin), accumulator, result, plugin);\n        }\n        return accumulator;\n    }\n    // chains, ignores returns\n    hookSeq(hookName, parameters, replaceContext) {\n        let promise = Promise.resolve();\n        for (const plugin of this.getSortedPlugins(hookName)) {\n            promise = promise.then(() => this.runHook(hookName, parameters, plugin, replaceContext));\n        }\n        return promise.then(noReturn);\n    }\n    getSortedPlugins(hookName, validateHandler) {\n        return getOrCreate(this.sortedPlugins, hookName, () => getSortedValidatedPlugins(hookName, this.plugins, validateHandler));\n    }\n    // Implementation signature\n    runHook(hookName, parameters, plugin, replaceContext) {\n        // We always filter for plugins that support the hook before running it\n        const hook = plugin[hookName];\n        const handler = typeof hook === 'object' ? hook.handler : hook;\n        let context = this.pluginContexts.get(plugin);\n        if (replaceContext) {\n            context = replaceContext(context, plugin);\n        }\n        let action = null;\n        return Promise.resolve()\n            .then(() => {\n            if (typeof handler !== 'function') {\n                return handler;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n            const hookResult = handler.apply(context, parameters);\n            if (!hookResult?.then) {\n                // short circuit for non-thenables and non-Promises\n                return hookResult;\n            }\n            // Track pending hook actions to properly error out when\n            // unfulfilled promises cause rollup to abruptly and confusingly\n            // exit with a successful 0 return code but without producing any\n            // output, errors or warnings.\n            action = [plugin.name, hookName, parameters];\n            this.unfulfilledActions.add(action);\n            // Although it would be more elegant to just return hookResult here\n            // and put the .then() handler just above the .catch() handler below,\n            // doing so would subtly change the defacto async event dispatch order\n            // which at least one test and some plugins in the wild may depend on.\n            return Promise.resolve(hookResult).then(result => {\n                // action was fulfilled\n                this.unfulfilledActions.delete(action);\n                return result;\n            });\n        })\n            .catch(error_ => {\n            if (action !== null) {\n                // action considered to be fulfilled since error being handled\n                this.unfulfilledActions.delete(action);\n            }\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logPluginError)(error_, plugin.name, { hook: hookName }));\n        });\n    }\n    /**\n     * Run a sync plugin hook and return the result.\n     * @param hookName Name of the plugin hook. Must be in `PluginHooks`.\n     * @param args Arguments passed to the plugin hook.\n     * @param plugin The acutal plugin\n     * @param replaceContext When passed, the plugin context can be overridden.\n     */\n    runHookSync(hookName, parameters, plugin, replaceContext) {\n        const hook = plugin[hookName];\n        const handler = typeof hook === 'object' ? hook.handler : hook;\n        let context = this.pluginContexts.get(plugin);\n        if (replaceContext) {\n            context = replaceContext(context, plugin);\n        }\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n            return handler.apply(context, parameters);\n        }\n        catch (error_) {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logPluginError)(error_, plugin.name, { hook: hookName }));\n        }\n    }\n}\nfunction getSortedValidatedPlugins(hookName, plugins, validateHandler = validateFunctionPluginHandler) {\n    const pre = [];\n    const normal = [];\n    const post = [];\n    for (const plugin of plugins) {\n        const hook = plugin[hookName];\n        if (hook) {\n            if (typeof hook === 'object') {\n                validateHandler(hook.handler, hookName, plugin);\n                if (hook.order === 'pre') {\n                    pre.push(plugin);\n                    continue;\n                }\n                if (hook.order === 'post') {\n                    post.push(plugin);\n                    continue;\n                }\n            }\n            else {\n                validateHandler(hook, hookName, plugin);\n            }\n            normal.push(plugin);\n        }\n    }\n    return [...pre, ...normal, ...post];\n}\nfunction validateFunctionPluginHandler(handler, hookName, plugin) {\n    if (typeof handler !== 'function') {\n        (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidFunctionPluginHook)(hookName, plugin.name));\n    }\n}\nfunction validateAddonPluginHandler(handler, hookName, plugin) {\n    if (typeof handler !== 'string' && typeof handler !== 'function') {\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidAddonPluginHook)(hookName, plugin.name));\n    }\n}\nfunction noReturn() { }\n\nclass Queue {\n    constructor(maxParallel) {\n        this.maxParallel = maxParallel;\n        this.queue = [];\n        this.workerCount = 0;\n    }\n    run(task) {\n        return new Promise((resolve, reject) => {\n            this.queue.push({ reject, resolve, task });\n            this.work();\n        });\n    }\n    async work() {\n        if (this.workerCount >= this.maxParallel)\n            return;\n        this.workerCount++;\n        let entry;\n        while ((entry = this.queue.shift())) {\n            const { reject, resolve, task } = entry;\n            try {\n                const result = await task();\n                resolve(result);\n            }\n            catch (error) {\n                reject(error);\n            }\n        }\n        this.workerCount--;\n    }\n}\n\nfunction normalizeEntryModules(entryModules) {\n    if (Array.isArray(entryModules)) {\n        return entryModules.map(id => ({\n            fileName: null,\n            id,\n            implicitlyLoadedAfter: [],\n            importer: undefined,\n            name: null\n        }));\n    }\n    return Object.entries(entryModules).map(([name, id]) => ({\n        fileName: null,\n        id,\n        implicitlyLoadedAfter: [],\n        importer: undefined,\n        name\n    }));\n}\nclass Graph {\n    constructor(options, watcher) {\n        this.options = options;\n        this.astLru = flru(5);\n        this.cachedModules = new Map();\n        this.deoptimizationTracker = new PathTracker();\n        this.entryModules = [];\n        this.modulesById = new Map();\n        this.needsTreeshakingPass = false;\n        this.phase = BuildPhase.LOAD_AND_PARSE;\n        this.scope = new GlobalScope();\n        this.watchFiles = Object.create(null);\n        this.watchMode = false;\n        this.externalModules = [];\n        this.implicitEntryModules = [];\n        this.modules = [];\n        this.getModuleInfo = (moduleId) => {\n            const foundModule = this.modulesById.get(moduleId);\n            if (!foundModule)\n                return null;\n            return foundModule.info;\n        };\n        if (options.cache !== false) {\n            if (options.cache?.modules) {\n                for (const module of options.cache.modules)\n                    this.cachedModules.set(module.id, module);\n            }\n            this.pluginCache = options.cache?.plugins || Object.create(null);\n            // increment access counter\n            for (const name in this.pluginCache) {\n                const cache = this.pluginCache[name];\n                for (const value of Object.values(cache))\n                    value[0]++;\n            }\n        }\n        if (watcher) {\n            this.watchMode = true;\n            const handleChange = (...parameters) => this.pluginDriver.hookParallel('watchChange', parameters);\n            const handleClose = () => this.pluginDriver.hookParallel('closeWatcher', []);\n            watcher.onCurrentRun('change', handleChange);\n            watcher.onCurrentRun('close', handleClose);\n        }\n        this.pluginDriver = new PluginDriver(this, options, options.plugins, this.pluginCache);\n        this.moduleLoader = new ModuleLoader(this, this.modulesById, this.options, this.pluginDriver);\n        this.fileOperationQueue = new Queue(options.maxParallelFileOps);\n        this.pureFunctions = getPureFunctions(options);\n    }\n    async build() {\n        timeStart('generate module graph', 2);\n        await this.generateModuleGraph();\n        timeEnd('generate module graph', 2);\n        timeStart('sort and bind modules', 2);\n        this.phase = BuildPhase.ANALYSE;\n        this.sortModules();\n        timeEnd('sort and bind modules', 2);\n        timeStart('mark included statements', 2);\n        this.includeStatements();\n        timeEnd('mark included statements', 2);\n        this.phase = BuildPhase.GENERATE;\n    }\n    getCache() {\n        // handle plugin cache eviction\n        for (const name in this.pluginCache) {\n            const cache = this.pluginCache[name];\n            let allDeleted = true;\n            for (const [key, value] of Object.entries(cache)) {\n                if (value[0] >= this.options.experimentalCacheExpiry)\n                    delete cache[key];\n                else\n                    allDeleted = false;\n            }\n            if (allDeleted)\n                delete this.pluginCache[name];\n        }\n        return {\n            modules: this.modules.map(module => module.toJSON()),\n            plugins: this.pluginCache\n        };\n    }\n    async generateModuleGraph() {\n        ({ entryModules: this.entryModules, implicitEntryModules: this.implicitEntryModules } =\n            await this.moduleLoader.addEntryModules(normalizeEntryModules(this.options.input), true));\n        if (this.entryModules.length === 0) {\n            throw new Error('You must supply options.input to rollup');\n        }\n        for (const module of this.modulesById.values()) {\n            module.cacheInfoGetters();\n            if (module instanceof Module) {\n                this.modules.push(module);\n            }\n            else {\n                this.externalModules.push(module);\n            }\n        }\n    }\n    includeStatements() {\n        const entryModules = [...this.entryModules, ...this.implicitEntryModules];\n        for (const module of entryModules) {\n            markModuleAndImpureDependenciesAsExecuted(module);\n        }\n        if (this.options.treeshake) {\n            let treeshakingPass = 1;\n            do {\n                timeStart(`treeshaking pass ${treeshakingPass}`, 3);\n                this.needsTreeshakingPass = false;\n                for (const module of this.modules) {\n                    if (module.isExecuted) {\n                        module.hasTreeShakingPassStarted = true;\n                        if (module.info.moduleSideEffects === 'no-treeshake') {\n                            module.includeAllInBundle();\n                        }\n                        else {\n                            module.include();\n                        }\n                    }\n                }\n                if (treeshakingPass === 1) {\n                    // We only include exports after the first pass to avoid issues with\n                    // the TDZ detection logic\n                    for (const module of entryModules) {\n                        if (module.preserveSignature !== false) {\n                            module.includeAllExports(false);\n                            this.needsTreeshakingPass = true;\n                        }\n                    }\n                }\n                timeEnd(`treeshaking pass ${treeshakingPass++}`, 3);\n            } while (this.needsTreeshakingPass);\n        }\n        else {\n            for (const module of this.modules)\n                module.includeAllInBundle();\n        }\n        for (const externalModule of this.externalModules)\n            externalModule.warnUnusedImports();\n        for (const module of this.implicitEntryModules) {\n            for (const dependant of module.implicitlyLoadedAfter) {\n                if (!(dependant.info.isEntry || dependant.isIncluded())) {\n                    (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logImplicitDependantIsNotIncluded)(dependant));\n                }\n            }\n        }\n    }\n    sortModules() {\n        const { orderedModules, cyclePaths } = analyseModuleExecution(this.entryModules);\n        for (const cyclePath of cyclePaths) {\n            this.options.onLog(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logCircularDependency)(cyclePath));\n        }\n        this.modules = orderedModules;\n        for (const module of this.modules) {\n            module.bindReferences();\n        }\n        this.warnForMissingExports();\n    }\n    warnForMissingExports() {\n        for (const module of this.modules) {\n            for (const importDescription of module.importDescriptions.values()) {\n                if (importDescription.name !== '*' &&\n                    !importDescription.module.getVariableForExportName(importDescription.name)[0]) {\n                    module.log(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logMissingExport)(importDescription.name, module.id, importDescription.module.id), importDescription.start);\n                }\n            }\n        }\n    }\n}\n\nfunction formatAction([pluginName, hookName, parameters]) {\n    const action = `(${pluginName}) ${hookName}`;\n    const s = JSON.stringify;\n    switch (hookName) {\n        case 'resolveId': {\n            return `${action} ${s(parameters[0])} ${s(parameters[1])}`;\n        }\n        case 'load': {\n            return `${action} ${s(parameters[0])}`;\n        }\n        case 'transform': {\n            return `${action} ${s(parameters[1])}`;\n        }\n        case 'shouldTransformCachedModule': {\n            return `${action} ${s(parameters[0].id)}`;\n        }\n        case 'moduleParsed': {\n            return `${action} ${s(parameters[0].id)}`;\n        }\n    }\n    return action;\n}\nlet handleBeforeExit = null;\nconst rejectByPluginDriver = new Map();\nasync function catchUnfinishedHookActions(pluginDriver, callback) {\n    const emptyEventLoopPromise = new Promise((_, reject) => {\n        rejectByPluginDriver.set(pluginDriver, reject);\n        if (!handleBeforeExit) {\n            // We only ever create a single event listener to avoid max listener and\n            // other issues\n            handleBeforeExit = () => {\n                for (const [pluginDriver, reject] of rejectByPluginDriver) {\n                    const unfulfilledActions = pluginDriver.getUnfulfilledHookActions();\n                    reject(new Error(`Unexpected early exit. This happens when Promises returned by plugins cannot resolve. Unfinished hook action(s) on exit:\\n` +\n                        [...unfulfilledActions].map(formatAction).join('\\n')));\n                }\n            };\n            node_process__WEBPACK_IMPORTED_MODULE_4__.once('beforeExit', handleBeforeExit);\n        }\n    });\n    try {\n        return await Promise.race([callback(), emptyEventLoopPromise]);\n    }\n    finally {\n        rejectByPluginDriver.delete(pluginDriver);\n        if (rejectByPluginDriver.size === 0) {\n            node_process__WEBPACK_IMPORTED_MODULE_4__.off('beforeExit', handleBeforeExit);\n            handleBeforeExit = null;\n        }\n    }\n}\n\nasync function initWasm() { }\n\nfunction getLogger(plugins, onLog, watchMode, logLevel) {\n    plugins = getSortedValidatedPlugins('onLog', plugins);\n    const minimalPriority = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logLevelPriority[logLevel];\n    const logger = (level, log, skipped = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_SET) => {\n        (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.augmentLogMessage)(log);\n        const logPriority = _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logLevelPriority[level];\n        if (logPriority < minimalPriority) {\n            return;\n        }\n        for (const plugin of plugins) {\n            if (skipped.has(plugin))\n                continue;\n            const { onLog: pluginOnLog } = plugin;\n            const getLogHandler = (level) => {\n                if (_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logLevelPriority[level] < minimalPriority) {\n                    return doNothing;\n                }\n                return log => logger(level, normalizeLog(log), new Set(skipped).add(plugin));\n            };\n            const handler = 'handler' in pluginOnLog ? pluginOnLog.handler : pluginOnLog;\n            if (handler.call({\n                debug: getLogHandler(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_DEBUG),\n                error: (log) => (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)(normalizeLog(log)),\n                info: getLogHandler(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_INFO),\n                meta: { rollupVersion: version, watchMode },\n                warn: getLogHandler(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN)\n            }, level, log) === false) {\n                return;\n            }\n        }\n        onLog(level, log);\n    };\n    return logger;\n}\n\nfunction ensureArray(items) {\n    if (Array.isArray(items)) {\n        return items.filter(Boolean);\n    }\n    if (items) {\n        return [items];\n    }\n    return [];\n}\n\nasync function normalizeInputOptions(config, watchMode) {\n    // These are options that may trigger special warnings or behaviour later\n    // if the user did not select an explicit value\n    const unsetOptions = new Set();\n    const context = config.context ?? 'undefined';\n    const plugins = await normalizePluginOption(config.plugins);\n    const logLevel = config.logLevel || _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_INFO;\n    const onLog = getLogger(plugins, getOnLog(config, logLevel), watchMode, logLevel);\n    const strictDeprecations = config.strictDeprecations || false;\n    const maxParallelFileOps = getMaxParallelFileOps(config);\n    const options = {\n        cache: getCache(config),\n        context,\n        experimentalCacheExpiry: config.experimentalCacheExpiry ?? 10,\n        experimentalLogSideEffects: config.experimentalLogSideEffects || false,\n        external: getIdMatcher(config.external),\n        input: getInput(config),\n        jsx: getJsx(config),\n        logLevel,\n        makeAbsoluteExternalsRelative: config.makeAbsoluteExternalsRelative ?? 'ifRelativeSource',\n        maxParallelFileOps,\n        moduleContext: getModuleContext(config, context),\n        onLog,\n        perf: config.perf || false,\n        plugins,\n        preserveEntrySignatures: config.preserveEntrySignatures ?? 'exports-only',\n        preserveSymlinks: config.preserveSymlinks || false,\n        shimMissingExports: config.shimMissingExports || false,\n        strictDeprecations,\n        treeshake: getTreeshake(config)\n    };\n    warnUnknownOptions(config, [...Object.keys(options), 'onwarn', 'watch'], 'input options', onLog, /^(output)$/);\n    return { options, unsetOptions };\n}\nconst getCache = (config) => config.cache === true // `true` is the default\n    ? undefined\n    : config.cache?.cache || config.cache;\nconst getIdMatcher = (option) => {\n    if (option === true) {\n        return () => true;\n    }\n    if (typeof option === 'function') {\n        return (id, ...parameters) => (!id.startsWith('\\0') && option(id, ...parameters)) || false;\n    }\n    if (option) {\n        const ids = new Set();\n        const matchers = [];\n        for (const value of ensureArray(option)) {\n            if (value instanceof RegExp) {\n                matchers.push(value);\n            }\n            else {\n                ids.add(value);\n            }\n        }\n        return (id, ..._arguments) => ids.has(id) || matchers.some(matcher => matcher.test(id));\n    }\n    return () => false;\n};\nconst getInput = (config) => {\n    const configInput = config.input;\n    return configInput == null ? [] : typeof configInput === 'string' ? [configInput] : configInput;\n};\nconst getJsx = (config) => {\n    const configJsx = config.jsx;\n    if (!configJsx)\n        return false;\n    const configWithPreset = getOptionWithPreset(configJsx, jsxPresets, 'jsx', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_JSX, 'false, ');\n    const { factory, importSource, mode } = configWithPreset;\n    switch (mode) {\n        case 'automatic': {\n            return {\n                factory: factory || 'React.createElement',\n                importSource: importSource || 'react',\n                jsxImportSource: configWithPreset.jsxImportSource || 'react/jsx-runtime',\n                mode: 'automatic'\n            };\n        }\n        case 'preserve': {\n            if (importSource && !(factory || configWithPreset.fragment)) {\n                (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('jsx', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_JSX, 'when preserving JSX and specifying an importSource, you also need to specify a factory or fragment'));\n            }\n            return {\n                factory: factory || null,\n                fragment: configWithPreset.fragment || null,\n                importSource: importSource || null,\n                mode: 'preserve'\n            };\n        }\n        // case 'classic':\n        default: {\n            if (mode && mode !== 'classic') {\n                (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('jsx.mode', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_JSX, 'mode must be \"automatic\", \"classic\" or \"preserve\"', mode));\n            }\n            return {\n                factory: factory || 'React.createElement',\n                fragment: configWithPreset.fragment || 'React.Fragment',\n                importSource: importSource || null,\n                mode: 'classic'\n            };\n        }\n    }\n};\nconst getMaxParallelFileOps = (config) => {\n    const maxParallelFileOps = config.maxParallelFileOps;\n    if (typeof maxParallelFileOps === 'number') {\n        if (maxParallelFileOps <= 0)\n            return Infinity;\n        return maxParallelFileOps;\n    }\n    return 20;\n};\nconst getModuleContext = (config, context) => {\n    const configModuleContext = config.moduleContext;\n    if (typeof configModuleContext === 'function') {\n        return id => configModuleContext(id) ?? context;\n    }\n    if (configModuleContext) {\n        const contextByModuleId = Object.create(null);\n        for (const [key, moduleContext] of Object.entries(configModuleContext)) {\n            contextByModuleId[(0,node_path__WEBPACK_IMPORTED_MODULE_1__.resolve)(key)] = moduleContext;\n        }\n        return id => contextByModuleId[id] ?? context;\n    }\n    return () => context;\n};\nconst getTreeshake = (config) => {\n    const configTreeshake = config.treeshake;\n    if (configTreeshake === false) {\n        return false;\n    }\n    const configWithPreset = getOptionWithPreset(config.treeshake, treeshakePresets, 'treeshake', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_TREESHAKE, 'false, true, ');\n    return {\n        annotations: configWithPreset.annotations !== false,\n        correctVarValueBeforeDeclaration: configWithPreset.correctVarValueBeforeDeclaration === true,\n        manualPureFunctions: configWithPreset.manualPureFunctions ?? _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY,\n        moduleSideEffects: getHasModuleSideEffects(configWithPreset.moduleSideEffects),\n        propertyReadSideEffects: configWithPreset.propertyReadSideEffects === 'always'\n            ? 'always'\n            : configWithPreset.propertyReadSideEffects !== false,\n        tryCatchDeoptimization: configWithPreset.tryCatchDeoptimization !== false,\n        unknownGlobalSideEffects: configWithPreset.unknownGlobalSideEffects !== false\n    };\n};\nconst getHasModuleSideEffects = (moduleSideEffectsOption) => {\n    if (typeof moduleSideEffectsOption === 'boolean') {\n        return () => moduleSideEffectsOption;\n    }\n    if (moduleSideEffectsOption === 'no-external') {\n        return (_id, external) => !external;\n    }\n    if (typeof moduleSideEffectsOption === 'function') {\n        return (id, external) => id.startsWith('\\0') ? true : moduleSideEffectsOption(id, external) !== false;\n    }\n    if (Array.isArray(moduleSideEffectsOption)) {\n        const ids = new Set(moduleSideEffectsOption);\n        return id => ids.has(id);\n    }\n    if (moduleSideEffectsOption) {\n        (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('treeshake.moduleSideEffects', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_TREESHAKE_MODULESIDEEFFECTS, 'please use one of false, \"no-external\", a function or an array'));\n    }\n    return () => true;\n};\n\n// https://datatracker.ietf.org/doc/html/rfc2396\n// eslint-disable-next-line no-control-regex\nconst INVALID_CHAR_REGEX = /[\\u0000-\\u001F\"#$%&*+,:;<=>?[\\]^`{|}\\u007F]/g;\nconst DRIVE_LETTER_REGEX = /^[a-z]:/i;\nfunction sanitizeFileName(name) {\n    const match = DRIVE_LETTER_REGEX.exec(name);\n    const driveLetter = match ? match[0] : '';\n    // A `:` is only allowed as part of a windows drive letter (ex: C:\\foo)\n    // Otherwise, avoid them because they can refer to NTFS alternate data streams.\n    return driveLetter + name.slice(driveLetter.length).replace(INVALID_CHAR_REGEX, '_');\n}\n\nasync function normalizeOutputOptions(config, inputOptions, unsetInputOptions) {\n    // These are options that may trigger special warnings or behaviour later\n    // if the user did not select an explicit value\n    const unsetOptions = new Set(unsetInputOptions);\n    const compact = config.compact || false;\n    const format = getFormat(config);\n    const inlineDynamicImports = getInlineDynamicImports(config, inputOptions);\n    const preserveModules = getPreserveModules(config, inlineDynamicImports, inputOptions);\n    const file = getFile(config, preserveModules, inputOptions);\n    const generatedCode = getGeneratedCode(config);\n    const externalImportAttributes = getExternalImportAttributes(config, inputOptions);\n    const outputOptions = {\n        amd: getAmd(config),\n        assetFileNames: config.assetFileNames ?? 'assets/[name]-[hash][extname]',\n        banner: getAddon(config, 'banner'),\n        chunkFileNames: config.chunkFileNames ?? '[name]-[hash].js',\n        compact,\n        dir: getDir(config, file),\n        dynamicImportInCjs: config.dynamicImportInCjs ?? true,\n        entryFileNames: getEntryFileNames(config, unsetOptions),\n        esModule: config.esModule ?? 'if-default-prop',\n        experimentalMinChunkSize: config.experimentalMinChunkSize ?? 1,\n        exports: getExports(config, unsetOptions),\n        extend: config.extend || false,\n        externalImportAssertions: externalImportAttributes,\n        externalImportAttributes,\n        externalLiveBindings: config.externalLiveBindings ?? true,\n        file,\n        footer: getAddon(config, 'footer'),\n        format,\n        freeze: config.freeze ?? true,\n        generatedCode,\n        globals: config.globals || {},\n        hashCharacters: config.hashCharacters ?? 'base64',\n        hoistTransitiveImports: config.hoistTransitiveImports ?? true,\n        importAttributesKey: config.importAttributesKey ?? 'assert',\n        indent: getIndent(config, compact),\n        inlineDynamicImports,\n        interop: getInterop(config),\n        intro: getAddon(config, 'intro'),\n        manualChunks: getManualChunks(config, inlineDynamicImports, preserveModules),\n        minifyInternalExports: getMinifyInternalExports(config, format, compact),\n        name: config.name,\n        noConflict: config.noConflict || false,\n        outro: getAddon(config, 'outro'),\n        paths: config.paths || {},\n        plugins: await normalizePluginOption(config.plugins),\n        preserveModules,\n        preserveModulesRoot: getPreserveModulesRoot(config),\n        reexportProtoFromExternal: config.reexportProtoFromExternal ?? true,\n        sanitizeFileName: typeof config.sanitizeFileName === 'function'\n            ? config.sanitizeFileName\n            : config.sanitizeFileName === false\n                ? id => id\n                : sanitizeFileName,\n        sourcemap: config.sourcemap || false,\n        sourcemapBaseUrl: getSourcemapBaseUrl(config),\n        sourcemapDebugIds: config.sourcemapDebugIds || false,\n        sourcemapExcludeSources: config.sourcemapExcludeSources || false,\n        sourcemapFile: config.sourcemapFile,\n        sourcemapFileNames: getSourcemapFileNames(config, unsetOptions),\n        sourcemapIgnoreList: typeof config.sourcemapIgnoreList === 'function'\n            ? config.sourcemapIgnoreList\n            : config.sourcemapIgnoreList === false\n                ? () => false\n                : relativeSourcePath => relativeSourcePath.includes('node_modules'),\n        sourcemapPathTransform: config.sourcemapPathTransform,\n        strict: config.strict ?? true,\n        systemNullSetters: config.systemNullSetters ?? true,\n        validate: config.validate || false,\n        virtualDirname: config.virtualDirname || '_virtual'\n    };\n    warnUnknownOptions(config, Object.keys(outputOptions), 'output options', inputOptions.onLog);\n    return { options: outputOptions, unsetOptions };\n}\nconst getFile = (config, preserveModules, inputOptions) => {\n    const { file } = config;\n    if (typeof file === 'string') {\n        if (preserveModules) {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('output.file', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_DIR, 'you must set \"output.dir\" instead of \"output.file\" when using the \"output.preserveModules\" option'));\n        }\n        if (!Array.isArray(inputOptions.input))\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('output.file', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_DIR, 'you must set \"output.dir\" instead of \"output.file\" when providing named inputs'));\n    }\n    return file;\n};\nconst getFormat = (config) => {\n    const configFormat = config.format;\n    switch (configFormat) {\n        case undefined:\n        case 'es':\n        case 'esm':\n        case 'module': {\n            return 'es';\n        }\n        case 'cjs':\n        case 'commonjs': {\n            return 'cjs';\n        }\n        case 'system':\n        case 'systemjs': {\n            return 'system';\n        }\n        case 'amd':\n        case 'iife':\n        case 'umd': {\n            return configFormat;\n        }\n        default: {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('output.format', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_FORMAT, `Valid values are \"amd\", \"cjs\", \"system\", \"es\", \"iife\" or \"umd\"`, configFormat));\n        }\n    }\n};\nconst getInlineDynamicImports = (config, inputOptions) => {\n    const inlineDynamicImports = config.inlineDynamicImports || false;\n    const { input } = inputOptions;\n    if (inlineDynamicImports && (Array.isArray(input) ? input : Object.keys(input)).length > 1) {\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('output.inlineDynamicImports', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_INLINEDYNAMICIMPORTS, 'multiple inputs are not supported when \"output.inlineDynamicImports\" is true'));\n    }\n    return inlineDynamicImports;\n};\nconst getPreserveModules = (config, inlineDynamicImports, inputOptions) => {\n    const preserveModules = config.preserveModules || false;\n    if (preserveModules) {\n        if (inlineDynamicImports) {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('output.inlineDynamicImports', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_INLINEDYNAMICIMPORTS, `this option is not supported for \"output.preserveModules\"`));\n        }\n        if (inputOptions.preserveEntrySignatures === false) {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('preserveEntrySignatures', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_PRESERVEENTRYSIGNATURES, 'setting this option to false is not supported for \"output.preserveModules\"'));\n        }\n    }\n    return preserveModules;\n};\nconst getPreserveModulesRoot = (config) => {\n    const { preserveModulesRoot } = config;\n    if (preserveModulesRoot === null || preserveModulesRoot === undefined) {\n        return undefined;\n    }\n    return (0,node_path__WEBPACK_IMPORTED_MODULE_1__.resolve)(preserveModulesRoot);\n};\nconst getAmd = (config) => {\n    const mergedOption = {\n        autoId: false,\n        basePath: '',\n        define: 'define',\n        forceJsExtensionForImports: false,\n        ...config.amd\n    };\n    if ((mergedOption.autoId || mergedOption.basePath) && mergedOption.id) {\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('output.amd.id', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_AMD_ID, 'this option cannot be used together with \"output.amd.autoId\"/\"output.amd.basePath\"'));\n    }\n    if (mergedOption.basePath && !mergedOption.autoId) {\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('output.amd.basePath', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_AMD_BASEPATH, 'this option only works with \"output.amd.autoId\"'));\n    }\n    return mergedOption.autoId\n        ? {\n            autoId: true,\n            basePath: mergedOption.basePath,\n            define: mergedOption.define,\n            forceJsExtensionForImports: mergedOption.forceJsExtensionForImports\n        }\n        : {\n            autoId: false,\n            define: mergedOption.define,\n            forceJsExtensionForImports: mergedOption.forceJsExtensionForImports,\n            id: mergedOption.id\n        };\n};\nconst getAddon = (config, name) => {\n    const configAddon = config[name];\n    if (typeof configAddon === 'function') {\n        return configAddon;\n    }\n    return () => configAddon || '';\n};\nconst getDir = (config, file) => {\n    const { dir } = config;\n    if (typeof dir === 'string' && typeof file === 'string') {\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('output.dir', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_DIR, 'you must set either \"output.file\" for a single-file build or \"output.dir\" when generating multiple chunks'));\n    }\n    return dir;\n};\nconst getEntryFileNames = (config, unsetOptions) => {\n    const configEntryFileNames = config.entryFileNames;\n    if (configEntryFileNames == null) {\n        unsetOptions.add('entryFileNames');\n    }\n    return configEntryFileNames ?? '[name].js';\n};\nfunction getExports(config, unsetOptions) {\n    const configExports = config.exports;\n    if (configExports == null) {\n        unsetOptions.add('exports');\n    }\n    else if (!['default', 'named', 'none', 'auto'].includes(configExports)) {\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidExportOptionValue)(configExports));\n    }\n    return configExports || 'auto';\n}\nconst getExternalImportAttributes = (config, inputOptions) => {\n    if (config.externalImportAssertions != undefined) {\n        (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.warnDeprecation)(`The \"output.externalImportAssertions\" option is deprecated. Use the \"output.externalImportAttributes\" option instead.`, _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_EXTERNALIMPORTATTRIBUTES, true, inputOptions);\n    }\n    return config.externalImportAttributes ?? config.externalImportAssertions ?? true;\n};\nconst getGeneratedCode = (config) => {\n    const configWithPreset = getOptionWithPreset(config.generatedCode, generatedCodePresets, 'output.generatedCode', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_GENERATEDCODE, '');\n    return {\n        arrowFunctions: configWithPreset.arrowFunctions === true,\n        constBindings: configWithPreset.constBindings === true,\n        objectShorthand: configWithPreset.objectShorthand === true,\n        reservedNamesAsProps: configWithPreset.reservedNamesAsProps !== false,\n        symbols: configWithPreset.symbols === true\n    };\n};\nconst getIndent = (config, compact) => {\n    if (compact) {\n        return '';\n    }\n    const configIndent = config.indent;\n    return configIndent === false ? '' : (configIndent ?? true);\n};\nconst ALLOWED_INTEROP_TYPES = new Set([\n    'compat',\n    'auto',\n    'esModule',\n    'default',\n    'defaultOnly'\n]);\nconst getInterop = (config) => {\n    const configInterop = config.interop;\n    if (typeof configInterop === 'function') {\n        const interopPerId = Object.create(null);\n        let defaultInterop = null;\n        return id => id === null\n            ? defaultInterop || validateInterop((defaultInterop = configInterop(id)))\n            : id in interopPerId\n                ? interopPerId[id]\n                : validateInterop((interopPerId[id] = configInterop(id)));\n    }\n    return configInterop === undefined ? () => 'default' : () => validateInterop(configInterop);\n};\nconst validateInterop = (interop) => {\n    if (!ALLOWED_INTEROP_TYPES.has(interop)) {\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('output.interop', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_INTEROP, `use one of ${Array.from(ALLOWED_INTEROP_TYPES, value => JSON.stringify(value)).join(', ')}`, interop));\n    }\n    return interop;\n};\nconst getManualChunks = (config, inlineDynamicImports, preserveModules) => {\n    const configManualChunks = config.manualChunks;\n    if (configManualChunks) {\n        if (inlineDynamicImports) {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('output.manualChunks', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_MANUALCHUNKS, 'this option is not supported for \"output.inlineDynamicImports\"'));\n        }\n        if (preserveModules) {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('output.manualChunks', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_MANUALCHUNKS, 'this option is not supported for \"output.preserveModules\"'));\n        }\n    }\n    return configManualChunks || {};\n};\nconst getMinifyInternalExports = (config, format, compact) => config.minifyInternalExports ?? (compact || format === 'es' || format === 'system');\nconst getSourcemapFileNames = (config, unsetOptions) => {\n    const configSourcemapFileNames = config.sourcemapFileNames;\n    if (configSourcemapFileNames == null) {\n        unsetOptions.add('sourcemapFileNames');\n    }\n    return configSourcemapFileNames;\n};\nconst getSourcemapBaseUrl = (config) => {\n    const { sourcemapBaseUrl } = config;\n    if (sourcemapBaseUrl) {\n        if ((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.isValidUrl)(sourcemapBaseUrl)) {\n            return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.addTrailingSlashIfMissed)(sourcemapBaseUrl);\n        }\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('output.sourcemapBaseUrl', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_SOURCEMAPBASEURL, `must be a valid URL, received ${JSON.stringify(sourcemapBaseUrl)}`));\n    }\n};\n\n// @ts-expect-error TS2540: the polyfill of `asyncDispose`.\nSymbol.asyncDispose ??= Symbol('Symbol.asyncDispose');\nfunction rollup(rawInputOptions) {\n    return rollupInternal(rawInputOptions, null);\n}\nasync function rollupInternal(rawInputOptions, watcher) {\n    const { options: inputOptions, unsetOptions: unsetInputOptions } = await getInputOptions(rawInputOptions, watcher !== null);\n    initialiseTimers(inputOptions);\n    await initWasm();\n    const graph = new Graph(inputOptions, watcher);\n    // remove the cache object from the memory after graph creation (cache is not used anymore)\n    const useCache = rawInputOptions.cache !== false;\n    if (rawInputOptions.cache) {\n        inputOptions.cache = undefined;\n        rawInputOptions.cache = undefined;\n    }\n    timeStart('BUILD', 1);\n    await catchUnfinishedHookActions(graph.pluginDriver, async () => {\n        try {\n            timeStart('initialize', 2);\n            await graph.pluginDriver.hookParallel('buildStart', [inputOptions]);\n            timeEnd('initialize', 2);\n            await graph.build();\n        }\n        catch (error_) {\n            const watchFiles = Object.keys(graph.watchFiles);\n            if (watchFiles.length > 0) {\n                error_.watchFiles = watchFiles;\n            }\n            await graph.pluginDriver.hookParallel('buildEnd', [error_]);\n            await graph.pluginDriver.hookParallel('closeBundle', []);\n            throw error_;\n        }\n        await graph.pluginDriver.hookParallel('buildEnd', []);\n    });\n    timeEnd('BUILD', 1);\n    const result = {\n        cache: useCache ? graph.getCache() : undefined,\n        async close() {\n            if (result.closed)\n                return;\n            result.closed = true;\n            await graph.pluginDriver.hookParallel('closeBundle', []);\n        },\n        closed: false,\n        async [Symbol.asyncDispose]() {\n            await this.close();\n        },\n        async generate(rawOutputOptions) {\n            if (result.closed)\n                return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logAlreadyClosed)());\n            return handleGenerateWrite(false, inputOptions, unsetInputOptions, rawOutputOptions, graph);\n        },\n        get watchFiles() {\n            return Object.keys(graph.watchFiles);\n        },\n        async write(rawOutputOptions) {\n            if (result.closed)\n                return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logAlreadyClosed)());\n            return handleGenerateWrite(true, inputOptions, unsetInputOptions, rawOutputOptions, graph);\n        }\n    };\n    if (inputOptions.perf)\n        result.getTimings = getTimings;\n    return result;\n}\nasync function getInputOptions(initialInputOptions, watchMode) {\n    if (!initialInputOptions) {\n        throw new Error('You must supply an options object to rollup');\n    }\n    const processedInputOptions = await getProcessedInputOptions(initialInputOptions, watchMode);\n    const { options, unsetOptions } = await normalizeInputOptions(processedInputOptions, watchMode);\n    normalizePlugins(options.plugins, ANONYMOUS_PLUGIN_PREFIX);\n    return { options, unsetOptions };\n}\nasync function getProcessedInputOptions(inputOptions, watchMode) {\n    const plugins = getSortedValidatedPlugins('options', await normalizePluginOption(inputOptions.plugins));\n    const logLevel = inputOptions.logLevel || _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_INFO;\n    const logger = getLogger(plugins, getOnLog(inputOptions, logLevel), watchMode, logLevel);\n    for (const plugin of plugins) {\n        const { name, options } = plugin;\n        const handler = 'handler' in options ? options.handler : options;\n        const processedOptions = await handler.call({\n            debug: getLogHandler(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_DEBUG, 'PLUGIN_LOG', logger, name, logLevel),\n            error: (error_) => (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logPluginError)(normalizeLog(error_), name, { hook: 'onLog' })),\n            info: getLogHandler(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_INFO, 'PLUGIN_LOG', logger, name, logLevel),\n            meta: { rollupVersion: version, watchMode },\n            warn: getLogHandler(_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_WARN, 'PLUGIN_WARNING', logger, name, logLevel)\n        }, inputOptions);\n        if (processedOptions) {\n            inputOptions = processedOptions;\n        }\n    }\n    return inputOptions;\n}\nfunction normalizePlugins(plugins, anonymousPrefix) {\n    for (const [index, plugin] of plugins.entries()) {\n        if (!plugin.name) {\n            plugin.name = `${anonymousPrefix}${index + 1}`;\n        }\n    }\n}\nasync function handleGenerateWrite(isWrite, inputOptions, unsetInputOptions, rawOutputOptions, graph) {\n    const { options: outputOptions, outputPluginDriver, unsetOptions } = await getOutputOptionsAndPluginDriver(rawOutputOptions, graph.pluginDriver, inputOptions, unsetInputOptions);\n    return catchUnfinishedHookActions(outputPluginDriver, async () => {\n        const bundle = new Bundle(outputOptions, unsetOptions, inputOptions, outputPluginDriver, graph);\n        const generated = await bundle.generate(isWrite);\n        if (isWrite) {\n            timeStart('WRITE', 1);\n            if (!outputOptions.dir && !outputOptions.file) {\n                return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logMissingFileOrDirOption)());\n            }\n            await Promise.all(Object.values(generated).map(chunk => graph.fileOperationQueue.run(() => writeOutputFile(chunk, outputOptions))));\n            await outputPluginDriver.hookParallel('writeBundle', [outputOptions, generated]);\n            timeEnd('WRITE', 1);\n        }\n        return createOutput(generated);\n    });\n}\nasync function getOutputOptionsAndPluginDriver(rawOutputOptions, inputPluginDriver, inputOptions, unsetInputOptions) {\n    if (!rawOutputOptions) {\n        throw new Error('You must supply an options object');\n    }\n    const rawPlugins = await normalizePluginOption(rawOutputOptions.plugins);\n    normalizePlugins(rawPlugins, ANONYMOUS_OUTPUT_PLUGIN_PREFIX);\n    const outputPluginDriver = inputPluginDriver.createOutputPluginDriver(rawPlugins);\n    return {\n        ...(await getOutputOptions(inputOptions, unsetInputOptions, rawOutputOptions, outputPluginDriver)),\n        outputPluginDriver\n    };\n}\nfunction getOutputOptions(inputOptions, unsetInputOptions, rawOutputOptions, outputPluginDriver) {\n    return normalizeOutputOptions(outputPluginDriver.hookReduceArg0Sync('outputOptions', [rawOutputOptions], (outputOptions, result) => result || outputOptions, pluginContext => {\n        const emitError = () => pluginContext.error((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logCannotEmitFromOptionsHook)());\n        return {\n            ...pluginContext,\n            emitFile: emitError,\n            setAssetSource: emitError\n        };\n    }), inputOptions, unsetInputOptions);\n}\nfunction createOutput(outputBundle) {\n    return {\n        output: Object.values(outputBundle).filter(outputFile => Object.keys(outputFile).length > 0).sort((outputFileA, outputFileB) => getSortingFileType(outputFileA) - getSortingFileType(outputFileB))\n    };\n}\nvar SortingFileType;\n(function (SortingFileType) {\n    SortingFileType[SortingFileType[\"ENTRY_CHUNK\"] = 0] = \"ENTRY_CHUNK\";\n    SortingFileType[SortingFileType[\"SECONDARY_CHUNK\"] = 1] = \"SECONDARY_CHUNK\";\n    SortingFileType[SortingFileType[\"ASSET\"] = 2] = \"ASSET\";\n})(SortingFileType || (SortingFileType = {}));\nfunction getSortingFileType(file) {\n    if (file.type === 'asset') {\n        return SortingFileType.ASSET;\n    }\n    if (file.isEntry) {\n        return SortingFileType.ENTRY_CHUNK;\n    }\n    return SortingFileType.SECONDARY_CHUNK;\n}\nasync function writeOutputFile(outputFile, outputOptions) {\n    const fileName = (0,node_path__WEBPACK_IMPORTED_MODULE_1__.resolve)(outputOptions.dir || (0,node_path__WEBPACK_IMPORTED_MODULE_1__.dirname)(outputOptions.file), outputFile.fileName);\n    // 'recursive: true' does not throw if the folder structure, or parts of it, already exist\n    await (0,node_fs_promises__WEBPACK_IMPORTED_MODULE_6__.mkdir)((0,node_path__WEBPACK_IMPORTED_MODULE_1__.dirname)(fileName), { recursive: true });\n    return (0,node_fs_promises__WEBPACK_IMPORTED_MODULE_6__.writeFile)(fileName, outputFile.type === 'asset' ? outputFile.source : outputFile.code);\n}\n/**\n * Auxiliary function for defining rollup configuration\n * Mainly to facilitate IDE code prompts, after all, export default does not\n * prompt, even if you add @type annotations, it is not accurate\n * @param options\n */\nfunction defineConfig(options) {\n    return options;\n}\n\nconst {\n  env = {},\n  argv = [],\n  platform = \"\",\n} = typeof process === \"undefined\" ? {} : process;\n\nconst isDisabled = \"NO_COLOR\" in env || argv.includes(\"--no-color\");\nconst isForced = \"FORCE_COLOR\" in env || argv.includes(\"--color\");\nconst isWindows = platform === \"win32\";\nconst isDumbTerminal = env.TERM === \"dumb\";\n\nconst isCompatibleTerminal =\n  Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'tty'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) && Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'tty'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) && Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'tty'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(1) && env.TERM && !isDumbTerminal;\n\nconst isCI =\n  \"CI\" in env &&\n  (\"GITHUB_ACTIONS\" in env || \"GITLAB_CI\" in env || \"CIRCLECI\" in env);\n\nconst isColorSupported =\n  !isDisabled &&\n  (isForced || (isWindows && !isDumbTerminal) || isCompatibleTerminal || isCI);\n\nconst replaceClose = (\n  index,\n  string,\n  close,\n  replace,\n  head = string.substring(0, index) + replace,\n  tail = string.substring(index + close.length),\n  next = tail.indexOf(close)\n) => head + (next < 0 ? tail : replaceClose(next, tail, close, replace));\n\nconst clearBleed = (index, string, open, close, replace) =>\n  index < 0\n    ? open + string + close\n    : open + replaceClose(index, string, close, replace) + close;\n\nconst filterEmpty =\n  (open, close, replace = open, at = open.length + 1) =>\n  (string) =>\n    string || !(string === \"\" || string === undefined)\n      ? clearBleed(\n          (\"\" + string).indexOf(close, at),\n          string,\n          open,\n          close,\n          replace\n        )\n      : \"\";\n\nconst init = (open, close, replace) =>\n  filterEmpty(`\\x1b[${open}m`, `\\x1b[${close}m`, replace);\n\nconst colors = {\n  reset: init(0, 0),\n  bold: init(1, 22, \"\\x1b[22m\\x1b[1m\"),\n  dim: init(2, 22, \"\\x1b[22m\\x1b[2m\"),\n  italic: init(3, 23),\n  underline: init(4, 24),\n  inverse: init(7, 27),\n  hidden: init(8, 28),\n  strikethrough: init(9, 29),\n  black: init(30, 39),\n  red: init(31, 39),\n  green: init(32, 39),\n  yellow: init(33, 39),\n  blue: init(34, 39),\n  magenta: init(35, 39),\n  cyan: init(36, 39),\n  white: init(37, 39),\n  gray: init(90, 39),\n  bgBlack: init(40, 49),\n  bgRed: init(41, 49),\n  bgGreen: init(42, 49),\n  bgYellow: init(43, 49),\n  bgBlue: init(44, 49),\n  bgMagenta: init(45, 49),\n  bgCyan: init(46, 49),\n  bgWhite: init(47, 49),\n  blackBright: init(90, 39),\n  redBright: init(91, 39),\n  greenBright: init(92, 39),\n  yellowBright: init(93, 39),\n  blueBright: init(94, 39),\n  magentaBright: init(95, 39),\n  cyanBright: init(96, 39),\n  whiteBright: init(97, 39),\n  bgBlackBright: init(100, 49),\n  bgRedBright: init(101, 49),\n  bgGreenBright: init(102, 49),\n  bgYellowBright: init(103, 49),\n  bgBlueBright: init(104, 49),\n  bgMagentaBright: init(105, 49),\n  bgCyanBright: init(106, 49),\n  bgWhiteBright: init(107, 49),\n};\n\nconst createColors = ({ useColor = isColorSupported } = {}) =>\n  useColor\n    ? colors\n    : Object.keys(colors).reduce(\n        (colors, key) => ({ ...colors, [key]: String }),\n        {}\n      );\n\ncreateColors();\n\n// @see https://no-color.org\n// @see https://www.npmjs.com/package/chalk\nconst { bold, cyan, dim, gray, green, red, underline, yellow } = createColors({\n    useColor: node_process__WEBPACK_IMPORTED_MODULE_4__.env.FORCE_COLOR !== '0' && !node_process__WEBPACK_IMPORTED_MODULE_4__.env.NO_COLOR\n});\n\n// log to stderr to keep `rollup main.js > bundle.js` from breaking\nconst stderr = (...parameters) => node_process__WEBPACK_IMPORTED_MODULE_4__.stderr.write(`${parameters.join('')}\\n`);\nfunction handleError(error, recover = false) {\n    const name = error.name || error.cause?.name;\n    const nameSection = name ? `${name}: ` : '';\n    const pluginSection = error.plugin ? `(plugin ${error.plugin}) ` : '';\n    const message = `${pluginSection}${nameSection}${error.message}`;\n    const outputLines = [bold(red(`[!] ${bold(message.toString())}`))];\n    if (error.url) {\n        outputLines.push(cyan(error.url));\n    }\n    if (error.loc) {\n        outputLines.push(`${(0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.relativeId)((error.loc.file || error.id))} (${error.loc.line}:${error.loc.column})`);\n    }\n    else if (error.id) {\n        outputLines.push((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.relativeId)(error.id));\n    }\n    if (error.frame) {\n        outputLines.push(dim(error.frame));\n    }\n    if (error.stack) {\n        outputLines.push(dim(error.stack?.replace(`${nameSection}${error.message}\\n`, '')));\n    }\n    // ES2022: Error.prototype.cause is optional\n    if (error.cause) {\n        let cause = error.cause;\n        const causeErrorLines = [];\n        let indent = '';\n        while (cause) {\n            indent += '  ';\n            const message = cause.stack || cause;\n            causeErrorLines.push(...`[cause] ${message}`.split('\\n').map(line => indent + line));\n            cause = cause.cause;\n        }\n        outputLines.push(dim(causeErrorLines.join('\\n')));\n    }\n    outputLines.push('', '');\n    stderr(outputLines.join('\\n'));\n    if (!recover)\n        node_process__WEBPACK_IMPORTED_MODULE_4__.exit(1);\n}\n\nconst commandAliases = {\n    c: 'config',\n    d: 'dir',\n    e: 'external',\n    f: 'format',\n    g: 'globals',\n    h: 'help',\n    i: 'input',\n    m: 'sourcemap',\n    n: 'name',\n    o: 'file',\n    p: 'plugin',\n    v: 'version',\n    w: 'watch'\n};\nconst EMPTY_COMMAND_OPTIONS = { external: [], globals: undefined };\nasync function mergeOptions(config, watchMode, rawCommandOptions = EMPTY_COMMAND_OPTIONS, printLog) {\n    const command = getCommandOptions(rawCommandOptions);\n    const plugins = await normalizePluginOption(config.plugins);\n    const logLevel = config.logLevel || _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.LOGLEVEL_INFO;\n    const onLog = getOnLog(config, logLevel, printLog);\n    const log = getLogger(plugins, onLog, watchMode, logLevel);\n    const inputOptions = mergeInputOptions(config, command, plugins, log, onLog);\n    if (command.output) {\n        Object.assign(command, command.output);\n    }\n    const outputOptionsArray = ensureArray(config.output);\n    if (outputOptionsArray.length === 0)\n        outputOptionsArray.push({});\n    const outputOptions = await Promise.all(outputOptionsArray.map(singleOutputOptions => mergeOutputOptions(singleOutputOptions, command, log)));\n    warnUnknownOptions(command, [\n        ...Object.keys(inputOptions),\n        ...Object.keys(outputOptions[0]).filter(option => option !== 'sourcemapIgnoreList' && option !== 'sourcemapPathTransform'),\n        ...Object.keys(commandAliases),\n        'bundleConfigAsCjs',\n        'config',\n        'configPlugin',\n        'environment',\n        'failAfterWarnings',\n        'filterLogs',\n        'forceExit',\n        'plugin',\n        'silent',\n        'stdin',\n        'waitForBundleInput'\n    ], 'CLI flags', log, /^_$|output$|config/);\n    inputOptions.output = outputOptions;\n    return inputOptions;\n}\nfunction getCommandOptions(rawCommandOptions) {\n    const external = rawCommandOptions.external && typeof rawCommandOptions.external === 'string'\n        ? rawCommandOptions.external.split(',')\n        : [];\n    return {\n        ...rawCommandOptions,\n        external,\n        globals: typeof rawCommandOptions.globals === 'string'\n            ? rawCommandOptions.globals.split(',').reduce((globals, globalDefinition) => {\n                const [id, variableName] = globalDefinition.split(':');\n                globals[id] = variableName;\n                if (!external.includes(id)) {\n                    external.push(id);\n                }\n                return globals;\n            }, Object.create(null))\n            : undefined\n    };\n}\nfunction mergeInputOptions(config, overrides, plugins, log, onLog) {\n    const getOption = (name) => overrides[name] ?? config[name];\n    const inputOptions = {\n        cache: config.cache,\n        context: getOption('context'),\n        experimentalCacheExpiry: getOption('experimentalCacheExpiry'),\n        experimentalLogSideEffects: getOption('experimentalLogSideEffects'),\n        external: getExternal(config, overrides),\n        input: getOption('input') || [],\n        jsx: getObjectOption(config, overrides, 'jsx', objectifyOptionWithPresets(jsxPresets, 'jsx', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_JSX, 'false, ')),\n        logLevel: getOption('logLevel'),\n        makeAbsoluteExternalsRelative: getOption('makeAbsoluteExternalsRelative'),\n        maxParallelFileOps: getOption('maxParallelFileOps'),\n        moduleContext: getOption('moduleContext'),\n        onLog,\n        onwarn: undefined,\n        perf: getOption('perf'),\n        plugins,\n        preserveEntrySignatures: getOption('preserveEntrySignatures'),\n        preserveSymlinks: getOption('preserveSymlinks'),\n        shimMissingExports: getOption('shimMissingExports'),\n        strictDeprecations: getOption('strictDeprecations'),\n        treeshake: getObjectOption(config, overrides, 'treeshake', objectifyOptionWithPresets(treeshakePresets, 'treeshake', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_TREESHAKE, 'false, true, ')),\n        watch: getWatch(config, overrides)\n    };\n    warnUnknownOptions(config, Object.keys(inputOptions), 'input options', log, /^output$/);\n    return inputOptions;\n}\nconst getExternal = (config, overrides) => {\n    const configExternal = config.external;\n    return typeof configExternal === 'function'\n        ? (source, importer, isResolved) => configExternal(source, importer, isResolved) || overrides.external.includes(source)\n        : [...ensureArray(configExternal), ...overrides.external];\n};\nconst getObjectOption = (config, overrides, name, objectifyValue = objectifyOption) => {\n    const commandOption = normalizeObjectOptionValue(overrides[name], objectifyValue);\n    const configOption = normalizeObjectOptionValue(config[name], objectifyValue);\n    if (commandOption !== undefined) {\n        return commandOption && { ...configOption, ...commandOption };\n    }\n    return configOption;\n};\nconst getWatch = (config, overrides) => config.watch !== false && getObjectOption(config, overrides, 'watch');\nconst normalizeObjectOptionValue = (optionValue, objectifyValue) => {\n    if (!optionValue) {\n        return optionValue;\n    }\n    if (Array.isArray(optionValue)) {\n        return optionValue.reduce((result, value) => value && result && { ...result, ...objectifyValue(value) }, {});\n    }\n    return objectifyValue(optionValue);\n};\nasync function mergeOutputOptions(config, overrides, log) {\n    const getOption = (name) => overrides[name] ?? config[name];\n    const outputOptions = {\n        amd: getObjectOption(config, overrides, 'amd'),\n        assetFileNames: getOption('assetFileNames'),\n        banner: getOption('banner'),\n        chunkFileNames: getOption('chunkFileNames'),\n        compact: getOption('compact'),\n        dir: getOption('dir'),\n        dynamicImportInCjs: getOption('dynamicImportInCjs'),\n        entryFileNames: getOption('entryFileNames'),\n        esModule: getOption('esModule'),\n        experimentalMinChunkSize: getOption('experimentalMinChunkSize'),\n        exports: getOption('exports'),\n        extend: getOption('extend'),\n        externalImportAssertions: getOption('externalImportAssertions'),\n        externalImportAttributes: getOption('externalImportAttributes'),\n        externalLiveBindings: getOption('externalLiveBindings'),\n        file: getOption('file'),\n        footer: getOption('footer'),\n        format: getOption('format'),\n        freeze: getOption('freeze'),\n        generatedCode: getObjectOption(config, overrides, 'generatedCode', objectifyOptionWithPresets(generatedCodePresets, 'output.generatedCode', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_OUTPUT_GENERATEDCODE, '')),\n        globals: getOption('globals'),\n        hashCharacters: getOption('hashCharacters'),\n        hoistTransitiveImports: getOption('hoistTransitiveImports'),\n        importAttributesKey: getOption('importAttributesKey'),\n        indent: getOption('indent'),\n        inlineDynamicImports: getOption('inlineDynamicImports'),\n        interop: getOption('interop'),\n        intro: getOption('intro'),\n        manualChunks: getOption('manualChunks'),\n        minifyInternalExports: getOption('minifyInternalExports'),\n        name: getOption('name'),\n        noConflict: getOption('noConflict'),\n        outro: getOption('outro'),\n        paths: getOption('paths'),\n        plugins: await normalizePluginOption(config.plugins),\n        preserveModules: getOption('preserveModules'),\n        preserveModulesRoot: getOption('preserveModulesRoot'),\n        reexportProtoFromExternal: getOption('reexportProtoFromExternal'),\n        sanitizeFileName: getOption('sanitizeFileName'),\n        sourcemap: getOption('sourcemap'),\n        sourcemapBaseUrl: getOption('sourcemapBaseUrl'),\n        sourcemapDebugIds: getOption('sourcemapDebugIds'),\n        sourcemapExcludeSources: getOption('sourcemapExcludeSources'),\n        sourcemapFile: getOption('sourcemapFile'),\n        sourcemapFileNames: getOption('sourcemapFileNames'),\n        sourcemapIgnoreList: getOption('sourcemapIgnoreList'),\n        sourcemapPathTransform: getOption('sourcemapPathTransform'),\n        strict: getOption('strict'),\n        systemNullSetters: getOption('systemNullSetters'),\n        validate: getOption('validate'),\n        virtualDirname: getOption('virtualDirname')\n    };\n    warnUnknownOptions(config, Object.keys(outputOptions), 'output options', log);\n    return outputOptions;\n}\n\nclass WatchEmitter {\n    constructor() {\n        this.currentHandlers = Object.create(null);\n        this.persistentHandlers = Object.create(null);\n    }\n    // Will be overwritten by Rollup\n    async close() { }\n    emit(event, ...parameters) {\n        return Promise.all([...this.getCurrentHandlers(event), ...this.getPersistentHandlers(event)].map(handler => handler(...parameters)));\n    }\n    off(event, listener) {\n        const listeners = this.persistentHandlers[event];\n        if (listeners) {\n            // A hack stolen from \"mitt\": \">>> 0\" does not change numbers >= 0, but -1\n            // (which would remove the last array element if used unchanged) is turned\n            // into max_int, which is outside the array and does not change anything.\n            listeners.splice(listeners.indexOf(listener) >>> 0, 1);\n        }\n        return this;\n    }\n    on(event, listener) {\n        this.getPersistentHandlers(event).push(listener);\n        return this;\n    }\n    onCurrentRun(event, listener) {\n        this.getCurrentHandlers(event).push(listener);\n        return this;\n    }\n    once(event, listener) {\n        const selfRemovingListener = (...parameters) => {\n            this.off(event, selfRemovingListener);\n            return listener(...parameters);\n        };\n        this.on(event, selfRemovingListener);\n        return this;\n    }\n    removeAllListeners() {\n        this.removeListenersForCurrentRun();\n        this.persistentHandlers = Object.create(null);\n        return this;\n    }\n    removeListenersForCurrentRun() {\n        this.currentHandlers = Object.create(null);\n        return this;\n    }\n    getCurrentHandlers(event) {\n        return this.currentHandlers[event] || (this.currentHandlers[event] = []);\n    }\n    getPersistentHandlers(event) {\n        return this.persistentHandlers[event] || (this.persistentHandlers[event] = []);\n    }\n}\n\nlet fsEvents;\nlet fsEventsImportError;\nasync function loadFsEvents() {\n    try {\n        ({ default: fsEvents } = await Promise.resolve().then(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fsevents'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }));\n    }\n    catch (error) {\n        fsEventsImportError = error;\n    }\n}\n// A call to this function will be injected into the chokidar code\nfunction getFsEvents() {\n    if (fsEventsImportError)\n        throw fsEventsImportError;\n    return fsEvents;\n}\n\nconst fseventsImporter = /*#__PURE__*/Object.defineProperty({\n  __proto__: null,\n  getFsEvents,\n  loadFsEvents\n}, Symbol.toStringTag, { value: 'Module' });\n\nfunction watch(configs) {\n    const emitter = new WatchEmitter();\n    watchInternal(configs, emitter).catch(error => {\n        handleError(error);\n    });\n    return emitter;\n}\nasync function watchInternal(configs, emitter) {\n    const optionsList = await Promise.all(ensureArray(configs).map(config => mergeOptions(config, true)));\n    const watchOptionsList = optionsList.filter(config => config.watch !== false);\n    if (watchOptionsList.length === 0) {\n        return (0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.error)((0,_parseAst_js__WEBPACK_IMPORTED_MODULE_0__.logInvalidOption)('watch', _parseAst_js__WEBPACK_IMPORTED_MODULE_0__.URL_WATCH, 'there must be at least one config where \"watch\" is not set to \"false\"'));\n    }\n    await loadFsEvents();\n    const { Watcher } = await __webpack_require__.e(/*! import() */ \"node_modules_rollup_dist_es_shared_watch_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./watch.js */ \"./node_modules/rollup/dist/es/shared/watch.js\"));\n    new Watcher(watchOptionsList, emitter);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcm9sbHVwL2Rpc3QvZXMvc2hhcmVkL25vZGUtZW50cnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDZ25IO0FBQ3poSDtBQUM5QjtBQUNpQztBQUNuQztBQUNUO0FBQzBDO0FBQzdEOztBQUUzQjs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHNDQUFzQztBQUN0Qyx1Q0FBdUM7QUFDdkMsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FB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O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLDZDQUE2QztBQUN6Rjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9ELE9BQU87O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRCxLQUFLOztBQUUxRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxTQUFTLEdBQUcsWUFBWSxLQUFLLGVBQWU7QUFDdEc7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEVBQUU7QUFDbEIsS0FBSztBQUNMLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFdBQVc7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkRBQTZEO0FBQzNGLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3REFBYztBQUMxQztBQUNBO0FBQ0EsaUNBQWlDLGdFQUFzQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFELDBEQUFrQjtBQUN2RTtBQUNBO0FBQ0EseUJBQXlCLGtEQUFVO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHFCQUFxQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE1BQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnTUFBZ007QUFDaE47QUFDQSxnREFBZ0QsWUFBWTtBQUM1RCxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE1BQU07QUFDaEQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLE1BQU0saUVBQWlFO0FBQ3ZFLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0RBQXNEO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxREFBcUQ7QUFDdkY7QUFDQTtBQUNBLGtDQUFrQyxrRUFBa0U7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw2QkFBNkI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsTUFBTTtBQUM5QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFEQUFXO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlEQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDBFQUE0QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLEtBQUs7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWSxtQkFBbUIsbUJBQW1CLElBQUksb0VBQW9FLEVBQUUsK0NBQUs7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EscURBQXFELFVBQVU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsd0RBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUyxHQUFHLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1FQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUVBQXFCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdIO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscURBQWE7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0JBQStCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakMsb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQ0FBcUM7QUFDdkQsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHdEQUF3RDtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVFQUF1RSxnREFBZ0Q7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHFDQUFxQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyREFBMkQsRUFBRSwrQ0FBSztBQUM5RjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtCQUErQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9EQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1REFBYSxFQUFFLG9FQUFzQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQ0FBZ0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtRUFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNB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QUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywwREFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0VBQWtCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdFQUFrQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSw2QkFBNkIseURBQWE7QUFDMUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLEtBQUs7QUFDTCxxQ0FBcUM7QUFDckM7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQ0FBcUM7QUFDckM7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUSxHQUFHLE1BQU07QUFDeEMsdUJBQXVCO0FBQ3ZCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsd0JBQXdCLHVEQUFhO0FBQ3JDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1REFBYTtBQUNqQyxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QiwyQkFBMkIsZ0VBQWtCO0FBQzdDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLGtDQUFrQyxnRUFBa0I7QUFDcEQsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVEQUFhO0FBQ2pDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLEtBQUs7QUFDTCwrQkFBK0I7QUFDL0I7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQ0FBaUM7QUFDakM7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLHdCQUF3Qix1REFBYTtBQUNyQztBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSx3QkFBd0IsdURBQWE7QUFDckM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixvQkFBb0IsdURBQWE7QUFDakM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBVztBQUMxQjtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVMsU0FBUyxtQkFBbUI7QUFDakQ7QUFDQTtBQUNBLCtCQUErQix1REFB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Q0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtREFBUTtBQUM3QiwwQkFBMEIsa0RBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsV0FBVztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLGVB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QUNBO0FBQ0EsdURBQXVELDBEQUFZO0FBQ25FO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMENBQTBDO0FBQ3RELFlBQVkseUdBQXlHO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNDQUFzQztBQUNsRCwrR0FBK0cs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QUNBLDhCQUE4Qix1QkFBdUI7QUFDckQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1GQUFtRjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQUssQ0FBQyw4REFBZ0IsVUFBVSxtREFBUztBQUN4RDtBQUNBO0FBQ0EsWUFBWSxVQUFVLFFBQVEsMk1BQW9CO0FBQ2xEO0FBQ0E7O0FBRWdKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vamltaXB1bHNhckBnaXRodWIuY29tLy4vbm9kZV9tb2R1bGVzL3JvbGx1cC9kaXN0L2VzL3NoYXJlZC9ub2RlLWVudHJ5LmpzPzc4ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgQGxpY2Vuc2Vcblx0Um9sbHVwLmpzIHY0LjI2LjBcblx0V2VkLCAxMyBOb3YgMjAyNCAwNjo0NDoyOSBHTVQgLSBjb21taXQgYWUxZDE0Yjc4NTVmZjY1NjhhNjY5N2QzNzI3MWE1ZWI0ZDhlMmQzZVxuXG5cdGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwXG5cblx0UmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiBhcyBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24kMSwgQ2FsbEV4cHJlc3Npb24gYXMgQ2FsbEV4cHJlc3Npb24kMSwgRU1QVFlfQVJSQVksIExPR0xFVkVMX1dBUk4sIGxvZ1VudXNlZEV4dGVybmFsSW1wb3J0cywgQU5OT1RBVElPTl9LRVksIElOVkFMSURfQU5OT1RBVElPTl9LRVksIE9iamVjdEV4cHJlc3Npb24gYXMgT2JqZWN0RXhwcmVzc2lvbiQxLCBQcm9wZXJ0eSBhcyBQcm9wZXJ0eSQxLCBQcm9ncmFtIGFzIFByb2dyYW0kMSwgbG9nSWxsZWdhbEltcG9ydFJlYXNzaWdubWVudCwgQkxBTkssIGxvZ1JlZGVjbGFyYXRpb25FcnJvciwgU3RhdGljQmxvY2sgYXMgU3RhdGljQmxvY2skMSwgQ2F0Y2hDbGF1c2UgYXMgQ2F0Y2hDbGF1c2UkMSwgbG9nRHVwbGljYXRlQXJndW1lbnROYW1lRXJyb3IsIGxvZ01vZHVsZUxldmVsRGlyZWN0aXZlLCBSZXR1cm5TdGF0ZW1lbnQgYXMgUmV0dXJuU3RhdGVtZW50JDEsIFZhcmlhYmxlRGVjbGFyYXRvciBhcyBWYXJpYWJsZURlY2xhcmF0b3IkMSwgRXhwcmVzc2lvblN0YXRlbWVudCBhcyBFeHByZXNzaW9uU3RhdGVtZW50JDEsIGxvZ01pc3NpbmdFeHBvcnQsIG5vcm1hbGl6ZSwgZ2V0SW1wb3J0UGF0aCwgbG9nTWlzc2luZ05vZGVCdWlsdGlucywgbG9nUmVzZXJ2ZWROYW1lc3BhY2UsIGVycm9yLCBsb2dJbGxlZ2FsSWRlbnRpZmllckFzTmFtZSwgbG9nTWlzc2luZ05hbWVPcHRpb25Gb3JJaWZlRXhwb3J0LCBsb2dNaXNzaW5nTmFtZU9wdGlvbkZvclVtZEV4cG9ydCwgbG9nQ29uc3RWYXJpYWJsZVJlYXNzaWduRXJyb3IsIEFycm93RnVuY3Rpb25FeHByZXNzaW9uIGFzIEFycm93RnVuY3Rpb25FeHByZXNzaW9uJDEsIEVNUFRZX1NFVCwgbG9nQ2Fubm90Q2FsbE5hbWVzcGFjZSwgbG9nRXZhbCwgQmxvY2tTdGF0ZW1lbnQgYXMgQmxvY2tTdGF0ZW1lbnQkMSwgZ2V0Um9sbHVwRXJyb3IsIGxvZ1BhcnNlRXJyb3IsIGxvZ01vZHVsZVBhcnNlRXJyb3IsIExPR0xFVkVMX0lORk8sIGxvZ0ZpcnN0U2lkZUVmZmVjdCwgbG9jYXRlLCBsb2dJbnZhbGlkQW5ub3RhdGlvbiwgSWRlbnRpZmllciBhcyBJZGVudGlmaWVyJDEsIGxvZ1RoaXNJc1VuZGVmaW5lZCwgZ2V0QXN0QnVmZmVyLCBjb252ZXJ0QW5ub3RhdGlvbnMsIEZJWEVEX1NUUklOR1MsIGNvbnZlcnROb2RlIGFzIGNvbnZlcnROb2RlJDEsIEVNUFRZX09CSkVDVCwgbG9nSW1wb3J0QXR0cmlidXRlSXNJbnZhbGlkLCBsb2dJbXBvcnRPcHRpb25zQXJlSW52YWxpZCwgbG9nU3ludGhldGljTmFtZWRFeHBvcnRzTmVlZE5hbWVzcGFjZUV4cG9ydCwgbG9nTWlzc2luZ0VudHJ5RXhwb3J0LCBsb2dEdXBsaWNhdGVFeHBvcnRFcnJvciwgbG9nSW52YWxpZFNvdXJjZW1hcEZvckVycm9yLCBhdWdtZW50Q29kZUxvY2F0aW9uLCBsb2dJbmNvbnNpc3RlbnRJbXBvcnRBdHRyaWJ1dGVzLCBsb2dNaXNzaW5nSnN4RXhwb3J0LCBsb2dOYW1lc3BhY2VDb25mbGljdCwgbG9nQW1iaWd1b3VzRXh0ZXJuYWxOYW1lc3BhY2VzLCBsb2dTaGltbWVkRXhwb3J0LCBwYXJzZUFzdCwgbG9nQ2lyY3VsYXJSZWV4cG9ydCwgbG9nSW52YWxpZEZvcm1hdEZvclRvcExldmVsQXdhaXQsIFRlbXBsYXRlTGl0ZXJhbCBhcyBUZW1wbGF0ZUxpdGVyYWwkMSwgTGl0ZXJhbCBhcyBMaXRlcmFsJDEsIGxvZ0FkZG9uTm90R2VuZXJhdGVkLCBsb2dJbmNvbXBhdGlibGVFeHBvcnRPcHRpb25WYWx1ZSwgbG9nTWl4ZWRFeHBvcnQsIGxvZ0ZhaWxlZFZhbGlkYXRpb24sIGlzUGF0aEZyYWdtZW50LCBsb2dDeWNsaWNDcm9zc0NodW5rUmVleHBvcnQsIGdldEFsaWFzTmFtZSwgbG9nVW5leHBlY3RlZE5hbWVkSW1wb3J0LCBpc0Fic29sdXRlIGFzIGlzQWJzb2x1dGUkMSwgcmVsYXRpdmUgYXMgcmVsYXRpdmUkMSwgbG9nVW5leHBlY3RlZE5hbWVzcGFjZVJlZXhwb3J0LCBsb2dFbXB0eUNodW5rLCBsb2dNaXNzaW5nR2xvYmFsTmFtZSwgbG9nT3B0aW1pemVDaHVua1N0YXR1cywgbG9nU291cmNlbWFwQnJva2VuLCBsb2dDb25mbGljdGluZ1NvdXJjZW1hcFNvdXJjZXMsIGxvZ0NodW5rSW52YWxpZCwgbG9nSW52YWxpZE9wdGlvbiwgVVJMX09VVFBVVF9GT1JNQVQsIFVSTF9PVVRQVVRfRElSLCBVUkxfT1VUUFVUX1NPVVJDRU1BUEZJTEUsIFVSTF9PVVRQVVRfQU1EX0lELCBsb2dDYW5ub3RBc3NpZ25Nb2R1bGVUb0NodW5rLCBsb2dBbm9ueW1vdXNQbHVnaW5DYWNoZSwgbG9nRHVwbGljYXRlUGx1Z2luTmFtZSwgbG9nVW5rbm93bk9wdGlvbiwgcHJpbnRRdW90ZWRTdHJpbmdMaXN0LCBMT0dMRVZFTF9FUlJPUiwgbG9nTGV2ZWxQcmlvcml0eSwgTE9HTEVWRUxfREVCVUcsIGxvZ0ludmFsaWRTZXRBc3NldFNvdXJjZUNhbGwsIGxvZ1BsdWdpbkVycm9yLCBsb2dOb1RyYW5zZm9ybU1hcE9yQXN0V2l0aG91dENvZGUsIHJlbGF0aXZlSWQsIGxvZ0JhZExvYWRlciwgbG9nRXh0ZXJuYWxNb2R1bGVzQ2Fubm90QmVUcmFuc2Zvcm1lZFRvTW9kdWxlcywgbG9nSW50ZXJuYWxJZENhbm5vdEJlRXh0ZXJuYWwsIGlzUmVsYXRpdmUsIGxvZ1VucmVzb2x2ZWRJbXBvcnQsIGxvZ1VucmVzb2x2ZWRJbXBvcnRUcmVhdGVkQXNFeHRlcm5hbCwgbG9nRXh0ZXJuYWxTeW50aGV0aWNFeHBvcnRzLCBsb2dVbnJlc29sdmVkRW50cnksIGxvZ1VucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGFudCwgbG9nRXh0ZXJuYWxNb2R1bGVzQ2Fubm90QmVJbmNsdWRlZEluTWFudWFsQ2h1bmtzLCBsb2dFbnRyeUNhbm5vdEJlRXh0ZXJuYWwsIGxvZ0ltcGxpY2l0RGVwZW5kYW50Q2Fubm90QmVFeHRlcm5hbCwgbG9nTm9Bc3NldFNvdXJjZVNldCwgbG9nRmlsZVJlZmVyZW5jZUlkTm90Rm91bmRGb3JGaWxlbmFtZSwgbG9nQXNzZXRSZWZlcmVuY2VJZE5vdEZvdW5kRm9yU2V0U291cmNlLCBsb2dBc3NldFNvdXJjZUFscmVhZHlTZXQsIGxvZ0ludmFsaWRSb2xsdXBQaGFzZUZvckNodW5rRW1pc3Npb24sIHdhcm5EZXByZWNhdGlvbiwgVVJMX0dFTkVSQVRFQlVORExFLCBsb2dGaWxlTmFtZUNvbmZsaWN0LCBsb2dBc3NldE5vdEZpbmFsaXNlZEZvckZpbGVOYW1lLCBsb2dDaHVua05vdEdlbmVyYXRlZEZvckZpbGVOYW1lLCBsb2dJbnZhbGlkTG9nUG9zaXRpb24sIGxvZ0lucHV0SG9va0luT3V0cHV0UGx1Z2luLCBsb2dJbnZhbGlkRnVuY3Rpb25QbHVnaW5Ib29rLCBsb2dJbnZhbGlkQWRkb25QbHVnaW5Ib29rLCBsb2dJbXBsaWNpdERlcGVuZGFudElzTm90SW5jbHVkZWQsIGxvZ0NpcmN1bGFyRGVwZW5kZW5jeSwgYXVnbWVudExvZ01lc3NhZ2UsIFVSTF9KU1gsIFVSTF9UUkVFU0hBS0UsIFVSTF9UUkVFU0hBS0VfTU9EVUxFU0lERUVGRkVDVFMsIGxvZ0ludmFsaWRFeHBvcnRPcHRpb25WYWx1ZSwgVVJMX09VVFBVVF9JTlRFUk9QLCBpc1ZhbGlkVXJsLCBhZGRUcmFpbGluZ1NsYXNoSWZNaXNzZWQsIFVSTF9PVVRQVVRfU09VUkNFTUFQQkFTRVVSTCwgVVJMX09VVFBVVF9JTkxJTkVEWU5BTUlDSU1QT1JUUywgVVJMX1BSRVNFUlZFRU5UUllTSUdOQVRVUkVTLCBVUkxfT1VUUFVUX0FNRF9CQVNFUEFUSCwgVVJMX09VVFBVVF9HRU5FUkFURURDT0RFLCBVUkxfT1VUUFVUX01BTlVBTENIVU5LUywgVVJMX09VVFBVVF9FWFRFUk5BTElNUE9SVEFUVFJJQlVURVMsIGxvZ0FscmVhZHlDbG9zZWQsIGxvZ01pc3NpbmdGaWxlT3JEaXJPcHRpb24sIGxvZ0Nhbm5vdEVtaXRGcm9tT3B0aW9uc0hvb2ssIFVSTF9XQVRDSCB9IGZyb20gJy4vcGFyc2VBc3QuanMnO1xuaW1wb3J0IHsgcmVsYXRpdmUsIGRpcm5hbWUsIGJhc2VuYW1lLCBleHRuYW1lLCByZXNvbHZlIGFzIHJlc29sdmUkMSB9IGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgeyBwb3NpeCwgd2luMzIsIGlzQWJzb2x1dGUsIHJlc29sdmUgfSBmcm9tICdwYXRoJztcbmltcG9ydCB7IHBhcnNlQXN5bmMsIHh4aGFzaEJhc2U2NFVybCwgeHhoYXNoQmFzZTM2LCB4eGhhc2hCYXNlMTYgfSBmcm9tICcuLi8uLi9uYXRpdmUuanMnO1xuaW1wb3J0IHByb2Nlc3MkMSwgeyBlbnYgYXMgZW52JDEgfSBmcm9tICdub2RlOnByb2Nlc3MnO1xuaW1wb3J0IHsgcGVyZm9ybWFuY2UgfSBmcm9tICdub2RlOnBlcmZfaG9va3MnO1xuaW1wb3J0IHsgbHN0YXQsIHJlYWxwYXRoLCByZWFkZGlyLCByZWFkRmlsZSwgbWtkaXIsIHdyaXRlRmlsZSB9IGZyb20gJ25vZGU6ZnMvcHJvbWlzZXMnO1xuaW1wb3J0ICogYXMgdHR5IGZyb20gJ3R0eSc7XG5cbnZhciB2ZXJzaW9uID0gXCI0LjI2LjBcIjtcblxuY29uc3QgY29tbWEgPSAnLCcuY2hhckNvZGVBdCgwKTtcbmNvbnN0IHNlbWljb2xvbiA9ICc7Jy5jaGFyQ29kZUF0KDApO1xuY29uc3QgY2hhcnMkMSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbmNvbnN0IGludFRvQ2hhciA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gNjQgcG9zc2libGUgY2hhcnMuXG5jb25zdCBjaGFyVG9JbnQgPSBuZXcgVWludDhBcnJheSgxMjgpOyAvLyB6IGlzIDEyMiBpbiBBU0NJSVxuZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycyQxLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYyA9IGNoYXJzJDEuY2hhckNvZGVBdChpKTtcbiAgICBpbnRUb0NoYXJbaV0gPSBjO1xuICAgIGNoYXJUb0ludFtjXSA9IGk7XG59XG5mdW5jdGlvbiBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgcmVsYXRpdmUpIHtcbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIGxldCBzaGlmdCA9IDA7XG4gICAgbGV0IGludGVnZXIgPSAwO1xuICAgIGRvIHtcbiAgICAgICAgY29uc3QgYyA9IHJlYWRlci5uZXh0KCk7XG4gICAgICAgIGludGVnZXIgPSBjaGFyVG9JbnRbY107XG4gICAgICAgIHZhbHVlIHw9IChpbnRlZ2VyICYgMzEpIDw8IHNoaWZ0O1xuICAgICAgICBzaGlmdCArPSA1O1xuICAgIH0gd2hpbGUgKGludGVnZXIgJiAzMik7XG4gICAgY29uc3Qgc2hvdWxkTmVnYXRlID0gdmFsdWUgJiAxO1xuICAgIHZhbHVlID4+Pj0gMTtcbiAgICBpZiAoc2hvdWxkTmVnYXRlKSB7XG4gICAgICAgIHZhbHVlID0gLTB4ODAwMDAwMDAgfCAtdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZWxhdGl2ZSArIHZhbHVlO1xufVxuZnVuY3Rpb24gZW5jb2RlSW50ZWdlcihidWlsZGVyLCBudW0sIHJlbGF0aXZlKSB7XG4gICAgbGV0IGRlbHRhID0gbnVtIC0gcmVsYXRpdmU7XG4gICAgZGVsdGEgPSBkZWx0YSA8IDAgPyAoLWRlbHRhIDw8IDEpIHwgMSA6IGRlbHRhIDw8IDE7XG4gICAgZG8ge1xuICAgICAgICBsZXQgY2xhbXBlZCA9IGRlbHRhICYgMGIwMTExMTE7XG4gICAgICAgIGRlbHRhID4+Pj0gNTtcbiAgICAgICAgaWYgKGRlbHRhID4gMClcbiAgICAgICAgICAgIGNsYW1wZWQgfD0gMGIxMDAwMDA7XG4gICAgICAgIGJ1aWxkZXIud3JpdGUoaW50VG9DaGFyW2NsYW1wZWRdKTtcbiAgICB9IHdoaWxlIChkZWx0YSA+IDApO1xuICAgIHJldHVybiBudW07XG59XG5mdW5jdGlvbiBoYXNNb3JlVmxxKHJlYWRlciwgbWF4KSB7XG4gICAgaWYgKHJlYWRlci5wb3MgPj0gbWF4KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHJlYWRlci5wZWVrKCkgIT09IGNvbW1hO1xufVxuXG5jb25zdCBidWZMZW5ndGggPSAxMDI0ICogMTY7XG4vLyBQcm92aWRlIGEgZmFsbGJhY2sgZm9yIG9sZGVyIGVudmlyb25tZW50cy5cbmNvbnN0IHRkID0gdHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJ1xuICAgID8gLyogI19fUFVSRV9fICovIG5ldyBUZXh0RGVjb2RlcigpXG4gICAgOiB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IHtcbiAgICAgICAgICAgIGRlY29kZShidWYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXQgPSBCdWZmZXIuZnJvbShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBkZWNvZGUoYnVmKSB7XG4gICAgICAgICAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuY2xhc3MgU3RyaW5nV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLm91dCA9ICcnO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1Zkxlbmd0aCk7XG4gICAgfVxuICAgIHdyaXRlKHYpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIgfSA9IHRoaXM7XG4gICAgICAgIGJ1ZmZlclt0aGlzLnBvcysrXSA9IHY7XG4gICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYnVmTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm91dCArPSB0ZC5kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gcG9zID4gMCA/IG91dCArIHRkLmRlY29kZShidWZmZXIuc3ViYXJyYXkoMCwgcG9zKSkgOiBvdXQ7XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmNoYXJDb2RlQXQodGhpcy5wb3MrKyk7XG4gICAgfVxuICAgIHBlZWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICB9XG4gICAgaW5kZXhPZihjaGFyKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGlkeCA9IGJ1ZmZlci5pbmRleE9mKGNoYXIsIHBvcyk7XG4gICAgICAgIHJldHVybiBpZHggPT09IC0xID8gYnVmZmVyLmxlbmd0aCA6IGlkeDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlY29kZShtYXBwaW5ncykge1xuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBtYXBwaW5ncztcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgU3RyaW5nUmVhZGVyKG1hcHBpbmdzKTtcbiAgICBjb25zdCBkZWNvZGVkID0gW107XG4gICAgbGV0IGdlbkNvbHVtbiA9IDA7XG4gICAgbGV0IHNvdXJjZXNJbmRleCA9IDA7XG4gICAgbGV0IHNvdXJjZUxpbmUgPSAwO1xuICAgIGxldCBzb3VyY2VDb2x1bW4gPSAwO1xuICAgIGxldCBuYW1lc0luZGV4ID0gMDtcbiAgICBkbyB7XG4gICAgICAgIGNvbnN0IHNlbWkgPSByZWFkZXIuaW5kZXhPZignOycpO1xuICAgICAgICBjb25zdCBsaW5lID0gW107XG4gICAgICAgIGxldCBzb3J0ZWQgPSB0cnVlO1xuICAgICAgICBsZXQgbGFzdENvbCA9IDA7XG4gICAgICAgIGdlbkNvbHVtbiA9IDA7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgc2VtaSkge1xuICAgICAgICAgICAgbGV0IHNlZztcbiAgICAgICAgICAgIGdlbkNvbHVtbiA9IGRlY29kZUludGVnZXIocmVhZGVyLCBnZW5Db2x1bW4pO1xuICAgICAgICAgICAgaWYgKGdlbkNvbHVtbiA8IGxhc3RDb2wpXG4gICAgICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICBsYXN0Q29sID0gZ2VuQ29sdW1uO1xuICAgICAgICAgICAgaWYgKGhhc01vcmVWbHEocmVhZGVyLCBzZW1pKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZXNJbmRleCA9IGRlY29kZUludGVnZXIocmVhZGVyLCBzb3VyY2VzSW5kZXgpO1xuICAgICAgICAgICAgICAgIHNvdXJjZUxpbmUgPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgc291cmNlTGluZSk7XG4gICAgICAgICAgICAgICAgc291cmNlQ29sdW1uID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIHNvdXJjZUNvbHVtbik7XG4gICAgICAgICAgICAgICAgaWYgKGhhc01vcmVWbHEocmVhZGVyLCBzZW1pKSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lc0luZGV4ID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIG5hbWVzSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzZWcgPSBbZ2VuQ29sdW1uLCBzb3VyY2VzSW5kZXgsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbHVtbiwgbmFtZXNJbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWcgPSBbZ2VuQ29sdW1uLCBzb3VyY2VzSW5kZXgsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbHVtbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VnID0gW2dlbkNvbHVtbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lLnB1c2goc2VnKTtcbiAgICAgICAgICAgIHJlYWRlci5wb3MrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNvcnRlZClcbiAgICAgICAgICAgIHNvcnQobGluZSk7XG4gICAgICAgIGRlY29kZWQucHVzaChsaW5lKTtcbiAgICAgICAgcmVhZGVyLnBvcyA9IHNlbWkgKyAxO1xuICAgIH0gd2hpbGUgKHJlYWRlci5wb3MgPD0gbGVuZ3RoKTtcbiAgICByZXR1cm4gZGVjb2RlZDtcbn1cbmZ1bmN0aW9uIHNvcnQobGluZSkge1xuICAgIGxpbmUuc29ydChzb3J0Q29tcGFyYXRvcik7XG59XG5mdW5jdGlvbiBzb3J0Q29tcGFyYXRvcihhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xufVxuZnVuY3Rpb24gZW5jb2RlKGRlY29kZWQpIHtcbiAgICBjb25zdCB3cml0ZXIgPSBuZXcgU3RyaW5nV3JpdGVyKCk7XG4gICAgbGV0IHNvdXJjZXNJbmRleCA9IDA7XG4gICAgbGV0IHNvdXJjZUxpbmUgPSAwO1xuICAgIGxldCBzb3VyY2VDb2x1bW4gPSAwO1xuICAgIGxldCBuYW1lc0luZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGluZSA9IGRlY29kZWRbaV07XG4gICAgICAgIGlmIChpID4gMClcbiAgICAgICAgICAgIHdyaXRlci53cml0ZShzZW1pY29sb24pO1xuICAgICAgICBpZiAobGluZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IGdlbkNvbHVtbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudCA9IGxpbmVbal07XG4gICAgICAgICAgICBpZiAoaiA+IDApXG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlKGNvbW1hKTtcbiAgICAgICAgICAgIGdlbkNvbHVtbiA9IGVuY29kZUludGVnZXIod3JpdGVyLCBzZWdtZW50WzBdLCBnZW5Db2x1bW4pO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgc291cmNlc0luZGV4ID0gZW5jb2RlSW50ZWdlcih3cml0ZXIsIHNlZ21lbnRbMV0sIHNvdXJjZXNJbmRleCk7XG4gICAgICAgICAgICBzb3VyY2VMaW5lID0gZW5jb2RlSW50ZWdlcih3cml0ZXIsIHNlZ21lbnRbMl0sIHNvdXJjZUxpbmUpO1xuICAgICAgICAgICAgc291cmNlQ29sdW1uID0gZW5jb2RlSW50ZWdlcih3cml0ZXIsIHNlZ21lbnRbM10sIHNvdXJjZUNvbHVtbik7XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBuYW1lc0luZGV4ID0gZW5jb2RlSW50ZWdlcih3cml0ZXIsIHNlZ21lbnRbNF0sIG5hbWVzSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXIuZmx1c2goKTtcbn1cblxuY2xhc3MgQml0U2V0IHtcblx0Y29uc3RydWN0b3IoYXJnKSB7XG5cdFx0dGhpcy5iaXRzID0gYXJnIGluc3RhbmNlb2YgQml0U2V0ID8gYXJnLmJpdHMuc2xpY2UoKSA6IFtdO1xuXHR9XG5cblx0YWRkKG4pIHtcblx0XHR0aGlzLmJpdHNbbiA+PiA1XSB8PSAxIDw8IChuICYgMzEpO1xuXHR9XG5cblx0aGFzKG4pIHtcblx0XHRyZXR1cm4gISEodGhpcy5iaXRzW24gPj4gNV0gJiAoMSA8PCAobiAmIDMxKSkpO1xuXHR9XG59XG5cbmxldCBDaHVuayQxID0gY2xhc3MgQ2h1bmsge1xuXHRjb25zdHJ1Y3RvcihzdGFydCwgZW5kLCBjb250ZW50KSB7XG5cdFx0dGhpcy5zdGFydCA9IHN0YXJ0O1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMub3JpZ2luYWwgPSBjb250ZW50O1xuXG5cdFx0dGhpcy5pbnRybyA9ICcnO1xuXHRcdHRoaXMub3V0cm8gPSAnJztcblxuXHRcdHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG5cdFx0dGhpcy5zdG9yZU5hbWUgPSBmYWxzZTtcblx0XHR0aGlzLmVkaXRlZCA9IGZhbHNlO1xuXG5cdFx0e1xuXHRcdFx0dGhpcy5wcmV2aW91cyA9IG51bGw7XG5cdFx0XHR0aGlzLm5leHQgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdGFwcGVuZExlZnQoY29udGVudCkge1xuXHRcdHRoaXMub3V0cm8gKz0gY29udGVudDtcblx0fVxuXG5cdGFwcGVuZFJpZ2h0KGNvbnRlbnQpIHtcblx0XHR0aGlzLmludHJvID0gdGhpcy5pbnRybyArIGNvbnRlbnQ7XG5cdH1cblxuXHRjbG9uZSgpIHtcblx0XHRjb25zdCBjaHVuayA9IG5ldyBDaHVuayh0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgdGhpcy5vcmlnaW5hbCk7XG5cblx0XHRjaHVuay5pbnRybyA9IHRoaXMuaW50cm87XG5cdFx0Y2h1bmsub3V0cm8gPSB0aGlzLm91dHJvO1xuXHRcdGNodW5rLmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQ7XG5cdFx0Y2h1bmsuc3RvcmVOYW1lID0gdGhpcy5zdG9yZU5hbWU7XG5cdFx0Y2h1bmsuZWRpdGVkID0gdGhpcy5lZGl0ZWQ7XG5cblx0XHRyZXR1cm4gY2h1bms7XG5cdH1cblxuXHRjb250YWlucyhpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLnN0YXJ0IDwgaW5kZXggJiYgaW5kZXggPCB0aGlzLmVuZDtcblx0fVxuXG5cdGVhY2hOZXh0KGZuKSB7XG5cdFx0bGV0IGNodW5rID0gdGhpcztcblx0XHR3aGlsZSAoY2h1bmspIHtcblx0XHRcdGZuKGNodW5rKTtcblx0XHRcdGNodW5rID0gY2h1bmsubmV4dDtcblx0XHR9XG5cdH1cblxuXHRlYWNoUHJldmlvdXMoZm4pIHtcblx0XHRsZXQgY2h1bmsgPSB0aGlzO1xuXHRcdHdoaWxlIChjaHVuaykge1xuXHRcdFx0Zm4oY2h1bmspO1xuXHRcdFx0Y2h1bmsgPSBjaHVuay5wcmV2aW91cztcblx0XHR9XG5cdH1cblxuXHRlZGl0KGNvbnRlbnQsIHN0b3JlTmFtZSwgY29udGVudE9ubHkpIHtcblx0XHR0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuXHRcdGlmICghY29udGVudE9ubHkpIHtcblx0XHRcdHRoaXMuaW50cm8gPSAnJztcblx0XHRcdHRoaXMub3V0cm8gPSAnJztcblx0XHR9XG5cdFx0dGhpcy5zdG9yZU5hbWUgPSBzdG9yZU5hbWU7XG5cblx0XHR0aGlzLmVkaXRlZCA9IHRydWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHByZXBlbmRMZWZ0KGNvbnRlbnQpIHtcblx0XHR0aGlzLm91dHJvID0gY29udGVudCArIHRoaXMub3V0cm87XG5cdH1cblxuXHRwcmVwZW5kUmlnaHQoY29udGVudCkge1xuXHRcdHRoaXMuaW50cm8gPSBjb250ZW50ICsgdGhpcy5pbnRybztcblx0fVxuXG5cdHJlc2V0KCkge1xuXHRcdHRoaXMuaW50cm8gPSAnJztcblx0XHR0aGlzLm91dHJvID0gJyc7XG5cdFx0aWYgKHRoaXMuZWRpdGVkKSB7XG5cdFx0XHR0aGlzLmNvbnRlbnQgPSB0aGlzLm9yaWdpbmFsO1xuXHRcdFx0dGhpcy5zdG9yZU5hbWUgPSBmYWxzZTtcblx0XHRcdHRoaXMuZWRpdGVkID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0c3BsaXQoaW5kZXgpIHtcblx0XHRjb25zdCBzbGljZUluZGV4ID0gaW5kZXggLSB0aGlzLnN0YXJ0O1xuXG5cdFx0Y29uc3Qgb3JpZ2luYWxCZWZvcmUgPSB0aGlzLm9yaWdpbmFsLnNsaWNlKDAsIHNsaWNlSW5kZXgpO1xuXHRcdGNvbnN0IG9yaWdpbmFsQWZ0ZXIgPSB0aGlzLm9yaWdpbmFsLnNsaWNlKHNsaWNlSW5kZXgpO1xuXG5cdFx0dGhpcy5vcmlnaW5hbCA9IG9yaWdpbmFsQmVmb3JlO1xuXG5cdFx0Y29uc3QgbmV3Q2h1bmsgPSBuZXcgQ2h1bmsoaW5kZXgsIHRoaXMuZW5kLCBvcmlnaW5hbEFmdGVyKTtcblx0XHRuZXdDaHVuay5vdXRybyA9IHRoaXMub3V0cm87XG5cdFx0dGhpcy5vdXRybyA9ICcnO1xuXG5cdFx0dGhpcy5lbmQgPSBpbmRleDtcblxuXHRcdGlmICh0aGlzLmVkaXRlZCkge1xuXHRcdFx0Ly8gYWZ0ZXIgc3BsaXQgd2Ugc2hvdWxkIHNhdmUgdGhlIGVkaXQgY29udGVudCByZWNvcmQgaW50byB0aGUgY29ycmVjdCBjaHVua1xuXHRcdFx0Ly8gdG8gbWFrZSBzdXJlIHNvdXJjZW1hcCBjb3JyZWN0XG5cdFx0XHQvLyBGb3IgZXhhbXBsZTpcblx0XHRcdC8vICcgIHRlc3QnLnRyaW0oKVxuXHRcdFx0Ly8gICAgIHNwbGl0ICAgLT4gJyAgJyArICd0ZXN0J1xuXHRcdFx0Ly8gICDinJTvuI8gZWRpdCAgICAtPiAnJyArICd0ZXN0J1xuXHRcdFx0Ly8gICDinJbvuI8gZWRpdCAgICAtPiAndGVzdCcgKyAnJyBcblx0XHRcdC8vIFRPRE8gaXMgdGhpcyBibG9jayBuZWNlc3Nhcnk/Li4uXG5cdFx0XHRuZXdDaHVuay5lZGl0KCcnLCBmYWxzZSk7XG5cdFx0XHR0aGlzLmNvbnRlbnQgPSAnJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jb250ZW50ID0gb3JpZ2luYWxCZWZvcmU7XG5cdFx0fVxuXG5cdFx0bmV3Q2h1bmsubmV4dCA9IHRoaXMubmV4dDtcblx0XHRpZiAobmV3Q2h1bmsubmV4dCkgbmV3Q2h1bmsubmV4dC5wcmV2aW91cyA9IG5ld0NodW5rO1xuXHRcdG5ld0NodW5rLnByZXZpb3VzID0gdGhpcztcblx0XHR0aGlzLm5leHQgPSBuZXdDaHVuaztcblxuXHRcdHJldHVybiBuZXdDaHVuaztcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLmludHJvICsgdGhpcy5jb250ZW50ICsgdGhpcy5vdXRybztcblx0fVxuXG5cdHRyaW1FbmQocngpIHtcblx0XHR0aGlzLm91dHJvID0gdGhpcy5vdXRyby5yZXBsYWNlKHJ4LCAnJyk7XG5cdFx0aWYgKHRoaXMub3V0cm8ubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcblxuXHRcdGNvbnN0IHRyaW1tZWQgPSB0aGlzLmNvbnRlbnQucmVwbGFjZShyeCwgJycpO1xuXG5cdFx0aWYgKHRyaW1tZWQubGVuZ3RoKSB7XG5cdFx0XHRpZiAodHJpbW1lZCAhPT0gdGhpcy5jb250ZW50KSB7XG5cdFx0XHRcdHRoaXMuc3BsaXQodGhpcy5zdGFydCArIHRyaW1tZWQubGVuZ3RoKS5lZGl0KCcnLCB1bmRlZmluZWQsIHRydWUpO1xuXHRcdFx0XHRpZiAodGhpcy5lZGl0ZWQpIHtcblx0XHRcdFx0XHQvLyBzYXZlIHRoZSBjaGFuZ2UsIGlmIGl0IGhhcyBiZWVuIGVkaXRlZFxuXHRcdFx0XHRcdHRoaXMuZWRpdCh0cmltbWVkLCB0aGlzLnN0b3JlTmFtZSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmVkaXQoJycsIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cblx0XHRcdHRoaXMuaW50cm8gPSB0aGlzLmludHJvLnJlcGxhY2UocngsICcnKTtcblx0XHRcdGlmICh0aGlzLmludHJvLmxlbmd0aCkgcmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cblx0dHJpbVN0YXJ0KHJ4KSB7XG5cdFx0dGhpcy5pbnRybyA9IHRoaXMuaW50cm8ucmVwbGFjZShyeCwgJycpO1xuXHRcdGlmICh0aGlzLmludHJvLmxlbmd0aCkgcmV0dXJuIHRydWU7XG5cblx0XHRjb25zdCB0cmltbWVkID0gdGhpcy5jb250ZW50LnJlcGxhY2UocngsICcnKTtcblxuXHRcdGlmICh0cmltbWVkLmxlbmd0aCkge1xuXHRcdFx0aWYgKHRyaW1tZWQgIT09IHRoaXMuY29udGVudCkge1xuXHRcdFx0XHRjb25zdCBuZXdDaHVuayA9IHRoaXMuc3BsaXQodGhpcy5lbmQgLSB0cmltbWVkLmxlbmd0aCk7XG5cdFx0XHRcdGlmICh0aGlzLmVkaXRlZCkge1xuXHRcdFx0XHRcdC8vIHNhdmUgdGhlIGNoYW5nZSwgaWYgaXQgaGFzIGJlZW4gZWRpdGVkXG5cdFx0XHRcdFx0bmV3Q2h1bmsuZWRpdCh0cmltbWVkLCB0aGlzLnN0b3JlTmFtZSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5lZGl0KCcnLCB1bmRlZmluZWQsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZWRpdCgnJywgdW5kZWZpbmVkLCB0cnVlKTtcblxuXHRcdFx0dGhpcy5vdXRybyA9IHRoaXMub3V0cm8ucmVwbGFjZShyeCwgJycpO1xuXHRcdFx0aWYgKHRoaXMub3V0cm8ubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cbn07XG5cbmZ1bmN0aW9uIGdldEJ0b2EoKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbFRoaXMuYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiAoc3RyKSA9PiBnbG9iYWxUaGlzLmJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpKTtcblx0fSBlbHNlIGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIChzdHIpID0+IEJ1ZmZlci5mcm9tKHN0ciwgJ3V0Zi04JykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGVudmlyb25tZW50OiBgd2luZG93LmJ0b2FgIG9yIGBCdWZmZXJgIHNob3VsZCBiZSBzdXBwb3J0ZWQuJyk7XG5cdFx0fTtcblx0fVxufVxuXG5jb25zdCBidG9hID0gLyojX19QVVJFX18qLyBnZXRCdG9hKCk7XG5cbmNsYXNzIFNvdXJjZU1hcCB7XG5cdGNvbnN0cnVjdG9yKHByb3BlcnRpZXMpIHtcblx0XHR0aGlzLnZlcnNpb24gPSAzO1xuXHRcdHRoaXMuZmlsZSA9IHByb3BlcnRpZXMuZmlsZTtcblx0XHR0aGlzLnNvdXJjZXMgPSBwcm9wZXJ0aWVzLnNvdXJjZXM7XG5cdFx0dGhpcy5zb3VyY2VzQ29udGVudCA9IHByb3BlcnRpZXMuc291cmNlc0NvbnRlbnQ7XG5cdFx0dGhpcy5uYW1lcyA9IHByb3BlcnRpZXMubmFtZXM7XG5cdFx0dGhpcy5tYXBwaW5ncyA9IGVuY29kZShwcm9wZXJ0aWVzLm1hcHBpbmdzKTtcblx0XHRpZiAodHlwZW9mIHByb3BlcnRpZXMueF9nb29nbGVfaWdub3JlTGlzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRoaXMueF9nb29nbGVfaWdub3JlTGlzdCA9IHByb3BlcnRpZXMueF9nb29nbGVfaWdub3JlTGlzdDtcblx0XHR9XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG5cdH1cblxuXHR0b1VybCgpIHtcblx0XHRyZXR1cm4gJ2RhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYnRvYSh0aGlzLnRvU3RyaW5nKCkpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGd1ZXNzSW5kZW50KGNvZGUpIHtcblx0Y29uc3QgbGluZXMgPSBjb2RlLnNwbGl0KCdcXG4nKTtcblxuXHRjb25zdCB0YWJiZWQgPSBsaW5lcy5maWx0ZXIoKGxpbmUpID0+IC9eXFx0Ky8udGVzdChsaW5lKSk7XG5cdGNvbnN0IHNwYWNlZCA9IGxpbmVzLmZpbHRlcigobGluZSkgPT4gL14gezIsfS8udGVzdChsaW5lKSk7XG5cblx0aWYgKHRhYmJlZC5sZW5ndGggPT09IDAgJiYgc3BhY2VkLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gTW9yZSBsaW5lcyB0YWJiZWQgdGhhbiBzcGFjZWQ/IEFzc3VtZSB0YWJzLCBhbmRcblx0Ly8gZGVmYXVsdCB0byB0YWJzIGluIHRoZSBjYXNlIG9mIGEgdGllIChvciBub3RoaW5nXG5cdC8vIHRvIGdvIG9uKVxuXHRpZiAodGFiYmVkLmxlbmd0aCA+PSBzcGFjZWQubGVuZ3RoKSB7XG5cdFx0cmV0dXJuICdcXHQnO1xuXHR9XG5cblx0Ly8gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIGd1ZXNzIHRoZSBtdWx0aXBsZVxuXHRjb25zdCBtaW4gPSBzcGFjZWQucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuXHRcdGNvbnN0IG51bVNwYWNlcyA9IC9eICsvLmV4ZWMoY3VycmVudClbMF0ubGVuZ3RoO1xuXHRcdHJldHVybiBNYXRoLm1pbihudW1TcGFjZXMsIHByZXZpb3VzKTtcblx0fSwgSW5maW5pdHkpO1xuXG5cdHJldHVybiBuZXcgQXJyYXkobWluICsgMSkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBhdGgoZnJvbSwgdG8pIHtcblx0Y29uc3QgZnJvbVBhcnRzID0gZnJvbS5zcGxpdCgvWy9cXFxcXS8pO1xuXHRjb25zdCB0b1BhcnRzID0gdG8uc3BsaXQoL1svXFxcXF0vKTtcblxuXHRmcm9tUGFydHMucG9wKCk7IC8vIGdldCBkaXJuYW1lXG5cblx0d2hpbGUgKGZyb21QYXJ0c1swXSA9PT0gdG9QYXJ0c1swXSkge1xuXHRcdGZyb21QYXJ0cy5zaGlmdCgpO1xuXHRcdHRvUGFydHMuc2hpZnQoKTtcblx0fVxuXG5cdGlmIChmcm9tUGFydHMubGVuZ3RoKSB7XG5cdFx0bGV0IGkgPSBmcm9tUGFydHMubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIGZyb21QYXJ0c1tpXSA9ICcuLic7XG5cdH1cblxuXHRyZXR1cm4gZnJvbVBhcnRzLmNvbmNhdCh0b1BhcnRzKS5qb2luKCcvJyk7XG59XG5cbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gaXNPYmplY3QodGhpbmcpIHtcblx0cmV0dXJuIHRvU3RyaW5nLmNhbGwodGhpbmcpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZnVuY3Rpb24gZ2V0TG9jYXRvcihzb3VyY2UpIHtcblx0Y29uc3Qgb3JpZ2luYWxMaW5lcyA9IHNvdXJjZS5zcGxpdCgnXFxuJyk7XG5cdGNvbnN0IGxpbmVPZmZzZXRzID0gW107XG5cblx0Zm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCBvcmlnaW5hbExpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0bGluZU9mZnNldHMucHVzaChwb3MpO1xuXHRcdHBvcyArPSBvcmlnaW5hbExpbmVzW2ldLmxlbmd0aCArIDE7XG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24gbG9jYXRlKGluZGV4KSB7XG5cdFx0bGV0IGkgPSAwO1xuXHRcdGxldCBqID0gbGluZU9mZnNldHMubGVuZ3RoO1xuXHRcdHdoaWxlIChpIDwgaikge1xuXHRcdFx0Y29uc3QgbSA9IChpICsgaikgPj4gMTtcblx0XHRcdGlmIChpbmRleCA8IGxpbmVPZmZzZXRzW21dKSB7XG5cdFx0XHRcdGogPSBtO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aSA9IG0gKyAxO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBsaW5lID0gaSAtIDE7XG5cdFx0Y29uc3QgY29sdW1uID0gaW5kZXggLSBsaW5lT2Zmc2V0c1tsaW5lXTtcblx0XHRyZXR1cm4geyBsaW5lLCBjb2x1bW4gfTtcblx0fTtcbn1cblxuY29uc3Qgd29yZFJlZ2V4ID0gL1xcdy87XG5cbmNsYXNzIE1hcHBpbmdzIHtcblx0Y29uc3RydWN0b3IoaGlyZXMpIHtcblx0XHR0aGlzLmhpcmVzID0gaGlyZXM7XG5cdFx0dGhpcy5nZW5lcmF0ZWRDb2RlTGluZSA9IDA7XG5cdFx0dGhpcy5nZW5lcmF0ZWRDb2RlQ29sdW1uID0gMDtcblx0XHR0aGlzLnJhdyA9IFtdO1xuXHRcdHRoaXMucmF3U2VnbWVudHMgPSB0aGlzLnJhd1t0aGlzLmdlbmVyYXRlZENvZGVMaW5lXSA9IFtdO1xuXHRcdHRoaXMucGVuZGluZyA9IG51bGw7XG5cdH1cblxuXHRhZGRFZGl0KHNvdXJjZUluZGV4LCBjb250ZW50LCBsb2MsIG5hbWVJbmRleCkge1xuXHRcdGlmIChjb250ZW50Lmxlbmd0aCkge1xuXHRcdFx0Y29uc3QgY29udGVudExlbmd0aE1pbnVzT25lID0gY29udGVudC5sZW5ndGggLSAxO1xuXHRcdFx0bGV0IGNvbnRlbnRMaW5lRW5kID0gY29udGVudC5pbmRleE9mKCdcXG4nLCAwKTtcblx0XHRcdGxldCBwcmV2aW91c0NvbnRlbnRMaW5lRW5kID0gLTE7XG5cdFx0XHQvLyBMb29wIHRocm91Z2ggZWFjaCBsaW5lIGluIHRoZSBjb250ZW50IGFuZCBhZGQgYSBzZWdtZW50LCBidXQgc3RvcCBpZiB0aGUgbGFzdCBsaW5lIGlzIGVtcHR5LFxuXHRcdFx0Ly8gZWxzZSBjb2RlIGFmdGVyd2FyZHMgd291bGQgZmlsbCBvbmUgbGluZSB0b28gbWFueVxuXHRcdFx0d2hpbGUgKGNvbnRlbnRMaW5lRW5kID49IDAgJiYgY29udGVudExlbmd0aE1pbnVzT25lID4gY29udGVudExpbmVFbmQpIHtcblx0XHRcdFx0Y29uc3Qgc2VnbWVudCA9IFt0aGlzLmdlbmVyYXRlZENvZGVDb2x1bW4sIHNvdXJjZUluZGV4LCBsb2MubGluZSwgbG9jLmNvbHVtbl07XG5cdFx0XHRcdGlmIChuYW1lSW5kZXggPj0gMCkge1xuXHRcdFx0XHRcdHNlZ21lbnQucHVzaChuYW1lSW5kZXgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucmF3U2VnbWVudHMucHVzaChzZWdtZW50KTtcblxuXHRcdFx0XHR0aGlzLmdlbmVyYXRlZENvZGVMaW5lICs9IDE7XG5cdFx0XHRcdHRoaXMucmF3W3RoaXMuZ2VuZXJhdGVkQ29kZUxpbmVdID0gdGhpcy5yYXdTZWdtZW50cyA9IFtdO1xuXHRcdFx0XHR0aGlzLmdlbmVyYXRlZENvZGVDb2x1bW4gPSAwO1xuXG5cdFx0XHRcdHByZXZpb3VzQ29udGVudExpbmVFbmQgPSBjb250ZW50TGluZUVuZDtcblx0XHRcdFx0Y29udGVudExpbmVFbmQgPSBjb250ZW50LmluZGV4T2YoJ1xcbicsIGNvbnRlbnRMaW5lRW5kICsgMSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlZ21lbnQgPSBbdGhpcy5nZW5lcmF0ZWRDb2RlQ29sdW1uLCBzb3VyY2VJbmRleCwgbG9jLmxpbmUsIGxvYy5jb2x1bW5dO1xuXHRcdFx0aWYgKG5hbWVJbmRleCA+PSAwKSB7XG5cdFx0XHRcdHNlZ21lbnQucHVzaChuYW1lSW5kZXgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5yYXdTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuXG5cdFx0XHR0aGlzLmFkdmFuY2UoY29udGVudC5zbGljZShwcmV2aW91c0NvbnRlbnRMaW5lRW5kICsgMSkpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5wZW5kaW5nKSB7XG5cdFx0XHR0aGlzLnJhd1NlZ21lbnRzLnB1c2godGhpcy5wZW5kaW5nKTtcblx0XHRcdHRoaXMuYWR2YW5jZShjb250ZW50KTtcblx0XHR9XG5cblx0XHR0aGlzLnBlbmRpbmcgPSBudWxsO1xuXHR9XG5cblx0YWRkVW5lZGl0ZWRDaHVuayhzb3VyY2VJbmRleCwgY2h1bmssIG9yaWdpbmFsLCBsb2MsIHNvdXJjZW1hcExvY2F0aW9ucykge1xuXHRcdGxldCBvcmlnaW5hbENoYXJJbmRleCA9IGNodW5rLnN0YXJ0O1xuXHRcdGxldCBmaXJzdCA9IHRydWU7XG5cdFx0Ly8gd2hlbiBpdGVyYXRpbmcgZWFjaCBjaGFyLCBjaGVjayBpZiBpdCdzIGluIGEgd29yZCBib3VuZGFyeVxuXHRcdGxldCBjaGFySW5IaXJlc0JvdW5kYXJ5ID0gZmFsc2U7XG5cblx0XHR3aGlsZSAob3JpZ2luYWxDaGFySW5kZXggPCBjaHVuay5lbmQpIHtcblx0XHRcdGlmIChvcmlnaW5hbFtvcmlnaW5hbENoYXJJbmRleF0gPT09ICdcXG4nKSB7XG5cdFx0XHRcdGxvYy5saW5lICs9IDE7XG5cdFx0XHRcdGxvYy5jb2x1bW4gPSAwO1xuXHRcdFx0XHR0aGlzLmdlbmVyYXRlZENvZGVMaW5lICs9IDE7XG5cdFx0XHRcdHRoaXMucmF3W3RoaXMuZ2VuZXJhdGVkQ29kZUxpbmVdID0gdGhpcy5yYXdTZWdtZW50cyA9IFtdO1xuXHRcdFx0XHR0aGlzLmdlbmVyYXRlZENvZGVDb2x1bW4gPSAwO1xuXHRcdFx0XHRmaXJzdCA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGhpcy5oaXJlcyB8fCBmaXJzdCB8fCBzb3VyY2VtYXBMb2NhdGlvbnMuaGFzKG9yaWdpbmFsQ2hhckluZGV4KSkge1xuXHRcdFx0XHRcdGNvbnN0IHNlZ21lbnQgPSBbdGhpcy5nZW5lcmF0ZWRDb2RlQ29sdW1uLCBzb3VyY2VJbmRleCwgbG9jLmxpbmUsIGxvYy5jb2x1bW5dO1xuXG5cdFx0XHRcdFx0aWYgKHRoaXMuaGlyZXMgPT09ICdib3VuZGFyeScpIHtcblx0XHRcdFx0XHRcdC8vIGluIGhpcmVzIFwiYm91bmRhcnlcIiwgZ3JvdXAgc2VnbWVudHMgcGVyIHdvcmQgYm91bmRhcnkgdGhhbiBwZXIgY2hhclxuXHRcdFx0XHRcdFx0aWYgKHdvcmRSZWdleC50ZXN0KG9yaWdpbmFsW29yaWdpbmFsQ2hhckluZGV4XSkpIHtcblx0XHRcdFx0XHRcdFx0Ly8gZm9yIGZpcnN0IGNoYXIgaW4gdGhlIGJvdW5kYXJ5IGZvdW5kLCBzdGFydCB0aGUgYm91bmRhcnkgYnkgcHVzaGluZyBhIHNlZ21lbnRcblx0XHRcdFx0XHRcdFx0aWYgKCFjaGFySW5IaXJlc0JvdW5kYXJ5KSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5yYXdTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuXHRcdFx0XHRcdFx0XHRcdGNoYXJJbkhpcmVzQm91bmRhcnkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBmb3Igbm9uLXdvcmQgY2hhciwgZW5kIHRoZSBib3VuZGFyeSBieSBwdXNoaW5nIGEgc2VnbWVudFxuXHRcdFx0XHRcdFx0XHR0aGlzLnJhd1NlZ21lbnRzLnB1c2goc2VnbWVudCk7XG5cdFx0XHRcdFx0XHRcdGNoYXJJbkhpcmVzQm91bmRhcnkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXdTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxvYy5jb2x1bW4gKz0gMTtcblx0XHRcdFx0dGhpcy5nZW5lcmF0ZWRDb2RlQ29sdW1uICs9IDE7XG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdG9yaWdpbmFsQ2hhckluZGV4ICs9IDE7XG5cdFx0fVxuXG5cdFx0dGhpcy5wZW5kaW5nID0gbnVsbDtcblx0fVxuXG5cdGFkdmFuY2Uoc3RyKSB7XG5cdFx0aWYgKCFzdHIpIHJldHVybjtcblxuXHRcdGNvbnN0IGxpbmVzID0gc3RyLnNwbGl0KCdcXG4nKTtcblxuXHRcdGlmIChsaW5lcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aCAtIDE7IGkrKykge1xuXHRcdFx0XHR0aGlzLmdlbmVyYXRlZENvZGVMaW5lKys7XG5cdFx0XHRcdHRoaXMucmF3W3RoaXMuZ2VuZXJhdGVkQ29kZUxpbmVdID0gdGhpcy5yYXdTZWdtZW50cyA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5nZW5lcmF0ZWRDb2RlQ29sdW1uID0gMDtcblx0XHR9XG5cblx0XHR0aGlzLmdlbmVyYXRlZENvZGVDb2x1bW4gKz0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoO1xuXHR9XG59XG5cbmNvbnN0IG4gPSAnXFxuJztcblxuY29uc3Qgd2FybmVkID0ge1xuXHRpbnNlcnRMZWZ0OiBmYWxzZSxcblx0aW5zZXJ0UmlnaHQ6IGZhbHNlLFxuXHRzdG9yZU5hbWU6IGZhbHNlLFxufTtcblxuY2xhc3MgTWFnaWNTdHJpbmcge1xuXHRjb25zdHJ1Y3RvcihzdHJpbmcsIG9wdGlvbnMgPSB7fSkge1xuXHRcdGNvbnN0IGNodW5rID0gbmV3IENodW5rJDEoMCwgc3RyaW5nLmxlbmd0aCwgc3RyaW5nKTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcblx0XHRcdG9yaWdpbmFsOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogc3RyaW5nIH0sXG5cdFx0XHRvdXRybzogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6ICcnIH0sXG5cdFx0XHRpbnRybzogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6ICcnIH0sXG5cdFx0XHRmaXJzdENodW5rOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogY2h1bmsgfSxcblx0XHRcdGxhc3RDaHVuazogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGNodW5rIH0sXG5cdFx0XHRsYXN0U2VhcmNoZWRDaHVuazogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGNodW5rIH0sXG5cdFx0XHRieVN0YXJ0OiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSxcblx0XHRcdGJ5RW5kOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSxcblx0XHRcdGZpbGVuYW1lOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogb3B0aW9ucy5maWxlbmFtZSB9LFxuXHRcdFx0aW5kZW50RXhjbHVzaW9uUmFuZ2VzOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogb3B0aW9ucy5pbmRlbnRFeGNsdXNpb25SYW5nZXMgfSxcblx0XHRcdHNvdXJjZW1hcExvY2F0aW9uczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IG5ldyBCaXRTZXQoKSB9LFxuXHRcdFx0c3RvcmVkTmFtZXM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuXHRcdFx0aW5kZW50U3RyOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH0sXG5cdFx0XHRpZ25vcmVMaXN0OiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogb3B0aW9ucy5pZ25vcmVMaXN0IH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmJ5U3RhcnRbMF0gPSBjaHVuaztcblx0XHR0aGlzLmJ5RW5kW3N0cmluZy5sZW5ndGhdID0gY2h1bms7XG5cdH1cblxuXHRhZGRTb3VyY2VtYXBMb2NhdGlvbihjaGFyKSB7XG5cdFx0dGhpcy5zb3VyY2VtYXBMb2NhdGlvbnMuYWRkKGNoYXIpO1xuXHR9XG5cblx0YXBwZW5kKGNvbnRlbnQpIHtcblx0XHRpZiAodHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdvdXRybyBjb250ZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcblxuXHRcdHRoaXMub3V0cm8gKz0gY29udGVudDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGFwcGVuZExlZnQoaW5kZXgsIGNvbnRlbnQpIHtcblx0XHRpZiAodHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnNlcnRlZCBjb250ZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcblxuXHRcdHRoaXMuX3NwbGl0KGluZGV4KTtcblxuXHRcdGNvbnN0IGNodW5rID0gdGhpcy5ieUVuZFtpbmRleF07XG5cblx0XHRpZiAoY2h1bmspIHtcblx0XHRcdGNodW5rLmFwcGVuZExlZnQoY29udGVudCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuaW50cm8gKz0gY29udGVudDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRhcHBlbmRSaWdodChpbmRleCwgY29udGVudCkge1xuXHRcdGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luc2VydGVkIGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuXG5cdFx0dGhpcy5fc3BsaXQoaW5kZXgpO1xuXG5cdFx0Y29uc3QgY2h1bmsgPSB0aGlzLmJ5U3RhcnRbaW5kZXhdO1xuXG5cdFx0aWYgKGNodW5rKSB7XG5cdFx0XHRjaHVuay5hcHBlbmRSaWdodChjb250ZW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5vdXRybyArPSBjb250ZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGNsb25lKCkge1xuXHRcdGNvbnN0IGNsb25lZCA9IG5ldyBNYWdpY1N0cmluZyh0aGlzLm9yaWdpbmFsLCB7IGZpbGVuYW1lOiB0aGlzLmZpbGVuYW1lIH0pO1xuXG5cdFx0bGV0IG9yaWdpbmFsQ2h1bmsgPSB0aGlzLmZpcnN0Q2h1bms7XG5cdFx0bGV0IGNsb25lZENodW5rID0gKGNsb25lZC5maXJzdENodW5rID0gY2xvbmVkLmxhc3RTZWFyY2hlZENodW5rID0gb3JpZ2luYWxDaHVuay5jbG9uZSgpKTtcblxuXHRcdHdoaWxlIChvcmlnaW5hbENodW5rKSB7XG5cdFx0XHRjbG9uZWQuYnlTdGFydFtjbG9uZWRDaHVuay5zdGFydF0gPSBjbG9uZWRDaHVuaztcblx0XHRcdGNsb25lZC5ieUVuZFtjbG9uZWRDaHVuay5lbmRdID0gY2xvbmVkQ2h1bms7XG5cblx0XHRcdGNvbnN0IG5leHRPcmlnaW5hbENodW5rID0gb3JpZ2luYWxDaHVuay5uZXh0O1xuXHRcdFx0Y29uc3QgbmV4dENsb25lZENodW5rID0gbmV4dE9yaWdpbmFsQ2h1bmsgJiYgbmV4dE9yaWdpbmFsQ2h1bmsuY2xvbmUoKTtcblxuXHRcdFx0aWYgKG5leHRDbG9uZWRDaHVuaykge1xuXHRcdFx0XHRjbG9uZWRDaHVuay5uZXh0ID0gbmV4dENsb25lZENodW5rO1xuXHRcdFx0XHRuZXh0Q2xvbmVkQ2h1bmsucHJldmlvdXMgPSBjbG9uZWRDaHVuaztcblxuXHRcdFx0XHRjbG9uZWRDaHVuayA9IG5leHRDbG9uZWRDaHVuaztcblx0XHRcdH1cblxuXHRcdFx0b3JpZ2luYWxDaHVuayA9IG5leHRPcmlnaW5hbENodW5rO1xuXHRcdH1cblxuXHRcdGNsb25lZC5sYXN0Q2h1bmsgPSBjbG9uZWRDaHVuaztcblxuXHRcdGlmICh0aGlzLmluZGVudEV4Y2x1c2lvblJhbmdlcykge1xuXHRcdFx0Y2xvbmVkLmluZGVudEV4Y2x1c2lvblJhbmdlcyA9IHRoaXMuaW5kZW50RXhjbHVzaW9uUmFuZ2VzLnNsaWNlKCk7XG5cdFx0fVxuXG5cdFx0Y2xvbmVkLnNvdXJjZW1hcExvY2F0aW9ucyA9IG5ldyBCaXRTZXQodGhpcy5zb3VyY2VtYXBMb2NhdGlvbnMpO1xuXG5cdFx0Y2xvbmVkLmludHJvID0gdGhpcy5pbnRybztcblx0XHRjbG9uZWQub3V0cm8gPSB0aGlzLm91dHJvO1xuXG5cdFx0cmV0dXJuIGNsb25lZDtcblx0fVxuXG5cdGdlbmVyYXRlRGVjb2RlZE1hcChvcHRpb25zKSB7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHRjb25zdCBzb3VyY2VJbmRleCA9IDA7XG5cdFx0Y29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLnN0b3JlZE5hbWVzKTtcblx0XHRjb25zdCBtYXBwaW5ncyA9IG5ldyBNYXBwaW5ncyhvcHRpb25zLmhpcmVzKTtcblxuXHRcdGNvbnN0IGxvY2F0ZSA9IGdldExvY2F0b3IodGhpcy5vcmlnaW5hbCk7XG5cblx0XHRpZiAodGhpcy5pbnRybykge1xuXHRcdFx0bWFwcGluZ3MuYWR2YW5jZSh0aGlzLmludHJvKTtcblx0XHR9XG5cblx0XHR0aGlzLmZpcnN0Q2h1bmsuZWFjaE5leHQoKGNodW5rKSA9PiB7XG5cdFx0XHRjb25zdCBsb2MgPSBsb2NhdGUoY2h1bmsuc3RhcnQpO1xuXG5cdFx0XHRpZiAoY2h1bmsuaW50cm8ubGVuZ3RoKSBtYXBwaW5ncy5hZHZhbmNlKGNodW5rLmludHJvKTtcblxuXHRcdFx0aWYgKGNodW5rLmVkaXRlZCkge1xuXHRcdFx0XHRtYXBwaW5ncy5hZGRFZGl0KFxuXHRcdFx0XHRcdHNvdXJjZUluZGV4LFxuXHRcdFx0XHRcdGNodW5rLmNvbnRlbnQsXG5cdFx0XHRcdFx0bG9jLFxuXHRcdFx0XHRcdGNodW5rLnN0b3JlTmFtZSA/IG5hbWVzLmluZGV4T2YoY2h1bmsub3JpZ2luYWwpIDogLTEsXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXBwaW5ncy5hZGRVbmVkaXRlZENodW5rKHNvdXJjZUluZGV4LCBjaHVuaywgdGhpcy5vcmlnaW5hbCwgbG9jLCB0aGlzLnNvdXJjZW1hcExvY2F0aW9ucyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjaHVuay5vdXRyby5sZW5ndGgpIG1hcHBpbmdzLmFkdmFuY2UoY2h1bmsub3V0cm8pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGZpbGU6IG9wdGlvbnMuZmlsZSA/IG9wdGlvbnMuZmlsZS5zcGxpdCgvWy9cXFxcXS8pLnBvcCgpIDogdW5kZWZpbmVkLFxuXHRcdFx0c291cmNlczogW1xuXHRcdFx0XHRvcHRpb25zLnNvdXJjZSA/IGdldFJlbGF0aXZlUGF0aChvcHRpb25zLmZpbGUgfHwgJycsIG9wdGlvbnMuc291cmNlKSA6IG9wdGlvbnMuZmlsZSB8fCAnJyxcblx0XHRcdF0sXG5cdFx0XHRzb3VyY2VzQ29udGVudDogb3B0aW9ucy5pbmNsdWRlQ29udGVudCA/IFt0aGlzLm9yaWdpbmFsXSA6IHVuZGVmaW5lZCxcblx0XHRcdG5hbWVzLFxuXHRcdFx0bWFwcGluZ3M6IG1hcHBpbmdzLnJhdyxcblx0XHRcdHhfZ29vZ2xlX2lnbm9yZUxpc3Q6IHRoaXMuaWdub3JlTGlzdCA/IFtzb3VyY2VJbmRleF0gOiB1bmRlZmluZWQsXG5cdFx0fTtcblx0fVxuXG5cdGdlbmVyYXRlTWFwKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gbmV3IFNvdXJjZU1hcCh0aGlzLmdlbmVyYXRlRGVjb2RlZE1hcChvcHRpb25zKSk7XG5cdH1cblxuXHRfZW5zdXJlaW5kZW50U3RyKCkge1xuXHRcdGlmICh0aGlzLmluZGVudFN0ciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLmluZGVudFN0ciA9IGd1ZXNzSW5kZW50KHRoaXMub3JpZ2luYWwpO1xuXHRcdH1cblx0fVxuXG5cdF9nZXRSYXdJbmRlbnRTdHJpbmcoKSB7XG5cdFx0dGhpcy5fZW5zdXJlaW5kZW50U3RyKCk7XG5cdFx0cmV0dXJuIHRoaXMuaW5kZW50U3RyO1xuXHR9XG5cblx0Z2V0SW5kZW50U3RyaW5nKCkge1xuXHRcdHRoaXMuX2Vuc3VyZWluZGVudFN0cigpO1xuXHRcdHJldHVybiB0aGlzLmluZGVudFN0ciA9PT0gbnVsbCA/ICdcXHQnIDogdGhpcy5pbmRlbnRTdHI7XG5cdH1cblxuXHRpbmRlbnQoaW5kZW50U3RyLCBvcHRpb25zKSB7XG5cdFx0Y29uc3QgcGF0dGVybiA9IC9eW15cXHJcXG5dL2dtO1xuXG5cdFx0aWYgKGlzT2JqZWN0KGluZGVudFN0cikpIHtcblx0XHRcdG9wdGlvbnMgPSBpbmRlbnRTdHI7XG5cdFx0XHRpbmRlbnRTdHIgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0aWYgKGluZGVudFN0ciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLl9lbnN1cmVpbmRlbnRTdHIoKTtcblx0XHRcdGluZGVudFN0ciA9IHRoaXMuaW5kZW50U3RyIHx8ICdcXHQnO1xuXHRcdH1cblxuXHRcdGlmIChpbmRlbnRTdHIgPT09ICcnKSByZXR1cm4gdGhpczsgLy8gbm9vcFxuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHQvLyBQcm9jZXNzIGV4Y2x1c2lvbiByYW5nZXNcblx0XHRjb25zdCBpc0V4Y2x1ZGVkID0ge307XG5cblx0XHRpZiAob3B0aW9ucy5leGNsdWRlKSB7XG5cdFx0XHRjb25zdCBleGNsdXNpb25zID1cblx0XHRcdFx0dHlwZW9mIG9wdGlvbnMuZXhjbHVkZVswXSA9PT0gJ251bWJlcicgPyBbb3B0aW9ucy5leGNsdWRlXSA6IG9wdGlvbnMuZXhjbHVkZTtcblx0XHRcdGV4Y2x1c2lvbnMuZm9yRWFjaCgoZXhjbHVzaW9uKSA9PiB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSBleGNsdXNpb25bMF07IGkgPCBleGNsdXNpb25bMV07IGkgKz0gMSkge1xuXHRcdFx0XHRcdGlzRXhjbHVkZWRbaV0gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRsZXQgc2hvdWxkSW5kZW50TmV4dENoYXJhY3RlciA9IG9wdGlvbnMuaW5kZW50U3RhcnQgIT09IGZhbHNlO1xuXHRcdGNvbnN0IHJlcGxhY2VyID0gKG1hdGNoKSA9PiB7XG5cdFx0XHRpZiAoc2hvdWxkSW5kZW50TmV4dENoYXJhY3RlcikgcmV0dXJuIGAke2luZGVudFN0cn0ke21hdGNofWA7XG5cdFx0XHRzaG91bGRJbmRlbnROZXh0Q2hhcmFjdGVyID0gdHJ1ZTtcblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9O1xuXG5cdFx0dGhpcy5pbnRybyA9IHRoaXMuaW50cm8ucmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlcik7XG5cblx0XHRsZXQgY2hhckluZGV4ID0gMDtcblx0XHRsZXQgY2h1bmsgPSB0aGlzLmZpcnN0Q2h1bms7XG5cblx0XHR3aGlsZSAoY2h1bmspIHtcblx0XHRcdGNvbnN0IGVuZCA9IGNodW5rLmVuZDtcblxuXHRcdFx0aWYgKGNodW5rLmVkaXRlZCkge1xuXHRcdFx0XHRpZiAoIWlzRXhjbHVkZWRbY2hhckluZGV4XSkge1xuXHRcdFx0XHRcdGNodW5rLmNvbnRlbnQgPSBjaHVuay5jb250ZW50LnJlcGxhY2UocGF0dGVybiwgcmVwbGFjZXIpO1xuXG5cdFx0XHRcdFx0aWYgKGNodW5rLmNvbnRlbnQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRzaG91bGRJbmRlbnROZXh0Q2hhcmFjdGVyID0gY2h1bmsuY29udGVudFtjaHVuay5jb250ZW50Lmxlbmd0aCAtIDFdID09PSAnXFxuJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNoYXJJbmRleCA9IGNodW5rLnN0YXJ0O1xuXG5cdFx0XHRcdHdoaWxlIChjaGFySW5kZXggPCBlbmQpIHtcblx0XHRcdFx0XHRpZiAoIWlzRXhjbHVkZWRbY2hhckluZGV4XSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgY2hhciA9IHRoaXMub3JpZ2luYWxbY2hhckluZGV4XTtcblxuXHRcdFx0XHRcdFx0aWYgKGNoYXIgPT09ICdcXG4nKSB7XG5cdFx0XHRcdFx0XHRcdHNob3VsZEluZGVudE5leHRDaGFyYWN0ZXIgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjaGFyICE9PSAnXFxyJyAmJiBzaG91bGRJbmRlbnROZXh0Q2hhcmFjdGVyKSB7XG5cdFx0XHRcdFx0XHRcdHNob3VsZEluZGVudE5leHRDaGFyYWN0ZXIgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoY2hhckluZGV4ID09PSBjaHVuay5zdGFydCkge1xuXHRcdFx0XHRcdFx0XHRcdGNodW5rLnByZXBlbmRSaWdodChpbmRlbnRTdHIpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3NwbGl0Q2h1bmsoY2h1bmssIGNoYXJJbmRleCk7XG5cdFx0XHRcdFx0XHRcdFx0Y2h1bmsgPSBjaHVuay5uZXh0O1xuXHRcdFx0XHRcdFx0XHRcdGNodW5rLnByZXBlbmRSaWdodChpbmRlbnRTdHIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2hhckluZGV4ICs9IDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y2hhckluZGV4ID0gY2h1bmsuZW5kO1xuXHRcdFx0Y2h1bmsgPSBjaHVuay5uZXh0O1xuXHRcdH1cblxuXHRcdHRoaXMub3V0cm8gPSB0aGlzLm91dHJvLnJlcGxhY2UocGF0dGVybiwgcmVwbGFjZXIpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRpbnNlcnQoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0J21hZ2ljU3RyaW5nLmluc2VydCguLi4pIGlzIGRlcHJlY2F0ZWQuIFVzZSBwcmVwZW5kUmlnaHQoLi4uKSBvciBhcHBlbmRMZWZ0KC4uLiknLFxuXHRcdCk7XG5cdH1cblxuXHRpbnNlcnRMZWZ0KGluZGV4LCBjb250ZW50KSB7XG5cdFx0aWYgKCF3YXJuZWQuaW5zZXJ0TGVmdCkge1xuXHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHQnbWFnaWNTdHJpbmcuaW5zZXJ0TGVmdCguLi4pIGlzIGRlcHJlY2F0ZWQuIFVzZSBtYWdpY1N0cmluZy5hcHBlbmRMZWZ0KC4uLikgaW5zdGVhZCcsXG5cdFx0XHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblx0XHRcdHdhcm5lZC5pbnNlcnRMZWZ0ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBlbmRMZWZ0KGluZGV4LCBjb250ZW50KTtcblx0fVxuXG5cdGluc2VydFJpZ2h0KGluZGV4LCBjb250ZW50KSB7XG5cdFx0aWYgKCF3YXJuZWQuaW5zZXJ0UmlnaHQpIHtcblx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0J21hZ2ljU3RyaW5nLmluc2VydFJpZ2h0KC4uLikgaXMgZGVwcmVjYXRlZC4gVXNlIG1hZ2ljU3RyaW5nLnByZXBlbmRSaWdodCguLi4pIGluc3RlYWQnLFxuXHRcdFx0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cdFx0XHR3YXJuZWQuaW5zZXJ0UmlnaHQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnByZXBlbmRSaWdodChpbmRleCwgY29udGVudCk7XG5cdH1cblxuXHRtb3ZlKHN0YXJ0LCBlbmQsIGluZGV4KSB7XG5cdFx0aWYgKGluZGV4ID49IHN0YXJ0ICYmIGluZGV4IDw9IGVuZCkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbW92ZSBhIHNlbGVjdGlvbiBpbnNpZGUgaXRzZWxmJyk7XG5cblx0XHR0aGlzLl9zcGxpdChzdGFydCk7XG5cdFx0dGhpcy5fc3BsaXQoZW5kKTtcblx0XHR0aGlzLl9zcGxpdChpbmRleCk7XG5cblx0XHRjb25zdCBmaXJzdCA9IHRoaXMuYnlTdGFydFtzdGFydF07XG5cdFx0Y29uc3QgbGFzdCA9IHRoaXMuYnlFbmRbZW5kXTtcblxuXHRcdGNvbnN0IG9sZExlZnQgPSBmaXJzdC5wcmV2aW91cztcblx0XHRjb25zdCBvbGRSaWdodCA9IGxhc3QubmV4dDtcblxuXHRcdGNvbnN0IG5ld1JpZ2h0ID0gdGhpcy5ieVN0YXJ0W2luZGV4XTtcblx0XHRpZiAoIW5ld1JpZ2h0ICYmIGxhc3QgPT09IHRoaXMubGFzdENodW5rKSByZXR1cm4gdGhpcztcblx0XHRjb25zdCBuZXdMZWZ0ID0gbmV3UmlnaHQgPyBuZXdSaWdodC5wcmV2aW91cyA6IHRoaXMubGFzdENodW5rO1xuXG5cdFx0aWYgKG9sZExlZnQpIG9sZExlZnQubmV4dCA9IG9sZFJpZ2h0O1xuXHRcdGlmIChvbGRSaWdodCkgb2xkUmlnaHQucHJldmlvdXMgPSBvbGRMZWZ0O1xuXG5cdFx0aWYgKG5ld0xlZnQpIG5ld0xlZnQubmV4dCA9IGZpcnN0O1xuXHRcdGlmIChuZXdSaWdodCkgbmV3UmlnaHQucHJldmlvdXMgPSBsYXN0O1xuXG5cdFx0aWYgKCFmaXJzdC5wcmV2aW91cykgdGhpcy5maXJzdENodW5rID0gbGFzdC5uZXh0O1xuXHRcdGlmICghbGFzdC5uZXh0KSB7XG5cdFx0XHR0aGlzLmxhc3RDaHVuayA9IGZpcnN0LnByZXZpb3VzO1xuXHRcdFx0dGhpcy5sYXN0Q2h1bmsubmV4dCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Zmlyc3QucHJldmlvdXMgPSBuZXdMZWZ0O1xuXHRcdGxhc3QubmV4dCA9IG5ld1JpZ2h0IHx8IG51bGw7XG5cblx0XHRpZiAoIW5ld0xlZnQpIHRoaXMuZmlyc3RDaHVuayA9IGZpcnN0O1xuXHRcdGlmICghbmV3UmlnaHQpIHRoaXMubGFzdENodW5rID0gbGFzdDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdG92ZXJ3cml0ZShzdGFydCwgZW5kLCBjb250ZW50LCBvcHRpb25zKSB7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlKHN0YXJ0LCBlbmQsIGNvbnRlbnQsIHsgLi4ub3B0aW9ucywgb3ZlcndyaXRlOiAhb3B0aW9ucy5jb250ZW50T25seSB9KTtcblx0fVxuXG5cdHVwZGF0ZShzdGFydCwgZW5kLCBjb250ZW50LCBvcHRpb25zKSB7XG5cdFx0aWYgKHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVwbGFjZW1lbnQgY29udGVudCBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cblx0XHRpZiAodGhpcy5vcmlnaW5hbC5sZW5ndGggIT09IDApIHtcblx0XHRcdHdoaWxlIChzdGFydCA8IDApIHN0YXJ0ICs9IHRoaXMub3JpZ2luYWwubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGVuZCA8IDApIGVuZCArPSB0aGlzLm9yaWdpbmFsLmxlbmd0aDtcblx0XHR9XG5cblx0XHRpZiAoZW5kID4gdGhpcy5vcmlnaW5hbC5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignZW5kIGlzIG91dCBvZiBib3VuZHMnKTtcblx0XHRpZiAoc3RhcnQgPT09IGVuZClcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0J0Nhbm5vdCBvdmVyd3JpdGUgYSB6ZXJvLWxlbmd0aCByYW5nZSDigJMgdXNlIGFwcGVuZExlZnQgb3IgcHJlcGVuZFJpZ2h0IGluc3RlYWQnLFxuXHRcdFx0KTtcblxuXHRcdHRoaXMuX3NwbGl0KHN0YXJ0KTtcblx0XHR0aGlzLl9zcGxpdChlbmQpO1xuXG5cdFx0aWYgKG9wdGlvbnMgPT09IHRydWUpIHtcblx0XHRcdGlmICghd2FybmVkLnN0b3JlTmFtZSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdFx0J1RoZSBmaW5hbCBhcmd1bWVudCB0byBtYWdpY1N0cmluZy5vdmVyd3JpdGUoLi4uKSBzaG91bGQgYmUgYW4gb3B0aW9ucyBvYmplY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcmljaC1oYXJyaXMvbWFnaWMtc3RyaW5nJyxcblx0XHRcdFx0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cdFx0XHRcdHdhcm5lZC5zdG9yZU5hbWUgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRvcHRpb25zID0geyBzdG9yZU5hbWU6IHRydWUgfTtcblx0XHR9XG5cdFx0Y29uc3Qgc3RvcmVOYW1lID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdG9yZU5hbWUgOiBmYWxzZTtcblx0XHRjb25zdCBvdmVyd3JpdGUgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm92ZXJ3cml0ZSA6IGZhbHNlO1xuXG5cdFx0aWYgKHN0b3JlTmFtZSkge1xuXHRcdFx0Y29uc3Qgb3JpZ2luYWwgPSB0aGlzLm9yaWdpbmFsLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuc3RvcmVkTmFtZXMsIG9yaWdpbmFsLCB7XG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZpcnN0ID0gdGhpcy5ieVN0YXJ0W3N0YXJ0XTtcblx0XHRjb25zdCBsYXN0ID0gdGhpcy5ieUVuZFtlbmRdO1xuXG5cdFx0aWYgKGZpcnN0KSB7XG5cdFx0XHRsZXQgY2h1bmsgPSBmaXJzdDtcblx0XHRcdHdoaWxlIChjaHVuayAhPT0gbGFzdCkge1xuXHRcdFx0XHRpZiAoY2h1bmsubmV4dCAhPT0gdGhpcy5ieVN0YXJ0W2NodW5rLmVuZF0pIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBvdmVyd3JpdGUgYWNyb3NzIGEgc3BsaXQgcG9pbnQnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0XHRcdGNodW5rLmVkaXQoJycsIGZhbHNlKTtcblx0XHRcdH1cblxuXHRcdFx0Zmlyc3QuZWRpdChjb250ZW50LCBzdG9yZU5hbWUsICFvdmVyd3JpdGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBtdXN0IGJlIGluc2VydGluZyBhdCB0aGUgZW5kXG5cdFx0XHRjb25zdCBuZXdDaHVuayA9IG5ldyBDaHVuayQxKHN0YXJ0LCBlbmQsICcnKS5lZGl0KGNvbnRlbnQsIHN0b3JlTmFtZSk7XG5cblx0XHRcdC8vIFRPRE8gbGFzdCBjaHVuayBpbiB0aGUgYXJyYXkgbWF5IG5vdCBiZSB0aGUgbGFzdCBjaHVuaywgaWYgaXQncyBtb3ZlZC4uLlxuXHRcdFx0bGFzdC5uZXh0ID0gbmV3Q2h1bms7XG5cdFx0XHRuZXdDaHVuay5wcmV2aW91cyA9IGxhc3Q7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0cHJlcGVuZChjb250ZW50KSB7XG5cdFx0aWYgKHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignb3V0cm8gY29udGVudCBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cblx0XHR0aGlzLmludHJvID0gY29udGVudCArIHRoaXMuaW50cm87XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRwcmVwZW5kTGVmdChpbmRleCwgY29udGVudCkge1xuXHRcdGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luc2VydGVkIGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuXG5cdFx0dGhpcy5fc3BsaXQoaW5kZXgpO1xuXG5cdFx0Y29uc3QgY2h1bmsgPSB0aGlzLmJ5RW5kW2luZGV4XTtcblxuXHRcdGlmIChjaHVuaykge1xuXHRcdFx0Y2h1bmsucHJlcGVuZExlZnQoY29udGVudCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuaW50cm8gPSBjb250ZW50ICsgdGhpcy5pbnRybztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRwcmVwZW5kUmlnaHQoaW5kZXgsIGNvbnRlbnQpIHtcblx0XHRpZiAodHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnNlcnRlZCBjb250ZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcblxuXHRcdHRoaXMuX3NwbGl0KGluZGV4KTtcblxuXHRcdGNvbnN0IGNodW5rID0gdGhpcy5ieVN0YXJ0W2luZGV4XTtcblxuXHRcdGlmIChjaHVuaykge1xuXHRcdFx0Y2h1bmsucHJlcGVuZFJpZ2h0KGNvbnRlbnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm91dHJvID0gY29udGVudCArIHRoaXMub3V0cm87XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0cmVtb3ZlKHN0YXJ0LCBlbmQpIHtcblx0XHRpZiAodGhpcy5vcmlnaW5hbC5sZW5ndGggIT09IDApIHtcblx0XHRcdHdoaWxlIChzdGFydCA8IDApIHN0YXJ0ICs9IHRoaXMub3JpZ2luYWwubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGVuZCA8IDApIGVuZCArPSB0aGlzLm9yaWdpbmFsLmxlbmd0aDtcblx0XHR9XG5cblx0XHRpZiAoc3RhcnQgPT09IGVuZCkgcmV0dXJuIHRoaXM7XG5cblx0XHRpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRoaXMub3JpZ2luYWwubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NoYXJhY3RlciBpcyBvdXQgb2YgYm91bmRzJyk7XG5cdFx0aWYgKHN0YXJ0ID4gZW5kKSB0aHJvdyBuZXcgRXJyb3IoJ2VuZCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBzdGFydCcpO1xuXG5cdFx0dGhpcy5fc3BsaXQoc3RhcnQpO1xuXHRcdHRoaXMuX3NwbGl0KGVuZCk7XG5cblx0XHRsZXQgY2h1bmsgPSB0aGlzLmJ5U3RhcnRbc3RhcnRdO1xuXG5cdFx0d2hpbGUgKGNodW5rKSB7XG5cdFx0XHRjaHVuay5pbnRybyA9ICcnO1xuXHRcdFx0Y2h1bmsub3V0cm8gPSAnJztcblx0XHRcdGNodW5rLmVkaXQoJycpO1xuXG5cdFx0XHRjaHVuayA9IGVuZCA+IGNodW5rLmVuZCA/IHRoaXMuYnlTdGFydFtjaHVuay5lbmRdIDogbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRyZXNldChzdGFydCwgZW5kKSB7XG5cdFx0aWYgKHRoaXMub3JpZ2luYWwubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHR3aGlsZSAoc3RhcnQgPCAwKSBzdGFydCArPSB0aGlzLm9yaWdpbmFsLmxlbmd0aDtcblx0XHRcdHdoaWxlIChlbmQgPCAwKSBlbmQgKz0gdGhpcy5vcmlnaW5hbC5sZW5ndGg7XG5cdFx0fVxuXG5cdFx0aWYgKHN0YXJ0ID09PSBlbmQpIHJldHVybiB0aGlzO1xuXG5cdFx0aWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0aGlzLm9yaWdpbmFsLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDaGFyYWN0ZXIgaXMgb3V0IG9mIGJvdW5kcycpO1xuXHRcdGlmIChzdGFydCA+IGVuZCkgdGhyb3cgbmV3IEVycm9yKCdlbmQgbXVzdCBiZSBncmVhdGVyIHRoYW4gc3RhcnQnKTtcblxuXHRcdHRoaXMuX3NwbGl0KHN0YXJ0KTtcblx0XHR0aGlzLl9zcGxpdChlbmQpO1xuXG5cdFx0bGV0IGNodW5rID0gdGhpcy5ieVN0YXJ0W3N0YXJ0XTtcblxuXHRcdHdoaWxlIChjaHVuaykge1xuXHRcdFx0Y2h1bmsucmVzZXQoKTtcblxuXHRcdFx0Y2h1bmsgPSBlbmQgPiBjaHVuay5lbmQgPyB0aGlzLmJ5U3RhcnRbY2h1bmsuZW5kXSA6IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0bGFzdENoYXIoKSB7XG5cdFx0aWYgKHRoaXMub3V0cm8ubGVuZ3RoKSByZXR1cm4gdGhpcy5vdXRyb1t0aGlzLm91dHJvLmxlbmd0aCAtIDFdO1xuXHRcdGxldCBjaHVuayA9IHRoaXMubGFzdENodW5rO1xuXHRcdGRvIHtcblx0XHRcdGlmIChjaHVuay5vdXRyby5sZW5ndGgpIHJldHVybiBjaHVuay5vdXRyb1tjaHVuay5vdXRyby5sZW5ndGggLSAxXTtcblx0XHRcdGlmIChjaHVuay5jb250ZW50Lmxlbmd0aCkgcmV0dXJuIGNodW5rLmNvbnRlbnRbY2h1bmsuY29udGVudC5sZW5ndGggLSAxXTtcblx0XHRcdGlmIChjaHVuay5pbnRyby5sZW5ndGgpIHJldHVybiBjaHVuay5pbnRyb1tjaHVuay5pbnRyby5sZW5ndGggLSAxXTtcblx0XHR9IHdoaWxlICgoY2h1bmsgPSBjaHVuay5wcmV2aW91cykpO1xuXHRcdGlmICh0aGlzLmludHJvLmxlbmd0aCkgcmV0dXJuIHRoaXMuaW50cm9bdGhpcy5pbnRyby5sZW5ndGggLSAxXTtcblx0XHRyZXR1cm4gJyc7XG5cdH1cblxuXHRsYXN0TGluZSgpIHtcblx0XHRsZXQgbGluZUluZGV4ID0gdGhpcy5vdXRyby5sYXN0SW5kZXhPZihuKTtcblx0XHRpZiAobGluZUluZGV4ICE9PSAtMSkgcmV0dXJuIHRoaXMub3V0cm8uc3Vic3RyKGxpbmVJbmRleCArIDEpO1xuXHRcdGxldCBsaW5lU3RyID0gdGhpcy5vdXRybztcblx0XHRsZXQgY2h1bmsgPSB0aGlzLmxhc3RDaHVuaztcblx0XHRkbyB7XG5cdFx0XHRpZiAoY2h1bmsub3V0cm8ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRsaW5lSW5kZXggPSBjaHVuay5vdXRyby5sYXN0SW5kZXhPZihuKTtcblx0XHRcdFx0aWYgKGxpbmVJbmRleCAhPT0gLTEpIHJldHVybiBjaHVuay5vdXRyby5zdWJzdHIobGluZUluZGV4ICsgMSkgKyBsaW5lU3RyO1xuXHRcdFx0XHRsaW5lU3RyID0gY2h1bmsub3V0cm8gKyBsaW5lU3RyO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2h1bmsuY29udGVudC5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGxpbmVJbmRleCA9IGNodW5rLmNvbnRlbnQubGFzdEluZGV4T2Yobik7XG5cdFx0XHRcdGlmIChsaW5lSW5kZXggIT09IC0xKSByZXR1cm4gY2h1bmsuY29udGVudC5zdWJzdHIobGluZUluZGV4ICsgMSkgKyBsaW5lU3RyO1xuXHRcdFx0XHRsaW5lU3RyID0gY2h1bmsuY29udGVudCArIGxpbmVTdHI7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjaHVuay5pbnRyby5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGxpbmVJbmRleCA9IGNodW5rLmludHJvLmxhc3RJbmRleE9mKG4pO1xuXHRcdFx0XHRpZiAobGluZUluZGV4ICE9PSAtMSkgcmV0dXJuIGNodW5rLmludHJvLnN1YnN0cihsaW5lSW5kZXggKyAxKSArIGxpbmVTdHI7XG5cdFx0XHRcdGxpbmVTdHIgPSBjaHVuay5pbnRybyArIGxpbmVTdHI7XG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAoKGNodW5rID0gY2h1bmsucHJldmlvdXMpKTtcblx0XHRsaW5lSW5kZXggPSB0aGlzLmludHJvLmxhc3RJbmRleE9mKG4pO1xuXHRcdGlmIChsaW5lSW5kZXggIT09IC0xKSByZXR1cm4gdGhpcy5pbnRyby5zdWJzdHIobGluZUluZGV4ICsgMSkgKyBsaW5lU3RyO1xuXHRcdHJldHVybiB0aGlzLmludHJvICsgbGluZVN0cjtcblx0fVxuXG5cdHNsaWNlKHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5vcmlnaW5hbC5sZW5ndGgpIHtcblx0XHRpZiAodGhpcy5vcmlnaW5hbC5sZW5ndGggIT09IDApIHtcblx0XHRcdHdoaWxlIChzdGFydCA8IDApIHN0YXJ0ICs9IHRoaXMub3JpZ2luYWwubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGVuZCA8IDApIGVuZCArPSB0aGlzLm9yaWdpbmFsLmxlbmd0aDtcblx0XHR9XG5cblx0XHRsZXQgcmVzdWx0ID0gJyc7XG5cblx0XHQvLyBmaW5kIHN0YXJ0IGNodW5rXG5cdFx0bGV0IGNodW5rID0gdGhpcy5maXJzdENodW5rO1xuXHRcdHdoaWxlIChjaHVuayAmJiAoY2h1bmsuc3RhcnQgPiBzdGFydCB8fCBjaHVuay5lbmQgPD0gc3RhcnQpKSB7XG5cdFx0XHQvLyBmb3VuZCBlbmQgY2h1bmsgYmVmb3JlIHN0YXJ0XG5cdFx0XHRpZiAoY2h1bmsuc3RhcnQgPCBlbmQgJiYgY2h1bmsuZW5kID49IGVuZCkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fVxuXG5cdFx0XHRjaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0fVxuXG5cdFx0aWYgKGNodW5rICYmIGNodW5rLmVkaXRlZCAmJiBjaHVuay5zdGFydCAhPT0gc3RhcnQpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCB1c2UgcmVwbGFjZWQgY2hhcmFjdGVyICR7c3RhcnR9IGFzIHNsaWNlIHN0YXJ0IGFuY2hvci5gKTtcblxuXHRcdGNvbnN0IHN0YXJ0Q2h1bmsgPSBjaHVuaztcblx0XHR3aGlsZSAoY2h1bmspIHtcblx0XHRcdGlmIChjaHVuay5pbnRybyAmJiAoc3RhcnRDaHVuayAhPT0gY2h1bmsgfHwgY2h1bmsuc3RhcnQgPT09IHN0YXJ0KSkge1xuXHRcdFx0XHRyZXN1bHQgKz0gY2h1bmsuaW50cm87XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNvbnRhaW5zRW5kID0gY2h1bmsuc3RhcnQgPCBlbmQgJiYgY2h1bmsuZW5kID49IGVuZDtcblx0XHRcdGlmIChjb250YWluc0VuZCAmJiBjaHVuay5lZGl0ZWQgJiYgY2h1bmsuZW5kICE9PSBlbmQpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHVzZSByZXBsYWNlZCBjaGFyYWN0ZXIgJHtlbmR9IGFzIHNsaWNlIGVuZCBhbmNob3IuYCk7XG5cblx0XHRcdGNvbnN0IHNsaWNlU3RhcnQgPSBzdGFydENodW5rID09PSBjaHVuayA/IHN0YXJ0IC0gY2h1bmsuc3RhcnQgOiAwO1xuXHRcdFx0Y29uc3Qgc2xpY2VFbmQgPSBjb250YWluc0VuZCA/IGNodW5rLmNvbnRlbnQubGVuZ3RoICsgZW5kIC0gY2h1bmsuZW5kIDogY2h1bmsuY29udGVudC5sZW5ndGg7XG5cblx0XHRcdHJlc3VsdCArPSBjaHVuay5jb250ZW50LnNsaWNlKHNsaWNlU3RhcnQsIHNsaWNlRW5kKTtcblxuXHRcdFx0aWYgKGNodW5rLm91dHJvICYmICghY29udGFpbnNFbmQgfHwgY2h1bmsuZW5kID09PSBlbmQpKSB7XG5cdFx0XHRcdHJlc3VsdCArPSBjaHVuay5vdXRybztcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNvbnRhaW5zRW5kKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRjaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8vIFRPRE8gZGVwcmVjYXRlIHRoaXM/IG5vdCByZWFsbHkgdmVyeSB1c2VmdWxcblx0c25pcChzdGFydCwgZW5kKSB7XG5cdFx0Y29uc3QgY2xvbmUgPSB0aGlzLmNsb25lKCk7XG5cdFx0Y2xvbmUucmVtb3ZlKDAsIHN0YXJ0KTtcblx0XHRjbG9uZS5yZW1vdmUoZW5kLCBjbG9uZS5vcmlnaW5hbC5sZW5ndGgpO1xuXG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9XG5cblx0X3NwbGl0KGluZGV4KSB7XG5cdFx0aWYgKHRoaXMuYnlTdGFydFtpbmRleF0gfHwgdGhpcy5ieUVuZFtpbmRleF0pIHJldHVybjtcblxuXHRcdGxldCBjaHVuayA9IHRoaXMubGFzdFNlYXJjaGVkQ2h1bms7XG5cdFx0Y29uc3Qgc2VhcmNoRm9yd2FyZCA9IGluZGV4ID4gY2h1bmsuZW5kO1xuXG5cdFx0d2hpbGUgKGNodW5rKSB7XG5cdFx0XHRpZiAoY2h1bmsuY29udGFpbnMoaW5kZXgpKSByZXR1cm4gdGhpcy5fc3BsaXRDaHVuayhjaHVuaywgaW5kZXgpO1xuXG5cdFx0XHRjaHVuayA9IHNlYXJjaEZvcndhcmQgPyB0aGlzLmJ5U3RhcnRbY2h1bmsuZW5kXSA6IHRoaXMuYnlFbmRbY2h1bmsuc3RhcnRdO1xuXHRcdH1cblx0fVxuXG5cdF9zcGxpdENodW5rKGNodW5rLCBpbmRleCkge1xuXHRcdGlmIChjaHVuay5lZGl0ZWQgJiYgY2h1bmsuY29udGVudC5sZW5ndGgpIHtcblx0XHRcdC8vIHplcm8tbGVuZ3RoIGVkaXRlZCBjaHVua3MgYXJlIGEgc3BlY2lhbCBjYXNlIChvdmVybGFwcGluZyByZXBsYWNlbWVudHMpXG5cdFx0XHRjb25zdCBsb2MgPSBnZXRMb2NhdG9yKHRoaXMub3JpZ2luYWwpKGluZGV4KTtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0YENhbm5vdCBzcGxpdCBhIGNodW5rIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBlZGl0ZWQgKCR7bG9jLmxpbmV9OiR7bG9jLmNvbHVtbn0g4oCTIFwiJHtjaHVuay5vcmlnaW5hbH1cIilgLFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRjb25zdCBuZXdDaHVuayA9IGNodW5rLnNwbGl0KGluZGV4KTtcblxuXHRcdHRoaXMuYnlFbmRbaW5kZXhdID0gY2h1bms7XG5cdFx0dGhpcy5ieVN0YXJ0W2luZGV4XSA9IG5ld0NodW5rO1xuXHRcdHRoaXMuYnlFbmRbbmV3Q2h1bmsuZW5kXSA9IG5ld0NodW5rO1xuXG5cdFx0aWYgKGNodW5rID09PSB0aGlzLmxhc3RDaHVuaykgdGhpcy5sYXN0Q2h1bmsgPSBuZXdDaHVuaztcblxuXHRcdHRoaXMubGFzdFNlYXJjaGVkQ2h1bmsgPSBjaHVuaztcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHRvU3RyaW5nKCkge1xuXHRcdGxldCBzdHIgPSB0aGlzLmludHJvO1xuXG5cdFx0bGV0IGNodW5rID0gdGhpcy5maXJzdENodW5rO1xuXHRcdHdoaWxlIChjaHVuaykge1xuXHRcdFx0c3RyICs9IGNodW5rLnRvU3RyaW5nKCk7XG5cdFx0XHRjaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0ciArIHRoaXMub3V0cm87XG5cdH1cblxuXHRpc0VtcHR5KCkge1xuXHRcdGxldCBjaHVuayA9IHRoaXMuZmlyc3RDaHVuaztcblx0XHRkbyB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdChjaHVuay5pbnRyby5sZW5ndGggJiYgY2h1bmsuaW50cm8udHJpbSgpKSB8fFxuXHRcdFx0XHQoY2h1bmsuY29udGVudC5sZW5ndGggJiYgY2h1bmsuY29udGVudC50cmltKCkpIHx8XG5cdFx0XHRcdChjaHVuay5vdXRyby5sZW5ndGggJiYgY2h1bmsub3V0cm8udHJpbSgpKVxuXHRcdFx0KVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSB3aGlsZSAoKGNodW5rID0gY2h1bmsubmV4dCkpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0bGVuZ3RoKCkge1xuXHRcdGxldCBjaHVuayA9IHRoaXMuZmlyc3RDaHVuaztcblx0XHRsZXQgbGVuZ3RoID0gMDtcblx0XHRkbyB7XG5cdFx0XHRsZW5ndGggKz0gY2h1bmsuaW50cm8ubGVuZ3RoICsgY2h1bmsuY29udGVudC5sZW5ndGggKyBjaHVuay5vdXRyby5sZW5ndGg7XG5cdFx0fSB3aGlsZSAoKGNodW5rID0gY2h1bmsubmV4dCkpO1xuXHRcdHJldHVybiBsZW5ndGg7XG5cdH1cblxuXHR0cmltTGluZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMudHJpbSgnW1xcXFxyXFxcXG5dJyk7XG5cdH1cblxuXHR0cmltKGNoYXJUeXBlKSB7XG5cdFx0cmV0dXJuIHRoaXMudHJpbVN0YXJ0KGNoYXJUeXBlKS50cmltRW5kKGNoYXJUeXBlKTtcblx0fVxuXG5cdHRyaW1FbmRBYm9ydGVkKGNoYXJUeXBlKSB7XG5cdFx0Y29uc3QgcnggPSBuZXcgUmVnRXhwKChjaGFyVHlwZSB8fCAnXFxcXHMnKSArICcrJCcpO1xuXG5cdFx0dGhpcy5vdXRybyA9IHRoaXMub3V0cm8ucmVwbGFjZShyeCwgJycpO1xuXHRcdGlmICh0aGlzLm91dHJvLmxlbmd0aCkgcmV0dXJuIHRydWU7XG5cblx0XHRsZXQgY2h1bmsgPSB0aGlzLmxhc3RDaHVuaztcblxuXHRcdGRvIHtcblx0XHRcdGNvbnN0IGVuZCA9IGNodW5rLmVuZDtcblx0XHRcdGNvbnN0IGFib3J0ZWQgPSBjaHVuay50cmltRW5kKHJ4KTtcblxuXHRcdFx0Ly8gaWYgY2h1bmsgd2FzIHRyaW1tZWQsIHdlIGhhdmUgYSBuZXcgbGFzdENodW5rXG5cdFx0XHRpZiAoY2h1bmsuZW5kICE9PSBlbmQpIHtcblx0XHRcdFx0aWYgKHRoaXMubGFzdENodW5rID09PSBjaHVuaykge1xuXHRcdFx0XHRcdHRoaXMubGFzdENodW5rID0gY2h1bmsubmV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuYnlFbmRbY2h1bmsuZW5kXSA9IGNodW5rO1xuXHRcdFx0XHR0aGlzLmJ5U3RhcnRbY2h1bmsubmV4dC5zdGFydF0gPSBjaHVuay5uZXh0O1xuXHRcdFx0XHR0aGlzLmJ5RW5kW2NodW5rLm5leHQuZW5kXSA9IGNodW5rLm5leHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChhYm9ydGVkKSByZXR1cm4gdHJ1ZTtcblx0XHRcdGNodW5rID0gY2h1bmsucHJldmlvdXM7XG5cdFx0fSB3aGlsZSAoY2h1bmspO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dHJpbUVuZChjaGFyVHlwZSkge1xuXHRcdHRoaXMudHJpbUVuZEFib3J0ZWQoY2hhclR5cGUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHRyaW1TdGFydEFib3J0ZWQoY2hhclR5cGUpIHtcblx0XHRjb25zdCByeCA9IG5ldyBSZWdFeHAoJ14nICsgKGNoYXJUeXBlIHx8ICdcXFxccycpICsgJysnKTtcblxuXHRcdHRoaXMuaW50cm8gPSB0aGlzLmludHJvLnJlcGxhY2UocngsICcnKTtcblx0XHRpZiAodGhpcy5pbnRyby5sZW5ndGgpIHJldHVybiB0cnVlO1xuXG5cdFx0bGV0IGNodW5rID0gdGhpcy5maXJzdENodW5rO1xuXG5cdFx0ZG8ge1xuXHRcdFx0Y29uc3QgZW5kID0gY2h1bmsuZW5kO1xuXHRcdFx0Y29uc3QgYWJvcnRlZCA9IGNodW5rLnRyaW1TdGFydChyeCk7XG5cblx0XHRcdGlmIChjaHVuay5lbmQgIT09IGVuZCkge1xuXHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UuLi5cblx0XHRcdFx0aWYgKGNodW5rID09PSB0aGlzLmxhc3RDaHVuaykgdGhpcy5sYXN0Q2h1bmsgPSBjaHVuay5uZXh0O1xuXG5cdFx0XHRcdHRoaXMuYnlFbmRbY2h1bmsuZW5kXSA9IGNodW5rO1xuXHRcdFx0XHR0aGlzLmJ5U3RhcnRbY2h1bmsubmV4dC5zdGFydF0gPSBjaHVuay5uZXh0O1xuXHRcdFx0XHR0aGlzLmJ5RW5kW2NodW5rLm5leHQuZW5kXSA9IGNodW5rLm5leHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChhYm9ydGVkKSByZXR1cm4gdHJ1ZTtcblx0XHRcdGNodW5rID0gY2h1bmsubmV4dDtcblx0XHR9IHdoaWxlIChjaHVuayk7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR0cmltU3RhcnQoY2hhclR5cGUpIHtcblx0XHR0aGlzLnRyaW1TdGFydEFib3J0ZWQoY2hhclR5cGUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0aGFzQ2hhbmdlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbCAhPT0gdGhpcy50b1N0cmluZygpO1xuXHR9XG5cblx0X3JlcGxhY2VSZWdleHAoc2VhcmNoVmFsdWUsIHJlcGxhY2VtZW50KSB7XG5cdFx0ZnVuY3Rpb24gZ2V0UmVwbGFjZW1lbnQobWF0Y2gsIHN0cikge1xuXHRcdFx0aWYgKHR5cGVvZiByZXBsYWNlbWVudCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cmV0dXJuIHJlcGxhY2VtZW50LnJlcGxhY2UoL1xcJChcXCR8JnxcXGQrKS9nLCAoXywgaSkgPT4ge1xuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9yZXBsYWNlI3NwZWNpZnlpbmdfYV9zdHJpbmdfYXNfYV9wYXJhbWV0ZXJcblx0XHRcdFx0XHRpZiAoaSA9PT0gJyQnKSByZXR1cm4gJyQnO1xuXHRcdFx0XHRcdGlmIChpID09PSAnJicpIHJldHVybiBtYXRjaFswXTtcblx0XHRcdFx0XHRjb25zdCBudW0gPSAraTtcblx0XHRcdFx0XHRpZiAobnVtIDwgbWF0Y2gubGVuZ3RoKSByZXR1cm4gbWF0Y2hbK2ldO1xuXHRcdFx0XHRcdHJldHVybiBgJCR7aX1gO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiByZXBsYWNlbWVudCguLi5tYXRjaCwgbWF0Y2guaW5kZXgsIHN0ciwgbWF0Y2guZ3JvdXBzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZnVuY3Rpb24gbWF0Y2hBbGwocmUsIHN0cikge1xuXHRcdFx0bGV0IG1hdGNoO1xuXHRcdFx0Y29uc3QgbWF0Y2hlcyA9IFtdO1xuXHRcdFx0d2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoc3RyKSkpIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKG1hdGNoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaGVzO1xuXHRcdH1cblx0XHRpZiAoc2VhcmNoVmFsdWUuZ2xvYmFsKSB7XG5cdFx0XHRjb25zdCBtYXRjaGVzID0gbWF0Y2hBbGwoc2VhcmNoVmFsdWUsIHRoaXMub3JpZ2luYWwpO1xuXHRcdFx0bWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuXHRcdFx0XHRpZiAobWF0Y2guaW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VtZW50ID0gZ2V0UmVwbGFjZW1lbnQobWF0Y2gsIHRoaXMub3JpZ2luYWwpO1xuXHRcdFx0XHRcdGlmIChyZXBsYWNlbWVudCAhPT0gbWF0Y2hbMF0pIHtcblx0XHRcdFx0XHRcdHRoaXMub3ZlcndyaXRlKFxuXHRcdFx0XHRcdFx0XHRtYXRjaC5pbmRleCxcblx0XHRcdFx0XHRcdFx0bWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdHJlcGxhY2VtZW50XG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IG1hdGNoID0gdGhpcy5vcmlnaW5hbC5tYXRjaChzZWFyY2hWYWx1ZSk7XG5cdFx0XHRpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHRjb25zdCByZXBsYWNlbWVudCA9IGdldFJlcGxhY2VtZW50KG1hdGNoLCB0aGlzLm9yaWdpbmFsKTtcblx0XHRcdFx0aWYgKHJlcGxhY2VtZW50ICE9PSBtYXRjaFswXSkge1xuXHRcdFx0XHRcdHRoaXMub3ZlcndyaXRlKFxuXHRcdFx0XHRcdFx0bWF0Y2guaW5kZXgsXG5cdFx0XHRcdFx0XHRtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCxcblx0XHRcdFx0XHRcdHJlcGxhY2VtZW50XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdF9yZXBsYWNlU3RyaW5nKHN0cmluZywgcmVwbGFjZW1lbnQpIHtcblx0XHRjb25zdCB7IG9yaWdpbmFsIH0gPSB0aGlzO1xuXHRcdGNvbnN0IGluZGV4ID0gb3JpZ2luYWwuaW5kZXhPZihzdHJpbmcpO1xuXG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0dGhpcy5vdmVyd3JpdGUoaW5kZXgsIGluZGV4ICsgc3RyaW5nLmxlbmd0aCwgcmVwbGFjZW1lbnQpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0cmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZW1lbnQpIHtcblx0XHRpZiAodHlwZW9mIHNlYXJjaFZhbHVlID09PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JlcGxhY2VTdHJpbmcoc2VhcmNoVmFsdWUsIHJlcGxhY2VtZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fcmVwbGFjZVJlZ2V4cChzZWFyY2hWYWx1ZSwgcmVwbGFjZW1lbnQpO1xuXHR9XG5cblx0X3JlcGxhY2VBbGxTdHJpbmcoc3RyaW5nLCByZXBsYWNlbWVudCkge1xuXHRcdGNvbnN0IHsgb3JpZ2luYWwgfSA9IHRoaXM7XG5cdFx0Y29uc3Qgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHRmb3IgKFxuXHRcdFx0bGV0IGluZGV4ID0gb3JpZ2luYWwuaW5kZXhPZihzdHJpbmcpO1xuXHRcdFx0aW5kZXggIT09IC0xO1xuXHRcdFx0aW5kZXggPSBvcmlnaW5hbC5pbmRleE9mKHN0cmluZywgaW5kZXggKyBzdHJpbmdMZW5ndGgpXG5cdFx0KSB7XG5cdFx0XHRjb25zdCBwcmV2aW91cyA9IG9yaWdpbmFsLnNsaWNlKGluZGV4LCBpbmRleCArIHN0cmluZ0xlbmd0aCk7XG5cdFx0XHRpZiAocHJldmlvdXMgIT09IHJlcGxhY2VtZW50KVxuXHRcdFx0XHR0aGlzLm92ZXJ3cml0ZShpbmRleCwgaW5kZXggKyBzdHJpbmdMZW5ndGgsIHJlcGxhY2VtZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHJlcGxhY2VBbGwoc2VhcmNoVmFsdWUsIHJlcGxhY2VtZW50KSB7XG5cdFx0aWYgKHR5cGVvZiBzZWFyY2hWYWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXBsYWNlQWxsU3RyaW5nKHNlYXJjaFZhbHVlLCByZXBsYWNlbWVudCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFzZWFyY2hWYWx1ZS5nbG9iYWwpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXG5cdFx0XHRcdCdNYWdpY1N0cmluZy5wcm90b3R5cGUucmVwbGFjZUFsbCBjYWxsZWQgd2l0aCBhIG5vbi1nbG9iYWwgUmVnRXhwIGFyZ3VtZW50Jyxcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX3JlcGxhY2VSZWdleHAoc2VhcmNoVmFsdWUsIHJlcGxhY2VtZW50KTtcblx0fVxufVxuXG5jb25zdCBoYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxubGV0IEJ1bmRsZSQxID0gY2xhc3MgQnVuZGxlIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG5cdFx0dGhpcy5pbnRybyA9IG9wdGlvbnMuaW50cm8gfHwgJyc7XG5cdFx0dGhpcy5zZXBhcmF0b3IgPSBvcHRpb25zLnNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zZXBhcmF0b3IgOiAnXFxuJztcblx0XHR0aGlzLnNvdXJjZXMgPSBbXTtcblx0XHR0aGlzLnVuaXF1ZVNvdXJjZXMgPSBbXTtcblx0XHR0aGlzLnVuaXF1ZVNvdXJjZUluZGV4QnlGaWxlbmFtZSA9IHt9O1xuXHR9XG5cblx0YWRkU291cmNlKHNvdXJjZSkge1xuXHRcdGlmIChzb3VyY2UgaW5zdGFuY2VvZiBNYWdpY1N0cmluZykge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkU291cmNlKHtcblx0XHRcdFx0Y29udGVudDogc291cmNlLFxuXHRcdFx0XHRmaWxlbmFtZTogc291cmNlLmZpbGVuYW1lLFxuXHRcdFx0XHRzZXBhcmF0b3I6IHRoaXMuc2VwYXJhdG9yLFxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFpc09iamVjdChzb3VyY2UpIHx8ICFzb3VyY2UuY29udGVudCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHQnYnVuZGxlLmFkZFNvdXJjZSgpIHRha2VzIGFuIG9iamVjdCB3aXRoIGEgYGNvbnRlbnRgIHByb3BlcnR5LCB3aGljaCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgTWFnaWNTdHJpbmcsIGFuZCBhbiBvcHRpb25hbCBgZmlsZW5hbWVgJyxcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0WydmaWxlbmFtZScsICdpZ25vcmVMaXN0JywgJ2luZGVudEV4Y2x1c2lvblJhbmdlcycsICdzZXBhcmF0b3InXS5mb3JFYWNoKChvcHRpb24pID0+IHtcblx0XHRcdGlmICghaGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgb3B0aW9uKSkgc291cmNlW29wdGlvbl0gPSBzb3VyY2UuY29udGVudFtvcHRpb25dO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHNvdXJjZS5zZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gVE9ETyB0aGVyZSdzIGEgYnVuY2ggb2YgdGhpcyBzb3J0IG9mIHRoaW5nLCBuZWVkcyBjbGVhbmluZyB1cFxuXHRcdFx0c291cmNlLnNlcGFyYXRvciA9IHRoaXMuc2VwYXJhdG9yO1xuXHRcdH1cblxuXHRcdGlmIChzb3VyY2UuZmlsZW5hbWUpIHtcblx0XHRcdGlmICghaGFzT3duUHJvcC5jYWxsKHRoaXMudW5pcXVlU291cmNlSW5kZXhCeUZpbGVuYW1lLCBzb3VyY2UuZmlsZW5hbWUpKSB7XG5cdFx0XHRcdHRoaXMudW5pcXVlU291cmNlSW5kZXhCeUZpbGVuYW1lW3NvdXJjZS5maWxlbmFtZV0gPSB0aGlzLnVuaXF1ZVNvdXJjZXMubGVuZ3RoO1xuXHRcdFx0XHR0aGlzLnVuaXF1ZVNvdXJjZXMucHVzaCh7IGZpbGVuYW1lOiBzb3VyY2UuZmlsZW5hbWUsIGNvbnRlbnQ6IHNvdXJjZS5jb250ZW50Lm9yaWdpbmFsIH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgdW5pcXVlU291cmNlID0gdGhpcy51bmlxdWVTb3VyY2VzW3RoaXMudW5pcXVlU291cmNlSW5kZXhCeUZpbGVuYW1lW3NvdXJjZS5maWxlbmFtZV1dO1xuXHRcdFx0XHRpZiAoc291cmNlLmNvbnRlbnQub3JpZ2luYWwgIT09IHVuaXF1ZVNvdXJjZS5jb250ZW50KSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIHNvdXJjZTogc2FtZSBmaWxlbmFtZSAoJHtzb3VyY2UuZmlsZW5hbWV9KSwgZGlmZmVyZW50IGNvbnRlbnRzYCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnNvdXJjZXMucHVzaChzb3VyY2UpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0YXBwZW5kKHN0ciwgb3B0aW9ucykge1xuXHRcdHRoaXMuYWRkU291cmNlKHtcblx0XHRcdGNvbnRlbnQ6IG5ldyBNYWdpY1N0cmluZyhzdHIpLFxuXHRcdFx0c2VwYXJhdG9yOiAob3B0aW9ucyAmJiBvcHRpb25zLnNlcGFyYXRvcikgfHwgJycsXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGNsb25lKCkge1xuXHRcdGNvbnN0IGJ1bmRsZSA9IG5ldyBCdW5kbGUoe1xuXHRcdFx0aW50cm86IHRoaXMuaW50cm8sXG5cdFx0XHRzZXBhcmF0b3I6IHRoaXMuc2VwYXJhdG9yLFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5zb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuXHRcdFx0YnVuZGxlLmFkZFNvdXJjZSh7XG5cdFx0XHRcdGZpbGVuYW1lOiBzb3VyY2UuZmlsZW5hbWUsXG5cdFx0XHRcdGNvbnRlbnQ6IHNvdXJjZS5jb250ZW50LmNsb25lKCksXG5cdFx0XHRcdHNlcGFyYXRvcjogc291cmNlLnNlcGFyYXRvcixcblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGJ1bmRsZTtcblx0fVxuXG5cdGdlbmVyYXRlRGVjb2RlZE1hcChvcHRpb25zID0ge30pIHtcblx0XHRjb25zdCBuYW1lcyA9IFtdO1xuXHRcdGxldCB4X2dvb2dsZV9pZ25vcmVMaXN0ID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuc291cmNlcy5mb3JFYWNoKChzb3VyY2UpID0+IHtcblx0XHRcdE9iamVjdC5rZXlzKHNvdXJjZS5jb250ZW50LnN0b3JlZE5hbWVzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG5cdFx0XHRcdGlmICghfm5hbWVzLmluZGV4T2YobmFtZSkpIG5hbWVzLnB1c2gobmFtZSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdGNvbnN0IG1hcHBpbmdzID0gbmV3IE1hcHBpbmdzKG9wdGlvbnMuaGlyZXMpO1xuXG5cdFx0aWYgKHRoaXMuaW50cm8pIHtcblx0XHRcdG1hcHBpbmdzLmFkdmFuY2UodGhpcy5pbnRybyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zb3VyY2VzLmZvckVhY2goKHNvdXJjZSwgaSkgPT4ge1xuXHRcdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRcdG1hcHBpbmdzLmFkdmFuY2UodGhpcy5zZXBhcmF0b3IpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzb3VyY2VJbmRleCA9IHNvdXJjZS5maWxlbmFtZSA/IHRoaXMudW5pcXVlU291cmNlSW5kZXhCeUZpbGVuYW1lW3NvdXJjZS5maWxlbmFtZV0gOiAtMTtcblx0XHRcdGNvbnN0IG1hZ2ljU3RyaW5nID0gc291cmNlLmNvbnRlbnQ7XG5cdFx0XHRjb25zdCBsb2NhdGUgPSBnZXRMb2NhdG9yKG1hZ2ljU3RyaW5nLm9yaWdpbmFsKTtcblxuXHRcdFx0aWYgKG1hZ2ljU3RyaW5nLmludHJvKSB7XG5cdFx0XHRcdG1hcHBpbmdzLmFkdmFuY2UobWFnaWNTdHJpbmcuaW50cm8pO1xuXHRcdFx0fVxuXG5cdFx0XHRtYWdpY1N0cmluZy5maXJzdENodW5rLmVhY2hOZXh0KChjaHVuaykgPT4ge1xuXHRcdFx0XHRjb25zdCBsb2MgPSBsb2NhdGUoY2h1bmsuc3RhcnQpO1xuXG5cdFx0XHRcdGlmIChjaHVuay5pbnRyby5sZW5ndGgpIG1hcHBpbmdzLmFkdmFuY2UoY2h1bmsuaW50cm8pO1xuXG5cdFx0XHRcdGlmIChzb3VyY2UuZmlsZW5hbWUpIHtcblx0XHRcdFx0XHRpZiAoY2h1bmsuZWRpdGVkKSB7XG5cdFx0XHRcdFx0XHRtYXBwaW5ncy5hZGRFZGl0KFxuXHRcdFx0XHRcdFx0XHRzb3VyY2VJbmRleCxcblx0XHRcdFx0XHRcdFx0Y2h1bmsuY29udGVudCxcblx0XHRcdFx0XHRcdFx0bG9jLFxuXHRcdFx0XHRcdFx0XHRjaHVuay5zdG9yZU5hbWUgPyBuYW1lcy5pbmRleE9mKGNodW5rLm9yaWdpbmFsKSA6IC0xLFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bWFwcGluZ3MuYWRkVW5lZGl0ZWRDaHVuayhcblx0XHRcdFx0XHRcdFx0c291cmNlSW5kZXgsXG5cdFx0XHRcdFx0XHRcdGNodW5rLFxuXHRcdFx0XHRcdFx0XHRtYWdpY1N0cmluZy5vcmlnaW5hbCxcblx0XHRcdFx0XHRcdFx0bG9jLFxuXHRcdFx0XHRcdFx0XHRtYWdpY1N0cmluZy5zb3VyY2VtYXBMb2NhdGlvbnMsXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtYXBwaW5ncy5hZHZhbmNlKGNodW5rLmNvbnRlbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNodW5rLm91dHJvLmxlbmd0aCkgbWFwcGluZ3MuYWR2YW5jZShjaHVuay5vdXRybyk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKG1hZ2ljU3RyaW5nLm91dHJvKSB7XG5cdFx0XHRcdG1hcHBpbmdzLmFkdmFuY2UobWFnaWNTdHJpbmcub3V0cm8pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc291cmNlLmlnbm9yZUxpc3QgJiYgc291cmNlSW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdGlmICh4X2dvb2dsZV9pZ25vcmVMaXN0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR4X2dvb2dsZV9pZ25vcmVMaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0eF9nb29nbGVfaWdub3JlTGlzdC5wdXNoKHNvdXJjZUluZGV4KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRmaWxlOiBvcHRpb25zLmZpbGUgPyBvcHRpb25zLmZpbGUuc3BsaXQoL1svXFxcXF0vKS5wb3AoKSA6IHVuZGVmaW5lZCxcblx0XHRcdHNvdXJjZXM6IHRoaXMudW5pcXVlU291cmNlcy5tYXAoKHNvdXJjZSkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gb3B0aW9ucy5maWxlID8gZ2V0UmVsYXRpdmVQYXRoKG9wdGlvbnMuZmlsZSwgc291cmNlLmZpbGVuYW1lKSA6IHNvdXJjZS5maWxlbmFtZTtcblx0XHRcdH0pLFxuXHRcdFx0c291cmNlc0NvbnRlbnQ6IHRoaXMudW5pcXVlU291cmNlcy5tYXAoKHNvdXJjZSkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gb3B0aW9ucy5pbmNsdWRlQ29udGVudCA/IHNvdXJjZS5jb250ZW50IDogbnVsbDtcblx0XHRcdH0pLFxuXHRcdFx0bmFtZXMsXG5cdFx0XHRtYXBwaW5nczogbWFwcGluZ3MucmF3LFxuXHRcdFx0eF9nb29nbGVfaWdub3JlTGlzdCxcblx0XHR9O1xuXHR9XG5cblx0Z2VuZXJhdGVNYXAob3B0aW9ucykge1xuXHRcdHJldHVybiBuZXcgU291cmNlTWFwKHRoaXMuZ2VuZXJhdGVEZWNvZGVkTWFwKG9wdGlvbnMpKTtcblx0fVxuXG5cdGdldEluZGVudFN0cmluZygpIHtcblx0XHRjb25zdCBpbmRlbnRTdHJpbmdDb3VudHMgPSB7fTtcblxuXHRcdHRoaXMuc291cmNlcy5mb3JFYWNoKChzb3VyY2UpID0+IHtcblx0XHRcdGNvbnN0IGluZGVudFN0ciA9IHNvdXJjZS5jb250ZW50Ll9nZXRSYXdJbmRlbnRTdHJpbmcoKTtcblxuXHRcdFx0aWYgKGluZGVudFN0ciA9PT0gbnVsbCkgcmV0dXJuO1xuXG5cdFx0XHRpZiAoIWluZGVudFN0cmluZ0NvdW50c1tpbmRlbnRTdHJdKSBpbmRlbnRTdHJpbmdDb3VudHNbaW5kZW50U3RyXSA9IDA7XG5cdFx0XHRpbmRlbnRTdHJpbmdDb3VudHNbaW5kZW50U3RyXSArPSAxO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdE9iamVjdC5rZXlzKGluZGVudFN0cmluZ0NvdW50cykuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0XHRyZXR1cm4gaW5kZW50U3RyaW5nQ291bnRzW2FdIC0gaW5kZW50U3RyaW5nQ291bnRzW2JdO1xuXHRcdFx0fSlbMF0gfHwgJ1xcdCdcblx0XHQpO1xuXHR9XG5cblx0aW5kZW50KGluZGVudFN0cikge1xuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0aW5kZW50U3RyID0gdGhpcy5nZXRJbmRlbnRTdHJpbmcoKTtcblx0XHR9XG5cblx0XHRpZiAoaW5kZW50U3RyID09PSAnJykgcmV0dXJuIHRoaXM7IC8vIG5vb3BcblxuXHRcdGxldCB0cmFpbGluZ05ld2xpbmUgPSAhdGhpcy5pbnRybyB8fCB0aGlzLmludHJvLnNsaWNlKC0xKSA9PT0gJ1xcbic7XG5cblx0XHR0aGlzLnNvdXJjZXMuZm9yRWFjaCgoc291cmNlLCBpKSA9PiB7XG5cdFx0XHRjb25zdCBzZXBhcmF0b3IgPSBzb3VyY2Uuc2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBzb3VyY2Uuc2VwYXJhdG9yIDogdGhpcy5zZXBhcmF0b3I7XG5cdFx0XHRjb25zdCBpbmRlbnRTdGFydCA9IHRyYWlsaW5nTmV3bGluZSB8fCAoaSA+IDAgJiYgL1xccj9cXG4kLy50ZXN0KHNlcGFyYXRvcikpO1xuXG5cdFx0XHRzb3VyY2UuY29udGVudC5pbmRlbnQoaW5kZW50U3RyLCB7XG5cdFx0XHRcdGV4Y2x1ZGU6IHNvdXJjZS5pbmRlbnRFeGNsdXNpb25SYW5nZXMsXG5cdFx0XHRcdGluZGVudFN0YXJ0LCAvLzogdHJhaWxpbmdOZXdsaW5lIHx8IC9cXHI/XFxuJC8udGVzdCggc2VwYXJhdG9yICkgIC8vdHJ1ZS8vL1xccj9cXG4vLnRlc3QoIHNlcGFyYXRvciApXG5cdFx0XHR9KTtcblxuXHRcdFx0dHJhaWxpbmdOZXdsaW5lID0gc291cmNlLmNvbnRlbnQubGFzdENoYXIoKSA9PT0gJ1xcbic7XG5cdFx0fSk7XG5cblx0XHRpZiAodGhpcy5pbnRybykge1xuXHRcdFx0dGhpcy5pbnRybyA9XG5cdFx0XHRcdGluZGVudFN0ciArXG5cdFx0XHRcdHRoaXMuaW50cm8ucmVwbGFjZSgvXlteXFxuXS9nbSwgKG1hdGNoLCBpbmRleCkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiBpbmRleCA+IDAgPyBpbmRlbnRTdHIgKyBtYXRjaCA6IG1hdGNoO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdHByZXBlbmQoc3RyKSB7XG5cdFx0dGhpcy5pbnRybyA9IHN0ciArIHRoaXMuaW50cm87XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRjb25zdCBib2R5ID0gdGhpcy5zb3VyY2VzXG5cdFx0XHQubWFwKChzb3VyY2UsIGkpID0+IHtcblx0XHRcdFx0Y29uc3Qgc2VwYXJhdG9yID0gc291cmNlLnNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gc291cmNlLnNlcGFyYXRvciA6IHRoaXMuc2VwYXJhdG9yO1xuXHRcdFx0XHRjb25zdCBzdHIgPSAoaSA+IDAgPyBzZXBhcmF0b3IgOiAnJykgKyBzb3VyY2UuY29udGVudC50b1N0cmluZygpO1xuXG5cdFx0XHRcdHJldHVybiBzdHI7XG5cdFx0XHR9KVxuXHRcdFx0LmpvaW4oJycpO1xuXG5cdFx0cmV0dXJuIHRoaXMuaW50cm8gKyBib2R5O1xuXHR9XG5cblx0aXNFbXB0eSgpIHtcblx0XHRpZiAodGhpcy5pbnRyby5sZW5ndGggJiYgdGhpcy5pbnRyby50cmltKCkpIHJldHVybiBmYWxzZTtcblx0XHRpZiAodGhpcy5zb3VyY2VzLnNvbWUoKHNvdXJjZSkgPT4gIXNvdXJjZS5jb250ZW50LmlzRW1wdHkoKSkpIHJldHVybiBmYWxzZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGxlbmd0aCgpIHtcblx0XHRyZXR1cm4gdGhpcy5zb3VyY2VzLnJlZHVjZShcblx0XHRcdChsZW5ndGgsIHNvdXJjZSkgPT4gbGVuZ3RoICsgc291cmNlLmNvbnRlbnQubGVuZ3RoKCksXG5cdFx0XHR0aGlzLmludHJvLmxlbmd0aCxcblx0XHQpO1xuXHR9XG5cblx0dHJpbUxpbmVzKCkge1xuXHRcdHJldHVybiB0aGlzLnRyaW0oJ1tcXFxcclxcXFxuXScpO1xuXHR9XG5cblx0dHJpbShjaGFyVHlwZSkge1xuXHRcdHJldHVybiB0aGlzLnRyaW1TdGFydChjaGFyVHlwZSkudHJpbUVuZChjaGFyVHlwZSk7XG5cdH1cblxuXHR0cmltU3RhcnQoY2hhclR5cGUpIHtcblx0XHRjb25zdCByeCA9IG5ldyBSZWdFeHAoJ14nICsgKGNoYXJUeXBlIHx8ICdcXFxccycpICsgJysnKTtcblx0XHR0aGlzLmludHJvID0gdGhpcy5pbnRyby5yZXBsYWNlKHJ4LCAnJyk7XG5cblx0XHRpZiAoIXRoaXMuaW50cm8pIHtcblx0XHRcdGxldCBzb3VyY2U7XG5cdFx0XHRsZXQgaSA9IDA7XG5cblx0XHRcdGRvIHtcblx0XHRcdFx0c291cmNlID0gdGhpcy5zb3VyY2VzW2krK107XG5cdFx0XHRcdGlmICghc291cmNlKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH0gd2hpbGUgKCFzb3VyY2UuY29udGVudC50cmltU3RhcnRBYm9ydGVkKGNoYXJUeXBlKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHR0cmltRW5kKGNoYXJUeXBlKSB7XG5cdFx0Y29uc3QgcnggPSBuZXcgUmVnRXhwKChjaGFyVHlwZSB8fCAnXFxcXHMnKSArICcrJCcpO1xuXG5cdFx0bGV0IHNvdXJjZTtcblx0XHRsZXQgaSA9IHRoaXMuc291cmNlcy5sZW5ndGggLSAxO1xuXG5cdFx0ZG8ge1xuXHRcdFx0c291cmNlID0gdGhpcy5zb3VyY2VzW2ktLV07XG5cdFx0XHRpZiAoIXNvdXJjZSkge1xuXHRcdFx0XHR0aGlzLmludHJvID0gdGhpcy5pbnRyby5yZXBsYWNlKHJ4LCAnJyk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH0gd2hpbGUgKCFzb3VyY2UuY29udGVudC50cmltRW5kQWJvcnRlZChjaGFyVHlwZSkpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cbmZ1bmN0aW9uIHRyZWVzaGFrZU5vZGUobm9kZSwgY29kZSwgc3RhcnQsIGVuZCkge1xuICAgIGNvZGUucmVtb3ZlKHN0YXJ0LCBlbmQpO1xuICAgIG5vZGUucmVtb3ZlQW5ub3RhdGlvbnMoY29kZSk7XG59XG5cbmNvbnN0IE5PX1NFTUlDT0xPTiA9IHsgaXNOb1N0YXRlbWVudDogdHJ1ZSB9O1xuLy8gVGhpcyBhc3N1bWVzIHRoZXJlIGFyZSBvbmx5IHdoaXRlLXNwYWNlIGFuZCBjb21tZW50cyBiZXR3ZWVuIHN0YXJ0IGFuZCB0aGUgc3RyaW5nIHdlIGFyZSBsb29raW5nIGZvclxuZnVuY3Rpb24gZmluZEZpcnN0T2NjdXJyZW5jZU91dHNpZGVDb21tZW50KGNvZGUsIHNlYXJjaFN0cmluZywgc3RhcnQgPSAwKSB7XG4gICAgbGV0IHNlYXJjaFBvcywgY2hhckNvZGVBZnRlclNsYXNoO1xuICAgIHNlYXJjaFBvcyA9IGNvZGUuaW5kZXhPZihzZWFyY2hTdHJpbmcsIHN0YXJ0KTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBzdGFydCA9IGNvZGUuaW5kZXhPZignLycsIHN0YXJ0KTtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSB8fCBzdGFydCA+PSBzZWFyY2hQb3MpXG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoUG9zO1xuICAgICAgICBjaGFyQ29kZUFmdGVyU2xhc2ggPSBjb2RlLmNoYXJDb2RlQXQoKytzdGFydCk7XG4gICAgICAgICsrc3RhcnQ7XG4gICAgICAgIC8vIFdpdGggb3VyIGFzc3VtcHRpb24sICcvJyBhbHdheXMgc3RhcnRzIGEgY29tbWVudC4gRGV0ZXJtaW5lIGNvbW1lbnQgdHlwZTpcbiAgICAgICAgc3RhcnQgPVxuICAgICAgICAgICAgY2hhckNvZGVBZnRlclNsYXNoID09PSA0NyAvKlwiL1wiKi9cbiAgICAgICAgICAgICAgICA/IGNvZGUuaW5kZXhPZignXFxuJywgc3RhcnQpICsgMVxuICAgICAgICAgICAgICAgIDogY29kZS5pbmRleE9mKCcqLycsIHN0YXJ0KSArIDI7XG4gICAgICAgIGlmIChzdGFydCA+IHNlYXJjaFBvcykge1xuICAgICAgICAgICAgc2VhcmNoUG9zID0gY29kZS5pbmRleE9mKHNlYXJjaFN0cmluZywgc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgTk9OX1dISVRFU1BBQ0UgPSAvXFxTL2c7XG5mdW5jdGlvbiBmaW5kTm9uV2hpdGVTcGFjZShjb2RlLCBpbmRleCkge1xuICAgIE5PTl9XSElURVNQQUNFLmxhc3RJbmRleCA9IGluZGV4O1xuICAgIGNvbnN0IHJlc3VsdCA9IE5PTl9XSElURVNQQUNFLmV4ZWMoY29kZSk7XG4gICAgcmV0dXJuIHJlc3VsdC5pbmRleDtcbn1cbmNvbnN0IFdISVRFU1BBQ0UgPSAvXFxzLztcbmZ1bmN0aW9uIGZpbmRMYXN0V2hpdGVTcGFjZVJldmVyc2UoY29kZSwgc3RhcnQsIGVuZCkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFdISVRFU1BBQ0UudGVzdChjb2RlW2VuZCAtIDFdKSkge1xuICAgICAgICAgICAgZW5kLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gVGhpcyBhc3N1bWVzIFwiY29kZVwiIG9ubHkgY29udGFpbnMgd2hpdGUtc3BhY2UgYW5kIGNvbW1lbnRzXG4vLyBSZXR1cm5zIHBvc2l0aW9uIG9mIGxpbmUtY29tbWVudCBpZiBhcHBsaWNhYmxlXG5mdW5jdGlvbiBmaW5kRmlyc3RMaW5lQnJlYWtPdXRzaWRlQ29tbWVudChjb2RlKSB7XG4gICAgbGV0IGxpbmVCcmVha1BvcywgY2hhckNvZGVBZnRlclNsYXNoLCBzdGFydCA9IDA7XG4gICAgbGluZUJyZWFrUG9zID0gY29kZS5pbmRleE9mKCdcXG4nLCBzdGFydCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3RhcnQgPSBjb2RlLmluZGV4T2YoJy8nLCBzdGFydCk7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEgfHwgc3RhcnQgPiBsaW5lQnJlYWtQb3MpXG4gICAgICAgICAgICByZXR1cm4gW2xpbmVCcmVha1BvcywgbGluZUJyZWFrUG9zICsgMV07XG4gICAgICAgIC8vIFdpdGggb3VyIGFzc3VtcHRpb24sICcvJyBhbHdheXMgc3RhcnRzIGEgY29tbWVudC4gRGV0ZXJtaW5lIGNvbW1lbnQgdHlwZTpcbiAgICAgICAgY2hhckNvZGVBZnRlclNsYXNoID0gY29kZS5jaGFyQ29kZUF0KHN0YXJ0ICsgMSk7XG4gICAgICAgIGlmIChjaGFyQ29kZUFmdGVyU2xhc2ggPT09IDQ3IC8qXCIvXCIqLylcbiAgICAgICAgICAgIHJldHVybiBbc3RhcnQsIGxpbmVCcmVha1BvcyArIDFdO1xuICAgICAgICBzdGFydCA9IGNvZGUuaW5kZXhPZignKi8nLCBzdGFydCArIDIpICsgMjtcbiAgICAgICAgaWYgKHN0YXJ0ID4gbGluZUJyZWFrUG9zKSB7XG4gICAgICAgICAgICBsaW5lQnJlYWtQb3MgPSBjb2RlLmluZGV4T2YoJ1xcbicsIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlclN0YXRlbWVudExpc3Qoc3RhdGVtZW50cywgY29kZSwgc3RhcnQsIGVuZCwgb3B0aW9ucykge1xuICAgIGxldCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVTdGFydCwgY3VycmVudE5vZGVOZWVkc0JvdW5kYXJpZXMsIG5leHROb2RlU3RhcnQ7XG4gICAgbGV0IG5leHROb2RlID0gc3RhdGVtZW50c1swXTtcbiAgICBsZXQgbmV4dE5vZGVOZWVkc0JvdW5kYXJpZXMgPSAhbmV4dE5vZGUuaW5jbHVkZWQgfHwgbmV4dE5vZGUubmVlZHNCb3VuZGFyaWVzO1xuICAgIGlmIChuZXh0Tm9kZU5lZWRzQm91bmRhcmllcykge1xuICAgICAgICBuZXh0Tm9kZVN0YXJ0ID1cbiAgICAgICAgICAgIHN0YXJ0ICsgZmluZEZpcnN0TGluZUJyZWFrT3V0c2lkZUNvbW1lbnQoY29kZS5vcmlnaW5hbC5zbGljZShzdGFydCwgbmV4dE5vZGUuc3RhcnQpKVsxXTtcbiAgICB9XG4gICAgZm9yIChsZXQgbmV4dEluZGV4ID0gMTsgbmV4dEluZGV4IDw9IHN0YXRlbWVudHMubGVuZ3RoOyBuZXh0SW5kZXgrKykge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IG5leHROb2RlO1xuICAgICAgICBjdXJyZW50Tm9kZVN0YXJ0ID0gbmV4dE5vZGVTdGFydDtcbiAgICAgICAgY3VycmVudE5vZGVOZWVkc0JvdW5kYXJpZXMgPSBuZXh0Tm9kZU5lZWRzQm91bmRhcmllcztcbiAgICAgICAgbmV4dE5vZGUgPSBzdGF0ZW1lbnRzW25leHRJbmRleF07XG4gICAgICAgIG5leHROb2RlTmVlZHNCb3VuZGFyaWVzID1cbiAgICAgICAgICAgIG5leHROb2RlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6ICFuZXh0Tm9kZS5pbmNsdWRlZCB8fCBuZXh0Tm9kZS5uZWVkc0JvdW5kYXJpZXM7XG4gICAgICAgIGlmIChjdXJyZW50Tm9kZU5lZWRzQm91bmRhcmllcyB8fCBuZXh0Tm9kZU5lZWRzQm91bmRhcmllcykge1xuICAgICAgICAgICAgbmV4dE5vZGVTdGFydCA9XG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUuZW5kICtcbiAgICAgICAgICAgICAgICAgICAgZmluZEZpcnN0TGluZUJyZWFrT3V0c2lkZUNvbW1lbnQoY29kZS5vcmlnaW5hbC5zbGljZShjdXJyZW50Tm9kZS5lbmQsIG5leHROb2RlID09PSB1bmRlZmluZWQgPyBlbmQgOiBuZXh0Tm9kZS5zdGFydCkpWzFdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlTmVlZHNCb3VuZGFyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnJlbmRlcihjb2RlLCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG5leHROb2RlU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogY3VycmVudE5vZGVTdGFydFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmVlc2hha2VOb2RlKGN1cnJlbnROb2RlLCBjb2RlLCBjdXJyZW50Tm9kZVN0YXJ0LCBuZXh0Tm9kZVN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFRoaXMgYXNzdW1lcyB0aGF0IHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IHBhcnQgb2YgdGhlIGZpcnN0IG5vZGVcbmZ1bmN0aW9uIGdldENvbW1hU2VwYXJhdGVkTm9kZXNXaXRoQm91bmRhcmllcyhub2RlcywgY29kZSwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IHNwbGl0VXBOb2RlcyA9IFtdO1xuICAgIGxldCBub2RlLCBuZXh0Tm9kZVN0YXJ0LCBjb250ZW50RW5kLCBjaGFyO1xuICAgIGxldCBzZXBhcmF0b3IgPSBzdGFydCAtIDE7XG4gICAgZm9yIChjb25zdCBuZXh0Tm9kZSBvZiBub2Rlcykge1xuICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPVxuICAgICAgICAgICAgICAgIG5vZGUuZW5kICtcbiAgICAgICAgICAgICAgICAgICAgZmluZEZpcnN0T2NjdXJyZW5jZU91dHNpZGVDb21tZW50KGNvZGUub3JpZ2luYWwuc2xpY2Uobm9kZS5lbmQsIG5leHROb2RlLnN0YXJ0KSwgJywnKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0Tm9kZVN0YXJ0ID0gY29udGVudEVuZCA9XG4gICAgICAgICAgICBzZXBhcmF0b3IgK1xuICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgIGZpbmRGaXJzdExpbmVCcmVha091dHNpZGVDb21tZW50KGNvZGUub3JpZ2luYWwuc2xpY2Uoc2VwYXJhdG9yICsgMSwgbmV4dE5vZGUuc3RhcnQpKVsxXTtcbiAgICAgICAgd2hpbGUgKCgoY2hhciA9IGNvZGUub3JpZ2luYWwuY2hhckNvZGVBdChuZXh0Tm9kZVN0YXJ0KSksXG4gICAgICAgICAgICBjaGFyID09PSAzMiAvKlwiIFwiKi8gfHwgY2hhciA9PT0gOSAvKlwiXFx0XCIqLyB8fCBjaGFyID09PSAxMCAvKlwiXFxuXCIqLyB8fCBjaGFyID09PSAxMykgLypcIlxcclwiKi8pXG4gICAgICAgICAgICBuZXh0Tm9kZVN0YXJ0Kys7XG4gICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNwbGl0VXBOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb250ZW50RW5kLFxuICAgICAgICAgICAgICAgIGVuZDogbmV4dE5vZGVTdGFydCxcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICBzdGFydFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5leHROb2RlO1xuICAgICAgICBzdGFydCA9IG5leHROb2RlU3RhcnQ7XG4gICAgfVxuICAgIHNwbGl0VXBOb2Rlcy5wdXNoKHtcbiAgICAgICAgY29udGVudEVuZDogZW5kLFxuICAgICAgICBlbmQsXG4gICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIHNlcGFyYXRvcjogbnVsbCxcbiAgICAgICAgc3RhcnRcbiAgICB9KTtcbiAgICByZXR1cm4gc3BsaXRVcE5vZGVzO1xufVxuLy8gVGhpcyBhc3N1bWVzIHRoZXJlIGFyZSBvbmx5IHdoaXRlLXNwYWNlIGFuZCBjb21tZW50cyBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmRcbmZ1bmN0aW9uIHJlbW92ZUxpbmVCcmVha3MoY29kZSwgc3RhcnQsIGVuZCkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IFtyZW1vdmVTdGFydCwgcmVtb3ZlRW5kXSA9IGZpbmRGaXJzdExpbmVCcmVha091dHNpZGVDb21tZW50KGNvZGUub3JpZ2luYWwuc2xpY2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICBpZiAocmVtb3ZlU3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb2RlLnJlbW92ZShzdGFydCArIHJlbW92ZVN0YXJ0LCAoc3RhcnQgKz0gcmVtb3ZlRW5kKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRTeXN0ZW1FeHBvcnRTdGF0ZW1lbnQoZXhwb3J0ZWRWYXJpYWJsZXMsIHsgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLCBzbmlwcGV0czogeyBfLCBnZXRPYmplY3QsIGdldFByb3BlcnR5QWNjZXNzIH0gfSwgbW9kaWZpZXIgPSAnJykge1xuICAgIGlmIChleHBvcnRlZFZhcmlhYmxlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLmdldChleHBvcnRlZFZhcmlhYmxlc1swXSkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlID0gZXhwb3J0ZWRWYXJpYWJsZXNbMF07XG4gICAgICAgIHJldHVybiBgZXhwb3J0cygke0pTT04uc3RyaW5naWZ5KGV4cG9ydE5hbWVzQnlWYXJpYWJsZS5nZXQodmFyaWFibGUpWzBdKX0sJHtffSR7dmFyaWFibGUuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2Vzcyl9JHttb2RpZmllcn0pYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHZhcmlhYmxlIG9mIGV4cG9ydGVkVmFyaWFibGVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV4cG9ydE5hbWUgb2YgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLmdldCh2YXJpYWJsZSkpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChbZXhwb3J0TmFtZSwgdmFyaWFibGUuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2VzcykgKyBtb2RpZmllcl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgZXhwb3J0cygke2dldE9iamVjdChmaWVsZHMsIHsgbGluZUJyZWFrSW5kZW50OiBudWxsIH0pfSlgO1xuICAgIH1cbn1cbi8vIFRoaXMgaXMgb25seSBpbnZva2VkIGlmIHRoZXJlIGlzIGV4YWN0bHkgb25lIGV4cG9ydCBuYW1lXG5mdW5jdGlvbiByZW5kZXJTeXN0ZW1FeHBvcnRFeHByZXNzaW9uKGV4cG9ydGVkVmFyaWFibGUsIGV4cHJlc3Npb25TdGFydCwgZXhwcmVzc2lvbkVuZCwgY29kZSwgeyBleHBvcnROYW1lc0J5VmFyaWFibGUsIHNuaXBwZXRzOiB7IF8gfSB9KSB7XG4gICAgY29kZS5wcmVwZW5kUmlnaHQoZXhwcmVzc2lvblN0YXJ0LCBgZXhwb3J0cygke0pTT04uc3RyaW5naWZ5KGV4cG9ydE5hbWVzQnlWYXJpYWJsZS5nZXQoZXhwb3J0ZWRWYXJpYWJsZSlbMF0pfSwke199YCk7XG4gICAgY29kZS5hcHBlbmRMZWZ0KGV4cHJlc3Npb25FbmQsICcpJyk7XG59XG5mdW5jdGlvbiByZW5kZXJTeXN0ZW1FeHBvcnRGdW5jdGlvbihleHBvcnRlZFZhcmlhYmxlcywgZXhwcmVzc2lvblN0YXJ0LCBleHByZXNzaW9uRW5kLCBuZWVkc1BhcmVucywgY29kZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgXywgZ2V0RGlyZWN0UmV0dXJuSWlmZUxlZnQgfSA9IG9wdGlvbnMuc25pcHBldHM7XG4gICAgY29kZS5wcmVwZW5kUmlnaHQoZXhwcmVzc2lvblN0YXJ0LCBnZXREaXJlY3RSZXR1cm5JaWZlTGVmdChbJ3YnXSwgYCR7Z2V0U3lzdGVtRXhwb3J0U3RhdGVtZW50KGV4cG9ydGVkVmFyaWFibGVzLCBvcHRpb25zKX0sJHtffXZgLCB7IG5lZWRzQXJyb3dSZXR1cm5QYXJlbnM6IHRydWUsIG5lZWRzV3JhcHBlZEZ1bmN0aW9uOiBuZWVkc1BhcmVucyB9KSk7XG4gICAgY29kZS5hcHBlbmRMZWZ0KGV4cHJlc3Npb25FbmQsICcpJyk7XG59XG5mdW5jdGlvbiByZW5kZXJTeXN0ZW1FeHBvcnRTZXF1ZW5jZUFmdGVyRXhwcmVzc2lvbihleHBvcnRlZFZhcmlhYmxlLCBleHByZXNzaW9uU3RhcnQsIGV4cHJlc3Npb25FbmQsIG5lZWRzUGFyZW5zLCBjb2RlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBfLCBnZXRQcm9wZXJ0eUFjY2VzcyB9ID0gb3B0aW9ucy5zbmlwcGV0cztcbiAgICBjb2RlLmFwcGVuZExlZnQoZXhwcmVzc2lvbkVuZCwgYCwke199JHtnZXRTeXN0ZW1FeHBvcnRTdGF0ZW1lbnQoW2V4cG9ydGVkVmFyaWFibGVdLCBvcHRpb25zKX0sJHtffSR7ZXhwb3J0ZWRWYXJpYWJsZS5nZXROYW1lKGdldFByb3BlcnR5QWNjZXNzKX1gKTtcbiAgICBpZiAobmVlZHNQYXJlbnMpIHtcbiAgICAgICAgY29kZS5wcmVwZW5kUmlnaHQoZXhwcmVzc2lvblN0YXJ0LCAnKCcpO1xuICAgICAgICBjb2RlLmFwcGVuZExlZnQoZXhwcmVzc2lvbkVuZCwgJyknKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJTeXN0ZW1FeHBvcnRTZXF1ZW5jZUJlZm9yZUV4cHJlc3Npb24oZXhwb3J0ZWRWYXJpYWJsZSwgZXhwcmVzc2lvblN0YXJ0LCBleHByZXNzaW9uRW5kLCBuZWVkc1BhcmVucywgY29kZSwgb3B0aW9ucywgbW9kaWZpZXIpIHtcbiAgICBjb25zdCB7IF8gfSA9IG9wdGlvbnMuc25pcHBldHM7XG4gICAgY29kZS5wcmVwZW5kUmlnaHQoZXhwcmVzc2lvblN0YXJ0LCBgJHtnZXRTeXN0ZW1FeHBvcnRTdGF0ZW1lbnQoW2V4cG9ydGVkVmFyaWFibGVdLCBvcHRpb25zLCBtb2RpZmllcil9LCR7X31gKTtcbiAgICBpZiAobmVlZHNQYXJlbnMpIHtcbiAgICAgICAgY29kZS5wcmVwZW5kUmlnaHQoZXhwcmVzc2lvblN0YXJ0LCAnKCcpO1xuICAgICAgICBjb2RlLmFwcGVuZExlZnQoZXhwcmVzc2lvbkVuZCwgJyknKTtcbiAgICB9XG59XG5cbi8qKiBAdHlwZWRlZiB7IGltcG9ydCgnZXN0cmVlJykuTm9kZX0gTm9kZSAqL1xuLyoqIEB0eXBlZGVmIHtOb2RlIHwge1xuICogICB0eXBlOiAnUHJvcGVydHlEZWZpbml0aW9uJztcbiAqICAgY29tcHV0ZWQ6IGJvb2xlYW47XG4gKiAgIHZhbHVlOiBOb2RlXG4gKiB9fSBOb2RlV2l0aFByb3BlcnR5RGVmaW5pdGlvbiAqL1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge05vZGVXaXRoUHJvcGVydHlEZWZpbml0aW9ufSBub2RlXG4gKiBAcGFyYW0ge05vZGVXaXRoUHJvcGVydHlEZWZpbml0aW9ufSBwYXJlbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc19yZWZlcmVuY2UgKG5vZGUsIHBhcmVudCkge1xuXHRpZiAobm9kZS50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicpIHtcblx0XHRyZXR1cm4gIW5vZGUuY29tcHV0ZWQgJiYgaXNfcmVmZXJlbmNlKG5vZGUub2JqZWN0LCBub2RlKTtcblx0fVxuXG5cdGlmIChub2RlLnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuXHRcdGlmICghcGFyZW50KSByZXR1cm4gdHJ1ZTtcblxuXHRcdHN3aXRjaCAocGFyZW50LnR5cGUpIHtcblx0XHRcdC8vIGRpc3JlZ2FyZCBgYmFyYCBpbiBgZm9vLmJhcmBcblx0XHRcdGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOiByZXR1cm4gcGFyZW50LmNvbXB1dGVkIHx8IG5vZGUgPT09IHBhcmVudC5vYmplY3Q7XG5cblx0XHRcdC8vIGRpc3JlZ2FyZCB0aGUgYGZvb2AgaW4gYGNsYXNzIHtmb28oKXt9fWAgYnV0IGtlZXAgaXQgaW4gYGNsYXNzIHtbZm9vXSgpe319YFxuXHRcdFx0Y2FzZSAnTWV0aG9kRGVmaW5pdGlvbic6IHJldHVybiBwYXJlbnQuY29tcHV0ZWQ7XG5cblx0XHRcdC8vIGRpc3JlZ2FyZCB0aGUgYGZvb2AgaW4gYGNsYXNzIHtmb289YmFyfWAgYnV0IGtlZXAgaXQgaW4gYGNsYXNzIHtbZm9vXT1iYXJ9YCBhbmQgYGNsYXNzIHtiYXI9Zm9vfWBcblx0XHRcdGNhc2UgJ1Byb3BlcnR5RGVmaW5pdGlvbic6IHJldHVybiBwYXJlbnQuY29tcHV0ZWQgfHwgbm9kZSA9PT0gcGFyZW50LnZhbHVlO1xuXG5cdFx0XHQvLyBkaXNyZWdhcmQgdGhlIGBiYXJgIGluIGB7IGJhcjogZm9vIH1gLCBidXQga2VlcCBpdCBpbiBgeyBbYmFyXTogZm9vIH1gXG5cdFx0XHRjYXNlICdQcm9wZXJ0eSc6IHJldHVybiBwYXJlbnQuY29tcHV0ZWQgfHwgbm9kZSA9PT0gcGFyZW50LnZhbHVlO1xuXG5cdFx0XHQvLyBkaXNyZWdhcmQgdGhlIGBiYXJgIGluIGBleHBvcnQgeyBmb28gYXMgYmFyIH1gIG9yXG5cdFx0XHQvLyB0aGUgZm9vIGluIGBpbXBvcnQgeyBmb28gYXMgYmFyIH1gXG5cdFx0XHRjYXNlICdFeHBvcnRTcGVjaWZpZXInOlxuXHRcdFx0Y2FzZSAnSW1wb3J0U3BlY2lmaWVyJzogcmV0dXJuIG5vZGUgPT09IHBhcmVudC5sb2NhbDtcblxuXHRcdFx0Ly8gZGlzcmVnYXJkIHRoZSBgZm9vYCBpbiBgZm9vOiB3aGlsZSAoLi4uKSB7IC4uLiBicmVhayBmb287IC4uLiBjb250aW51ZSBmb287fWBcblx0XHRcdGNhc2UgJ0xhYmVsZWRTdGF0ZW1lbnQnOlxuXHRcdFx0Y2FzZSAnQnJlYWtTdGF0ZW1lbnQnOlxuXHRcdFx0Y2FzZSAnQ29udGludWVTdGF0ZW1lbnQnOiByZXR1cm4gZmFsc2U7XG5cdFx0XHRkZWZhdWx0OiByZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IFB1cmVGdW5jdGlvbktleSA9IFN5bWJvbCgnUHVyZUZ1bmN0aW9uJyk7XG5jb25zdCBnZXRQdXJlRnVuY3Rpb25zID0gKHsgdHJlZXNoYWtlIH0pID0+IHtcbiAgICBjb25zdCBwdXJlRnVuY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGNvbnN0IGZ1bmN0aW9uTmFtZSBvZiB0cmVlc2hha2UgPyB0cmVlc2hha2UubWFudWFsUHVyZUZ1bmN0aW9ucyA6IFtdKSB7XG4gICAgICAgIGxldCBjdXJyZW50RnVuY3Rpb25zID0gcHVyZUZ1bmN0aW9ucztcbiAgICAgICAgZm9yIChjb25zdCBwYXRoU2VnbWVudCBvZiBmdW5jdGlvbk5hbWUuc3BsaXQoJy4nKSkge1xuICAgICAgICAgICAgY3VycmVudEZ1bmN0aW9ucyA9IGN1cnJlbnRGdW5jdGlvbnNbcGF0aFNlZ21lbnRdIHx8PSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRGdW5jdGlvbnNbUHVyZUZ1bmN0aW9uS2V5XSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBwdXJlRnVuY3Rpb25zO1xufTtcblxuZnVuY3Rpb24gZ2V0T3JDcmVhdGUobWFwLCBrZXksIGluaXQpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gaW5pdCgpO1xuICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0TmV3U2V0KCkge1xuICAgIHJldHVybiBuZXcgU2V0KCk7XG59XG5mdW5jdGlvbiBnZXROZXdBcnJheSgpIHtcbiAgICByZXR1cm4gW107XG59XG5cbmNvbnN0IFVua25vd25LZXkgPSBTeW1ib2woJ1Vua25vd24gS2V5Jyk7XG5jb25zdCBVbmtub3duTm9uQWNjZXNzb3JLZXkgPSBTeW1ib2woJ1Vua25vd24gTm9uLUFjY2Vzc29yIEtleScpO1xuY29uc3QgVW5rbm93bkludGVnZXIgPSBTeW1ib2woJ1Vua25vd24gSW50ZWdlcicpO1xuY29uc3QgU3ltYm9sVG9TdHJpbmdUYWcgPSBTeW1ib2woJ1N5bWJvbC50b1N0cmluZ1RhZycpO1xuY29uc3QgRU1QVFlfUEFUSCA9IFtdO1xuY29uc3QgVU5LTk9XTl9QQVRIID0gW1Vua25vd25LZXldO1xuLy8gRm9yIGRlb3B0aW1pemF0aW9ucywgdGhpcyBtZWFucyB3ZSBhcmUgbW9kaWZ5aW5nIGFuIHVua25vd24gcHJvcGVydHkgYnV0IGRpZFxuLy8gbm90IGxvc2UgdHJhY2sgb2YgdGhlIG9iamVjdCBvciBhcmUgY3JlYXRpbmcgYSBzZXR0ZXIvZ2V0dGVyO1xuLy8gRm9yIGFzc2lnbm1lbnQgZWZmZWN0cyBpdCBtZWFucyB3ZSBkbyBub3QgY2hlY2sgZm9yIHNldHRlci9nZXR0ZXIgZWZmZWN0c1xuLy8gYnV0IG9ubHkgaWYgc29tZXRoaW5nIGlzIG11dGF0ZWQgdGhhdCBpcyBpbmNsdWRlZCwgd2hpY2ggaXMgcmVsZXZhbnQgZm9yXG4vLyBPYmplY3QuZGVmaW5lUHJvcGVydHlcbmNvbnN0IFVOS05PV05fTk9OX0FDQ0VTU09SX1BBVEggPSBbVW5rbm93bk5vbkFjY2Vzc29yS2V5XTtcbmNvbnN0IFVOS05PV05fSU5URUdFUl9QQVRIID0gW1Vua25vd25JbnRlZ2VyXTtcbmNvbnN0IEVudGl0aWVzS2V5ID0gU3ltYm9sKCdFbnRpdGllcycpO1xuY2xhc3MgUGF0aFRyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVudGl0eVBhdGhzID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgICBbRW50aXRpZXNLZXldOiB7IHZhbHVlOiBuZXcgU2V0KCkgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQocGF0aCwgZW50aXR5KSB7XG4gICAgICAgIGNvbnN0IHRyYWNrZWRFbnRpdGllcyA9IHRoaXMuZ2V0RW50aXRpZXMocGF0aCk7XG4gICAgICAgIGlmICh0cmFja2VkRW50aXRpZXMuaGFzKGVudGl0eSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdHJhY2tlZEVudGl0aWVzLmFkZChlbnRpdHkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHdpdGhUcmFja2VkRW50aXR5QXRQYXRoKHBhdGgsIGVudGl0eSwgb25VbnRyYWNrZWQsIHJldHVybklmVHJhY2tlZCkge1xuICAgICAgICBjb25zdCB0cmFja2VkRW50aXRpZXMgPSB0aGlzLmdldEVudGl0aWVzKHBhdGgpO1xuICAgICAgICBpZiAodHJhY2tlZEVudGl0aWVzLmhhcyhlbnRpdHkpKVxuICAgICAgICAgICAgcmV0dXJuIHJldHVybklmVHJhY2tlZDtcbiAgICAgICAgdHJhY2tlZEVudGl0aWVzLmFkZChlbnRpdHkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBvblVudHJhY2tlZCgpO1xuICAgICAgICB0cmFja2VkRW50aXRpZXMuZGVsZXRlKGVudGl0eSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldEVudGl0aWVzKHBhdGgpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRQYXRocyA9IHRoaXMuZW50aXR5UGF0aHM7XG4gICAgICAgIGZvciAoY29uc3QgcGF0aFNlZ21lbnQgb2YgcGF0aCkge1xuICAgICAgICAgICAgY3VycmVudFBhdGhzID0gY3VycmVudFBhdGhzW3BhdGhTZWdtZW50XSA9XG4gICAgICAgICAgICAgICAgY3VycmVudFBhdGhzW3BhdGhTZWdtZW50XSB8fFxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlKG51bGwsIHsgW0VudGl0aWVzS2V5XTogeyB2YWx1ZTogbmV3IFNldCgpIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXRoc1tFbnRpdGllc0tleV07XG4gICAgfVxufVxuY29uc3QgU0hBUkVEX1JFQ1VSU0lPTl9UUkFDS0VSID0gbmV3IFBhdGhUcmFja2VyKCk7XG5jbGFzcyBEaXNjcmltaW5hdGVkUGF0aFRyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVudGl0eVBhdGhzID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgICBbRW50aXRpZXNLZXldOiB7IHZhbHVlOiBuZXcgTWFwKCkgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQocGF0aCwgZGlzY3JpbWluYXRvciwgZW50aXR5KSB7XG4gICAgICAgIGxldCBjdXJyZW50UGF0aHMgPSB0aGlzLmVudGl0eVBhdGhzO1xuICAgICAgICBmb3IgKGNvbnN0IHBhdGhTZWdtZW50IG9mIHBhdGgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXRocyA9IGN1cnJlbnRQYXRoc1twYXRoU2VnbWVudF0gPVxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXRoc1twYXRoU2VnbWVudF0gfHxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsLCB7IFtFbnRpdGllc0tleV06IHsgdmFsdWU6IG5ldyBNYXAoKSB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYWNrZWRFbnRpdGllcyA9IGdldE9yQ3JlYXRlKGN1cnJlbnRQYXRoc1tFbnRpdGllc0tleV0sIGRpc2NyaW1pbmF0b3IsIChnZXROZXdTZXQpKTtcbiAgICAgICAgaWYgKHRyYWNrZWRFbnRpdGllcy5oYXMoZW50aXR5KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0cmFja2VkRW50aXRpZXMuYWRkKGVudGl0eSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRmxhZ1NldChmbGFncywgZmxhZykge1xuICAgIHJldHVybiAoZmxhZ3MgJiBmbGFnKSAhPT0gMDtcbn1cbmZ1bmN0aW9uIHNldEZsYWcoZmxhZ3MsIGZsYWcsIHZhbHVlKSB7XG4gICAgcmV0dXJuIChmbGFncyAmIH5mbGFnKSB8ICgtdmFsdWUgJiBmbGFnKTtcbn1cblxuY29uc3QgVW5rbm93blZhbHVlID0gU3ltYm9sKCdVbmtub3duIFZhbHVlJyk7XG5jb25zdCBVbmtub3duVHJ1dGh5VmFsdWUgPSBTeW1ib2woJ1Vua25vd24gVHJ1dGh5IFZhbHVlJyk7XG5jbGFzcyBFeHByZXNzaW9uRW50aXR5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5mbGFncyA9IDA7XG4gICAgfVxuICAgIGdldCBpbmNsdWRlZCgpIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhZ1NldCh0aGlzLmZsYWdzLCAxIC8qIEZsYWcuaW5jbHVkZWQgKi8pO1xuICAgIH1cbiAgICBzZXQgaW5jbHVkZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5mbGFncyA9IHNldEZsYWcodGhpcy5mbGFncywgMSAvKiBGbGFnLmluY2x1ZGVkICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBfcGF0aCwgX3JlY3Vyc2lvblRyYWNrZXIpIHtcbiAgICAgICAgZGVvcHRpbWl6ZUludGVyYWN0aW9uKGludGVyYWN0aW9uKTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZVBhdGgoX3BhdGgpIHsgfVxuICAgIC8qKlxuICAgICAqIElmIHBvc3NpYmxlIGl0IHJldHVybnMgYSBzdHJpbmdpZnlhYmxlIGxpdGVyYWwgdmFsdWUgZm9yIHRoaXMgbm9kZSB0aGF0XG4gICAgICogY2FuIGJlIHVzZWQgZm9yIGlubGluaW5nIG9yIGNvbXBhcmluZyB2YWx1ZXMuIE90aGVyd2lzZSwgaXQgc2hvdWxkIHJldHVyblxuICAgICAqIFVua25vd25WYWx1ZS5cbiAgICAgKi9cbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGgoX3BhdGgsIF9yZWN1cnNpb25UcmFja2VyLCBfb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBVbmtub3duVmFsdWU7XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKF9wYXRoLCBfaW50ZXJhY3Rpb24sIF9yZWN1cnNpb25UcmFja2VyLCBfb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBVTktOT1dOX1JFVFVSTl9FWFBSRVNTSU9OO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChfcGF0aCwgX2ludGVyYWN0aW9uLCBfY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5jbHVkZShfY29udGV4dCwgX2luY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5LCBfb3B0aW9ucykge1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaW5jbHVkZUNhbGxBcmd1bWVudHMoY29udGV4dCwgcGFyYW1ldGVycykge1xuICAgICAgICBmb3IgKGNvbnN0IGFyZ3VtZW50IG9mIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGFyZ3VtZW50LmluY2x1ZGUoY29udGV4dCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNob3VsZEJlSW5jbHVkZWQoX2NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuY29uc3QgVU5LTk9XTl9FWFBSRVNTSU9OID0gbmV3IChjbGFzcyBVbmtub3duRXhwcmVzc2lvbiBleHRlbmRzIEV4cHJlc3Npb25FbnRpdHkge1xufSkoKTtcbmNvbnN0IFVOS05PV05fUkVUVVJOX0VYUFJFU1NJT04gPSBbXG4gICAgVU5LTk9XTl9FWFBSRVNTSU9OLFxuICAgIGZhbHNlXG5dO1xuY29uc3QgZGVvcHRpbWl6ZUludGVyYWN0aW9uID0gKGludGVyYWN0aW9uKSA9PiB7XG4gICAgZm9yIChjb25zdCBhcmd1bWVudCBvZiBpbnRlcmFjdGlvbi5hcmdzKSB7XG4gICAgICAgIGFyZ3VtZW50Py5kZW9wdGltaXplUGF0aChVTktOT1dOX1BBVEgpO1xuICAgIH1cbn07XG5cbmNvbnN0IElOVEVSQUNUSU9OX0FDQ0VTU0VEID0gMDtcbmNvbnN0IElOVEVSQUNUSU9OX0FTU0lHTkVEID0gMTtcbmNvbnN0IElOVEVSQUNUSU9OX0NBTExFRCA9IDI7XG5jb25zdCBOT0RFX0lOVEVSQUNUSU9OX1VOS05PV05fQUNDRVNTID0ge1xuICAgIGFyZ3M6IFtudWxsXSxcbiAgICB0eXBlOiBJTlRFUkFDVElPTl9BQ0NFU1NFRFxufTtcbmNvbnN0IE5PREVfSU5URVJBQ1RJT05fVU5LTk9XTl9BU1NJR05NRU5UID0ge1xuICAgIGFyZ3M6IFtudWxsLCBVTktOT1dOX0VYUFJFU1NJT05dLFxuICAgIHR5cGU6IElOVEVSQUNUSU9OX0FTU0lHTkVEXG59O1xuLy8gV2hpbGUgdGhpcyBpcyB0ZWNobmljYWxseSBhIGNhbGwgd2l0aG91dCBhcmd1bWVudHMsIHdlIGNhbiBjb21wYXJlIGFnYWluc3Rcbi8vIHRoaXMgcmVmZXJlbmNlIGluIHBsYWNlcyB3aGVyZSBwcmVjaXNlIHZhbHVlcyBvciB0aGlzIGFyZ3VtZW50IHdvdWxkIG1ha2UgYVxuLy8gZGlmZmVyZW5jZVxuY29uc3QgTk9ERV9JTlRFUkFDVElPTl9VTktOT1dOX0NBTEwgPSB7XG4gICAgYXJnczogW251bGxdLFxuICAgIHR5cGU6IElOVEVSQUNUSU9OX0NBTExFRCxcbiAgICB3aXRoTmV3OiBmYWxzZVxufTtcblxuY2xhc3MgVmFyaWFibGUgZXh0ZW5kcyBFeHByZXNzaW9uRW50aXR5IHtcbiAgICBtYXJrUmVhc3NpZ25lZCgpIHtcbiAgICAgICAgdGhpcy5pc1JlYXNzaWduZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYWx3YXlzUmVuZGVyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mb3JiaWRkZW5OYW1lcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2xvYmFsTmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5pdFJlYWNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0lkID0gZmFsc2U7XG4gICAgICAgIHRoaXMua2luZCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVuZGVyQmFzZU5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlck5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmlzUmVhc3NpZ25lZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9ubHlGdW5jdGlvbkNhbGxVc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZHMgaWRlbnRpZmllcnMgdGhhdCByZWZlcmVuY2UgdGhpcyB2YXJpYWJsZSB0byB0aGlzIHZhcmlhYmxlLlxuICAgICAqIE5lY2Vzc2FyeSB0byBiZSBhYmxlIHRvIGNoYW5nZSB2YXJpYWJsZSBuYW1lcy5cbiAgICAgKi9cbiAgICBhZGRSZWZlcmVuY2UoX2lkZW50aWZpZXIpIHsgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBpZGVudGlmaWVyIHZhcmlhYmxlIGlzIG9ubHkgdXNlZCBhcyBmdW5jdGlvbiBjYWxsXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFyaWFibGUgaXMgb25seSB1c2VkIGFzIGZ1bmN0aW9uIGNhbGxcbiAgICAgKi9cbiAgICBnZXRPbmx5RnVuY3Rpb25DYWxsVXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25seUZ1bmN0aW9uQ2FsbFVzZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbGxlY3QgdGhlIHBsYWNlcyB3aGVyZSB0aGUgaWRlbnRpZmllciB2YXJpYWJsZSBpcyB1c2VkXG4gICAgICogQHBhcmFtIHVzZWRQbGFjZSBXaGVyZSB0aGUgdmFyaWFibGUgaXMgdXNlZFxuICAgICAqL1xuICAgIGFkZFVzZWRQbGFjZSh1c2VkUGxhY2UpIHtcbiAgICAgICAgY29uc3QgaXNGdW5jdGlvbkNhbGwgPSB1c2VkUGxhY2UucGFyZW50LnR5cGUgPT09IENhbGxFeHByZXNzaW9uJDEgJiZcbiAgICAgICAgICAgIHVzZWRQbGFjZS5wYXJlbnQuY2FsbGVlID09PSB1c2VkUGxhY2U7XG4gICAgICAgIGlmICghaXNGdW5jdGlvbkNhbGwgJiYgdXNlZFBsYWNlLnBhcmVudC50eXBlICE9PSBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24kMSkge1xuICAgICAgICAgICAgdGhpcy5vbmx5RnVuY3Rpb25DYWxsVXNlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXZlbnQgdGhpcyB2YXJpYWJsZSBmcm9tIGJlaW5nIHJlbmFtZWQgdG8gdGhpcyBuYW1lIHRvIGF2b2lkIG5hbWVcbiAgICAgKiBjb2xsaXNpb25zXG4gICAgICovXG4gICAgZm9yYmlkTmFtZShuYW1lKSB7XG4gICAgICAgICh0aGlzLmZvcmJpZGRlbk5hbWVzIHx8PSBuZXcgU2V0KCkpLmFkZChuYW1lKTtcbiAgICB9XG4gICAgZ2V0QmFzZVZhcmlhYmxlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnJlbmRlcmVkTGlrZUhvaXN0ZWQ/LmdldEJhc2VWYXJpYWJsZU5hbWUoKSB8fFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJCYXNlTmFtZSB8fFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJOYW1lIHx8XG4gICAgICAgICAgICB0aGlzLm5hbWUpO1xuICAgIH1cbiAgICBnZXROYW1lKGdldFByb3BlcnR5QWNjZXNzLCB1c2VPcmlnaW5hbE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2xvYmFsTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlT3JpZ2luYWxOYW1lPy4odGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRMaWtlSG9pc3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZWRMaWtlSG9pc3RlZC5nZXROYW1lKGdldFByb3BlcnR5QWNjZXNzLCB1c2VPcmlnaW5hbE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnJlbmRlck5hbWUgfHwgdGhpcy5uYW1lO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJCYXNlTmFtZSA/IGAke3RoaXMucmVuZGVyQmFzZU5hbWV9JHtnZXRQcm9wZXJ0eUFjY2VzcyhuYW1lKX1gIDogbmFtZTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgeyB0eXBlIH0sIF9jb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0eXBlICE9PSBJTlRFUkFDVElPTl9BQ0NFU1NFRCB8fCBwYXRoLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoaXMgdmFyaWFibGUgYXMgYmVpbmcgcGFydCBvZiB0aGUgYnVuZGxlLCB3aGljaCBpcyB1c3VhbGx5IHRoZSBjYXNlXG4gICAgICogd2hlbiBvbmUgb2YgaXRzIGlkZW50aWZpZXJzIGJlY29tZXMgcGFydCBvZiB0aGUgYnVuZGxlLiBSZXR1cm5zIHRydWUgaWYgaXRcbiAgICAgKiBoYXMgbm90IGJlZW4gaW5jbHVkZWQgcHJldmlvdXNseS4gT25jZSBhIHZhcmlhYmxlIGlzIGluY2x1ZGVkLCBpdCBzaG91bGRcbiAgICAgKiB0YWtlIGNhcmUgYWxsIGl0cyBkZWNsYXJhdGlvbnMgYXJlIGluY2x1ZGVkLlxuICAgICAqL1xuICAgIGluY2x1ZGUoKSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlbmRlcmVkTGlrZUhvaXN0ZWQ/LmluY2x1ZGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlua3MgdGhlIHJlbmRlcmVkIG5hbWUgb2YgdGhpcyB2YXJpYWJsZSB0byBhbm90aGVyIHZhcmlhYmxlIGFuZCBpbmNsdWRlc1xuICAgICAqIHRoaXMgdmFyaWFibGUgaWYgdGhlIG90aGVyIHZhcmlhYmxlIGlzIGluY2x1ZGVkLlxuICAgICAqL1xuICAgIHJlbmRlckxpa2VIb2lzdGVkKHZhcmlhYmxlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZWRMaWtlSG9pc3RlZCA9IHZhcmlhYmxlO1xuICAgIH1cbiAgICBtYXJrQ2FsbGVkRnJvbVRyeVN0YXRlbWVudCgpIHsgfVxuICAgIHNldFJlbmRlck5hbWVzKGJhc2VOYW1lLCBuYW1lKSB7XG4gICAgICAgIHRoaXMucmVuZGVyQmFzZU5hbWUgPSBiYXNlTmFtZTtcbiAgICAgICAgdGhpcy5yZW5kZXJOYW1lID0gbmFtZTtcbiAgICB9XG59XG5cbmNsYXNzIEV4dGVybmFsVmFyaWFibGUgZXh0ZW5kcyBWYXJpYWJsZSB7XG4gICAgY29uc3RydWN0b3IobW9kdWxlLCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKG5hbWUpO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2R1bGU7XG4gICAgICAgIHRoaXMuaXNOYW1lc3BhY2UgPSBuYW1lID09PSAnKic7XG4gICAgfVxuICAgIGFkZFJlZmVyZW5jZShpZGVudGlmaWVyKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLm5hbWUgPT09ICdkZWZhdWx0JyB8fCB0aGlzLm5hbWUgPT09ICcqJykge1xuICAgICAgICAgICAgdGhpcy5tb2R1bGUuc3VnZ2VzdE5hbWUoaWRlbnRpZmllci5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCB7IHR5cGUgfSkge1xuICAgICAgICByZXR1cm4gdHlwZSAhPT0gSU5URVJBQ1RJT05fQUNDRVNTRUQgfHwgcGF0aC5sZW5ndGggPiAodGhpcy5pc05hbWVzcGFjZSA/IDEgOiAwKTtcbiAgICB9XG4gICAgaW5jbHVkZSgpIHtcbiAgICAgICAgc3VwZXIuaW5jbHVkZSgpO1xuICAgICAgICB0aGlzLm1vZHVsZS51c2VkID0gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNhY2hlT2JqZWN0R2V0dGVycyhvYmplY3QsIGdldHRlclByb3BlcnRpZXMpIHtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGdldHRlclByb3BlcnRpZXMpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlHZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpLmdldDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3BlcnR5R2V0dGVyLmNhbGwob2JqZWN0KTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHJlcGxhY2VzIHRoZSBnZXR0ZXIgd2l0aCBhIGZpeGVkIHZhbHVlIGZvciBzdWJzZXF1ZW50IGNhbGxzXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IFJFU0VSVkVEX05BTUVTID0gbmV3IFNldChbXG4gICAgJ2F3YWl0JyxcbiAgICAnYnJlYWsnLFxuICAgICdjYXNlJyxcbiAgICAnY2F0Y2gnLFxuICAgICdjbGFzcycsXG4gICAgJ2NvbnN0JyxcbiAgICAnY29udGludWUnLFxuICAgICdkZWJ1Z2dlcicsXG4gICAgJ2RlZmF1bHQnLFxuICAgICdkZWxldGUnLFxuICAgICdkbycsXG4gICAgJ2Vsc2UnLFxuICAgICdlbnVtJyxcbiAgICAnZXZhbCcsXG4gICAgJ2V4cG9ydCcsXG4gICAgJ2V4dGVuZHMnLFxuICAgICdmYWxzZScsXG4gICAgJ2ZpbmFsbHknLFxuICAgICdmb3InLFxuICAgICdmdW5jdGlvbicsXG4gICAgJ2lmJyxcbiAgICAnaW1wbGVtZW50cycsXG4gICAgJ2ltcG9ydCcsXG4gICAgJ2luJyxcbiAgICAnaW5zdGFuY2VvZicsXG4gICAgJ2ludGVyZmFjZScsXG4gICAgJ2xldCcsXG4gICAgJ05hTicsXG4gICAgJ25ldycsXG4gICAgJ251bGwnLFxuICAgICdwYWNrYWdlJyxcbiAgICAncHJpdmF0ZScsXG4gICAgJ3Byb3RlY3RlZCcsXG4gICAgJ3B1YmxpYycsXG4gICAgJ3JldHVybicsXG4gICAgJ3N0YXRpYycsXG4gICAgJ3N1cGVyJyxcbiAgICAnc3dpdGNoJyxcbiAgICAndGhpcycsXG4gICAgJ3Rocm93JyxcbiAgICAndHJ1ZScsXG4gICAgJ3RyeScsXG4gICAgJ3R5cGVvZicsXG4gICAgJ3VuZGVmaW5lZCcsXG4gICAgJ3ZhcicsXG4gICAgJ3ZvaWQnLFxuICAgICd3aGlsZScsXG4gICAgJ3dpdGgnLFxuICAgICd5aWVsZCdcbl0pO1xuXG5jb25zdCBpbGxlZ2FsQ2hhcmFjdGVycyA9IC9bXlxcdyRdL2c7XG5jb25zdCBzdGFydHNXaXRoRGlnaXQgPSAodmFsdWUpID0+IC9cXGQvLnRlc3QodmFsdWVbMF0pO1xuY29uc3QgbmVlZHNFc2NhcGUgPSAodmFsdWUpID0+IHN0YXJ0c1dpdGhEaWdpdCh2YWx1ZSkgfHwgUkVTRVJWRURfTkFNRVMuaGFzKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2FyZ3VtZW50cyc7XG5mdW5jdGlvbiBpc0xlZ2FsKHZhbHVlKSB7XG4gICAgaWYgKG5lZWRzRXNjYXBlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAhaWxsZWdhbENoYXJhY3RlcnMudGVzdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBtYWtlTGVnYWwodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHZhbHVlXG4gICAgICAgIC5yZXBsYWNlKC8tKFxcdykvZywgKF8sIGxldHRlcikgPT4gbGV0dGVyLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgIC5yZXBsYWNlKGlsbGVnYWxDaGFyYWN0ZXJzLCAnXycpO1xuICAgIGlmIChuZWVkc0VzY2FwZSh2YWx1ZSkpXG4gICAgICAgIHZhbHVlID0gYF8ke3ZhbHVlfWA7XG4gICAgcmV0dXJuIHZhbHVlIHx8ICdfJztcbn1cbmNvbnN0IFZBTElEX0lERU5USUZJRVJfUkVHRVhQID0gL15bJF9cXHB7SURfU3RhcnR9XVskXFx1MjAwQ1xcdTIwMERcXHB7SURfQ29udGludWV9XSokL3U7XG5jb25zdCBOVU1CRVJfUkVHRVhQID0gL14oPzowfFsxLTldXFxkKikkLztcbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdEtleUlmTmVlZGVkKGtleSkge1xuICAgIGlmIChWQUxJRF9JREVOVElGSUVSX1JFR0VYUC50ZXN0KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGtleSA9PT0gJ19fcHJvdG9fXycgPyAnW1wiX19wcm90b19fXCJdJyA6IGtleTtcbiAgICB9XG4gICAgaWYgKE5VTUJFUl9SRUdFWFAudGVzdChrZXkpICYmICtrZXkgPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGtleSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlJZGVudGlmaWVySWZOZWVkZWQoa2V5KSB7XG4gICAgaWYgKFZBTElEX0lERU5USUZJRVJfUkVHRVhQLnRlc3Qoa2V5KSkge1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbn1cblxuY2xhc3MgRXh0ZXJuYWxNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlkLCBtb2R1bGVTaWRlRWZmZWN0cywgbWV0YSwgcmVub3JtYWxpemVSZW5kZXJQYXRoLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5yZW5vcm1hbGl6ZVJlbmRlclBhdGggPSByZW5vcm1hbGl6ZVJlbmRlclBhdGg7XG4gICAgICAgIHRoaXMuZHluYW1pY0ltcG9ydGVycyA9IFtdO1xuICAgICAgICB0aGlzLmV4ZWNJbmRleCA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLmV4cG9ydGVkVmFyaWFibGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmltcG9ydGVycyA9IFtdO1xuICAgICAgICB0aGlzLnJlZXhwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm1vc3RDb21tb25TdWdnZXN0aW9uID0gMDtcbiAgICAgICAgdGhpcy5uYW1lU3VnZ2VzdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc3VnZ2VzdGVkVmFyaWFibGVOYW1lID0gbWFrZUxlZ2FsKGlkLnNwbGl0KC9bL1xcXFxdLykucG9wKCkpO1xuICAgICAgICBjb25zdCB7IGltcG9ydGVycywgZHluYW1pY0ltcG9ydGVycyB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5pbmZvID0ge1xuICAgICAgICAgICAgYXN0OiBudWxsLFxuICAgICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGNvZGU6IG51bGwsXG4gICAgICAgICAgICBkeW5hbWljYWxseUltcG9ydGVkSWRSZXNvbHV0aW9uczogRU1QVFlfQVJSQVksXG4gICAgICAgICAgICBkeW5hbWljYWxseUltcG9ydGVkSWRzOiBFTVBUWV9BUlJBWSxcbiAgICAgICAgICAgIGdldCBkeW5hbWljSW1wb3J0ZXJzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkeW5hbWljSW1wb3J0ZXJzLnNvcnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleHBvcnRlZEJpbmRpbmdzOiBudWxsLFxuICAgICAgICAgICAgZXhwb3J0czogbnVsbCxcbiAgICAgICAgICAgIGhhc0RlZmF1bHRFeHBvcnQ6IG51bGwsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGltcGxpY2l0bHlMb2FkZWRBZnRlck9uZU9mOiBFTVBUWV9BUlJBWSxcbiAgICAgICAgICAgIGltcGxpY2l0bHlMb2FkZWRCZWZvcmU6IEVNUFRZX0FSUkFZLFxuICAgICAgICAgICAgaW1wb3J0ZWRJZFJlc29sdXRpb25zOiBFTVBUWV9BUlJBWSxcbiAgICAgICAgICAgIGltcG9ydGVkSWRzOiBFTVBUWV9BUlJBWSxcbiAgICAgICAgICAgIGdldCBpbXBvcnRlcnMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydGVycy5zb3J0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNFbnRyeTogZmFsc2UsXG4gICAgICAgICAgICBpc0V4dGVybmFsOiB0cnVlLFxuICAgICAgICAgICAgaXNJbmNsdWRlZDogbnVsbCxcbiAgICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgICBtb2R1bGVTaWRlRWZmZWN0cyxcbiAgICAgICAgICAgIHN5bnRoZXRpY05hbWVkRXhwb3J0czogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2FjaGVJbmZvR2V0dGVycygpIHtcbiAgICAgICAgY2FjaGVPYmplY3RHZXR0ZXJzKHRoaXMuaW5mbywgWydkeW5hbWljSW1wb3J0ZXJzJywgJ2ltcG9ydGVycyddKTtcbiAgICB9XG4gICAgZ2V0VmFyaWFibGVGb3JFeHBvcnROYW1lKG5hbWUpIHtcbiAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSB0aGlzLmRlY2xhcmF0aW9ucy5nZXQobmFtZSk7XG4gICAgICAgIGlmIChkZWNsYXJhdGlvbilcbiAgICAgICAgICAgIHJldHVybiBbZGVjbGFyYXRpb25dO1xuICAgICAgICBjb25zdCBleHRlcm5hbFZhcmlhYmxlID0gbmV3IEV4dGVybmFsVmFyaWFibGUodGhpcywgbmFtZSk7XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25zLnNldChuYW1lLCBleHRlcm5hbFZhcmlhYmxlKTtcbiAgICAgICAgdGhpcy5leHBvcnRlZFZhcmlhYmxlcy5zZXQoZXh0ZXJuYWxWYXJpYWJsZSwgbmFtZSk7XG4gICAgICAgIHJldHVybiBbZXh0ZXJuYWxWYXJpYWJsZV07XG4gICAgfVxuICAgIHN1Z2dlc3ROYW1lKG5hbWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSAodGhpcy5uYW1lU3VnZ2VzdGlvbnMuZ2V0KG5hbWUpID8/IDApICsgMTtcbiAgICAgICAgdGhpcy5uYW1lU3VnZ2VzdGlvbnMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID4gdGhpcy5tb3N0Q29tbW9uU3VnZ2VzdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tb3N0Q29tbW9uU3VnZ2VzdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zdWdnZXN0ZWRWYXJpYWJsZU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhcm5VbnVzZWRJbXBvcnRzKCkge1xuICAgICAgICBjb25zdCB1bnVzZWQgPSBbLi4udGhpcy5kZWNsYXJhdGlvbnNdXG4gICAgICAgICAgICAuZmlsdGVyKChbbmFtZSwgZGVjbGFyYXRpb25dKSA9PiBuYW1lICE9PSAnKicgJiYgIWRlY2xhcmF0aW9uLmluY2x1ZGVkICYmICF0aGlzLnJlZXhwb3J0ZWQgJiYgIWRlY2xhcmF0aW9uLnJlZmVyZW5jZWQpXG4gICAgICAgICAgICAubWFwKChbbmFtZV0pID0+IG5hbWUpO1xuICAgICAgICBpZiAodW51c2VkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaW1wb3J0ZXJzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdW51c2VkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGltcG9ydGVyIG9mIHRoaXMuZGVjbGFyYXRpb25zLmdldChuYW1lKS5tb2R1bGUuaW1wb3J0ZXJzKSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0ZXJzU2V0LmFkZChpbXBvcnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW1wb3J0ZXJzQXJyYXkgPSBbLi4uaW1wb3J0ZXJzU2V0XTtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uTG9nKExPR0xFVkVMX1dBUk4sIGxvZ1VudXNlZEV4dGVybmFsSW1wb3J0cyh0aGlzLmlkLCB1bnVzZWQsIGltcG9ydGVyc0FycmF5KSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtYXJrTW9kdWxlQW5kSW1wdXJlRGVwZW5kZW5jaWVzQXNFeGVjdXRlZChiYXNlTW9kdWxlKSB7XG4gICAgYmFzZU1vZHVsZS5pc0V4ZWN1dGVkID0gdHJ1ZTtcbiAgICBjb25zdCBtb2R1bGVzID0gW2Jhc2VNb2R1bGVdO1xuICAgIGNvbnN0IHZpc2l0ZWRNb2R1bGVzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIFsuLi5tb2R1bGUuZGVwZW5kZW5jaWVzLCAuLi5tb2R1bGUuaW1wbGljaXRseUxvYWRlZEJlZm9yZV0pIHtcbiAgICAgICAgICAgIGlmICghKGRlcGVuZGVuY3kgaW5zdGFuY2VvZiBFeHRlcm5hbE1vZHVsZSkgJiZcbiAgICAgICAgICAgICAgICAhZGVwZW5kZW5jeS5pc0V4ZWN1dGVkICYmXG4gICAgICAgICAgICAgICAgKGRlcGVuZGVuY3kuaW5mby5tb2R1bGVTaWRlRWZmZWN0cyB8fCBtb2R1bGUuaW1wbGljaXRseUxvYWRlZEJlZm9yZS5oYXMoZGVwZW5kZW5jeSkpICYmXG4gICAgICAgICAgICAgICAgIXZpc2l0ZWRNb2R1bGVzLmhhcyhkZXBlbmRlbmN5LmlkKSkge1xuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kuaXNFeGVjdXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmlzaXRlZE1vZHVsZXMuYWRkKGRlcGVuZGVuY3kuaWQpO1xuICAgICAgICAgICAgICAgIG1vZHVsZXMucHVzaChkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgZG9Ob3RoaW5nID0gKCkgPT4geyB9O1xuXG4vLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHNjcmlwdHMvZ2VuZXJhdGUtY2hpbGQtbm9kZS1rZXlzLmpzLlxuLy8gRG8gbm90IGVkaXQgdGhpcyBmaWxlIGRpcmVjdGx5LlxuY29uc3QgY2hpbGROb2RlS2V5cyA9IHtcbiAgICBBcnJheUV4cHJlc3Npb246IFsnZWxlbWVudHMnXSxcbiAgICBBcnJheVBhdHRlcm46IFsnZWxlbWVudHMnXSxcbiAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogWydwYXJhbXMnLCAnYm9keSddLFxuICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBbJ2xlZnQnLCAncmlnaHQnXSxcbiAgICBBc3NpZ25tZW50UGF0dGVybjogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgQXdhaXRFeHByZXNzaW9uOiBbJ2FyZ3VtZW50J10sXG4gICAgQmluYXJ5RXhwcmVzc2lvbjogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgQmxvY2tTdGF0ZW1lbnQ6IFsnYm9keSddLFxuICAgIEJyZWFrU3RhdGVtZW50OiBbJ2xhYmVsJ10sXG4gICAgQ2FsbEV4cHJlc3Npb246IFsnY2FsbGVlJywgJ2FyZ3VtZW50cyddLFxuICAgIENhdGNoQ2xhdXNlOiBbJ3BhcmFtJywgJ2JvZHknXSxcbiAgICBDaGFpbkV4cHJlc3Npb246IFsnZXhwcmVzc2lvbiddLFxuICAgIENsYXNzQm9keTogWydib2R5J10sXG4gICAgQ2xhc3NEZWNsYXJhdGlvbjogWydkZWNvcmF0b3JzJywgJ2lkJywgJ3N1cGVyQ2xhc3MnLCAnYm9keSddLFxuICAgIENsYXNzRXhwcmVzc2lvbjogWydkZWNvcmF0b3JzJywgJ2lkJywgJ3N1cGVyQ2xhc3MnLCAnYm9keSddLFxuICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogWyd0ZXN0JywgJ2NvbnNlcXVlbnQnLCAnYWx0ZXJuYXRlJ10sXG4gICAgQ29udGludWVTdGF0ZW1lbnQ6IFsnbGFiZWwnXSxcbiAgICBEZWJ1Z2dlclN0YXRlbWVudDogW10sXG4gICAgRGVjb3JhdG9yOiBbJ2V4cHJlc3Npb24nXSxcbiAgICBEb1doaWxlU3RhdGVtZW50OiBbJ2JvZHknLCAndGVzdCddLFxuICAgIEVtcHR5U3RhdGVtZW50OiBbXSxcbiAgICBFeHBvcnRBbGxEZWNsYXJhdGlvbjogWydleHBvcnRlZCcsICdzb3VyY2UnLCAnYXR0cmlidXRlcyddLFxuICAgIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjogWydkZWNsYXJhdGlvbiddLFxuICAgIEV4cG9ydE5hbWVkRGVjbGFyYXRpb246IFsnc3BlY2lmaWVycycsICdzb3VyY2UnLCAnYXR0cmlidXRlcycsICdkZWNsYXJhdGlvbiddLFxuICAgIEV4cG9ydFNwZWNpZmllcjogWydsb2NhbCcsICdleHBvcnRlZCddLFxuICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6IFsnZXhwcmVzc2lvbiddLFxuICAgIEZvckluU3RhdGVtZW50OiBbJ2xlZnQnLCAncmlnaHQnLCAnYm9keSddLFxuICAgIEZvck9mU3RhdGVtZW50OiBbJ2xlZnQnLCAncmlnaHQnLCAnYm9keSddLFxuICAgIEZvclN0YXRlbWVudDogWydpbml0JywgJ3Rlc3QnLCAndXBkYXRlJywgJ2JvZHknXSxcbiAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiBbJ2lkJywgJ3BhcmFtcycsICdib2R5J10sXG4gICAgRnVuY3Rpb25FeHByZXNzaW9uOiBbJ2lkJywgJ3BhcmFtcycsICdib2R5J10sXG4gICAgSWRlbnRpZmllcjogW10sXG4gICAgSWZTdGF0ZW1lbnQ6IFsndGVzdCcsICdjb25zZXF1ZW50JywgJ2FsdGVybmF0ZSddLFxuICAgIEltcG9ydEF0dHJpYnV0ZTogWydrZXknLCAndmFsdWUnXSxcbiAgICBJbXBvcnREZWNsYXJhdGlvbjogWydzcGVjaWZpZXJzJywgJ3NvdXJjZScsICdhdHRyaWJ1dGVzJ10sXG4gICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogWydsb2NhbCddLFxuICAgIEltcG9ydEV4cHJlc3Npb246IFsnc291cmNlJywgJ29wdGlvbnMnXSxcbiAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IFsnbG9jYWwnXSxcbiAgICBJbXBvcnRTcGVjaWZpZXI6IFsnaW1wb3J0ZWQnLCAnbG9jYWwnXSxcbiAgICBKU1hBdHRyaWJ1dGU6IFsnbmFtZScsICd2YWx1ZSddLFxuICAgIEpTWENsb3NpbmdFbGVtZW50OiBbJ25hbWUnXSxcbiAgICBKU1hDbG9zaW5nRnJhZ21lbnQ6IFtdLFxuICAgIEpTWEVsZW1lbnQ6IFsnb3BlbmluZ0VsZW1lbnQnLCAnY2hpbGRyZW4nLCAnY2xvc2luZ0VsZW1lbnQnXSxcbiAgICBKU1hFbXB0eUV4cHJlc3Npb246IFtdLFxuICAgIEpTWEV4cHJlc3Npb25Db250YWluZXI6IFsnZXhwcmVzc2lvbiddLFxuICAgIEpTWEZyYWdtZW50OiBbJ29wZW5pbmdGcmFnbWVudCcsICdjaGlsZHJlbicsICdjbG9zaW5nRnJhZ21lbnQnXSxcbiAgICBKU1hJZGVudGlmaWVyOiBbXSxcbiAgICBKU1hNZW1iZXJFeHByZXNzaW9uOiBbJ29iamVjdCcsICdwcm9wZXJ0eSddLFxuICAgIEpTWE5hbWVzcGFjZWROYW1lOiBbJ25hbWVzcGFjZScsICduYW1lJ10sXG4gICAgSlNYT3BlbmluZ0VsZW1lbnQ6IFsnbmFtZScsICdhdHRyaWJ1dGVzJ10sXG4gICAgSlNYT3BlbmluZ0ZyYWdtZW50OiBbXSxcbiAgICBKU1hTcHJlYWRBdHRyaWJ1dGU6IFsnYXJndW1lbnQnXSxcbiAgICBKU1hTcHJlYWRDaGlsZDogWydleHByZXNzaW9uJ10sXG4gICAgSlNYVGV4dDogW10sXG4gICAgTGFiZWxlZFN0YXRlbWVudDogWydsYWJlbCcsICdib2R5J10sXG4gICAgTGl0ZXJhbDogW10sXG4gICAgTG9naWNhbEV4cHJlc3Npb246IFsnbGVmdCcsICdyaWdodCddLFxuICAgIE1lbWJlckV4cHJlc3Npb246IFsnb2JqZWN0JywgJ3Byb3BlcnR5J10sXG4gICAgTWV0YVByb3BlcnR5OiBbJ21ldGEnLCAncHJvcGVydHknXSxcbiAgICBNZXRob2REZWZpbml0aW9uOiBbJ2RlY29yYXRvcnMnLCAna2V5JywgJ3ZhbHVlJ10sXG4gICAgTmV3RXhwcmVzc2lvbjogWydjYWxsZWUnLCAnYXJndW1lbnRzJ10sXG4gICAgT2JqZWN0RXhwcmVzc2lvbjogWydwcm9wZXJ0aWVzJ10sXG4gICAgT2JqZWN0UGF0dGVybjogWydwcm9wZXJ0aWVzJ10sXG4gICAgUGFuaWNFcnJvcjogW10sXG4gICAgUGFyc2VFcnJvcjogW10sXG4gICAgUHJpdmF0ZUlkZW50aWZpZXI6IFtdLFxuICAgIFByb2dyYW06IFsnYm9keSddLFxuICAgIFByb3BlcnR5OiBbJ2tleScsICd2YWx1ZSddLFxuICAgIFByb3BlcnR5RGVmaW5pdGlvbjogWydkZWNvcmF0b3JzJywgJ2tleScsICd2YWx1ZSddLFxuICAgIFJlc3RFbGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgUmV0dXJuU3RhdGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgU2VxdWVuY2VFeHByZXNzaW9uOiBbJ2V4cHJlc3Npb25zJ10sXG4gICAgU3ByZWFkRWxlbWVudDogWydhcmd1bWVudCddLFxuICAgIFN0YXRpY0Jsb2NrOiBbJ2JvZHknXSxcbiAgICBTdXBlcjogW10sXG4gICAgU3dpdGNoQ2FzZTogWyd0ZXN0JywgJ2NvbnNlcXVlbnQnXSxcbiAgICBTd2l0Y2hTdGF0ZW1lbnQ6IFsnZGlzY3JpbWluYW50JywgJ2Nhc2VzJ10sXG4gICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiBbJ3RhZycsICdxdWFzaSddLFxuICAgIFRlbXBsYXRlRWxlbWVudDogW10sXG4gICAgVGVtcGxhdGVMaXRlcmFsOiBbJ3F1YXNpcycsICdleHByZXNzaW9ucyddLFxuICAgIFRoaXNFeHByZXNzaW9uOiBbXSxcbiAgICBUaHJvd1N0YXRlbWVudDogWydhcmd1bWVudCddLFxuICAgIFRyeVN0YXRlbWVudDogWydibG9jaycsICdoYW5kbGVyJywgJ2ZpbmFsaXplciddLFxuICAgIFVuYXJ5RXhwcmVzc2lvbjogWydhcmd1bWVudCddLFxuICAgIFVwZGF0ZUV4cHJlc3Npb246IFsnYXJndW1lbnQnXSxcbiAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiBbJ2RlY2xhcmF0aW9ucyddLFxuICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogWydpZCcsICdpbml0J10sXG4gICAgV2hpbGVTdGF0ZW1lbnQ6IFsndGVzdCcsICdib2R5J10sXG4gICAgWWllbGRFeHByZXNzaW9uOiBbJ2FyZ3VtZW50J11cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUluY2x1c2lvbkNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYnJva2VuRmxvdzogZmFsc2UsXG4gICAgICAgIGhhc0JyZWFrOiBmYWxzZSxcbiAgICAgICAgaGFzQ29udGludWU6IGZhbHNlLFxuICAgICAgICBpbmNsdWRlZENhbGxBcmd1bWVudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgaW5jbHVkZWRMYWJlbHM6IG5ldyBTZXQoKVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVIYXNFZmZlY3RzQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhY2Nlc3NlZDogbmV3IFBhdGhUcmFja2VyKCksXG4gICAgICAgIGFzc2lnbmVkOiBuZXcgUGF0aFRyYWNrZXIoKSxcbiAgICAgICAgYnJva2VuRmxvdzogZmFsc2UsXG4gICAgICAgIGNhbGxlZDogbmV3IERpc2NyaW1pbmF0ZWRQYXRoVHJhY2tlcigpLFxuICAgICAgICBoYXNCcmVhazogZmFsc2UsXG4gICAgICAgIGhhc0NvbnRpbnVlOiBmYWxzZSxcbiAgICAgICAgaWdub3JlOiB7XG4gICAgICAgICAgICBicmVha3M6IGZhbHNlLFxuICAgICAgICAgICAgY29udGludWVzOiBmYWxzZSxcbiAgICAgICAgICAgIGxhYmVsczogbmV3IFNldCgpLFxuICAgICAgICAgICAgcmV0dXJuWWllbGQ6IGZhbHNlLFxuICAgICAgICAgICAgdGhpczogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgaW5jbHVkZWRMYWJlbHM6IG5ldyBTZXQoKSxcbiAgICAgICAgaW5zdGFudGlhdGVkOiBuZXcgRGlzY3JpbWluYXRlZFBhdGhUcmFja2VyKCksXG4gICAgICAgIHJlcGxhY2VkVmFyaWFibGVJbml0czogbmV3IE1hcCgpXG4gICAgfTtcbn1cblxuY29uc3QgSU5DTFVERV9QQVJBTUVURVJTID0gJ3ZhcmlhYmxlcyc7XG5jb25zdCBJU19TS0lQUEVEX0NIQUlOID0gU3ltYm9sKCdJU19TS0lQUEVEX0NIQUlOJyk7XG5jbGFzcyBOb2RlQmFzZSBleHRlbmRzIEV4cHJlc3Npb25FbnRpdHkge1xuICAgIC8qKlxuICAgICAqIE5vZGVzIGNhbiBhcHBseSBjdXN0b20gZGVvcHRpbWl6YXRpb25zIG9uY2UgdGhleSBiZWNvbWUgcGFydCBvZiB0aGVcbiAgICAgKiBleGVjdXRlZCBjb2RlLiBUbyBkbyB0aGlzLCB0aGV5IG11c3QgaW5pdGlhbGl6ZSB0aGlzIGFzIGZhbHNlLCBpbXBsZW1lbnRcbiAgICAgKiBhcHBseURlb3B0aW1pemF0aW9ucyBhbmQgY2FsbCB0aGlzIGZyb20gaW5jbHVkZSBhbmQgaGFzRWZmZWN0cyBpZiB0aGV5IGhhdmVcbiAgICAgKiBjdXN0b20gaGFuZGxlcnNcbiAgICAgKi9cbiAgICBnZXQgZGVvcHRpbWl6ZWQoKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYWdTZXQodGhpcy5mbGFncywgMiAvKiBGbGFnLmRlb3B0aW1pemVkICovKTtcbiAgICB9XG4gICAgc2V0IGRlb3B0aW1pemVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBzZXRGbGFnKHRoaXMuZmxhZ3MsIDIgLyogRmxhZy5kZW9wdGltaXplZCAqLywgdmFsdWUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHBhcmVudFNjb3BlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLnNjb3BlID0gcGFyZW50U2NvcGU7XG4gICAgICAgIHRoaXMuY3JlYXRlU2NvcGUocGFyZW50U2NvcGUpO1xuICAgIH1cbiAgICBhZGRFeHBvcnRlZFZhcmlhYmxlcyhfdmFyaWFibGVzLCBfZXhwb3J0TmFtZXNCeVZhcmlhYmxlKSB7IH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIHRvIGJpbmQgYXNzaWdubWVudHMgdG8gdmFyaWFibGVzIGFuZCBkbyBhbnkgaW5pdGlhbGlzYXRpb25zXG4gICAgICogdGhhdCByZXF1aXJlIHRoZSBzY29wZXMgdG8gYmUgcG9wdWxhdGVkIHdpdGggdmFyaWFibGVzLlxuICAgICAqL1xuICAgIGJpbmQoKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGNoaWxkTm9kZUtleXNbdGhpcy50eXBlXSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2tleV07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkPy5iaW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iaW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgaWYgdGhpcyBub2RlIHNob3VsZCByZWNlaXZlIGEgZGlmZmVyZW50IHNjb3BlIHRoYW4gdGhlIHBhcmVudFxuICAgICAqIHNjb3BlLlxuICAgICAqL1xuICAgIGNyZWF0ZVNjb3BlKHBhcmVudFNjb3BlKSB7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBwYXJlbnRTY29wZTtcbiAgICB9XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgY2hpbGROb2RlS2V5c1t0aGlzLnR5cGVdKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXNba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkPy5oYXNFZmZlY3RzKGNvbnRleHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuaGFzRWZmZWN0cyhjb250ZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNBc0Fzc2lnbm1lbnRUYXJnZXQoY29udGV4dCwgX2NoZWNrQWNjZXNzKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5oYXNFZmZlY3RzKGNvbnRleHQpIHx8XG4gICAgICAgICAgICB0aGlzLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKEVNUFRZX1BBVEgsIHRoaXMuYXNzaWdubWVudEludGVyYWN0aW9uLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIGluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHksIF9vcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGNoaWxkTm9kZUtleXNbdGhpcy50eXBlXSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkPy5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmNsdWRlQXNBc3NpZ25tZW50VGFyZ2V0KGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5LCBfZGVvcHRpbWl6ZUFjY2Vzcykge1xuICAgICAgICB0aGlzLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0byBwZXJmb3JtIHNwZWNpYWwgaW5pdGlhbGlzYXRpb24gc3RlcHMgYWZ0ZXIgdGhlIHNjb3BlIGlzXG4gICAgICogaW5pdGlhbGlzZWRcbiAgICAgKi9cbiAgICBpbml0aWFsaXNlKCkge1xuICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQubWFnaWNTdHJpbmcuYWRkU291cmNlbWFwTG9jYXRpb24odGhpcy5zdGFydCk7XG4gICAgICAgIHRoaXMuc2NvcGUuY29udGV4dC5tYWdpY1N0cmluZy5hZGRTb3VyY2VtYXBMb2NhdGlvbih0aGlzLmVuZCk7XG4gICAgfVxuICAgIHBhcnNlTm9kZShlc1RyZWVOb2RlKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGVzVHJlZU5vZGUpKSB7XG4gICAgICAgICAgICAvLyBTa2lwIHByb3BlcnRpZXMgZGVmaW5lZCBvbiB0aGUgY2xhc3MgYWxyZWFkeS5cbiAgICAgICAgICAgIC8vIFRoaXMgd2F5LCB3ZSBjYW4gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBhZGQgY3VzdG9tIGluaXRpYWxpc2F0aW9uIGFuZCB0aGVuIGNhbGwgc3VwZXIucGFyc2VOb2RlXG4gICAgICAgICAgICAvLyBOb3RlOiB0aGlzIGRvZXNuJ3Qgc2tpcCBwcm9wZXJ0aWVzIHdpdGggZGVmaW5lZCBnZXR0ZXJzL3NldHRlcnMgd2hpY2ggd2UgdXNlIHRvIHBhY2sgd3JhcCBib29sZWFuc1xuICAgICAgICAgICAgLy8gaW4gYml0ZmllbGRzLiBUaG9zZSBhcmUgc3RpbGwgYXNzaWduZWQgZnJvbSB0aGUgdmFsdWUgaW4gdGhlIGVzVHJlZU5vZGUuXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGtleS5jaGFyQ29kZUF0KDApID09PSA5NSAvKiBfICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gQU5OT1RBVElPTl9LRVkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IElOVkFMSURfQU5OT1RBVElPTl9LRVkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkQW5ub3RhdGlvbnMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IG5ldyBBcnJheSh2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV1baW5kZXgrK10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyAodGhpcy5zY29wZS5jb250ZXh0LmdldE5vZGVDb25zdHJ1Y3RvcihjaGlsZC50eXBlKSkodGhpcywgdGhpcy5zY29wZSkucGFyc2VOb2RlKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBuZXcgKHRoaXMuc2NvcGUuY29udGV4dC5nZXROb2RlQ29uc3RydWN0b3IodmFsdWUudHlwZSkpKHRoaXMsIHRoaXMuc2NvcGUpLnBhcnNlTm9kZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXh0ZW5kIGNoaWxkIGtleXMgZm9yIHVua25vd24gbm9kZSB0eXBlc1xuICAgICAgICBjaGlsZE5vZGVLZXlzW2VzVHJlZU5vZGUudHlwZV0gfHw9IGNyZWF0ZUNoaWxkTm9kZUtleXNGb3JOb2RlKGVzVHJlZU5vZGUpO1xuICAgICAgICB0aGlzLmluaXRpYWxpc2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlbW92ZUFubm90YXRpb25zKGNvZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYW5ub3RhdGlvbiBvZiB0aGlzLmFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29kZS5yZW1vdmUoYW5ub3RhdGlvbi5zdGFydCwgYW5ub3RhdGlvbi5lbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGNoaWxkTm9kZUtleXNbdGhpcy50eXBlXSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkPy5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldEFzc2lnbmVkVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5hc3NpZ25tZW50SW50ZXJhY3Rpb24gPSB7IGFyZ3M6IFtudWxsLCB2YWx1ZV0sIHR5cGU6IElOVEVSQUNUSU9OX0FTU0lHTkVEIH07XG4gICAgfVxuICAgIHNob3VsZEJlSW5jbHVkZWQoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmNsdWRlZCB8fCAoIWNvbnRleHQuYnJva2VuRmxvdyAmJiB0aGlzLmhhc0VmZmVjdHMoY3JlYXRlSGFzRWZmZWN0c0NvbnRleHQoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBKdXN0IGRlb3B0aW1pemUgZXZlcnl0aGluZyBieSBkZWZhdWx0IHNvIHRoYXQgd2hlbiBlLmcuIHdlIGRvIG5vdCB0cmFja1xuICAgICAqIHNvbWV0aGluZyBwcm9wZXJseSwgaXQgaXMgZGVvcHRpbWl6ZWQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFwcGx5RGVvcHRpbWl6YXRpb25zKCkge1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgY2hpbGROb2RlS2V5c1t0aGlzLnR5cGVdKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXNba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQ/LmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuZGVvcHRpbWl6ZVBhdGgoVU5LTk9XTl9QQVRIKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkTm9kZUtleXNGb3JOb2RlKGVzVHJlZU5vZGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZXNUcmVlTm9kZSkuZmlsdGVyKGtleSA9PiB0eXBlb2YgZXNUcmVlTm9kZVtrZXldID09PSAnb2JqZWN0JyAmJiBrZXkuY2hhckNvZGVBdCgwKSAhPT0gOTUgLyogXyAqLyk7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0RXhwcmVzc2lvbk5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgTm9kZUJhc2UgJiYgbm9kZS50eXBlID09PSBPYmplY3RFeHByZXNzaW9uJDE7XG59XG5mdW5jdGlvbiBpc1Byb3BlcnR5Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gUHJvcGVydHkkMTtcbn1cblxuZnVuY3Rpb24gYXNzZW1ibGVNZW1iZXJEZXNjcmlwdGlvbnMobWVtYmVyRGVzY3JpcHRpb25zLCBpbmhlcml0ZWREZXNjcmlwdGlvbnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoaW5oZXJpdGVkRGVzY3JpcHRpb25zLCBtZW1iZXJEZXNjcmlwdGlvbnMpO1xufVxuY29uc3QgVU5ERUZJTkVEX0VYUFJFU1NJT04gPSBuZXcgKGNsYXNzIFVuZGVmaW5lZEV4cHJlc3Npb24gZXh0ZW5kcyBFeHByZXNzaW9uRW50aXR5IHtcbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufSkoKTtcbmNvbnN0IHJldHVybnNVbmtub3duID0ge1xuICAgIHZhbHVlOiB7XG4gICAgICAgIGhhc0VmZmVjdHNXaGVuQ2FsbGVkOiBudWxsLFxuICAgICAgICByZXR1cm5zOiBVTktOT1dOX0VYUFJFU1NJT05cbiAgICB9XG59O1xuY29uc3QgVU5LTk9XTl9MSVRFUkFMX0JPT0xFQU4gPSBuZXcgKGNsYXNzIFVua25vd25Cb29sZWFuIGV4dGVuZHMgRXhwcmVzc2lvbkVudGl0eSB7XG4gICAgZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRNZW1iZXJSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZChsaXRlcmFsQm9vbGVhbk1lbWJlcnMsIHBhdGhbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVTktOT1dOX1JFVFVSTl9FWFBSRVNTSU9OO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICBpZiAoaW50ZXJhY3Rpb24udHlwZSA9PT0gSU5URVJBQ1RJT05fQUNDRVNTRUQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVyYWN0aW9uLnR5cGUgPT09IElOVEVSQUNUSU9OX0NBTExFRCAmJiBwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhc01lbWJlckVmZmVjdFdoZW5DYWxsZWQobGl0ZXJhbEJvb2xlYW5NZW1iZXJzLCBwYXRoWzBdLCBpbnRlcmFjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSkoKTtcbmNvbnN0IHJldHVybnNCb29sZWFuID0ge1xuICAgIHZhbHVlOiB7XG4gICAgICAgIGhhc0VmZmVjdHNXaGVuQ2FsbGVkOiBudWxsLFxuICAgICAgICByZXR1cm5zOiBVTktOT1dOX0xJVEVSQUxfQk9PTEVBTlxuICAgIH1cbn07XG5jb25zdCBVTktOT1dOX0xJVEVSQUxfTlVNQkVSID0gbmV3IChjbGFzcyBVbmtub3duTnVtYmVyIGV4dGVuZHMgRXhwcmVzc2lvbkVudGl0eSB7XG4gICAgZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRNZW1iZXJSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZChsaXRlcmFsTnVtYmVyTWVtYmVycywgcGF0aFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVOS05PV05fUkVUVVJOX0VYUFJFU1NJT047XG4gICAgfVxuICAgIGhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChpbnRlcmFjdGlvbi50eXBlID09PSBJTlRFUkFDVElPTl9BQ0NFU1NFRCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJhY3Rpb24udHlwZSA9PT0gSU5URVJBQ1RJT05fQ0FMTEVEICYmIHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzTWVtYmVyRWZmZWN0V2hlbkNhbGxlZChsaXRlcmFsTnVtYmVyTWVtYmVycywgcGF0aFswXSwgaW50ZXJhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pKCk7XG5jb25zdCByZXR1cm5zTnVtYmVyID0ge1xuICAgIHZhbHVlOiB7XG4gICAgICAgIGhhc0VmZmVjdHNXaGVuQ2FsbGVkOiBudWxsLFxuICAgICAgICByZXR1cm5zOiBVTktOT1dOX0xJVEVSQUxfTlVNQkVSXG4gICAgfVxufTtcbmNvbnN0IFVOS05PV05fTElURVJBTF9TVFJJTkcgPSBuZXcgKGNsYXNzIFVua25vd25TdHJpbmcgZXh0ZW5kcyBFeHByZXNzaW9uRW50aXR5IHtcbiAgICBnZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE1lbWJlclJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkKGxpdGVyYWxTdHJpbmdNZW1iZXJzLCBwYXRoWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVU5LTk9XTl9SRVRVUk5fRVhQUkVTU0lPTjtcbiAgICB9XG4gICAgaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGludGVyYWN0aW9uLnR5cGUgPT09IElOVEVSQUNUSU9OX0FDQ0VTU0VEKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcmFjdGlvbi50eXBlID09PSBJTlRFUkFDVElPTl9DQUxMRUQgJiYgcGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNNZW1iZXJFZmZlY3RXaGVuQ2FsbGVkKGxpdGVyYWxTdHJpbmdNZW1iZXJzLCBwYXRoWzBdLCBpbnRlcmFjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSkoKTtcbmNvbnN0IHJldHVybnNTdHJpbmcgPSB7XG4gICAgdmFsdWU6IHtcbiAgICAgICAgaGFzRWZmZWN0c1doZW5DYWxsZWQ6IG51bGwsXG4gICAgICAgIHJldHVybnM6IFVOS05PV05fTElURVJBTF9TVFJJTkdcbiAgICB9XG59O1xuY29uc3Qgc3RyaW5nUmVwbGFjZSA9IHtcbiAgICB2YWx1ZToge1xuICAgICAgICBoYXNFZmZlY3RzV2hlbkNhbGxlZCh7IGFyZ3MgfSwgY29udGV4dCkge1xuICAgICAgICAgICAgY29uc3QgYXJndW1lbnQxID0gYXJnc1syXTtcbiAgICAgICAgICAgIHJldHVybiAoYXJncy5sZW5ndGggPCAzIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBhcmd1bWVudDEuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKEVNUFRZX1BBVEgsIFNIQVJFRF9SRUNVUlNJT05fVFJBQ0tFUiwge1xuICAgICAgICAgICAgICAgICAgICBkZW9wdGltaXplQ2FjaGUoKSB7IH1cbiAgICAgICAgICAgICAgICB9KSA9PT0gJ3N5bWJvbCcgJiZcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQxLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKEVNUFRZX1BBVEgsIE5PREVfSU5URVJBQ1RJT05fVU5LTk9XTl9DQUxMLCBjb250ZXh0KSkpO1xuICAgICAgICB9LFxuICAgICAgICByZXR1cm5zOiBVTktOT1dOX0xJVEVSQUxfU1RSSU5HXG4gICAgfVxufTtcbmNvbnN0IG9iamVjdE1lbWJlcnMgPSBhc3NlbWJsZU1lbWJlckRlc2NyaXB0aW9ucyh7XG4gICAgaGFzT3duUHJvcGVydHk6IHJldHVybnNCb29sZWFuLFxuICAgIGlzUHJvdG90eXBlT2Y6IHJldHVybnNCb29sZWFuLFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlOiByZXR1cm5zQm9vbGVhbixcbiAgICB0b0xvY2FsZVN0cmluZzogcmV0dXJuc1N0cmluZyxcbiAgICB0b1N0cmluZzogcmV0dXJuc1N0cmluZyxcbiAgICB2YWx1ZU9mOiByZXR1cm5zVW5rbm93blxufSk7XG5jb25zdCBsaXRlcmFsQm9vbGVhbk1lbWJlcnMgPSBhc3NlbWJsZU1lbWJlckRlc2NyaXB0aW9ucyh7XG4gICAgdmFsdWVPZjogcmV0dXJuc0Jvb2xlYW5cbn0sIG9iamVjdE1lbWJlcnMpO1xuY29uc3QgbGl0ZXJhbE51bWJlck1lbWJlcnMgPSBhc3NlbWJsZU1lbWJlckRlc2NyaXB0aW9ucyh7XG4gICAgdG9FeHBvbmVudGlhbDogcmV0dXJuc1N0cmluZyxcbiAgICB0b0ZpeGVkOiByZXR1cm5zU3RyaW5nLFxuICAgIHRvTG9jYWxlU3RyaW5nOiByZXR1cm5zU3RyaW5nLFxuICAgIHRvUHJlY2lzaW9uOiByZXR1cm5zU3RyaW5nLFxuICAgIHZhbHVlT2Y6IHJldHVybnNOdW1iZXJcbn0sIG9iamVjdE1lbWJlcnMpO1xuLyoqXG4gKiBSZWdFeHAgYXJlIHN0YXRlZnVsIHdoZW4gdGhleSBoYXZlIHRoZSBnbG9iYWwgb3Igc3RpY2t5IGZsYWdzIHNldC5cbiAqIEJ1dCBpZiB3ZSBhY3R1YWxseSBkb24ndCB1c2UgdGhlbSwgdGhlIHNpZGUgZWZmZWN0IGRvZXMgbm90IG1hdHRlci5cbiAqIHRoZSBjaGVjayBsb2dpYyBpbiBgaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGhgLlxuICovXG5jb25zdCBsaXRlcmFsUmVnRXhwTWVtYmVycyA9IGFzc2VtYmxlTWVtYmVyRGVzY3JpcHRpb25zKHtcbiAgICBleGVjOiByZXR1cm5zVW5rbm93bixcbiAgICB0ZXN0OiByZXR1cm5zQm9vbGVhblxufSwgb2JqZWN0TWVtYmVycyk7XG5jb25zdCBsaXRlcmFsU3RyaW5nTWVtYmVycyA9IGFzc2VtYmxlTWVtYmVyRGVzY3JpcHRpb25zKHtcbiAgICBhbmNob3I6IHJldHVybnNTdHJpbmcsXG4gICAgYXQ6IHJldHVybnNVbmtub3duLFxuICAgIGJpZzogcmV0dXJuc1N0cmluZyxcbiAgICBibGluazogcmV0dXJuc1N0cmluZyxcbiAgICBib2xkOiByZXR1cm5zU3RyaW5nLFxuICAgIGNoYXJBdDogcmV0dXJuc1N0cmluZyxcbiAgICBjaGFyQ29kZUF0OiByZXR1cm5zTnVtYmVyLFxuICAgIGNvZGVQb2ludEF0OiByZXR1cm5zVW5rbm93bixcbiAgICBjb25jYXQ6IHJldHVybnNTdHJpbmcsXG4gICAgZW5kc1dpdGg6IHJldHVybnNCb29sZWFuLFxuICAgIGZpeGVkOiByZXR1cm5zU3RyaW5nLFxuICAgIGZvbnRjb2xvcjogcmV0dXJuc1N0cmluZyxcbiAgICBmb250c2l6ZTogcmV0dXJuc1N0cmluZyxcbiAgICBpbmNsdWRlczogcmV0dXJuc0Jvb2xlYW4sXG4gICAgaW5kZXhPZjogcmV0dXJuc051bWJlcixcbiAgICBpdGFsaWNzOiByZXR1cm5zU3RyaW5nLFxuICAgIGxhc3RJbmRleE9mOiByZXR1cm5zTnVtYmVyLFxuICAgIGxpbms6IHJldHVybnNTdHJpbmcsXG4gICAgbG9jYWxlQ29tcGFyZTogcmV0dXJuc051bWJlcixcbiAgICBtYXRjaDogcmV0dXJuc1Vua25vd24sXG4gICAgbWF0Y2hBbGw6IHJldHVybnNVbmtub3duLFxuICAgIG5vcm1hbGl6ZTogcmV0dXJuc1N0cmluZyxcbiAgICBwYWRFbmQ6IHJldHVybnNTdHJpbmcsXG4gICAgcGFkU3RhcnQ6IHJldHVybnNTdHJpbmcsXG4gICAgcmVwZWF0OiByZXR1cm5zU3RyaW5nLFxuICAgIHJlcGxhY2U6IHN0cmluZ1JlcGxhY2UsXG4gICAgcmVwbGFjZUFsbDogc3RyaW5nUmVwbGFjZSxcbiAgICBzZWFyY2g6IHJldHVybnNOdW1iZXIsXG4gICAgc2xpY2U6IHJldHVybnNTdHJpbmcsXG4gICAgc21hbGw6IHJldHVybnNTdHJpbmcsXG4gICAgc3BsaXQ6IHJldHVybnNVbmtub3duLFxuICAgIHN0YXJ0c1dpdGg6IHJldHVybnNCb29sZWFuLFxuICAgIHN0cmlrZTogcmV0dXJuc1N0cmluZyxcbiAgICBzdWI6IHJldHVybnNTdHJpbmcsXG4gICAgc3Vic3RyOiByZXR1cm5zU3RyaW5nLFxuICAgIHN1YnN0cmluZzogcmV0dXJuc1N0cmluZyxcbiAgICBzdXA6IHJldHVybnNTdHJpbmcsXG4gICAgdG9Mb2NhbGVMb3dlckNhc2U6IHJldHVybnNTdHJpbmcsXG4gICAgdG9Mb2NhbGVVcHBlckNhc2U6IHJldHVybnNTdHJpbmcsXG4gICAgdG9Mb3dlckNhc2U6IHJldHVybnNTdHJpbmcsXG4gICAgdG9TdHJpbmc6IHJldHVybnNTdHJpbmcsIC8vIG92ZXJyaWRlcyB0aGUgdG9TdHJpbmcoKSBtZXRob2Qgb2YgdGhlIE9iamVjdCBvYmplY3Q7IGl0IGRvZXMgbm90IGluaGVyaXQgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG4gICAgdG9VcHBlckNhc2U6IHJldHVybnNTdHJpbmcsXG4gICAgdHJpbTogcmV0dXJuc1N0cmluZyxcbiAgICB0cmltRW5kOiByZXR1cm5zU3RyaW5nLFxuICAgIHRyaW1MZWZ0OiByZXR1cm5zU3RyaW5nLFxuICAgIHRyaW1SaWdodDogcmV0dXJuc1N0cmluZyxcbiAgICB0cmltU3RhcnQ6IHJldHVybnNTdHJpbmcsXG4gICAgdmFsdWVPZjogcmV0dXJuc1N0cmluZ1xufSwgb2JqZWN0TWVtYmVycyk7XG5mdW5jdGlvbiBnZXRMaXRlcmFsTWVtYmVyc0ZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsUmVnRXhwTWVtYmVycztcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6IHtcbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsQm9vbGVhbk1lbWJlcnM7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnbnVtYmVyJzoge1xuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxOdW1iZXJNZW1iZXJzO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6IHtcbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsU3RyaW5nTWVtYmVycztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cbmZ1bmN0aW9uIGhhc01lbWJlckVmZmVjdFdoZW5DYWxsZWQobWVtYmVycywgbWVtYmVyTmFtZSwgaW50ZXJhY3Rpb24sIGNvbnRleHQpIHtcbiAgICBpZiAodHlwZW9mIG1lbWJlck5hbWUgIT09ICdzdHJpbmcnIHx8ICFtZW1iZXJzW21lbWJlck5hbWVdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbWVtYmVyc1ttZW1iZXJOYW1lXS5oYXNFZmZlY3RzV2hlbkNhbGxlZD8uKGludGVyYWN0aW9uLCBjb250ZXh0KSB8fCBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldE1lbWJlclJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkKG1lbWJlcnMsIG1lbWJlck5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG1lbWJlck5hbWUgIT09ICdzdHJpbmcnIHx8ICFtZW1iZXJzW21lbWJlck5hbWVdKVxuICAgICAgICByZXR1cm4gVU5LTk9XTl9SRVRVUk5fRVhQUkVTU0lPTjtcbiAgICByZXR1cm4gW21lbWJlcnNbbWVtYmVyTmFtZV0ucmV0dXJucywgZmFsc2VdO1xufVxuXG5jbGFzcyBTcHJlYWRFbGVtZW50IGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoLCByZWN1cnNpb25UcmFja2VyKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYXJndW1lbnQuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIFtVbmtub3duS2V5LCAuLi5wYXRoXSwgcmVjdXJzaW9uVHJhY2tlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgY29uc3QgeyBwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0cyB9ID0gdGhpcy5zY29wZS5jb250ZXh0Lm9wdGlvbnNcbiAgICAgICAgICAgIC50cmVlc2hha2U7XG4gICAgICAgIHJldHVybiAodGhpcy5hcmd1bWVudC5oYXNFZmZlY3RzKGNvbnRleHQpIHx8XG4gICAgICAgICAgICAocHJvcGVydHlSZWFkU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICAgICAgICAocHJvcGVydHlSZWFkU2lkZUVmZmVjdHMgPT09ICdhbHdheXMnIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJndW1lbnQuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoVU5LTk9XTl9QQVRILCBOT0RFX0lOVEVSQUNUSU9OX1VOS05PV05fQUNDRVNTLCBjb250ZXh0KSkpKTtcbiAgICB9XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICAvLyBPbmx5IHByb3BlcnRpZXMgb2YgcHJvcGVydGllcyBvZiB0aGUgYXJndW1lbnQgY291bGQgYmVjb21lIHN1YmplY3QgdG8gcmVhc3NpZ25tZW50XG4gICAgICAgIC8vIFRoaXMgd2lsbCBhbHNvIHJlYXNzaWduIHRoZSByZXR1cm4gdmFsdWVzIG9mIGl0ZXJhdG9yc1xuICAgICAgICB0aGlzLmFyZ3VtZW50LmRlb3B0aW1pemVQYXRoKFtVbmtub3duS2V5LCBVbmtub3duS2V5XSk7XG4gICAgICAgIHRoaXMuc2NvcGUuY29udGV4dC5yZXF1ZXN0VHJlZXNoYWtpbmdQYXNzKCk7XG4gICAgfVxufVxuXG5jbGFzcyBNZXRob2QgZXh0ZW5kcyBFeHByZXNzaW9uRW50aXR5IHtcbiAgICBjb25zdHJ1Y3RvcihkZXNjcmlwdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgfVxuICAgIGRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHsgYXJncywgdHlwZSB9LCBwYXRoKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBJTlRFUkFDVElPTl9DQUxMRUQgJiYgcGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlc2NyaXB0aW9uLm11dGF0ZXNTZWxmQXNBcnJheSkge1xuICAgICAgICAgICAgICAgIGFyZ3NbMF0/LmRlb3B0aW1pemVQYXRoKFVOS05PV05fSU5URUdFUl9QQVRIKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRlc2NyaXB0aW9uLm11dGF0ZXNBcmdzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaW5kZXhdLmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIHsgYXJncyB9KSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBVTktOT1dOX1JFVFVSTl9FWFBSRVNTSU9OO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLmRlc2NyaXB0aW9uLnJldHVybnNQcmltaXRpdmUgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5kZXNjcmlwdGlvbi5yZXR1cm5zID09PSAnc2VsZidcbiAgICAgICAgICAgICAgICAgICAgPyBhcmdzWzBdIHx8IFVOS05PV05fRVhQUkVTU0lPTlxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuZGVzY3JpcHRpb24ucmV0dXJucygpKSxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgIF07XG4gICAgfVxuICAgIGhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gaW50ZXJhY3Rpb247XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+ICh0eXBlID09PSBJTlRFUkFDVElPTl9BQ0NFU1NFRCA/IDEgOiAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IElOVEVSQUNUSU9OX0NBTExFRCkge1xuICAgICAgICAgICAgY29uc3QgeyBhcmdzIH0gPSBpbnRlcmFjdGlvbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlc2NyaXB0aW9uLm11dGF0ZXNTZWxmQXNBcnJheSA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICAgIGFyZ3NbMF0/Lmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKFVOS05PV05fSU5URUdFUl9QQVRILCBOT0RFX0lOVEVSQUNUSU9OX1VOS05PV05fQVNTSUdOTUVOVCwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRlc2NyaXB0aW9uLmNhbGxzQXJncykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXJndW1lbnRJbmRleCBvZiB0aGlzLmRlc2NyaXB0aW9uLmNhbGxzQXJncykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnc1thcmd1bWVudEluZGV4ICsgMV0/Lmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKEVNUFRZX1BBVEgsIE5PREVfSU5URVJBQ1RJT05fVU5LTk9XTl9DQUxMLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNvbnN0IE1FVEhPRF9SRVRVUk5TX0JPT0xFQU4gPSBbXG4gICAgbmV3IE1ldGhvZCh7XG4gICAgICAgIGNhbGxzQXJnczogbnVsbCxcbiAgICAgICAgbXV0YXRlc0FyZ3M6IGZhbHNlLFxuICAgICAgICBtdXRhdGVzU2VsZkFzQXJyYXk6IGZhbHNlLFxuICAgICAgICByZXR1cm5zOiBudWxsLFxuICAgICAgICByZXR1cm5zUHJpbWl0aXZlOiBVTktOT1dOX0xJVEVSQUxfQk9PTEVBTlxuICAgIH0pXG5dO1xuY29uc3QgTUVUSE9EX1JFVFVSTlNfU1RSSU5HID0gW1xuICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICBjYWxsc0FyZ3M6IG51bGwsXG4gICAgICAgIG11dGF0ZXNBcmdzOiBmYWxzZSxcbiAgICAgICAgbXV0YXRlc1NlbGZBc0FycmF5OiBmYWxzZSxcbiAgICAgICAgcmV0dXJuczogbnVsbCxcbiAgICAgICAgcmV0dXJuc1ByaW1pdGl2ZTogVU5LTk9XTl9MSVRFUkFMX1NUUklOR1xuICAgIH0pXG5dO1xuY29uc3QgTUVUSE9EX1JFVFVSTlNfTlVNQkVSID0gW1xuICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICBjYWxsc0FyZ3M6IG51bGwsXG4gICAgICAgIG11dGF0ZXNBcmdzOiBmYWxzZSxcbiAgICAgICAgbXV0YXRlc1NlbGZBc0FycmF5OiBmYWxzZSxcbiAgICAgICAgcmV0dXJuczogbnVsbCxcbiAgICAgICAgcmV0dXJuc1ByaW1pdGl2ZTogVU5LTk9XTl9MSVRFUkFMX05VTUJFUlxuICAgIH0pXG5dO1xuY29uc3QgTUVUSE9EX1JFVFVSTlNfVU5LTk9XTiA9IFtcbiAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgY2FsbHNBcmdzOiBudWxsLFxuICAgICAgICBtdXRhdGVzQXJnczogZmFsc2UsXG4gICAgICAgIG11dGF0ZXNTZWxmQXNBcnJheTogZmFsc2UsXG4gICAgICAgIHJldHVybnM6IG51bGwsXG4gICAgICAgIHJldHVybnNQcmltaXRpdmU6IFVOS05PV05fRVhQUkVTU0lPTlxuICAgIH0pXG5dO1xuXG5jb25zdCBJTlRFR0VSX1JFR19FWFAgPSAvXlxcZCskLztcbmNsYXNzIE9iamVjdEVudGl0eSBleHRlbmRzIEV4cHJlc3Npb25FbnRpdHkge1xuICAgIGdldCBoYXNMb3N0VHJhY2soKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYWdTZXQodGhpcy5mbGFncywgMjA0OCAvKiBGbGFnLmhhc0xvc3RUcmFjayAqLyk7XG4gICAgfVxuICAgIHNldCBoYXNMb3N0VHJhY2sodmFsdWUpIHtcbiAgICAgICAgdGhpcy5mbGFncyA9IHNldEZsYWcodGhpcy5mbGFncywgMjA0OCAvKiBGbGFnLmhhc0xvc3RUcmFjayAqLywgdmFsdWUpO1xuICAgIH1cbiAgICBnZXQgaGFzVW5rbm93bkRlb3B0aW1pemVkSW50ZWdlcigpIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhZ1NldCh0aGlzLmZsYWdzLCA0MDk2IC8qIEZsYWcuaGFzVW5rbm93bkRlb3B0aW1pemVkSW50ZWdlciAqLyk7XG4gICAgfVxuICAgIHNldCBoYXNVbmtub3duRGVvcHRpbWl6ZWRJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBzZXRGbGFnKHRoaXMuZmxhZ3MsIDQwOTYgLyogRmxhZy5oYXNVbmtub3duRGVvcHRpbWl6ZWRJbnRlZ2VyICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBoYXNVbmtub3duRGVvcHRpbWl6ZWRQcm9wZXJ0eSgpIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhZ1NldCh0aGlzLmZsYWdzLCA4MTkyIC8qIEZsYWcuaGFzVW5rbm93bkRlb3B0aW1pemVkUHJvcGVydHkgKi8pO1xuICAgIH1cbiAgICBzZXQgaGFzVW5rbm93bkRlb3B0aW1pemVkUHJvcGVydHkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5mbGFncyA9IHNldEZsYWcodGhpcy5mbGFncywgODE5MiAvKiBGbGFnLmhhc1Vua25vd25EZW9wdGltaXplZFByb3BlcnR5ICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIElmIGEgUHJvcGVydHlNYXAgaXMgdXNlZCwgdGhpcyB3aWxsIGJlIHRha2VuIGFzIHByb3BlcnRpZXNBbmRHZXR0ZXJzQnlLZXlcbiAgICAvLyBhbmQgd2UgYXNzdW1lIHRoZXJlIGFyZSBubyBzZXR0ZXJzIG9yIGdldHRlcnNcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzLCBwcm90b3R5cGVFeHByZXNzaW9uLCBpbW11dGFibGUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24gPSBwcm90b3R5cGVFeHByZXNzaW9uO1xuICAgICAgICB0aGlzLmltbXV0YWJsZSA9IGltbXV0YWJsZTtcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsRXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuYWxsUHJvcGVydGllcyA9IFtdO1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVkUGF0aHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkQnlLZXkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmdldHRlcnNCeUtleSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMucHJvcGVydGllc0FuZEdldHRlcnNCeUtleSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMucHJvcGVydGllc0FuZFNldHRlcnNCeUtleSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuc2V0dGVyc0J5S2V5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy51bmtub3duSW50ZWdlclByb3BzID0gW107XG4gICAgICAgIHRoaXMudW5tYXRjaGFibGVHZXR0ZXJzID0gW107XG4gICAgICAgIHRoaXMudW5tYXRjaGFibGVQcm9wZXJ0aWVzQW5kR2V0dGVycyA9IFtdO1xuICAgICAgICB0aGlzLnVubWF0Y2hhYmxlU2V0dGVycyA9IFtdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgdGhpcy5idWlsZFByb3BlcnR5TWFwcyhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc0FuZEdldHRlcnNCeUtleSA9IHRoaXMucHJvcGVydGllc0FuZFNldHRlcnNCeUtleSA9IHByb3BlcnRpZXM7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnRpZXNGb3JLZXkgb2YgT2JqZWN0LnZhbHVlcyhwcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsUHJvcGVydGllcy5wdXNoKC4uLnByb3BlcnRpZXNGb3JLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlb3B0aW1pemVBbGxQcm9wZXJ0aWVzKG5vQWNjZXNzb3JzKSB7XG4gICAgICAgIGNvbnN0IGlzRGVvcHRpbWl6ZWQgPSB0aGlzLmhhc0xvc3RUcmFjayB8fCB0aGlzLmhhc1Vua25vd25EZW9wdGltaXplZFByb3BlcnR5O1xuICAgICAgICBpZiAobm9BY2Nlc3NvcnMpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzVW5rbm93bkRlb3B0aW1pemVkUHJvcGVydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYXNMb3N0VHJhY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Rlb3B0aW1pemVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0aWVzIG9mIFtcbiAgICAgICAgICAgIC4uLk9iamVjdC52YWx1ZXModGhpcy5wcm9wZXJ0aWVzQW5kR2V0dGVyc0J5S2V5KSxcbiAgICAgICAgICAgIC4uLk9iamVjdC52YWx1ZXModGhpcy5zZXR0ZXJzQnlLZXkpXG4gICAgICAgIF0pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgcHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5LmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hpbGUgdGhlIHByb3RvdHlwZSBpdHNlbGYgY2Fubm90IGJlIG11dGF0ZWQsIGVhY2ggcHJvcGVydHkgY2FuXG4gICAgICAgIHRoaXMucHJvdG90eXBlRXhwcmVzc2lvbj8uZGVvcHRpbWl6ZVBhdGgoW1Vua25vd25LZXksIFVua25vd25LZXldKTtcbiAgICAgICAgdGhpcy5kZW9wdGltaXplQ2FjaGVkRW50aXRpZXMoKTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIpIHtcbiAgICAgICAgY29uc3QgW2tleSwgLi4uc3ViUGF0aF0gPSBwYXRoO1xuICAgICAgICBjb25zdCB7IGFyZ3MsIHR5cGUgfSA9IGludGVyYWN0aW9uO1xuICAgICAgICBpZiAodGhpcy5oYXNMb3N0VHJhY2sgfHxcbiAgICAgICAgICAgIC8vIHNpbmdsZSBwYXRocyB0aGF0IGFyZSBkZW9wdGltaXplZCB3aWxsIG5vdCBiZWNvbWUgZ2V0dGVycyBvciBzZXR0ZXJzXG4gICAgICAgICAgICAoKHR5cGUgPT09IElOVEVSQUNUSU9OX0NBTExFRCB8fCBwYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuaGFzVW5rbm93bkRlb3B0aW1pemVkUHJvcGVydHkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIHRoaXMuZGVvcHRpbWl6ZWRQYXRoc1trZXldKSkpKSB7XG4gICAgICAgICAgICBkZW9wdGltaXplSW50ZXJhY3Rpb24oaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtwcm9wZXJ0aWVzRm9yRXhhY3RNYXRjaEJ5S2V5LCByZWxldmFudFByb3BlcnRpZXNCeUtleSwgcmVsZXZhbnRVbm1hdGNoYWJsZVByb3BlcnRpZXNdID0gdHlwZSA9PT0gSU5URVJBQ1RJT05fQ0FMTEVEIHx8IHBhdGgubGVuZ3RoID4gMVxuICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzQW5kR2V0dGVyc0J5S2V5LFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydGllc0FuZEdldHRlcnNCeUtleSxcbiAgICAgICAgICAgICAgICB0aGlzLnVubWF0Y2hhYmxlUHJvcGVydGllc0FuZEdldHRlcnNcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIDogdHlwZSA9PT0gSU5URVJBQ1RJT05fQUNDRVNTRURcbiAgICAgICAgICAgICAgICA/IFt0aGlzLnByb3BlcnRpZXNBbmRHZXR0ZXJzQnlLZXksIHRoaXMuZ2V0dGVyc0J5S2V5LCB0aGlzLnVubWF0Y2hhYmxlR2V0dGVyc11cbiAgICAgICAgICAgICAgICA6IFt0aGlzLnByb3BlcnRpZXNBbmRTZXR0ZXJzQnlLZXksIHRoaXMuc2V0dGVyc0J5S2V5LCB0aGlzLnVubWF0Y2hhYmxlU2V0dGVyc107XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNGb3JFeGFjdE1hdGNoQnlLZXlba2V5XSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSByZWxldmFudFByb3BlcnRpZXNCeUtleVtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgcHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHN1YlBhdGgsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pbW11dGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBhcmd1bWVudCBvZiBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZGl0aW9uYWxFeHByZXNzaW9uc1RvQmVEZW9wdGltaXplZC5hZGQoYXJndW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgcmVsZXZhbnRVbm1hdGNoYWJsZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eS5kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aChpbnRlcmFjdGlvbiwgc3ViUGF0aCwgcmVjdXJzaW9uVHJhY2tlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSU5URUdFUl9SRUdfRVhQLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgdGhpcy51bmtub3duSW50ZWdlclByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBzdWJQYXRoLCByZWN1cnNpb25UcmFja2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnRpZXMgb2YgW1xuICAgICAgICAgICAgICAgIC4uLk9iamVjdC52YWx1ZXMocmVsZXZhbnRQcm9wZXJ0aWVzQnlLZXkpLFxuICAgICAgICAgICAgICAgIHJlbGV2YW50VW5tYXRjaGFibGVQcm9wZXJ0aWVzXG4gICAgICAgICAgICBdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBzdWJQYXRoLCByZWN1cnNpb25UcmFja2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHRoaXMudW5rbm93bkludGVnZXJQcm9wcykge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5LmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBzdWJQYXRoLCByZWN1cnNpb25UcmFja2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaW1tdXRhYmxlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFyZ3VtZW50IG9mIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRpdGlvbmFsRXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQuYWRkKGFyZ3VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm90b3R5cGVFeHByZXNzaW9uPy5kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aChpbnRlcmFjdGlvbiwgcGF0aCwgcmVjdXJzaW9uVHJhY2tlcik7XG4gICAgfVxuICAgIGRlb3B0aW1pemVJbnRlZ2VyUHJvcGVydGllcygpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzTG9zdFRyYWNrIHx8XG4gICAgICAgICAgICB0aGlzLmhhc1Vua25vd25EZW9wdGltaXplZFByb3BlcnR5IHx8XG4gICAgICAgICAgICB0aGlzLmhhc1Vua25vd25EZW9wdGltaXplZEludGVnZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc1Vua25vd25EZW9wdGltaXplZEludGVnZXIgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHByb3BlcnRpZXNBbmRHZXR0ZXJzXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnByb3BlcnRpZXNBbmRHZXR0ZXJzQnlLZXkpKSB7XG4gICAgICAgICAgICBpZiAoSU5URUdFUl9SRUdfRVhQLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgcHJvcGVydGllc0FuZEdldHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkuZGVvcHRpbWl6ZVBhdGgoVU5LTk9XTl9QQVRIKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZW9wdGltaXplQ2FjaGVkSW50ZWdlckVudGl0aWVzKCk7XG4gICAgfVxuICAgIC8vIEFzc3VtcHRpb246IElmIG9ubHkgYSBzcGVjaWZpYyBwYXRoIGlzIGRlb3B0aW1pemVkLCBubyBhY2Nlc3NvcnMgYXJlIGNyZWF0ZWRcbiAgICBkZW9wdGltaXplUGF0aChwYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0xvc3RUcmFjayB8fCB0aGlzLmltbXV0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IHBhdGhbMF07XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gVW5rbm93bkludGVnZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZW9wdGltaXplSW50ZWdlclByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVvcHRpbWl6ZUFsbFByb3BlcnRpZXMoa2V5ID09PSBVbmtub3duTm9uQWNjZXNzb3JLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkUGF0aHNba2V5XSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVvcHRpbWl6ZWRQYXRoc1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyB3ZSBvbmx5IGRlb3B0aW1pemVDYWNoZSBleGFjdCBtYXRjaGVzIGFzIGluIGFsbCBvdGhlciBjYXNlcyxcbiAgICAgICAgICAgICAgICAvLyB3ZSBkbyBub3QgcmV0dXJuIGEgbGl0ZXJhbCB2YWx1ZSBvciByZXR1cm4gZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkID0gdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZEJ5S2V5W2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXhwcmVzc2lvbiBvZiBleHByZXNzaW9uc1RvQmVEZW9wdGltaXplZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5kZW9wdGltaXplQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJQYXRoID0gcGF0aC5sZW5ndGggPT09IDEgPyBVTktOT1dOX1BBVEggOiBwYXRoLnNsaWNlKDEpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAuLi4odGhpcy5wcm9wZXJ0aWVzQW5kR2V0dGVyc0J5S2V5W2tleV0gfHwgdGhpcy51bm1hdGNoYWJsZVByb3BlcnRpZXNBbmRHZXR0ZXJzKSxcbiAgICAgICAgICAgICAgICAuLi4odGhpcy5zZXR0ZXJzQnlLZXlba2V5XSB8fCB0aGlzLnVubWF0Y2hhYmxlU2V0dGVycylcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIDogdGhpcy5hbGxQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eS5kZW9wdGltaXplUGF0aChzdWJQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24/LmRlb3B0aW1pemVQYXRoKHBhdGgubGVuZ3RoID09PSAxID8gWy4uLnBhdGgsIFVua25vd25LZXldIDogcGF0aCk7XG4gICAgfVxuICAgIGdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blRydXRoeVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IHBhdGhbMF07XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25BdFBhdGggPSB0aGlzLmdldE1lbWJlckV4cHJlc3Npb25BbmRUcmFja0Rlb3B0KGtleSwgb3JpZ2luKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25BdFBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uQXRQYXRoLmdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLnNsaWNlKDEpLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24uZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVbmtub3duVmFsdWU7XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gVU5LTk9XTl9SRVRVUk5fRVhQUkVTU0lPTjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBba2V5LCAuLi5zdWJQYXRoXSA9IHBhdGg7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25BdFBhdGggPSB0aGlzLmdldE1lbWJlckV4cHJlc3Npb25BbmRUcmFja0Rlb3B0KGtleSwgb3JpZ2luKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25BdFBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uQXRQYXRoLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHN1YlBhdGgsIGludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24uZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVOS05PV05fUkVUVVJOX0VYUFJFU1NJT047XG4gICAgfVxuICAgIGhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IFtrZXksIC4uLnN1YlBhdGhdID0gcGF0aDtcbiAgICAgICAgaWYgKHN1YlBhdGgubGVuZ3RoID4gMCB8fCBpbnRlcmFjdGlvbi50eXBlID09PSBJTlRFUkFDVElPTl9DQUxMRUQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25BdFBhdGggPSB0aGlzLmdldE1lbWJlckV4cHJlc3Npb24oa2V5KTtcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uQXRQYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25BdFBhdGguaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoc3ViUGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucHJvdG90eXBlRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24uaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSA9PT0gVW5rbm93bk5vbkFjY2Vzc29yS2V5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5oYXNMb3N0VHJhY2spXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgW3Byb3BlcnRpZXNBbmRBY2Nlc3NvcnNCeUtleSwgYWNjZXNzb3JzQnlLZXksIHVubWF0Y2hhYmxlQWNjZXNzb3JzXSA9IGludGVyYWN0aW9uLnR5cGUgPT09IElOVEVSQUNUSU9OX0FDQ0VTU0VEXG4gICAgICAgICAgICA/IFt0aGlzLnByb3BlcnRpZXNBbmRHZXR0ZXJzQnlLZXksIHRoaXMuZ2V0dGVyc0J5S2V5LCB0aGlzLnVubWF0Y2hhYmxlR2V0dGVyc11cbiAgICAgICAgICAgIDogW3RoaXMucHJvcGVydGllc0FuZFNldHRlcnNCeUtleSwgdGhpcy5zZXR0ZXJzQnlLZXksIHRoaXMudW5tYXRjaGFibGVTZXR0ZXJzXTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllc0FuZEFjY2Vzc29yc0J5S2V5W2tleV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2Nlc3NvcnMgPSBhY2Nlc3NvcnNCeUtleVtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChhY2Nlc3NvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBhY2Nlc3NvciBvZiBhY2Nlc3NvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY2Nlc3Nvci5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChzdWJQYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBhY2Nlc3NvciBvZiB1bm1hdGNoYWJsZUFjY2Vzc29ycykge1xuICAgICAgICAgICAgICAgIGlmIChhY2Nlc3Nvci5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChzdWJQYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhY2Nlc3NvcnMgb2YgWy4uLk9iamVjdC52YWx1ZXMoYWNjZXNzb3JzQnlLZXkpLCB1bm1hdGNoYWJsZUFjY2Vzc29yc10pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFjY2Vzc29yIG9mIGFjY2Vzc29ycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWNjZXNzb3IuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoc3ViUGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24uaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYnVpbGRQcm9wZXJ0eU1hcHMocHJvcGVydGllcykge1xuICAgICAgICBjb25zdCB7IGFsbFByb3BlcnRpZXMsIHByb3BlcnRpZXNBbmRHZXR0ZXJzQnlLZXksIHByb3BlcnRpZXNBbmRTZXR0ZXJzQnlLZXksIHNldHRlcnNCeUtleSwgZ2V0dGVyc0J5S2V5LCB1bmtub3duSW50ZWdlclByb3BzLCB1bm1hdGNoYWJsZVByb3BlcnRpZXNBbmRHZXR0ZXJzLCB1bm1hdGNoYWJsZUdldHRlcnMsIHVubWF0Y2hhYmxlU2V0dGVycyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdW5tYXRjaGFibGVQcm9wZXJ0aWVzQW5kU2V0dGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IHByb3BlcnRpZXMubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgICAgICAgICAgY29uc3QgeyBrZXksIGtpbmQsIHByb3BlcnR5IH0gPSBwcm9wZXJ0aWVzW2luZGV4XTtcbiAgICAgICAgICAgIGFsbFByb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2luZCA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0aWVzQW5kU2V0dGVyc0J5S2V5W2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXNBbmRTZXR0ZXJzQnlLZXlba2V5XSA9IFtwcm9wZXJ0eSwgLi4udW5tYXRjaGFibGVQcm9wZXJ0aWVzQW5kU2V0dGVyc107XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXJzQnlLZXlba2V5XSA9IFtwcm9wZXJ0eSwgLi4udW5tYXRjaGFibGVTZXR0ZXJzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChraW5kID09PSAnZ2V0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnRpZXNBbmRHZXR0ZXJzQnlLZXlba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllc0FuZEdldHRlcnNCeUtleVtrZXldID0gW3Byb3BlcnR5LCAuLi51bm1hdGNoYWJsZVByb3BlcnRpZXNBbmRHZXR0ZXJzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldHRlcnNCeUtleVtrZXldID0gW3Byb3BlcnR5LCAuLi51bm1hdGNoYWJsZUdldHRlcnNdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnRpZXNBbmRTZXR0ZXJzQnlLZXlba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllc0FuZFNldHRlcnNCeUtleVtrZXldID0gW3Byb3BlcnR5LCAuLi51bm1hdGNoYWJsZVByb3BlcnRpZXNBbmRTZXR0ZXJzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnRpZXNBbmRHZXR0ZXJzQnlLZXlba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllc0FuZEdldHRlcnNCeUtleVtrZXldID0gW3Byb3BlcnR5LCAuLi51bm1hdGNoYWJsZVByb3BlcnRpZXNBbmRHZXR0ZXJzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFVua25vd25JbnRlZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHVua25vd25JbnRlZ2VyUHJvcHMucHVzaChwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2luZCA9PT0gJ3NldCcpXG4gICAgICAgICAgICAgICAgICAgIHVubWF0Y2hhYmxlU2V0dGVycy5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICBpZiAoa2luZCA9PT0gJ2dldCcpXG4gICAgICAgICAgICAgICAgICAgIHVubWF0Y2hhYmxlR2V0dGVycy5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICBpZiAoa2luZCAhPT0gJ2dldCcpXG4gICAgICAgICAgICAgICAgICAgIHVubWF0Y2hhYmxlUHJvcGVydGllc0FuZFNldHRlcnMucHVzaChwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgaWYgKGtpbmQgIT09ICdzZXQnKVxuICAgICAgICAgICAgICAgICAgICB1bm1hdGNoYWJsZVByb3BlcnRpZXNBbmRHZXR0ZXJzLnB1c2gocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlb3B0aW1pemVDYWNoZWRFbnRpdGllcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uc1RvQmVEZW9wdGltaXplZCBvZiBPYmplY3QudmFsdWVzKHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWRCeUtleSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXhwcmVzc2lvbiBvZiBleHByZXNzaW9uc1RvQmVEZW9wdGltaXplZCkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24uZGVvcHRpbWl6ZUNhY2hlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIHRoaXMuYWRkaXRpb25hbEV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uLmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVvcHRpbWl6ZUNhY2hlZEludGVnZXJFbnRpdGllcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBleHByZXNzaW9uc1RvQmVEZW9wdGltaXplZF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZEJ5S2V5KSkge1xuICAgICAgICAgICAgaWYgKElOVEVHRVJfUkVHX0VYUC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV4cHJlc3Npb24gb2YgZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5kZW9wdGltaXplQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIHRoaXMuYWRkaXRpb25hbEV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uLmRlb3B0aW1pemVQYXRoKFVOS05PV05fSU5URUdFUl9QQVRIKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRNZW1iZXJFeHByZXNzaW9uKGtleSkge1xuICAgICAgICBpZiAodGhpcy5oYXNMb3N0VHJhY2sgfHxcbiAgICAgICAgICAgIHRoaXMuaGFzVW5rbm93bkRlb3B0aW1pemVkUHJvcGVydHkgfHxcbiAgICAgICAgICAgIHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAodGhpcy5oYXNVbmtub3duRGVvcHRpbWl6ZWRJbnRlZ2VyICYmIElOVEVHRVJfUkVHX0VYUC50ZXN0KGtleSkpIHx8XG4gICAgICAgICAgICB0aGlzLmRlb3B0aW1pemVkUGF0aHNba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIFVOS05PV05fRVhQUkVTU0lPTjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzQW5kR2V0dGVyc0J5S2V5W2tleV07XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzPy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0aWVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzIHx8XG4gICAgICAgICAgICB0aGlzLnVubWF0Y2hhYmxlUHJvcGVydGllc0FuZEdldHRlcnMubGVuZ3RoID4gMCB8fFxuICAgICAgICAgICAgKHRoaXMudW5rbm93bkludGVnZXJQcm9wcy5sZW5ndGggPiAwICYmIElOVEVHRVJfUkVHX0VYUC50ZXN0KGtleSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gVU5LTk9XTl9FWFBSRVNTSU9OO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXRNZW1iZXJFeHByZXNzaW9uQW5kVHJhY2tEZW9wdChrZXksIG9yaWdpbikge1xuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBVTktOT1dOX0VYUFJFU1NJT047XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHRoaXMuZ2V0TWVtYmVyRXhwcmVzc2lvbihrZXkpO1xuICAgICAgICBpZiAoIShleHByZXNzaW9uID09PSBVTktOT1dOX0VYUFJFU1NJT04gfHwgdGhpcy5pbW11dGFibGUpKSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uc1RvQmVEZW9wdGltaXplZCA9ICh0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkQnlLZXlba2V5XSA9XG4gICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZEJ5S2V5W2tleV0gfHwgW10pO1xuICAgICAgICAgICAgZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQucHVzaChvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgIH1cbn1cblxuY29uc3QgaXNJbnRlZ2VyID0gKHByb3BlcnR5KSA9PiB0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnICYmIC9eXFxkKyQvLnRlc3QocHJvcGVydHkpO1xuLy8gVGhpcyBtYWtlcyBzdXJlIHVua25vd24gcHJvcGVydGllcyBhcmUgbm90IGhhbmRsZWQgYXMgXCJ1bmRlZmluZWRcIiBidXQgYXNcbi8vIFwidW5rbm93blwiIGJ1dCB3aXRob3V0IGFjY2VzcyBzaWRlIGVmZmVjdHMuIEFuIGV4Y2VwdGlvbiBpcyBkb25lIGZvciBudW1lcmljXG4vLyBwcm9wZXJ0aWVzIGFzIHdlIGRvIG5vdCBleHBlY3QgbmV3IGJ1aWx0aW4gcHJvcGVydGllcyB0byBiZSBudW1iZXJzLCB0aGlzXG4vLyB3aWxsIGltcHJvdmUgdHJlZS1zaGFraW5nIGZvciBvdXQtb2YtYm91bmRzIGFycmF5IHByb3BlcnRpZXNcbmNvbnN0IE9CSkVDVF9QUk9UT1RZUEVfRkFMTEJBQ0sgPSBuZXcgKGNsYXNzIE9iamVjdFByb3RvdHlwZUZhbGxiYWNrRXhwcmVzc2lvbiBleHRlbmRzIEV4cHJlc3Npb25FbnRpdHkge1xuICAgIGRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoKSB7XG4gICAgICAgIGlmIChpbnRlcmFjdGlvbi50eXBlID09PSBJTlRFUkFDVElPTl9DQUxMRUQgJiYgcGF0aC5sZW5ndGggPT09IDEgJiYgIWlzSW50ZWdlcihwYXRoWzBdKSkge1xuICAgICAgICAgICAgZGVvcHRpbWl6ZUludGVyYWN0aW9uKGludGVyYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCkge1xuICAgICAgICAvLyBXZSBpZ25vcmUgbnVtYmVyIHByb3BlcnRpZXMgYXMgd2UgZG8gbm90IGV4cGVjdCBuZXcgcHJvcGVydGllcyB0byBiZVxuICAgICAgICAvLyBudW1iZXJzIGFuZCBhbHNvIHdhbnQgdG8ga2VlcCBoYW5kbGluZyBvdXQtb2YtYm91bmQgYXJyYXkgZWxlbWVudHMgYXNcbiAgICAgICAgLy8gXCJ1bmRlZmluZWRcIlxuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPT09IDEgJiYgaXNJbnRlZ2VyKHBhdGhbMF0pID8gdW5kZWZpbmVkIDogVW5rbm93blZhbHVlO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCB7IHR5cGUgfSkge1xuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAxIHx8IHR5cGUgPT09IElOVEVSQUNUSU9OX0NBTExFRDtcbiAgICB9XG59KSgpO1xuY29uc3QgT0JKRUNUX1BST1RPVFlQRSA9IG5ldyBPYmplY3RFbnRpdHkoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBoYXNPd25Qcm9wZXJ0eTogTUVUSE9EX1JFVFVSTlNfQk9PTEVBTixcbiAgICBpc1Byb3RvdHlwZU9mOiBNRVRIT0RfUkVUVVJOU19CT09MRUFOLFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlOiBNRVRIT0RfUkVUVVJOU19CT09MRUFOLFxuICAgIHRvTG9jYWxlU3RyaW5nOiBNRVRIT0RfUkVUVVJOU19TVFJJTkcsXG4gICAgdG9TdHJpbmc6IE1FVEhPRF9SRVRVUk5TX1NUUklORyxcbiAgICB2YWx1ZU9mOiBNRVRIT0RfUkVUVVJOU19VTktOT1dOXG59LCBPQkpFQ1RfUFJPVE9UWVBFX0ZBTExCQUNLLCB0cnVlKTtcblxuY29uc3QgTkVXX0FSUkFZX1BST1BFUlRJRVMgPSBbXG4gICAgeyBrZXk6IFVua25vd25JbnRlZ2VyLCBraW5kOiAnaW5pdCcsIHByb3BlcnR5OiBVTktOT1dOX0VYUFJFU1NJT04gfSxcbiAgICB7IGtleTogJ2xlbmd0aCcsIGtpbmQ6ICdpbml0JywgcHJvcGVydHk6IFVOS05PV05fTElURVJBTF9OVU1CRVIgfVxuXTtcbmNvbnN0IE1FVEhPRF9DQUxMU19BUkdfREVPUFRTX1NFTEZfUkVUVVJOU19CT09MRUFOID0gW1xuICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICBjYWxsc0FyZ3M6IFswXSxcbiAgICAgICAgbXV0YXRlc0FyZ3M6IGZhbHNlLFxuICAgICAgICBtdXRhdGVzU2VsZkFzQXJyYXk6ICdkZW9wdC1vbmx5JyxcbiAgICAgICAgcmV0dXJuczogbnVsbCxcbiAgICAgICAgcmV0dXJuc1ByaW1pdGl2ZTogVU5LTk9XTl9MSVRFUkFMX0JPT0xFQU5cbiAgICB9KVxuXTtcbmNvbnN0IE1FVEhPRF9DQUxMU19BUkdfREVPUFRTX1NFTEZfUkVUVVJOU19OVU1CRVIgPSBbXG4gICAgbmV3IE1ldGhvZCh7XG4gICAgICAgIGNhbGxzQXJnczogWzBdLFxuICAgICAgICBtdXRhdGVzQXJnczogZmFsc2UsXG4gICAgICAgIG11dGF0ZXNTZWxmQXNBcnJheTogJ2Rlb3B0LW9ubHknLFxuICAgICAgICByZXR1cm5zOiBudWxsLFxuICAgICAgICByZXR1cm5zUHJpbWl0aXZlOiBVTktOT1dOX0xJVEVSQUxfTlVNQkVSXG4gICAgfSlcbl07XG5jb25zdCBNRVRIT0RfTVVUQVRFU19TRUxGX1JFVFVSTlNfTkVXX0FSUkFZID0gW1xuICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICBjYWxsc0FyZ3M6IG51bGwsXG4gICAgICAgIG11dGF0ZXNBcmdzOiBmYWxzZSxcbiAgICAgICAgbXV0YXRlc1NlbGZBc0FycmF5OiB0cnVlLFxuICAgICAgICByZXR1cm5zOiAoKSA9PiBuZXcgT2JqZWN0RW50aXR5KE5FV19BUlJBWV9QUk9QRVJUSUVTLCBBUlJBWV9QUk9UT1RZUEUpLFxuICAgICAgICByZXR1cm5zUHJpbWl0aXZlOiBudWxsXG4gICAgfSlcbl07XG5jb25zdCBNRVRIT0RfREVPUFRTX1NFTEZfUkVUVVJOU19ORVdfQVJSQVkgPSBbXG4gICAgbmV3IE1ldGhvZCh7XG4gICAgICAgIGNhbGxzQXJnczogbnVsbCxcbiAgICAgICAgbXV0YXRlc0FyZ3M6IGZhbHNlLFxuICAgICAgICBtdXRhdGVzU2VsZkFzQXJyYXk6ICdkZW9wdC1vbmx5JyxcbiAgICAgICAgcmV0dXJuczogKCkgPT4gbmV3IE9iamVjdEVudGl0eShORVdfQVJSQVlfUFJPUEVSVElFUywgQVJSQVlfUFJPVE9UWVBFKSxcbiAgICAgICAgcmV0dXJuc1ByaW1pdGl2ZTogbnVsbFxuICAgIH0pXG5dO1xuY29uc3QgTUVUSE9EX0NBTExTX0FSR19ERU9QVFNfU0VMRl9SRVRVUk5TX05FV19BUlJBWSA9IFtcbiAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgY2FsbHNBcmdzOiBbMF0sXG4gICAgICAgIG11dGF0ZXNBcmdzOiBmYWxzZSxcbiAgICAgICAgbXV0YXRlc1NlbGZBc0FycmF5OiAnZGVvcHQtb25seScsXG4gICAgICAgIHJldHVybnM6ICgpID0+IG5ldyBPYmplY3RFbnRpdHkoTkVXX0FSUkFZX1BST1BFUlRJRVMsIEFSUkFZX1BST1RPVFlQRSksXG4gICAgICAgIHJldHVybnNQcmltaXRpdmU6IG51bGxcbiAgICB9KVxuXTtcbmNvbnN0IE1FVEhPRF9NVVRBVEVTX1NFTEZfQU5EX0FSR1NfUkVUVVJOU19OVU1CRVIgPSBbXG4gICAgbmV3IE1ldGhvZCh7XG4gICAgICAgIGNhbGxzQXJnczogbnVsbCxcbiAgICAgICAgbXV0YXRlc0FyZ3M6IHRydWUsXG4gICAgICAgIG11dGF0ZXNTZWxmQXNBcnJheTogdHJ1ZSxcbiAgICAgICAgcmV0dXJuczogbnVsbCxcbiAgICAgICAgcmV0dXJuc1ByaW1pdGl2ZTogVU5LTk9XTl9MSVRFUkFMX05VTUJFUlxuICAgIH0pXG5dO1xuY29uc3QgTUVUSE9EX01VVEFURVNfU0VMRl9SRVRVUk5TX1VOS05PV04gPSBbXG4gICAgbmV3IE1ldGhvZCh7XG4gICAgICAgIGNhbGxzQXJnczogbnVsbCxcbiAgICAgICAgbXV0YXRlc0FyZ3M6IGZhbHNlLFxuICAgICAgICBtdXRhdGVzU2VsZkFzQXJyYXk6IHRydWUsXG4gICAgICAgIHJldHVybnM6IG51bGwsXG4gICAgICAgIHJldHVybnNQcmltaXRpdmU6IFVOS05PV05fRVhQUkVTU0lPTlxuICAgIH0pXG5dO1xuY29uc3QgTUVUSE9EX0RFT1BUU19TRUxGX1JFVFVSTlNfVU5LTk9XTiA9IFtcbiAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgY2FsbHNBcmdzOiBudWxsLFxuICAgICAgICBtdXRhdGVzQXJnczogZmFsc2UsXG4gICAgICAgIG11dGF0ZXNTZWxmQXNBcnJheTogJ2Rlb3B0LW9ubHknLFxuICAgICAgICByZXR1cm5zOiBudWxsLFxuICAgICAgICByZXR1cm5zUHJpbWl0aXZlOiBVTktOT1dOX0VYUFJFU1NJT05cbiAgICB9KVxuXTtcbmNvbnN0IE1FVEhPRF9DQUxMU19BUkdfREVPUFRTX1NFTEZfUkVUVVJOU19VTktOT1dOID0gW1xuICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICBjYWxsc0FyZ3M6IFswXSxcbiAgICAgICAgbXV0YXRlc0FyZ3M6IGZhbHNlLFxuICAgICAgICBtdXRhdGVzU2VsZkFzQXJyYXk6ICdkZW9wdC1vbmx5JyxcbiAgICAgICAgcmV0dXJuczogbnVsbCxcbiAgICAgICAgcmV0dXJuc1ByaW1pdGl2ZTogVU5LTk9XTl9FWFBSRVNTSU9OXG4gICAgfSlcbl07XG5jb25zdCBNRVRIT0RfTVVUQVRFU19TRUxGX1JFVFVSTlNfU0VMRiA9IFtcbiAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgY2FsbHNBcmdzOiBudWxsLFxuICAgICAgICBtdXRhdGVzQXJnczogZmFsc2UsXG4gICAgICAgIG11dGF0ZXNTZWxmQXNBcnJheTogdHJ1ZSxcbiAgICAgICAgcmV0dXJuczogJ3NlbGYnLFxuICAgICAgICByZXR1cm5zUHJpbWl0aXZlOiBudWxsXG4gICAgfSlcbl07XG5jb25zdCBNRVRIT0RfQ0FMTFNfQVJHX01VVEFURVNfU0VMRl9SRVRVUk5TX1NFTEYgPSBbXG4gICAgbmV3IE1ldGhvZCh7XG4gICAgICAgIGNhbGxzQXJnczogWzBdLFxuICAgICAgICBtdXRhdGVzQXJnczogZmFsc2UsXG4gICAgICAgIG11dGF0ZXNTZWxmQXNBcnJheTogdHJ1ZSxcbiAgICAgICAgcmV0dXJuczogJ3NlbGYnLFxuICAgICAgICByZXR1cm5zUHJpbWl0aXZlOiBudWxsXG4gICAgfSlcbl07XG5jb25zdCBBUlJBWV9QUk9UT1RZUEUgPSBuZXcgT2JqZWN0RW50aXR5KHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgLy8gV2UgYXNzdW1lIHRoYXQgYWNjZXNzb3JzIGhhdmUgZWZmZWN0cyBhcyB3ZSBkbyBub3QgdHJhY2sgdGhlIGFjY2Vzc2VkIHZhbHVlIGFmdGVyd2FyZHNcbiAgICBhdDogTUVUSE9EX0RFT1BUU19TRUxGX1JFVFVSTlNfVU5LTk9XTixcbiAgICBjb25jYXQ6IE1FVEhPRF9ERU9QVFNfU0VMRl9SRVRVUk5TX05FV19BUlJBWSxcbiAgICBjb3B5V2l0aGluOiBNRVRIT0RfTVVUQVRFU19TRUxGX1JFVFVSTlNfU0VMRixcbiAgICBlbnRyaWVzOiBNRVRIT0RfREVPUFRTX1NFTEZfUkVUVVJOU19ORVdfQVJSQVksXG4gICAgZXZlcnk6IE1FVEhPRF9DQUxMU19BUkdfREVPUFRTX1NFTEZfUkVUVVJOU19CT09MRUFOLFxuICAgIGZpbGw6IE1FVEhPRF9NVVRBVEVTX1NFTEZfUkVUVVJOU19TRUxGLFxuICAgIGZpbHRlcjogTUVUSE9EX0NBTExTX0FSR19ERU9QVFNfU0VMRl9SRVRVUk5TX05FV19BUlJBWSxcbiAgICBmaW5kOiBNRVRIT0RfQ0FMTFNfQVJHX0RFT1BUU19TRUxGX1JFVFVSTlNfVU5LTk9XTixcbiAgICBmaW5kSW5kZXg6IE1FVEhPRF9DQUxMU19BUkdfREVPUFRTX1NFTEZfUkVUVVJOU19OVU1CRVIsXG4gICAgZmluZExhc3Q6IE1FVEhPRF9DQUxMU19BUkdfREVPUFRTX1NFTEZfUkVUVVJOU19VTktOT1dOLFxuICAgIGZpbmRMYXN0SW5kZXg6IE1FVEhPRF9DQUxMU19BUkdfREVPUFRTX1NFTEZfUkVUVVJOU19OVU1CRVIsXG4gICAgZmxhdDogTUVUSE9EX0RFT1BUU19TRUxGX1JFVFVSTlNfTkVXX0FSUkFZLFxuICAgIGZsYXRNYXA6IE1FVEhPRF9DQUxMU19BUkdfREVPUFRTX1NFTEZfUkVUVVJOU19ORVdfQVJSQVksXG4gICAgZm9yRWFjaDogTUVUSE9EX0NBTExTX0FSR19ERU9QVFNfU0VMRl9SRVRVUk5TX1VOS05PV04sXG4gICAgaW5jbHVkZXM6IE1FVEhPRF9SRVRVUk5TX0JPT0xFQU4sXG4gICAgaW5kZXhPZjogTUVUSE9EX1JFVFVSTlNfTlVNQkVSLFxuICAgIGpvaW46IE1FVEhPRF9SRVRVUk5TX1NUUklORyxcbiAgICBrZXlzOiBNRVRIT0RfUkVUVVJOU19VTktOT1dOLFxuICAgIGxhc3RJbmRleE9mOiBNRVRIT0RfUkVUVVJOU19OVU1CRVIsXG4gICAgbWFwOiBNRVRIT0RfQ0FMTFNfQVJHX0RFT1BUU19TRUxGX1JFVFVSTlNfTkVXX0FSUkFZLFxuICAgIHBvcDogTUVUSE9EX01VVEFURVNfU0VMRl9SRVRVUk5TX1VOS05PV04sXG4gICAgcHVzaDogTUVUSE9EX01VVEFURVNfU0VMRl9BTkRfQVJHU19SRVRVUk5TX05VTUJFUixcbiAgICByZWR1Y2U6IE1FVEhPRF9DQUxMU19BUkdfREVPUFRTX1NFTEZfUkVUVVJOU19VTktOT1dOLFxuICAgIHJlZHVjZVJpZ2h0OiBNRVRIT0RfQ0FMTFNfQVJHX0RFT1BUU19TRUxGX1JFVFVSTlNfVU5LTk9XTixcbiAgICByZXZlcnNlOiBNRVRIT0RfTVVUQVRFU19TRUxGX1JFVFVSTlNfU0VMRixcbiAgICBzaGlmdDogTUVUSE9EX01VVEFURVNfU0VMRl9SRVRVUk5TX1VOS05PV04sXG4gICAgc2xpY2U6IE1FVEhPRF9ERU9QVFNfU0VMRl9SRVRVUk5TX05FV19BUlJBWSxcbiAgICBzb21lOiBNRVRIT0RfQ0FMTFNfQVJHX0RFT1BUU19TRUxGX1JFVFVSTlNfQk9PTEVBTixcbiAgICBzb3J0OiBNRVRIT0RfQ0FMTFNfQVJHX01VVEFURVNfU0VMRl9SRVRVUk5TX1NFTEYsXG4gICAgc3BsaWNlOiBNRVRIT0RfTVVUQVRFU19TRUxGX1JFVFVSTlNfTkVXX0FSUkFZLFxuICAgIHRvTG9jYWxlU3RyaW5nOiBNRVRIT0RfUkVUVVJOU19TVFJJTkcsXG4gICAgdG9TdHJpbmc6IE1FVEhPRF9SRVRVUk5TX1NUUklORyxcbiAgICB1bnNoaWZ0OiBNRVRIT0RfTVVUQVRFU19TRUxGX0FORF9BUkdTX1JFVFVSTlNfTlVNQkVSLFxuICAgIHZhbHVlczogTUVUSE9EX0RFT1BUU19TRUxGX1JFVFVSTlNfVU5LTk9XTlxufSwgT0JKRUNUX1BST1RPVFlQRSwgdHJ1ZSk7XG5cbmNsYXNzIEFycmF5RXhwcmVzc2lvbiBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5vYmplY3RFbnRpdHkgPSBudWxsO1xuICAgIH1cbiAgICBkZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aChpbnRlcmFjdGlvbiwgcGF0aCwgcmVjdXJzaW9uVHJhY2tlcikge1xuICAgICAgICB0aGlzLmdldE9iamVjdEVudGl0eSgpLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoLCByZWN1cnNpb25UcmFja2VyKTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZVBhdGgocGF0aCkge1xuICAgICAgICB0aGlzLmdldE9iamVjdEVudGl0eSgpLmRlb3B0aW1pemVQYXRoKHBhdGgpO1xuICAgIH1cbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdEVudGl0eSgpLmdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgIH1cbiAgICBnZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdEVudGl0eSgpLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGFwcGx5RGVvcHRpbWl6YXRpb25zKCkge1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGhhc1NwcmVhZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5lbGVtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIChoYXNTcHJlYWQgfHwgZWxlbWVudCBpbnN0YW5jZW9mIFNwcmVhZEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgaGFzU3ByZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY29wZS5jb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKTtcbiAgICB9XG4gICAgZ2V0T2JqZWN0RW50aXR5KCkge1xuICAgICAgICBpZiAodGhpcy5vYmplY3RFbnRpdHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdEVudGl0eTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gW1xuICAgICAgICAgICAgeyBrZXk6ICdsZW5ndGgnLCBraW5kOiAnaW5pdCcsIHByb3BlcnR5OiBVTktOT1dOX0xJVEVSQUxfTlVNQkVSIH1cbiAgICAgICAgXTtcbiAgICAgICAgbGV0IGhhc1NwcmVhZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5lbGVtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChoYXNTcHJlYWQgfHwgZWxlbWVudCBpbnN0YW5jZW9mIFNwcmVhZEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBoYXNTcHJlYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnVuc2hpZnQoeyBrZXk6IFVua25vd25JbnRlZ2VyLCBraW5kOiAnaW5pdCcsIHByb3BlcnR5OiBlbGVtZW50IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goeyBrZXk6IFN0cmluZyhpbmRleCksIGtpbmQ6ICdpbml0JywgcHJvcGVydHk6IGVsZW1lbnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goeyBrZXk6IFN0cmluZyhpbmRleCksIGtpbmQ6ICdpbml0JywgcHJvcGVydHk6IFVOREVGSU5FRF9FWFBSRVNTSU9OIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5vYmplY3RFbnRpdHkgPSBuZXcgT2JqZWN0RW50aXR5KHByb3BlcnRpZXMsIEFSUkFZX1BST1RPVFlQRSkpO1xuICAgIH1cbn1cblxuLyogZXNsaW50IHNvcnQta2V5czogXCJvZmZcIiAqL1xuY29uc3QgVmFsdWVQcm9wZXJ0aWVzID0gU3ltYm9sKCdWYWx1ZSBQcm9wZXJ0aWVzJyk7XG5jb25zdCBnZXRUcnV0aHlMaXRlcmFsVmFsdWUgPSAoKSA9PiBVbmtub3duVHJ1dGh5VmFsdWU7XG5jb25zdCByZXR1cm5GYWxzZSA9ICgpID0+IGZhbHNlO1xuY29uc3QgcmV0dXJuVHJ1ZSA9ICgpID0+IHRydWU7XG5jb25zdCBQVVJFID0ge1xuICAgIGRlb3B0aW1pemVBcmd1bWVudHNPbkNhbGw6IGRvTm90aGluZyxcbiAgICBnZXRMaXRlcmFsVmFsdWU6IGdldFRydXRoeUxpdGVyYWxWYWx1ZSxcbiAgICBoYXNFZmZlY3RzV2hlbkNhbGxlZDogcmV0dXJuRmFsc2Vcbn07XG5jb25zdCBJTVBVUkUgPSB7XG4gICAgZGVvcHRpbWl6ZUFyZ3VtZW50c09uQ2FsbDogZG9Ob3RoaW5nLFxuICAgIGdldExpdGVyYWxWYWx1ZTogZ2V0VHJ1dGh5TGl0ZXJhbFZhbHVlLFxuICAgIGhhc0VmZmVjdHNXaGVuQ2FsbGVkOiByZXR1cm5UcnVlXG59O1xuY29uc3QgUFVSRV9XSVRIX0FSUkFZID0ge1xuICAgIGRlb3B0aW1pemVBcmd1bWVudHNPbkNhbGw6IGRvTm90aGluZyxcbiAgICBnZXRMaXRlcmFsVmFsdWU6IGdldFRydXRoeUxpdGVyYWxWYWx1ZSxcbiAgICBoYXNFZmZlY3RzV2hlbkNhbGxlZCh7IGFyZ3MgfSkge1xuICAgICAgICByZXR1cm4gYXJncy5sZW5ndGggPiAxICYmICEoYXJnc1sxXSBpbnN0YW5jZW9mIEFycmF5RXhwcmVzc2lvbik7XG4gICAgfVxufTtcbmNvbnN0IEdFVFRFUl9BQ0NFU1MgPSB7XG4gICAgZGVvcHRpbWl6ZUFyZ3VtZW50c09uQ2FsbDogZG9Ob3RoaW5nLFxuICAgIGdldExpdGVyYWxWYWx1ZTogZ2V0VHJ1dGh5TGl0ZXJhbFZhbHVlLFxuICAgIGhhc0VmZmVjdHNXaGVuQ2FsbGVkKHsgYXJncyB9LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IFtfdGhpc0FyZ3VtZW50LCBmaXJzdEFyZ3VtZW50XSA9IGFyZ3M7XG4gICAgICAgIHJldHVybiAoIShmaXJzdEFyZ3VtZW50IGluc3RhbmNlb2YgRXhwcmVzc2lvbkVudGl0eSkgfHxcbiAgICAgICAgICAgIGZpcnN0QXJndW1lbnQuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoVU5LTk9XTl9QQVRILCBOT0RFX0lOVEVSQUNUSU9OX1VOS05PV05fQUNDRVNTLCBjb250ZXh0KSk7XG4gICAgfVxufTtcbi8vIFdlIHVzZSBzaG9ydGVuZWQgdmFyaWFibGVzIHRvIHJlZHVjZSBmaWxlIHNpemUgaGVyZVxuLyogT0JKRUNUICovXG5jb25zdCBPID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBbVmFsdWVQcm9wZXJ0aWVzXTogSU1QVVJFXG59O1xuLyogUFVSRSBGVU5DVElPTiAqL1xuY29uc3QgUEYgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIFtWYWx1ZVByb3BlcnRpZXNdOiBQVVJFXG59O1xuLyogUFVSRSBGVU5DVElPTiBJRiBGSVJTVCBBUkcgRE9FUyBOT1QgQ09OVEFJTiBBIEdFVFRFUiAqL1xuY29uc3QgUEZfTk9fR0VUVEVSID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBbVmFsdWVQcm9wZXJ0aWVzXTogR0VUVEVSX0FDQ0VTU1xufTtcbi8qIEZVTkNUSU9OIFRIQVQgTVVUQVRFUyBGSVJTVCBBUkcgV0lUSE9VVCBUUklHR0VSSU5HIEFDQ0VTU09SUyAqL1xuY29uc3QgTVVUQVRFU19BUkdfV0lUSE9VVF9BQ0NFU1NPUiA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgW1ZhbHVlUHJvcGVydGllc106IHtcbiAgICAgICAgZGVvcHRpbWl6ZUFyZ3VtZW50c09uQ2FsbCh7IGFyZ3M6IFssIGZpcnN0QXJndW1lbnRdIH0pIHtcbiAgICAgICAgICAgIGZpcnN0QXJndW1lbnQ/LmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldExpdGVyYWxWYWx1ZTogZ2V0VHJ1dGh5TGl0ZXJhbFZhbHVlLFxuICAgICAgICBoYXNFZmZlY3RzV2hlbkNhbGxlZCh7IGFyZ3MgfSwgY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIChhcmdzLmxlbmd0aCA8PSAxIHx8XG4gICAgICAgICAgICAgICAgYXJnc1sxXS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChVTktOT1dOX05PTl9BQ0NFU1NPUl9QQVRILCBOT0RFX0lOVEVSQUNUSU9OX1VOS05PV05fQVNTSUdOTUVOVCwgY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qIENPTlNUUlVDVE9SICovXG5jb25zdCBDID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBbVmFsdWVQcm9wZXJ0aWVzXTogSU1QVVJFLFxuICAgIHByb3RvdHlwZTogT1xufTtcbi8qIFBVUkUgQ09OU1RSVUNUT1IgKi9cbmNvbnN0IFBDID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBbVmFsdWVQcm9wZXJ0aWVzXTogUFVSRSxcbiAgICBwcm90b3R5cGU6IE9cbn07XG5jb25zdCBQQ19XSVRIX0FSUkFZID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBbVmFsdWVQcm9wZXJ0aWVzXTogUFVSRV9XSVRIX0FSUkFZLFxuICAgIHByb3RvdHlwZTogT1xufTtcbmNvbnN0IEFSUkFZX1RZUEUgPSB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIFtWYWx1ZVByb3BlcnRpZXNdOiBQVVJFLFxuICAgIGZyb206IE8sXG4gICAgb2Y6IFBGLFxuICAgIHByb3RvdHlwZTogT1xufTtcbmNvbnN0IElOVExfTUVNQkVSID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBbVmFsdWVQcm9wZXJ0aWVzXTogUFVSRSxcbiAgICBzdXBwb3J0ZWRMb2NhbGVzT2Y6IFBDXG59O1xuY29uc3Qga25vd25HbG9iYWxzID0ge1xuICAgIC8vIFBsYWNlaG9sZGVycyBmb3IgZ2xvYmFsIG9iamVjdHMgdG8gYXZvaWQgc2hhcGUgbXV0YXRpb25zXG4gICAgZ2xvYmFsOiBPLFxuICAgIGdsb2JhbFRoaXM6IE8sXG4gICAgc2VsZjogTyxcbiAgICB3aW5kb3c6IE8sXG4gICAgLy8gQ29tbW9uIGdsb2JhbHNcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgW1ZhbHVlUHJvcGVydGllc106IElNUFVSRSxcbiAgICBBcnJheToge1xuICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgIFtWYWx1ZVByb3BlcnRpZXNdOiBJTVBVUkUsXG4gICAgICAgIGZyb206IE8sXG4gICAgICAgIGlzQXJyYXk6IFBGLFxuICAgICAgICBvZjogUEYsXG4gICAgICAgIHByb3RvdHlwZTogT1xuICAgIH0sXG4gICAgQXJyYXlCdWZmZXI6IHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBbVmFsdWVQcm9wZXJ0aWVzXTogUFVSRSxcbiAgICAgICAgaXNWaWV3OiBQRixcbiAgICAgICAgcHJvdG90eXBlOiBPXG4gICAgfSxcbiAgICBBZ2dyZWdhdGVFcnJvcjogUENfV0lUSF9BUlJBWSxcbiAgICBBdG9taWNzOiBPLFxuICAgIEJpZ0ludDogQyxcbiAgICBCaWdJbnQ2NEFycmF5OiBDLFxuICAgIEJpZ1VpbnQ2NEFycmF5OiBDLFxuICAgIEJvb2xlYW46IFBDLFxuICAgIGNvbnN0cnVjdG9yOiBDLFxuICAgIERhdGFWaWV3OiBQQyxcbiAgICBEYXRlOiB7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgW1ZhbHVlUHJvcGVydGllc106IFBVUkUsXG4gICAgICAgIG5vdzogUEYsXG4gICAgICAgIHBhcnNlOiBQRixcbiAgICAgICAgcHJvdG90eXBlOiBPLFxuICAgICAgICBVVEM6IFBGXG4gICAgfSxcbiAgICBkZWNvZGVVUkk6IFBGLFxuICAgIGRlY29kZVVSSUNvbXBvbmVudDogUEYsXG4gICAgZW5jb2RlVVJJOiBQRixcbiAgICBlbmNvZGVVUklDb21wb25lbnQ6IFBGLFxuICAgIEVycm9yOiBQQyxcbiAgICBlc2NhcGU6IFBGLFxuICAgIGV2YWw6IE8sXG4gICAgRXZhbEVycm9yOiBQQyxcbiAgICBGaW5hbGl6YXRpb25SZWdpc3RyeTogQyxcbiAgICBGbG9hdDMyQXJyYXk6IEFSUkFZX1RZUEUsXG4gICAgRmxvYXQ2NEFycmF5OiBBUlJBWV9UWVBFLFxuICAgIEZ1bmN0aW9uOiBDLFxuICAgIGhhc093blByb3BlcnR5OiBPLFxuICAgIEluZmluaXR5OiBPLFxuICAgIEludDE2QXJyYXk6IEFSUkFZX1RZUEUsXG4gICAgSW50MzJBcnJheTogQVJSQVlfVFlQRSxcbiAgICBJbnQ4QXJyYXk6IEFSUkFZX1RZUEUsXG4gICAgaXNGaW5pdGU6IFBGLFxuICAgIGlzTmFOOiBQRixcbiAgICBpc1Byb3RvdHlwZU9mOiBPLFxuICAgIEpTT046IE8sXG4gICAgTWFwOiBQQ19XSVRIX0FSUkFZLFxuICAgIE1hdGg6IHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBbVmFsdWVQcm9wZXJ0aWVzXTogSU1QVVJFLFxuICAgICAgICBhYnM6IFBGLFxuICAgICAgICBhY29zOiBQRixcbiAgICAgICAgYWNvc2g6IFBGLFxuICAgICAgICBhc2luOiBQRixcbiAgICAgICAgYXNpbmg6IFBGLFxuICAgICAgICBhdGFuOiBQRixcbiAgICAgICAgYXRhbjI6IFBGLFxuICAgICAgICBhdGFuaDogUEYsXG4gICAgICAgIGNicnQ6IFBGLFxuICAgICAgICBjZWlsOiBQRixcbiAgICAgICAgY2x6MzI6IFBGLFxuICAgICAgICBjb3M6IFBGLFxuICAgICAgICBjb3NoOiBQRixcbiAgICAgICAgZXhwOiBQRixcbiAgICAgICAgZXhwbTE6IFBGLFxuICAgICAgICBmbG9vcjogUEYsXG4gICAgICAgIGZyb3VuZDogUEYsXG4gICAgICAgIGh5cG90OiBQRixcbiAgICAgICAgaW11bDogUEYsXG4gICAgICAgIGxvZzogUEYsXG4gICAgICAgIGxvZzEwOiBQRixcbiAgICAgICAgbG9nMXA6IFBGLFxuICAgICAgICBsb2cyOiBQRixcbiAgICAgICAgbWF4OiBQRixcbiAgICAgICAgbWluOiBQRixcbiAgICAgICAgcG93OiBQRixcbiAgICAgICAgcmFuZG9tOiBQRixcbiAgICAgICAgcm91bmQ6IFBGLFxuICAgICAgICBzaWduOiBQRixcbiAgICAgICAgc2luOiBQRixcbiAgICAgICAgc2luaDogUEYsXG4gICAgICAgIHNxcnQ6IFBGLFxuICAgICAgICB0YW46IFBGLFxuICAgICAgICB0YW5oOiBQRixcbiAgICAgICAgdHJ1bmM6IFBGXG4gICAgfSxcbiAgICBOYU46IE8sXG4gICAgTnVtYmVyOiB7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgW1ZhbHVlUHJvcGVydGllc106IFBVUkUsXG4gICAgICAgIGlzRmluaXRlOiBQRixcbiAgICAgICAgaXNJbnRlZ2VyOiBQRixcbiAgICAgICAgaXNOYU46IFBGLFxuICAgICAgICBpc1NhZmVJbnRlZ2VyOiBQRixcbiAgICAgICAgcGFyc2VGbG9hdDogUEYsXG4gICAgICAgIHBhcnNlSW50OiBQRixcbiAgICAgICAgcHJvdG90eXBlOiBPXG4gICAgfSxcbiAgICBPYmplY3Q6IHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBbVmFsdWVQcm9wZXJ0aWVzXTogUFVSRSxcbiAgICAgICAgY3JlYXRlOiBQRixcbiAgICAgICAgLy8gVGVjaG5pY2FsbHkgdGhvc2UgY2FuIHRocm93IGluIGNlcnRhaW4gc2l0dWF0aW9ucywgYnV0IHdlIGlnbm9yZSB0aGlzIGFzXG4gICAgICAgIC8vIGNvZGUgdGhhdCByZWxpZXMgb24gdGhpcyB3aWxsIGhvcGVmdWxseSB3cmFwIHRoaXMgaW4gYSB0cnktY2F0Y2gsIHdoaWNoXG4gICAgICAgIC8vIGRlb3B0aW1pemVzIGV2ZXJ5dGhpbmcgYW55d2F5XG4gICAgICAgIGRlZmluZVByb3BlcnR5OiBNVVRBVEVTX0FSR19XSVRIT1VUX0FDQ0VTU09SLFxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzOiBNVVRBVEVTX0FSR19XSVRIT1VUX0FDQ0VTU09SLFxuICAgICAgICBmcmVlemU6IE1VVEFURVNfQVJHX1dJVEhPVVRfQUNDRVNTT1IsXG4gICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogUEYsXG4gICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6IFBGLFxuICAgICAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiBQRixcbiAgICAgICAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBQRixcbiAgICAgICAgZ2V0UHJvdG90eXBlT2Y6IFBGLFxuICAgICAgICBoYXNPd246IFBGLFxuICAgICAgICBpczogUEYsXG4gICAgICAgIGlzRXh0ZW5zaWJsZTogUEYsXG4gICAgICAgIGlzRnJvemVuOiBQRixcbiAgICAgICAgaXNTZWFsZWQ6IFBGLFxuICAgICAgICBrZXlzOiBQRixcbiAgICAgICAgZnJvbUVudHJpZXM6IE8sXG4gICAgICAgIGVudHJpZXM6IFBGX05PX0dFVFRFUixcbiAgICAgICAgdmFsdWVzOiBQRl9OT19HRVRURVIsXG4gICAgICAgIHByb3RvdHlwZTogT1xuICAgIH0sXG4gICAgcGFyc2VGbG9hdDogUEYsXG4gICAgcGFyc2VJbnQ6IFBGLFxuICAgIFByb21pc2U6IHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBbVmFsdWVQcm9wZXJ0aWVzXTogSU1QVVJFLFxuICAgICAgICBhbGw6IE8sXG4gICAgICAgIGFsbFNldHRsZWQ6IE8sXG4gICAgICAgIGFueTogTyxcbiAgICAgICAgcHJvdG90eXBlOiBPLFxuICAgICAgICByYWNlOiBPLFxuICAgICAgICByZWplY3Q6IE8sXG4gICAgICAgIHJlc29sdmU6IE9cbiAgICB9LFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlOiBPLFxuICAgIFByb3h5OiB7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgW1ZhbHVlUHJvcGVydGllc106IHtcbiAgICAgICAgICAgIGRlb3B0aW1pemVBcmd1bWVudHNPbkNhbGw6ICh7IGFyZ3M6IFssIHRhcmdldCwgcGFyYW1ldGVyXSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0RXhwcmVzc2lvbk5vZGUocGFyYW1ldGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNTcHJlYWRFbGVtZW50ID0gcGFyYW1ldGVyLnByb3BlcnRpZXMuc29tZShwcm9wZXJ0eSA9PiAhaXNQcm9wZXJ0eU5vZGUocHJvcGVydHkpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNTcHJlYWRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHBhcmFtZXRlci5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbbnVsbCwgdGFyZ2V0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogSU5URVJBQ1RJT05fQ0FMTEVELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoTmV3OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIEVNUFRZX1BBVEgsIFNIQVJFRF9SRUNVUlNJT05fVFJBQ0tFUik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0TGl0ZXJhbFZhbHVlOiBnZXRUcnV0aHlMaXRlcmFsVmFsdWUsXG4gICAgICAgICAgICBoYXNFZmZlY3RzV2hlbkNhbGxlZDogcmV0dXJuVHJ1ZVxuICAgICAgICB9XG4gICAgfSxcbiAgICBSYW5nZUVycm9yOiBQQyxcbiAgICBSZWZlcmVuY2VFcnJvcjogUEMsXG4gICAgUmVmbGVjdDogTyxcbiAgICBSZWdFeHA6IFBDLFxuICAgIFNldDogUENfV0lUSF9BUlJBWSxcbiAgICBTaGFyZWRBcnJheUJ1ZmZlcjogQyxcbiAgICBTdHJpbmc6IHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBbVmFsdWVQcm9wZXJ0aWVzXTogUFVSRSxcbiAgICAgICAgZnJvbUNoYXJDb2RlOiBQRixcbiAgICAgICAgZnJvbUNvZGVQb2ludDogUEYsXG4gICAgICAgIHByb3RvdHlwZTogTyxcbiAgICAgICAgcmF3OiBQRlxuICAgIH0sXG4gICAgU3ltYm9sOiB7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgW1ZhbHVlUHJvcGVydGllc106IFBVUkUsXG4gICAgICAgIGZvcjogUEYsXG4gICAgICAgIGtleUZvcjogUEYsXG4gICAgICAgIHByb3RvdHlwZTogTyxcbiAgICAgICAgdG9TdHJpbmdUYWc6IHtcbiAgICAgICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgICAgIFtWYWx1ZVByb3BlcnRpZXNdOiB7XG4gICAgICAgICAgICAgICAgZGVvcHRpbWl6ZUFyZ3VtZW50c09uQ2FsbDogZG9Ob3RoaW5nLFxuICAgICAgICAgICAgICAgIGdldExpdGVyYWxWYWx1ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN5bWJvbFRvU3RyaW5nVGFnO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGFzRWZmZWN0c1doZW5DYWxsZWQ6IHJldHVyblRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgU3ludGF4RXJyb3I6IFBDLFxuICAgIHRvTG9jYWxlU3RyaW5nOiBPLFxuICAgIHRvU3RyaW5nOiBPLFxuICAgIFR5cGVFcnJvcjogUEMsXG4gICAgVWludDE2QXJyYXk6IEFSUkFZX1RZUEUsXG4gICAgVWludDMyQXJyYXk6IEFSUkFZX1RZUEUsXG4gICAgVWludDhBcnJheTogQVJSQVlfVFlQRSxcbiAgICBVaW50OENsYW1wZWRBcnJheTogQVJSQVlfVFlQRSxcbiAgICAvLyBUZWNobmljYWxseSwgdGhpcyBpcyBhIGdsb2JhbCwgYnV0IGl0IG5lZWRzIHNwZWNpYWwgaGFuZGxpbmdcbiAgICAvLyB1bmRlZmluZWQ6ID8sXG4gICAgdW5lc2NhcGU6IFBGLFxuICAgIFVSSUVycm9yOiBQQyxcbiAgICB2YWx1ZU9mOiBPLFxuICAgIFdlYWtNYXA6IFBDX1dJVEhfQVJSQVksXG4gICAgV2Vha1JlZjogQyxcbiAgICBXZWFrU2V0OiBQQ19XSVRIX0FSUkFZLFxuICAgIC8vIEFkZGl0aW9uYWwgZ2xvYmFscyBzaGFyZWQgYnkgTm9kZSBhbmQgQnJvd3NlciB0aGF0IGFyZSBub3Qgc3RyaWN0bHkgcGFydCBvZiB0aGUgbGFuZ3VhZ2VcbiAgICBjbGVhckludGVydmFsOiBDLFxuICAgIGNsZWFyVGltZW91dDogQyxcbiAgICBjb25zb2xlOiB7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgW1ZhbHVlUHJvcGVydGllc106IElNUFVSRSxcbiAgICAgICAgYXNzZXJ0OiBDLFxuICAgICAgICBjbGVhcjogQyxcbiAgICAgICAgY291bnQ6IEMsXG4gICAgICAgIGNvdW50UmVzZXQ6IEMsXG4gICAgICAgIGRlYnVnOiBDLFxuICAgICAgICBkaXI6IEMsXG4gICAgICAgIGRpcnhtbDogQyxcbiAgICAgICAgZXJyb3I6IEMsXG4gICAgICAgIGV4Y2VwdGlvbjogQyxcbiAgICAgICAgZ3JvdXA6IEMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBDLFxuICAgICAgICBncm91cEVuZDogQyxcbiAgICAgICAgaW5mbzogQyxcbiAgICAgICAgbG9nOiBDLFxuICAgICAgICB0YWJsZTogQyxcbiAgICAgICAgdGltZTogQyxcbiAgICAgICAgdGltZUVuZDogQyxcbiAgICAgICAgdGltZUxvZzogQyxcbiAgICAgICAgdHJhY2U6IEMsXG4gICAgICAgIHdhcm46IENcbiAgICB9LFxuICAgIEludGw6IHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBbVmFsdWVQcm9wZXJ0aWVzXTogSU1QVVJFLFxuICAgICAgICBDb2xsYXRvcjogSU5UTF9NRU1CRVIsXG4gICAgICAgIERhdGVUaW1lRm9ybWF0OiBJTlRMX01FTUJFUixcbiAgICAgICAgRGlzcGxheU5hbWVzOiBJTlRMX01FTUJFUixcbiAgICAgICAgTGlzdEZvcm1hdDogSU5UTF9NRU1CRVIsXG4gICAgICAgIExvY2FsZTogSU5UTF9NRU1CRVIsXG4gICAgICAgIE51bWJlckZvcm1hdDogSU5UTF9NRU1CRVIsXG4gICAgICAgIFBsdXJhbFJ1bGVzOiBJTlRMX01FTUJFUixcbiAgICAgICAgUmVsYXRpdmVUaW1lRm9ybWF0OiBJTlRMX01FTUJFUixcbiAgICAgICAgU2VnbWVudGVyOiBJTlRMX01FTUJFUlxuICAgIH0sXG4gICAgc2V0SW50ZXJ2YWw6IEMsXG4gICAgc2V0VGltZW91dDogQyxcbiAgICBUZXh0RGVjb2RlcjogQyxcbiAgICBUZXh0RW5jb2RlcjogQyxcbiAgICBVUkw6IHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBbVmFsdWVQcm9wZXJ0aWVzXTogSU1QVVJFLFxuICAgICAgICBwcm90b3R5cGU6IE8sXG4gICAgICAgIGNhblBhcnNlOiBQRlxuICAgIH0sXG4gICAgVVJMU2VhcmNoUGFyYW1zOiBDLFxuICAgIC8vIEJyb3dzZXIgc3BlY2lmaWMgZ2xvYmFsc1xuICAgIEFib3J0Q29udHJvbGxlcjogQyxcbiAgICBBYm9ydFNpZ25hbDogQyxcbiAgICBhZGRFdmVudExpc3RlbmVyOiBPLFxuICAgIGFsZXJ0OiBPLFxuICAgIEFuYWx5c2VyTm9kZTogQyxcbiAgICBBbmltYXRpb246IEMsXG4gICAgQW5pbWF0aW9uRXZlbnQ6IEMsXG4gICAgYXBwbGljYXRpb25DYWNoZTogTyxcbiAgICBBcHBsaWNhdGlvbkNhY2hlOiBDLFxuICAgIEFwcGxpY2F0aW9uQ2FjaGVFcnJvckV2ZW50OiBDLFxuICAgIGF0b2I6IE8sXG4gICAgQXR0cjogQyxcbiAgICBBdWRpbzogQyxcbiAgICBBdWRpb0J1ZmZlcjogQyxcbiAgICBBdWRpb0J1ZmZlclNvdXJjZU5vZGU6IEMsXG4gICAgQXVkaW9Db250ZXh0OiBDLFxuICAgIEF1ZGlvRGVzdGluYXRpb25Ob2RlOiBDLFxuICAgIEF1ZGlvTGlzdGVuZXI6IEMsXG4gICAgQXVkaW9Ob2RlOiBDLFxuICAgIEF1ZGlvUGFyYW06IEMsXG4gICAgQXVkaW9Qcm9jZXNzaW5nRXZlbnQ6IEMsXG4gICAgQXVkaW9TY2hlZHVsZWRTb3VyY2VOb2RlOiBDLFxuICAgIEF1ZGlvV29ya2xldE5vZGU6IEMsXG4gICAgQmFyUHJvcDogQyxcbiAgICBCYXNlQXVkaW9Db250ZXh0OiBDLFxuICAgIEJhdHRlcnlNYW5hZ2VyOiBDLFxuICAgIEJlZm9yZVVubG9hZEV2ZW50OiBDLFxuICAgIEJpcXVhZEZpbHRlck5vZGU6IEMsXG4gICAgQmxvYjogQyxcbiAgICBCbG9iRXZlbnQ6IEMsXG4gICAgYmx1cjogTyxcbiAgICBCcm9hZGNhc3RDaGFubmVsOiBDLFxuICAgIGJ0b2E6IE8sXG4gICAgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneTogQyxcbiAgICBDYWNoZTogQyxcbiAgICBjYWNoZXM6IE8sXG4gICAgQ2FjaGVTdG9yYWdlOiBDLFxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lOiBPLFxuICAgIGNhbmNlbElkbGVDYWxsYmFjazogTyxcbiAgICBDYW52YXNDYXB0dXJlTWVkaWFTdHJlYW1UcmFjazogQyxcbiAgICBDYW52YXNHcmFkaWVudDogQyxcbiAgICBDYW52YXNQYXR0ZXJuOiBDLFxuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDogQyxcbiAgICBDaGFubmVsTWVyZ2VyTm9kZTogQyxcbiAgICBDaGFubmVsU3BsaXR0ZXJOb2RlOiBDLFxuICAgIENoYXJhY3RlckRhdGE6IEMsXG4gICAgY2xpZW50SW5mb3JtYXRpb246IE8sXG4gICAgQ2xpcGJvYXJkRXZlbnQ6IEMsXG4gICAgY2xvc2U6IE8sXG4gICAgY2xvc2VkOiBPLFxuICAgIENsb3NlRXZlbnQ6IEMsXG4gICAgQ29tbWVudDogQyxcbiAgICBDb21wb3NpdGlvbkV2ZW50OiBDLFxuICAgIGNvbmZpcm06IE8sXG4gICAgQ29uc3RhbnRTb3VyY2VOb2RlOiBDLFxuICAgIENvbnZvbHZlck5vZGU6IEMsXG4gICAgQ291bnRRdWV1aW5nU3RyYXRlZ3k6IEMsXG4gICAgY3JlYXRlSW1hZ2VCaXRtYXA6IE8sXG4gICAgQ3JlZGVudGlhbDogQyxcbiAgICBDcmVkZW50aWFsc0NvbnRhaW5lcjogQyxcbiAgICBjcnlwdG86IE8sXG4gICAgQ3J5cHRvOiBDLFxuICAgIENyeXB0b0tleTogQyxcbiAgICBDU1M6IEMsXG4gICAgQ1NTQ29uZGl0aW9uUnVsZTogQyxcbiAgICBDU1NGb250RmFjZVJ1bGU6IEMsXG4gICAgQ1NTR3JvdXBpbmdSdWxlOiBDLFxuICAgIENTU0ltcG9ydFJ1bGU6IEMsXG4gICAgQ1NTS2V5ZnJhbWVSdWxlOiBDLFxuICAgIENTU0tleWZyYW1lc1J1bGU6IEMsXG4gICAgQ1NTTWVkaWFSdWxlOiBDLFxuICAgIENTU05hbWVzcGFjZVJ1bGU6IEMsXG4gICAgQ1NTUGFnZVJ1bGU6IEMsXG4gICAgQ1NTUnVsZTogQyxcbiAgICBDU1NSdWxlTGlzdDogQyxcbiAgICBDU1NTdHlsZURlY2xhcmF0aW9uOiBDLFxuICAgIENTU1N0eWxlUnVsZTogQyxcbiAgICBDU1NTdHlsZVNoZWV0OiBDLFxuICAgIENTU1N1cHBvcnRzUnVsZTogQyxcbiAgICBDdXN0b21FbGVtZW50UmVnaXN0cnk6IEMsXG4gICAgY3VzdG9tRWxlbWVudHM6IE8sXG4gICAgQ3VzdG9tRXZlbnQ6IHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBbVmFsdWVQcm9wZXJ0aWVzXToge1xuICAgICAgICAgICAgZGVvcHRpbWl6ZUFyZ3VtZW50c09uQ2FsbCh7IGFyZ3MgfSkge1xuICAgICAgICAgICAgICAgIGFyZ3NbMl0/LmRlb3B0aW1pemVQYXRoKFsnZGV0YWlsJ10pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldExpdGVyYWxWYWx1ZTogZ2V0VHJ1dGh5TGl0ZXJhbFZhbHVlLFxuICAgICAgICAgICAgaGFzRWZmZWN0c1doZW5DYWxsZWQ6IHJldHVybkZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHByb3RvdHlwZTogT1xuICAgIH0sXG4gICAgRGF0YVRyYW5zZmVyOiBDLFxuICAgIERhdGFUcmFuc2Zlckl0ZW06IEMsXG4gICAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IEMsXG4gICAgZGVmYXVsdHN0YXR1czogTyxcbiAgICBkZWZhdWx0U3RhdHVzOiBPLFxuICAgIERlbGF5Tm9kZTogQyxcbiAgICBEZXZpY2VNb3Rpb25FdmVudDogQyxcbiAgICBEZXZpY2VPcmllbnRhdGlvbkV2ZW50OiBDLFxuICAgIGRldmljZVBpeGVsUmF0aW86IE8sXG4gICAgZGlzcGF0Y2hFdmVudDogTyxcbiAgICBkb2N1bWVudDogTyxcbiAgICBEb2N1bWVudDogQyxcbiAgICBEb2N1bWVudEZyYWdtZW50OiBDLFxuICAgIERvY3VtZW50VHlwZTogQyxcbiAgICBET01FcnJvcjogQyxcbiAgICBET01FeGNlcHRpb246IEMsXG4gICAgRE9NSW1wbGVtZW50YXRpb246IEMsXG4gICAgRE9NTWF0cml4OiBDLFxuICAgIERPTU1hdHJpeFJlYWRPbmx5OiBDLFxuICAgIERPTVBhcnNlcjogQyxcbiAgICBET01Qb2ludDogQyxcbiAgICBET01Qb2ludFJlYWRPbmx5OiBDLFxuICAgIERPTVF1YWQ6IEMsXG4gICAgRE9NUmVjdDogQyxcbiAgICBET01SZWN0UmVhZE9ubHk6IEMsXG4gICAgRE9NU3RyaW5nTGlzdDogQyxcbiAgICBET01TdHJpbmdNYXA6IEMsXG4gICAgRE9NVG9rZW5MaXN0OiBDLFxuICAgIERyYWdFdmVudDogQyxcbiAgICBEeW5hbWljc0NvbXByZXNzb3JOb2RlOiBDLFxuICAgIEVsZW1lbnQ6IEMsXG4gICAgRXJyb3JFdmVudDogQyxcbiAgICBFdmVudDogQyxcbiAgICBFdmVudFNvdXJjZTogQyxcbiAgICBFdmVudFRhcmdldDogQyxcbiAgICBleHRlcm5hbDogTyxcbiAgICBmZXRjaDogTyxcbiAgICBGaWxlOiBDLFxuICAgIEZpbGVMaXN0OiBDLFxuICAgIEZpbGVSZWFkZXI6IEMsXG4gICAgZmluZDogTyxcbiAgICBmb2N1czogTyxcbiAgICBGb2N1c0V2ZW50OiBDLFxuICAgIEZvbnRGYWNlOiBDLFxuICAgIEZvbnRGYWNlU2V0TG9hZEV2ZW50OiBDLFxuICAgIEZvcm1EYXRhOiBDLFxuICAgIGZyYW1lczogTyxcbiAgICBHYWluTm9kZTogQyxcbiAgICBHYW1lcGFkOiBDLFxuICAgIEdhbWVwYWRCdXR0b246IEMsXG4gICAgR2FtZXBhZEV2ZW50OiBDLFxuICAgIGdldENvbXB1dGVkU3R5bGU6IE8sXG4gICAgZ2V0U2VsZWN0aW9uOiBPLFxuICAgIEhhc2hDaGFuZ2VFdmVudDogQyxcbiAgICBIZWFkZXJzOiBDLFxuICAgIGhpc3Rvcnk6IE8sXG4gICAgSGlzdG9yeTogQyxcbiAgICBIVE1MQWxsQ29sbGVjdGlvbjogQyxcbiAgICBIVE1MQW5jaG9yRWxlbWVudDogQyxcbiAgICBIVE1MQXJlYUVsZW1lbnQ6IEMsXG4gICAgSFRNTEF1ZGlvRWxlbWVudDogQyxcbiAgICBIVE1MQmFzZUVsZW1lbnQ6IEMsXG4gICAgSFRNTEJvZHlFbGVtZW50OiBDLFxuICAgIEhUTUxCUkVsZW1lbnQ6IEMsXG4gICAgSFRNTEJ1dHRvbkVsZW1lbnQ6IEMsXG4gICAgSFRNTENhbnZhc0VsZW1lbnQ6IEMsXG4gICAgSFRNTENvbGxlY3Rpb246IEMsXG4gICAgSFRNTENvbnRlbnRFbGVtZW50OiBDLFxuICAgIEhUTUxEYXRhRWxlbWVudDogQyxcbiAgICBIVE1MRGF0YUxpc3RFbGVtZW50OiBDLFxuICAgIEhUTUxEZXRhaWxzRWxlbWVudDogQyxcbiAgICBIVE1MRGlhbG9nRWxlbWVudDogQyxcbiAgICBIVE1MRGlyZWN0b3J5RWxlbWVudDogQyxcbiAgICBIVE1MRGl2RWxlbWVudDogQyxcbiAgICBIVE1MRExpc3RFbGVtZW50OiBDLFxuICAgIEhUTUxEb2N1bWVudDogQyxcbiAgICBIVE1MRWxlbWVudDogQyxcbiAgICBIVE1MRW1iZWRFbGVtZW50OiBDLFxuICAgIEhUTUxGaWVsZFNldEVsZW1lbnQ6IEMsXG4gICAgSFRNTEZvbnRFbGVtZW50OiBDLFxuICAgIEhUTUxGb3JtQ29udHJvbHNDb2xsZWN0aW9uOiBDLFxuICAgIEhUTUxGb3JtRWxlbWVudDogQyxcbiAgICBIVE1MRnJhbWVFbGVtZW50OiBDLFxuICAgIEhUTUxGcmFtZVNldEVsZW1lbnQ6IEMsXG4gICAgSFRNTEhlYWRFbGVtZW50OiBDLFxuICAgIEhUTUxIZWFkaW5nRWxlbWVudDogQyxcbiAgICBIVE1MSFJFbGVtZW50OiBDLFxuICAgIEhUTUxIdG1sRWxlbWVudDogQyxcbiAgICBIVE1MSUZyYW1lRWxlbWVudDogQyxcbiAgICBIVE1MSW1hZ2VFbGVtZW50OiBDLFxuICAgIEhUTUxJbnB1dEVsZW1lbnQ6IEMsXG4gICAgSFRNTExhYmVsRWxlbWVudDogQyxcbiAgICBIVE1MTGVnZW5kRWxlbWVudDogQyxcbiAgICBIVE1MTElFbGVtZW50OiBDLFxuICAgIEhUTUxMaW5rRWxlbWVudDogQyxcbiAgICBIVE1MTWFwRWxlbWVudDogQyxcbiAgICBIVE1MTWFycXVlZUVsZW1lbnQ6IEMsXG4gICAgSFRNTE1lZGlhRWxlbWVudDogQyxcbiAgICBIVE1MTWVudUVsZW1lbnQ6IEMsXG4gICAgSFRNTE1ldGFFbGVtZW50OiBDLFxuICAgIEhUTUxNZXRlckVsZW1lbnQ6IEMsXG4gICAgSFRNTE1vZEVsZW1lbnQ6IEMsXG4gICAgSFRNTE9iamVjdEVsZW1lbnQ6IEMsXG4gICAgSFRNTE9MaXN0RWxlbWVudDogQyxcbiAgICBIVE1MT3B0R3JvdXBFbGVtZW50OiBDLFxuICAgIEhUTUxPcHRpb25FbGVtZW50OiBDLFxuICAgIEhUTUxPcHRpb25zQ29sbGVjdGlvbjogQyxcbiAgICBIVE1MT3V0cHV0RWxlbWVudDogQyxcbiAgICBIVE1MUGFyYWdyYXBoRWxlbWVudDogQyxcbiAgICBIVE1MUGFyYW1FbGVtZW50OiBDLFxuICAgIEhUTUxQaWN0dXJlRWxlbWVudDogQyxcbiAgICBIVE1MUHJlRWxlbWVudDogQyxcbiAgICBIVE1MUHJvZ3Jlc3NFbGVtZW50OiBDLFxuICAgIEhUTUxRdW90ZUVsZW1lbnQ6IEMsXG4gICAgSFRNTFNjcmlwdEVsZW1lbnQ6IEMsXG4gICAgSFRNTFNlbGVjdEVsZW1lbnQ6IEMsXG4gICAgSFRNTFNoYWRvd0VsZW1lbnQ6IEMsXG4gICAgSFRNTFNsb3RFbGVtZW50OiBDLFxuICAgIEhUTUxTb3VyY2VFbGVtZW50OiBDLFxuICAgIEhUTUxTcGFuRWxlbWVudDogQyxcbiAgICBIVE1MU3R5bGVFbGVtZW50OiBDLFxuICAgIEhUTUxUYWJsZUNhcHRpb25FbGVtZW50OiBDLFxuICAgIEhUTUxUYWJsZUNlbGxFbGVtZW50OiBDLFxuICAgIEhUTUxUYWJsZUNvbEVsZW1lbnQ6IEMsXG4gICAgSFRNTFRhYmxlRWxlbWVudDogQyxcbiAgICBIVE1MVGFibGVSb3dFbGVtZW50OiBDLFxuICAgIEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50OiBDLFxuICAgIEhUTUxUZW1wbGF0ZUVsZW1lbnQ6IEMsXG4gICAgSFRNTFRleHRBcmVhRWxlbWVudDogQyxcbiAgICBIVE1MVGltZUVsZW1lbnQ6IEMsXG4gICAgSFRNTFRpdGxlRWxlbWVudDogQyxcbiAgICBIVE1MVHJhY2tFbGVtZW50OiBDLFxuICAgIEhUTUxVTGlzdEVsZW1lbnQ6IEMsXG4gICAgSFRNTFVua25vd25FbGVtZW50OiBDLFxuICAgIEhUTUxWaWRlb0VsZW1lbnQ6IEMsXG4gICAgSURCQ3Vyc29yOiBDLFxuICAgIElEQkN1cnNvcldpdGhWYWx1ZTogQyxcbiAgICBJREJEYXRhYmFzZTogQyxcbiAgICBJREJGYWN0b3J5OiBDLFxuICAgIElEQkluZGV4OiBDLFxuICAgIElEQktleVJhbmdlOiBDLFxuICAgIElEQk9iamVjdFN0b3JlOiBDLFxuICAgIElEQk9wZW5EQlJlcXVlc3Q6IEMsXG4gICAgSURCUmVxdWVzdDogQyxcbiAgICBJREJUcmFuc2FjdGlvbjogQyxcbiAgICBJREJWZXJzaW9uQ2hhbmdlRXZlbnQ6IEMsXG4gICAgSWRsZURlYWRsaW5lOiBDLFxuICAgIElJUkZpbHRlck5vZGU6IEMsXG4gICAgSW1hZ2U6IEMsXG4gICAgSW1hZ2VCaXRtYXA6IEMsXG4gICAgSW1hZ2VCaXRtYXBSZW5kZXJpbmdDb250ZXh0OiBDLFxuICAgIEltYWdlQ2FwdHVyZTogQyxcbiAgICBJbWFnZURhdGE6IEMsXG4gICAgaW5kZXhlZERCOiBPLFxuICAgIGlubmVySGVpZ2h0OiBPLFxuICAgIGlubmVyV2lkdGg6IE8sXG4gICAgSW5wdXRFdmVudDogQyxcbiAgICBJbnRlcnNlY3Rpb25PYnNlcnZlcjogQyxcbiAgICBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5OiBDLFxuICAgIGlzU2VjdXJlQ29udGV4dDogTyxcbiAgICBLZXlib2FyZEV2ZW50OiBDLFxuICAgIEtleWZyYW1lRWZmZWN0OiBDLFxuICAgIGxlbmd0aDogTyxcbiAgICBsb2NhbFN0b3JhZ2U6IE8sXG4gICAgbG9jYXRpb246IE8sXG4gICAgTG9jYXRpb246IEMsXG4gICAgbG9jYXRpb25iYXI6IE8sXG4gICAgbWF0Y2hNZWRpYTogTyxcbiAgICBNZWRpYURldmljZUluZm86IEMsXG4gICAgTWVkaWFEZXZpY2VzOiBDLFxuICAgIE1lZGlhRWxlbWVudEF1ZGlvU291cmNlTm9kZTogQyxcbiAgICBNZWRpYUVuY3J5cHRlZEV2ZW50OiBDLFxuICAgIE1lZGlhRXJyb3I6IEMsXG4gICAgTWVkaWFLZXlNZXNzYWdlRXZlbnQ6IEMsXG4gICAgTWVkaWFLZXlTZXNzaW9uOiBDLFxuICAgIE1lZGlhS2V5U3RhdHVzTWFwOiBDLFxuICAgIE1lZGlhS2V5U3lzdGVtQWNjZXNzOiBDLFxuICAgIE1lZGlhTGlzdDogQyxcbiAgICBNZWRpYVF1ZXJ5TGlzdDogQyxcbiAgICBNZWRpYVF1ZXJ5TGlzdEV2ZW50OiBDLFxuICAgIE1lZGlhUmVjb3JkZXI6IEMsXG4gICAgTWVkaWFTZXR0aW5nc1JhbmdlOiBDLFxuICAgIE1lZGlhU291cmNlOiBDLFxuICAgIE1lZGlhU3RyZWFtOiBDLFxuICAgIE1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGU6IEMsXG4gICAgTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGU6IEMsXG4gICAgTWVkaWFTdHJlYW1FdmVudDogQyxcbiAgICBNZWRpYVN0cmVhbVRyYWNrOiBDLFxuICAgIE1lZGlhU3RyZWFtVHJhY2tFdmVudDogQyxcbiAgICBtZW51YmFyOiBPLFxuICAgIE1lc3NhZ2VDaGFubmVsOiBDLFxuICAgIE1lc3NhZ2VFdmVudDogQyxcbiAgICBNZXNzYWdlUG9ydDogQyxcbiAgICBNSURJQWNjZXNzOiBDLFxuICAgIE1JRElDb25uZWN0aW9uRXZlbnQ6IEMsXG4gICAgTUlESUlucHV0OiBDLFxuICAgIE1JRElJbnB1dE1hcDogQyxcbiAgICBNSURJTWVzc2FnZUV2ZW50OiBDLFxuICAgIE1JRElPdXRwdXQ6IEMsXG4gICAgTUlESU91dHB1dE1hcDogQyxcbiAgICBNSURJUG9ydDogQyxcbiAgICBNaW1lVHlwZTogQyxcbiAgICBNaW1lVHlwZUFycmF5OiBDLFxuICAgIE1vdXNlRXZlbnQ6IEMsXG4gICAgbW92ZUJ5OiBPLFxuICAgIG1vdmVUbzogTyxcbiAgICBNdXRhdGlvbkV2ZW50OiBDLFxuICAgIE11dGF0aW9uT2JzZXJ2ZXI6IEMsXG4gICAgTXV0YXRpb25SZWNvcmQ6IEMsXG4gICAgbmFtZTogTyxcbiAgICBOYW1lZE5vZGVNYXA6IEMsXG4gICAgTmF2aWdhdGlvblByZWxvYWRNYW5hZ2VyOiBDLFxuICAgIG5hdmlnYXRvcjogTyxcbiAgICBOYXZpZ2F0b3I6IEMsXG4gICAgTmV0d29ya0luZm9ybWF0aW9uOiBDLFxuICAgIE5vZGU6IEMsXG4gICAgTm9kZUZpbHRlcjogTyxcbiAgICBOb2RlSXRlcmF0b3I6IEMsXG4gICAgTm9kZUxpc3Q6IEMsXG4gICAgTm90aWZpY2F0aW9uOiBDLFxuICAgIE9mZmxpbmVBdWRpb0NvbXBsZXRpb25FdmVudDogQyxcbiAgICBPZmZsaW5lQXVkaW9Db250ZXh0OiBDLFxuICAgIG9mZnNjcmVlbkJ1ZmZlcmluZzogTyxcbiAgICBPZmZzY3JlZW5DYW52YXM6IEMsXG4gICAgb3BlbjogTyxcbiAgICBvcGVuRGF0YWJhc2U6IE8sXG4gICAgT3B0aW9uOiBDLFxuICAgIG9yaWdpbjogTyxcbiAgICBPc2NpbGxhdG9yTm9kZTogQyxcbiAgICBvdXRlckhlaWdodDogTyxcbiAgICBvdXRlcldpZHRoOiBPLFxuICAgIFBhZ2VUcmFuc2l0aW9uRXZlbnQ6IEMsXG4gICAgcGFnZVhPZmZzZXQ6IE8sXG4gICAgcGFnZVlPZmZzZXQ6IE8sXG4gICAgUGFubmVyTm9kZTogQyxcbiAgICBwYXJlbnQ6IE8sXG4gICAgUGF0aDJEOiBDLFxuICAgIFBheW1lbnRBZGRyZXNzOiBDLFxuICAgIFBheW1lbnRSZXF1ZXN0OiBDLFxuICAgIFBheW1lbnRSZXF1ZXN0VXBkYXRlRXZlbnQ6IEMsXG4gICAgUGF5bWVudFJlc3BvbnNlOiBDLFxuICAgIHBlcmZvcm1hbmNlOiBPLFxuICAgIFBlcmZvcm1hbmNlOiBDLFxuICAgIFBlcmZvcm1hbmNlRW50cnk6IEMsXG4gICAgUGVyZm9ybWFuY2VMb25nVGFza1RpbWluZzogQyxcbiAgICBQZXJmb3JtYW5jZU1hcms6IEMsXG4gICAgUGVyZm9ybWFuY2VNZWFzdXJlOiBDLFxuICAgIFBlcmZvcm1hbmNlTmF2aWdhdGlvbjogQyxcbiAgICBQZXJmb3JtYW5jZU5hdmlnYXRpb25UaW1pbmc6IEMsXG4gICAgUGVyZm9ybWFuY2VPYnNlcnZlcjogQyxcbiAgICBQZXJmb3JtYW5jZU9ic2VydmVyRW50cnlMaXN0OiBDLFxuICAgIFBlcmZvcm1hbmNlUGFpbnRUaW1pbmc6IEMsXG4gICAgUGVyZm9ybWFuY2VSZXNvdXJjZVRpbWluZzogQyxcbiAgICBQZXJmb3JtYW5jZVRpbWluZzogQyxcbiAgICBQZXJpb2RpY1dhdmU6IEMsXG4gICAgUGVybWlzc2lvbnM6IEMsXG4gICAgUGVybWlzc2lvblN0YXR1czogQyxcbiAgICBwZXJzb25hbGJhcjogTyxcbiAgICBQaG90b0NhcGFiaWxpdGllczogQyxcbiAgICBQbHVnaW46IEMsXG4gICAgUGx1Z2luQXJyYXk6IEMsXG4gICAgUG9pbnRlckV2ZW50OiBDLFxuICAgIFBvcFN0YXRlRXZlbnQ6IEMsXG4gICAgcG9zdE1lc3NhZ2U6IE8sXG4gICAgUHJlc2VudGF0aW9uOiBDLFxuICAgIFByZXNlbnRhdGlvbkF2YWlsYWJpbGl0eTogQyxcbiAgICBQcmVzZW50YXRpb25Db25uZWN0aW9uOiBDLFxuICAgIFByZXNlbnRhdGlvbkNvbm5lY3Rpb25BdmFpbGFibGVFdmVudDogQyxcbiAgICBQcmVzZW50YXRpb25Db25uZWN0aW9uQ2xvc2VFdmVudDogQyxcbiAgICBQcmVzZW50YXRpb25Db25uZWN0aW9uTGlzdDogQyxcbiAgICBQcmVzZW50YXRpb25SZWNlaXZlcjogQyxcbiAgICBQcmVzZW50YXRpb25SZXF1ZXN0OiBDLFxuICAgIHByaW50OiBPLFxuICAgIFByb2Nlc3NpbmdJbnN0cnVjdGlvbjogQyxcbiAgICBQcm9ncmVzc0V2ZW50OiBDLFxuICAgIFByb21pc2VSZWplY3Rpb25FdmVudDogQyxcbiAgICBwcm9tcHQ6IE8sXG4gICAgUHVzaE1hbmFnZXI6IEMsXG4gICAgUHVzaFN1YnNjcmlwdGlvbjogQyxcbiAgICBQdXNoU3Vic2NyaXB0aW9uT3B0aW9uczogQyxcbiAgICBxdWV1ZU1pY3JvdGFzazogTyxcbiAgICBSYWRpb05vZGVMaXN0OiBDLFxuICAgIFJhbmdlOiBDLFxuICAgIFJlYWRhYmxlU3RyZWFtOiBDLFxuICAgIFJlbW90ZVBsYXliYWNrOiBDLFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IE8sXG4gICAgUmVxdWVzdDogQyxcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IE8sXG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogTyxcbiAgICByZXNpemVCeTogTyxcbiAgICBSZXNpemVPYnNlcnZlcjogQyxcbiAgICBSZXNpemVPYnNlcnZlckVudHJ5OiBDLFxuICAgIHJlc2l6ZVRvOiBPLFxuICAgIFJlc3BvbnNlOiBDLFxuICAgIFJUQ0NlcnRpZmljYXRlOiBDLFxuICAgIFJUQ0RhdGFDaGFubmVsOiBDLFxuICAgIFJUQ0RhdGFDaGFubmVsRXZlbnQ6IEMsXG4gICAgUlRDRHRsc1RyYW5zcG9ydDogQyxcbiAgICBSVENJY2VDYW5kaWRhdGU6IEMsXG4gICAgUlRDSWNlVHJhbnNwb3J0OiBDLFxuICAgIFJUQ1BlZXJDb25uZWN0aW9uOiBDLFxuICAgIFJUQ1BlZXJDb25uZWN0aW9uSWNlRXZlbnQ6IEMsXG4gICAgUlRDUnRwUmVjZWl2ZXI6IEMsXG4gICAgUlRDUnRwU2VuZGVyOiBDLFxuICAgIFJUQ1NjdHBUcmFuc3BvcnQ6IEMsXG4gICAgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uOiBDLFxuICAgIFJUQ1N0YXRzUmVwb3J0OiBDLFxuICAgIFJUQ1RyYWNrRXZlbnQ6IEMsXG4gICAgc2NyZWVuOiBPLFxuICAgIFNjcmVlbjogQyxcbiAgICBzY3JlZW5MZWZ0OiBPLFxuICAgIFNjcmVlbk9yaWVudGF0aW9uOiBDLFxuICAgIHNjcmVlblRvcDogTyxcbiAgICBzY3JlZW5YOiBPLFxuICAgIHNjcmVlblk6IE8sXG4gICAgU2NyaXB0UHJvY2Vzc29yTm9kZTogQyxcbiAgICBzY3JvbGw6IE8sXG4gICAgc2Nyb2xsYmFyczogTyxcbiAgICBzY3JvbGxCeTogTyxcbiAgICBzY3JvbGxUbzogTyxcbiAgICBzY3JvbGxYOiBPLFxuICAgIHNjcm9sbFk6IE8sXG4gICAgU2VjdXJpdHlQb2xpY3lWaW9sYXRpb25FdmVudDogQyxcbiAgICBTZWxlY3Rpb246IEMsXG4gICAgU2VydmljZVdvcmtlcjogQyxcbiAgICBTZXJ2aWNlV29ya2VyQ29udGFpbmVyOiBDLFxuICAgIFNlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb246IEMsXG4gICAgc2Vzc2lvblN0b3JhZ2U6IE8sXG4gICAgU2hhZG93Um9vdDogQyxcbiAgICBTaGFyZWRXb3JrZXI6IEMsXG4gICAgU291cmNlQnVmZmVyOiBDLFxuICAgIFNvdXJjZUJ1ZmZlckxpc3Q6IEMsXG4gICAgc3BlZWNoU3ludGhlc2lzOiBPLFxuICAgIFNwZWVjaFN5bnRoZXNpc0V2ZW50OiBDLFxuICAgIFNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZTogQyxcbiAgICBTdGF0aWNSYW5nZTogQyxcbiAgICBzdGF0dXM6IE8sXG4gICAgc3RhdHVzYmFyOiBPLFxuICAgIFN0ZXJlb1Bhbm5lck5vZGU6IEMsXG4gICAgc3RvcDogTyxcbiAgICBTdG9yYWdlOiBDLFxuICAgIFN0b3JhZ2VFdmVudDogQyxcbiAgICBTdG9yYWdlTWFuYWdlcjogQyxcbiAgICBzdHlsZU1lZGlhOiBPLFxuICAgIFN0eWxlU2hlZXQ6IEMsXG4gICAgU3R5bGVTaGVldExpc3Q6IEMsXG4gICAgU3VidGxlQ3J5cHRvOiBDLFxuICAgIFNWR0FFbGVtZW50OiBDLFxuICAgIFNWR0FuZ2xlOiBDLFxuICAgIFNWR0FuaW1hdGVkQW5nbGU6IEMsXG4gICAgU1ZHQW5pbWF0ZWRCb29sZWFuOiBDLFxuICAgIFNWR0FuaW1hdGVkRW51bWVyYXRpb246IEMsXG4gICAgU1ZHQW5pbWF0ZWRJbnRlZ2VyOiBDLFxuICAgIFNWR0FuaW1hdGVkTGVuZ3RoOiBDLFxuICAgIFNWR0FuaW1hdGVkTGVuZ3RoTGlzdDogQyxcbiAgICBTVkdBbmltYXRlZE51bWJlcjogQyxcbiAgICBTVkdBbmltYXRlZE51bWJlckxpc3Q6IEMsXG4gICAgU1ZHQW5pbWF0ZWRQcmVzZXJ2ZUFzcGVjdFJhdGlvOiBDLFxuICAgIFNWR0FuaW1hdGVkUmVjdDogQyxcbiAgICBTVkdBbmltYXRlZFN0cmluZzogQyxcbiAgICBTVkdBbmltYXRlZFRyYW5zZm9ybUxpc3Q6IEMsXG4gICAgU1ZHQW5pbWF0ZUVsZW1lbnQ6IEMsXG4gICAgU1ZHQW5pbWF0ZU1vdGlvbkVsZW1lbnQ6IEMsXG4gICAgU1ZHQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQ6IEMsXG4gICAgU1ZHQW5pbWF0aW9uRWxlbWVudDogQyxcbiAgICBTVkdDaXJjbGVFbGVtZW50OiBDLFxuICAgIFNWR0NsaXBQYXRoRWxlbWVudDogQyxcbiAgICBTVkdDb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9uRWxlbWVudDogQyxcbiAgICBTVkdEZWZzRWxlbWVudDogQyxcbiAgICBTVkdEZXNjRWxlbWVudDogQyxcbiAgICBTVkdEaXNjYXJkRWxlbWVudDogQyxcbiAgICBTVkdFbGVtZW50OiBDLFxuICAgIFNWR0VsbGlwc2VFbGVtZW50OiBDLFxuICAgIFNWR0ZFQmxlbmRFbGVtZW50OiBDLFxuICAgIFNWR0ZFQ29sb3JNYXRyaXhFbGVtZW50OiBDLFxuICAgIFNWR0ZFQ29tcG9uZW50VHJhbnNmZXJFbGVtZW50OiBDLFxuICAgIFNWR0ZFQ29tcG9zaXRlRWxlbWVudDogQyxcbiAgICBTVkdGRUNvbnZvbHZlTWF0cml4RWxlbWVudDogQyxcbiAgICBTVkdGRURpZmZ1c2VMaWdodGluZ0VsZW1lbnQ6IEMsXG4gICAgU1ZHRkVEaXNwbGFjZW1lbnRNYXBFbGVtZW50OiBDLFxuICAgIFNWR0ZFRGlzdGFudExpZ2h0RWxlbWVudDogQyxcbiAgICBTVkdGRURyb3BTaGFkb3dFbGVtZW50OiBDLFxuICAgIFNWR0ZFRmxvb2RFbGVtZW50OiBDLFxuICAgIFNWR0ZFRnVuY0FFbGVtZW50OiBDLFxuICAgIFNWR0ZFRnVuY0JFbGVtZW50OiBDLFxuICAgIFNWR0ZFRnVuY0dFbGVtZW50OiBDLFxuICAgIFNWR0ZFRnVuY1JFbGVtZW50OiBDLFxuICAgIFNWR0ZFR2F1c3NpYW5CbHVyRWxlbWVudDogQyxcbiAgICBTVkdGRUltYWdlRWxlbWVudDogQyxcbiAgICBTVkdGRU1lcmdlRWxlbWVudDogQyxcbiAgICBTVkdGRU1lcmdlTm9kZUVsZW1lbnQ6IEMsXG4gICAgU1ZHRkVNb3JwaG9sb2d5RWxlbWVudDogQyxcbiAgICBTVkdGRU9mZnNldEVsZW1lbnQ6IEMsXG4gICAgU1ZHRkVQb2ludExpZ2h0RWxlbWVudDogQyxcbiAgICBTVkdGRVNwZWN1bGFyTGlnaHRpbmdFbGVtZW50OiBDLFxuICAgIFNWR0ZFU3BvdExpZ2h0RWxlbWVudDogQyxcbiAgICBTVkdGRVRpbGVFbGVtZW50OiBDLFxuICAgIFNWR0ZFVHVyYnVsZW5jZUVsZW1lbnQ6IEMsXG4gICAgU1ZHRmlsdGVyRWxlbWVudDogQyxcbiAgICBTVkdGb3JlaWduT2JqZWN0RWxlbWVudDogQyxcbiAgICBTVkdHRWxlbWVudDogQyxcbiAgICBTVkdHZW9tZXRyeUVsZW1lbnQ6IEMsXG4gICAgU1ZHR3JhZGllbnRFbGVtZW50OiBDLFxuICAgIFNWR0dyYXBoaWNzRWxlbWVudDogQyxcbiAgICBTVkdJbWFnZUVsZW1lbnQ6IEMsXG4gICAgU1ZHTGVuZ3RoOiBDLFxuICAgIFNWR0xlbmd0aExpc3Q6IEMsXG4gICAgU1ZHTGluZWFyR3JhZGllbnRFbGVtZW50OiBDLFxuICAgIFNWR0xpbmVFbGVtZW50OiBDLFxuICAgIFNWR01hcmtlckVsZW1lbnQ6IEMsXG4gICAgU1ZHTWFza0VsZW1lbnQ6IEMsXG4gICAgU1ZHTWF0cml4OiBDLFxuICAgIFNWR01ldGFkYXRhRWxlbWVudDogQyxcbiAgICBTVkdNUGF0aEVsZW1lbnQ6IEMsXG4gICAgU1ZHTnVtYmVyOiBDLFxuICAgIFNWR051bWJlckxpc3Q6IEMsXG4gICAgU1ZHUGF0aEVsZW1lbnQ6IEMsXG4gICAgU1ZHUGF0dGVybkVsZW1lbnQ6IEMsXG4gICAgU1ZHUG9pbnQ6IEMsXG4gICAgU1ZHUG9pbnRMaXN0OiBDLFxuICAgIFNWR1BvbHlnb25FbGVtZW50OiBDLFxuICAgIFNWR1BvbHlsaW5lRWxlbWVudDogQyxcbiAgICBTVkdQcmVzZXJ2ZUFzcGVjdFJhdGlvOiBDLFxuICAgIFNWR1JhZGlhbEdyYWRpZW50RWxlbWVudDogQyxcbiAgICBTVkdSZWN0OiBDLFxuICAgIFNWR1JlY3RFbGVtZW50OiBDLFxuICAgIFNWR1NjcmlwdEVsZW1lbnQ6IEMsXG4gICAgU1ZHU2V0RWxlbWVudDogQyxcbiAgICBTVkdTdG9wRWxlbWVudDogQyxcbiAgICBTVkdTdHJpbmdMaXN0OiBDLFxuICAgIFNWR1N0eWxlRWxlbWVudDogQyxcbiAgICBTVkdTVkdFbGVtZW50OiBDLFxuICAgIFNWR1N3aXRjaEVsZW1lbnQ6IEMsXG4gICAgU1ZHU3ltYm9sRWxlbWVudDogQyxcbiAgICBTVkdUZXh0Q29udGVudEVsZW1lbnQ6IEMsXG4gICAgU1ZHVGV4dEVsZW1lbnQ6IEMsXG4gICAgU1ZHVGV4dFBhdGhFbGVtZW50OiBDLFxuICAgIFNWR1RleHRQb3NpdGlvbmluZ0VsZW1lbnQ6IEMsXG4gICAgU1ZHVGl0bGVFbGVtZW50OiBDLFxuICAgIFNWR1RyYW5zZm9ybTogQyxcbiAgICBTVkdUcmFuc2Zvcm1MaXN0OiBDLFxuICAgIFNWR1RTcGFuRWxlbWVudDogQyxcbiAgICBTVkdVbml0VHlwZXM6IEMsXG4gICAgU1ZHVXNlRWxlbWVudDogQyxcbiAgICBTVkdWaWV3RWxlbWVudDogQyxcbiAgICBUYXNrQXR0cmlidXRpb25UaW1pbmc6IEMsXG4gICAgVGV4dDogQyxcbiAgICBUZXh0RXZlbnQ6IEMsXG4gICAgVGV4dE1ldHJpY3M6IEMsXG4gICAgVGV4dFRyYWNrOiBDLFxuICAgIFRleHRUcmFja0N1ZTogQyxcbiAgICBUZXh0VHJhY2tDdWVMaXN0OiBDLFxuICAgIFRleHRUcmFja0xpc3Q6IEMsXG4gICAgVGltZVJhbmdlczogQyxcbiAgICB0b29sYmFyOiBPLFxuICAgIHRvcDogTyxcbiAgICBUb3VjaDogQyxcbiAgICBUb3VjaEV2ZW50OiBDLFxuICAgIFRvdWNoTGlzdDogQyxcbiAgICBUcmFja0V2ZW50OiBDLFxuICAgIFRyYW5zaXRpb25FdmVudDogQyxcbiAgICBUcmVlV2Fsa2VyOiBDLFxuICAgIFVJRXZlbnQ6IEMsXG4gICAgVmFsaWRpdHlTdGF0ZTogQyxcbiAgICB2aXN1YWxWaWV3cG9ydDogTyxcbiAgICBWaXN1YWxWaWV3cG9ydDogQyxcbiAgICBWVFRDdWU6IEMsXG4gICAgV2F2ZVNoYXBlck5vZGU6IEMsXG4gICAgV2ViQXNzZW1ibHk6IE8sXG4gICAgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDogQyxcbiAgICBXZWJHTEFjdGl2ZUluZm86IEMsXG4gICAgV2ViR0xCdWZmZXI6IEMsXG4gICAgV2ViR0xDb250ZXh0RXZlbnQ6IEMsXG4gICAgV2ViR0xGcmFtZWJ1ZmZlcjogQyxcbiAgICBXZWJHTFByb2dyYW06IEMsXG4gICAgV2ViR0xRdWVyeTogQyxcbiAgICBXZWJHTFJlbmRlcmJ1ZmZlcjogQyxcbiAgICBXZWJHTFJlbmRlcmluZ0NvbnRleHQ6IEMsXG4gICAgV2ViR0xTYW1wbGVyOiBDLFxuICAgIFdlYkdMU2hhZGVyOiBDLFxuICAgIFdlYkdMU2hhZGVyUHJlY2lzaW9uRm9ybWF0OiBDLFxuICAgIFdlYkdMU3luYzogQyxcbiAgICBXZWJHTFRleHR1cmU6IEMsXG4gICAgV2ViR0xUcmFuc2Zvcm1GZWVkYmFjazogQyxcbiAgICBXZWJHTFVuaWZvcm1Mb2NhdGlvbjogQyxcbiAgICBXZWJHTFZlcnRleEFycmF5T2JqZWN0OiBDLFxuICAgIFdlYlNvY2tldDogQyxcbiAgICBXaGVlbEV2ZW50OiBDLFxuICAgIFdpbmRvdzogQyxcbiAgICBXb3JrZXI6IEMsXG4gICAgV3JpdGFibGVTdHJlYW06IEMsXG4gICAgWE1MRG9jdW1lbnQ6IEMsXG4gICAgWE1MSHR0cFJlcXVlc3Q6IEMsXG4gICAgWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldDogQyxcbiAgICBYTUxIdHRwUmVxdWVzdFVwbG9hZDogQyxcbiAgICBYTUxTZXJpYWxpemVyOiBDLFxuICAgIFhQYXRoRXZhbHVhdG9yOiBDLFxuICAgIFhQYXRoRXhwcmVzc2lvbjogQyxcbiAgICBYUGF0aFJlc3VsdDogQyxcbiAgICBYU0xUUHJvY2Vzc29yOiBDXG59O1xuZm9yIChjb25zdCBnbG9iYWwgb2YgWyd3aW5kb3cnLCAnZ2xvYmFsJywgJ3NlbGYnLCAnZ2xvYmFsVGhpcyddKSB7XG4gICAga25vd25HbG9iYWxzW2dsb2JhbF0gPSBrbm93bkdsb2JhbHM7XG59XG5mdW5jdGlvbiBnZXRHbG9iYWxBdFBhdGgocGF0aCkge1xuICAgIGxldCBjdXJyZW50R2xvYmFsID0ga25vd25HbG9iYWxzO1xuICAgIGZvciAoY29uc3QgcGF0aFNlZ21lbnQgb2YgcGF0aCkge1xuICAgICAgICBpZiAodHlwZW9mIHBhdGhTZWdtZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEdsb2JhbCA9IGN1cnJlbnRHbG9iYWxbcGF0aFNlZ21lbnRdO1xuICAgICAgICBpZiAoIWN1cnJlbnRHbG9iYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50R2xvYmFsW1ZhbHVlUHJvcGVydGllc107XG59XG5cbmNsYXNzIEdsb2JhbFZhcmlhYmxlIGV4dGVuZHMgVmFyaWFibGUge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgc3VwZXIobmFtZSk7XG4gICAgICAgIC8vIEVuc3VyZSB3ZSB1c2UgbGl2ZS1iaW5kaW5ncyBmb3IgZ2xvYmFscyBhcyB3ZSBkbyBub3Qga25vdyBpZiB0aGV5IGhhdmVcbiAgICAgICAgLy8gYmVlbiByZWFzc2lnbmVkXG4gICAgICAgIHRoaXMubWFya1JlYXNzaWduZWQoKTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIpIHtcbiAgICAgICAgc3dpdGNoIChpbnRlcmFjdGlvbi50eXBlKSB7XG4gICAgICAgICAgICAvLyBXaGlsZSB0aGVyZSBpcyBubyBwb2ludCBpbiB0ZXN0aW5nIHRoZXNlIGNhc2VzIGFzIGF0IHRoZSBtb21lbnQsIHRoZXlcbiAgICAgICAgICAgIC8vIGFyZSBhbHNvIGNvdmVyZWQgdmlhIG90aGVyIG1lYW5zLCB3ZSBrZWVwIHRoZW0gZm9yIGNvbXBsZXRlbmVzc1xuICAgICAgICAgICAgY2FzZSBJTlRFUkFDVElPTl9BQ0NFU1NFRDpcbiAgICAgICAgICAgIGNhc2UgSU5URVJBQ1RJT05fQVNTSUdORUQ6IHtcbiAgICAgICAgICAgICAgICBpZiAoIWdldEdsb2JhbEF0UGF0aChbdGhpcy5uYW1lLCAuLi5wYXRoXS5zbGljZSgwLCAtMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoLCByZWN1cnNpb25UcmFja2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBJTlRFUkFDVElPTl9DQUxMRUQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBnbG9iYWxBdFBhdGggPSBnZXRHbG9iYWxBdFBhdGgoW3RoaXMubmFtZSwgLi4ucGF0aF0pO1xuICAgICAgICAgICAgICAgIGlmIChnbG9iYWxBdFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsQXRQYXRoLmRlb3B0aW1pemVBcmd1bWVudHNPbkNhbGwoaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIF9yZWN1cnNpb25UcmFja2VyLCBfb3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IGdsb2JhbEF0UGF0aCA9IGdldEdsb2JhbEF0UGF0aChbdGhpcy5uYW1lLCAuLi5wYXRoXSk7XG4gICAgICAgIHJldHVybiBnbG9iYWxBdFBhdGggPyBnbG9iYWxBdFBhdGguZ2V0TGl0ZXJhbFZhbHVlKCkgOiBVbmtub3duVmFsdWU7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHN3aXRjaCAoaW50ZXJhY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgY2FzZSBJTlRFUkFDVElPTl9BQ0NFU1NFRDoge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUZWNobmljYWxseSwgXCJ1bmRlZmluZWRcIiBpcyBhIGdsb2JhbCB2YXJpYWJsZSBvZiBzb3J0c1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lICE9PSAndW5kZWZpbmVkJyAmJiAhZ2V0R2xvYmFsQXRQYXRoKFt0aGlzLm5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICFnZXRHbG9iYWxBdFBhdGgoW3RoaXMubmFtZSwgLi4ucGF0aF0uc2xpY2UoMCwgLTEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgSU5URVJBQ1RJT05fQVNTSUdORUQ6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgSU5URVJBQ1RJT05fQ0FMTEVEOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2xvYmFsQXRQYXRoID0gZ2V0R2xvYmFsQXRQYXRoKFt0aGlzLm5hbWUsIC4uLnBhdGhdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWdsb2JhbEF0UGF0aCB8fCBnbG9iYWxBdFBhdGguaGFzRWZmZWN0c1doZW5DYWxsZWQoaW50ZXJhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBMb2NhbFZhcmlhYmxlIGV4dGVuZHMgVmFyaWFibGUge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGRlY2xhcmF0b3IsIGluaXQsIGNvbnRleHQsIGtpbmQpIHtcbiAgICAgICAgc3VwZXIobmFtZSk7XG4gICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgICAgIHRoaXMuY2FsbGVkRnJvbVRyeVN0YXRlbWVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFkZGl0aW9uYWxJbml0aWFsaXplcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkID0gW107XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRvciA/IFtkZWNsYXJhdG9yXSA6IFtdO1xuICAgICAgICB0aGlzLmRlb3B0aW1pemF0aW9uVHJhY2tlciA9IGNvbnRleHQuZGVvcHRpbWl6YXRpb25UcmFja2VyO1xuICAgICAgICB0aGlzLm1vZHVsZSA9IGNvbnRleHQubW9kdWxlO1xuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIH1cbiAgICBhZGREZWNsYXJhdGlvbihpZGVudGlmaWVyLCBpbml0KSB7XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25zLnB1c2goaWRlbnRpZmllcik7XG4gICAgICAgIHRoaXMubWFya0luaXRpYWxpemVyc0ZvckRlb3B0aW1pemF0aW9uKCkucHVzaChpbml0KTtcbiAgICB9XG4gICAgY29uc29saWRhdGVJbml0aWFsaXplcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmFkZGl0aW9uYWxJbml0aWFsaXplcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5pdGlhbGl6ZXIgb2YgdGhpcy5hZGRpdGlvbmFsSW5pdGlhbGl6ZXJzKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZXIuZGVvcHRpbWl6ZVBhdGgoVU5LTk9XTl9QQVRIKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkaXRpb25hbEluaXRpYWxpemVycyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWFzc2lnbmVkKSB7XG4gICAgICAgICAgICBkZW9wdGltaXplSW50ZXJhY3Rpb24oaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlY3Vyc2lvblRyYWNrZXIud2l0aFRyYWNrZWRFbnRpdHlBdFBhdGgocGF0aCwgdGhpcy5pbml0LCAoKSA9PiB0aGlzLmluaXQuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIpLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBkZW9wdGltaXplUGF0aChwYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVhc3NpZ25lZCB8fFxuICAgICAgICAgICAgdGhpcy5kZW9wdGltaXphdGlvblRyYWNrZXIudHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQocGF0aCwgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubWFya1JlYXNzaWduZWQoKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkID0gdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZDtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQgPSBFTVBUWV9BUlJBWTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXhwcmVzc2lvbiBvZiBleHByZXNzaW9uc1RvQmVEZW9wdGltaXplZCkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24uZGVvcHRpbWl6ZUNhY2hlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluaXQuZGVvcHRpbWl6ZVBhdGgoVU5LTk9XTl9QQVRIKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdC5kZW9wdGltaXplUGF0aChwYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVhc3NpZ25lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFVua25vd25WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjdXJzaW9uVHJhY2tlci53aXRoVHJhY2tlZEVudGl0eUF0UGF0aChwYXRoLCB0aGlzLmluaXQsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQucHVzaChvcmlnaW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC5nZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKTtcbiAgICAgICAgfSwgVW5rbm93blZhbHVlKTtcbiAgICB9XG4gICAgZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgICAgICBpZiAodGhpcy5pc1JlYXNzaWduZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBVTktOT1dOX1JFVFVSTl9FWFBSRVNTSU9OO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWN1cnNpb25UcmFja2VyLndpdGhUcmFja2VkRW50aXR5QXRQYXRoKHBhdGgsIHRoaXMuaW5pdCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZC5wdXNoKG9yaWdpbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0LmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgICAgICB9LCBVTktOT1dOX1JFVFVSTl9FWFBSRVNTSU9OKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgICAgc3dpdGNoIChpbnRlcmFjdGlvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIElOVEVSQUNUSU9OX0FDQ0VTU0VEOiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSZWFzc2lnbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCFjb250ZXh0LmFjY2Vzc2VkLnRyYWNrRW50aXR5QXRQYXRoQW5kR2V0SWZUcmFja2VkKHBhdGgsIHRoaXMpICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdC5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBJTlRFUkFDVElPTl9BU1NJR05FRDoge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluY2x1ZGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1JlYXNzaWduZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAoIWNvbnRleHQuYXNzaWduZWQudHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQocGF0aCwgdGhpcykgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0Lmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIElOVEVSQUNUSU9OX0NBTExFRDoge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUmVhc3NpZ25lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuICghKGludGVyYWN0aW9uLndpdGhOZXcgPyBjb250ZXh0Lmluc3RhbnRpYXRlZCA6IGNvbnRleHQuY2FsbGVkKS50cmFja0VudGl0eUF0UGF0aEFuZEdldElmVHJhY2tlZChwYXRoLCBpbnRlcmFjdGlvbi5hcmdzLCB0aGlzKSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXQuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmNsdWRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgIHN1cGVyLmluY2x1ZGUoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVjbGFyYXRpb24gb2YgdGhpcy5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBub2RlIGlzIGEgZGVmYXVsdCBleHBvcnQsIGl0IGNhbiBzYXZlIGEgdHJlZS1zaGFraW5nIHJ1biB0byBpbmNsdWRlIHRoZSBmdWxsIGRlY2xhcmF0aW9uIG5vd1xuICAgICAgICAgICAgICAgIGlmICghZGVjbGFyYXRpb24uaW5jbHVkZWQpXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uLmluY2x1ZGUoY3JlYXRlSW5jbHVzaW9uQ29udGV4dCgpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBkZWNsYXJhdGlvbi5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFub2RlLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIG5vdCB3YW50IHRvIHByb3Blcmx5IGluY2x1ZGUgcGFyZW50cyBpbiBjYXNlIHRoZXkgYXJlIHBhcnQgb2YgYSBkZWFkIGJyYW5jaFxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB3aGljaCBjYXNlIC5pbmNsdWRlKCkgbWlnaHQgcHVsbCBpbiBtb3JlIGRlYWQgY29kZVxuICAgICAgICAgICAgICAgICAgICBub2RlLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gUHJvZ3JhbSQxKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5jbHVkZUNhbGxBcmd1bWVudHMoY29udGV4dCwgcGFyYW1ldGVycykge1xuICAgICAgICBpZiAodGhpcy5pc1JlYXNzaWduZWQgfHwgY29udGV4dC5pbmNsdWRlZENhbGxBcmd1bWVudHMuaGFzKHRoaXMuaW5pdCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXJndW1lbnQgb2YgcGFyYW1ldGVycykge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50LmluY2x1ZGUoY29udGV4dCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5pbmNsdWRlZENhbGxBcmd1bWVudHMuYWRkKHRoaXMuaW5pdCk7XG4gICAgICAgICAgICB0aGlzLmluaXQuaW5jbHVkZUNhbGxBcmd1bWVudHMoY29udGV4dCwgcGFyYW1ldGVycyk7XG4gICAgICAgICAgICBjb250ZXh0LmluY2x1ZGVkQ2FsbEFyZ3VtZW50cy5kZWxldGUodGhpcy5pbml0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXJrQ2FsbGVkRnJvbVRyeVN0YXRlbWVudCgpIHtcbiAgICAgICAgdGhpcy5jYWxsZWRGcm9tVHJ5U3RhdGVtZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgbWFya0luaXRpYWxpemVyc0ZvckRlb3B0aW1pemF0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5hZGRpdGlvbmFsSW5pdGlhbGl6ZXJzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFkZGl0aW9uYWxJbml0aWFsaXplcnMgPSBbdGhpcy5pbml0XTtcbiAgICAgICAgICAgIHRoaXMuaW5pdCA9IFVOS05PV05fRVhQUkVTU0lPTjtcbiAgICAgICAgICAgIHRoaXMubWFya1JlYXNzaWduZWQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hZGRpdGlvbmFsSW5pdGlhbGl6ZXJzO1xuICAgIH1cbn1cblxuY29uc3QgdGR6VmFyaWFibGVLaW5kcyA9IG5ldyBTZXQoWydjbGFzcycsICdjb25zdCcsICdsZXQnLCAndmFyJywgJ3VzaW5nJywgJ2F3YWl0IHVzaW5nJ10pO1xuY2xhc3MgSWRlbnRpZmllckJhc2UgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmFyaWFibGUgPSBudWxsO1xuICAgICAgICB0aGlzLmlzVmFyaWFibGVSZWZlcmVuY2UgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGlzVERaQWNjZXNzKCkge1xuICAgICAgICBpZiAoIWlzRmxhZ1NldCh0aGlzLmZsYWdzLCA0IC8qIEZsYWcudGR6QWNjZXNzRGVmaW5lZCAqLykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0ZsYWdTZXQodGhpcy5mbGFncywgOCAvKiBGbGFnLnRkekFjY2VzcyAqLyk7XG4gICAgfVxuICAgIHNldCBpc1REWkFjY2Vzcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZsYWdzID0gc2V0RmxhZyh0aGlzLmZsYWdzLCA0IC8qIEZsYWcudGR6QWNjZXNzRGVmaW5lZCAqLywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBzZXRGbGFnKHRoaXMuZmxhZ3MsIDggLyogRmxhZy50ZHpBY2Nlc3MgKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZS5kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aChpbnRlcmFjdGlvbiwgcGF0aCwgcmVjdXJzaW9uVHJhY2tlcik7XG4gICAgfVxuICAgIGRlb3B0aW1pemVQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwICYmICF0aGlzLnNjb3BlLmNvbnRhaW5zKHRoaXMubmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWxsb3dJbXBvcnRSZWFzc2lnbm1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBrZWVwIGNvbmRpdGlvbmFsIGNoYWluaW5nIGJlY2F1c2UgYW4gdW5rbm93biBOb2RlIGNvdWxkIGhhdmUgYW5cbiAgICAgICAgLy8gSWRlbnRpZmllciBhcyBwcm9wZXJ0eSB0aGF0IG1pZ2h0IGJlIGRlb3B0aW1pemVkIGJ5IGRlZmF1bHRcbiAgICAgICAgdGhpcy52YXJpYWJsZT8uZGVvcHRpbWl6ZVBhdGgocGF0aCk7XG4gICAgfVxuICAgIGdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFyaWFibGVSZXNwZWN0aW5nVERaKCkuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgY29uc3QgW2V4cHJlc3Npb24sIGlzUHVyZV0gPSB0aGlzLmdldFZhcmlhYmxlUmVzcGVjdGluZ1REWigpLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgICAgICByZXR1cm4gW2V4cHJlc3Npb24sIGlzUHVyZSB8fCB0aGlzLmlzUHVyZUZ1bmN0aW9uKHBhdGgpXTtcbiAgICB9XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNQb3NzaWJsZVREWigpICYmIHRoaXMudmFyaWFibGUua2luZCAhPT0gJ3ZhcicpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5zY29wZS5jb250ZXh0Lm9wdGlvbnMudHJlZXNoYWtlXG4gICAgICAgICAgICAudW5rbm93bkdsb2JhbFNpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlIGluc3RhbmNlb2YgR2xvYmFsVmFyaWFibGUgJiZcbiAgICAgICAgICAgICF0aGlzLmlzUHVyZUZ1bmN0aW9uKEVNUFRZX1BBVEgpICYmXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKEVNUFRZX1BBVEgsIE5PREVfSU5URVJBQ1RJT05fVU5LTk9XTl9BQ0NFU1MsIGNvbnRleHQpKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgICAgc3dpdGNoIChpbnRlcmFjdGlvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIElOVEVSQUNUSU9OX0FDQ0VTU0VEOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLnZhcmlhYmxlICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmlzUHVyZUZ1bmN0aW9uKHBhdGgpICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VmFyaWFibGVSZXNwZWN0aW5nVERaKCkuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgSU5URVJBQ1RJT05fQVNTSUdORUQ6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHBhdGgubGVuZ3RoID4gMCA/IHRoaXMuZ2V0VmFyaWFibGVSZXNwZWN0aW5nVERaKCkgOiB0aGlzLnZhcmlhYmxlKS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIElOVEVSQUNUSU9OX0NBTExFRDoge1xuICAgICAgICAgICAgICAgIHJldHVybiAoIXRoaXMuaXNQdXJlRnVuY3Rpb24ocGF0aCkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRWYXJpYWJsZVJlc3BlY3RpbmdURFooKS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGluY2x1ZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgaWYgKCF0aGlzLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhcmlhYmxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY29wZS5jb250ZXh0LmluY2x1ZGVWYXJpYWJsZUluTW9kdWxlKHRoaXMudmFyaWFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGluY2x1ZGVDYWxsQXJndW1lbnRzKGNvbnRleHQsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZS5pbmNsdWRlQ2FsbEFyZ3VtZW50cyhjb250ZXh0LCBwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgaXNQb3NzaWJsZVREWigpIHtcbiAgICAgICAgLy8gcmV0dXJuIGNhY2hlZCB2YWx1ZSB0byBhdm9pZCBpc3N1ZXMgd2l0aCB0aGUgbmV4dCB0cmVlLXNoYWtpbmcgcGFzc1xuICAgICAgICBjb25zdCBjYWNoZWRUZHpBY2Nlc3MgPSB0aGlzLmlzVERaQWNjZXNzO1xuICAgICAgICBpZiAoY2FjaGVkVGR6QWNjZXNzICE9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFRkekFjY2VzcztcbiAgICAgICAgaWYgKCEodGhpcy52YXJpYWJsZSBpbnN0YW5jZW9mIExvY2FsVmFyaWFibGUgJiZcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGUua2luZCAmJlxuICAgICAgICAgICAgdGR6VmFyaWFibGVLaW5kcy5oYXModGhpcy52YXJpYWJsZS5raW5kKSAmJlxuICAgICAgICAgICAgLy8gV2UgaWdub3JlIG1vZHVsZXMgdGhhdCBkaWQgbm90IHJlY2VpdmUgYSB0cmVlc2hha2luZyBwYXNzIHlldCBhcyB0aGF0XG4gICAgICAgICAgICAvLyBjYXVzZXMgbWFueSBmYWxzZSBwb3NpdGl2ZXMgZHVlIHRvIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBvciBkaXNhYmxlZFxuICAgICAgICAgICAgLy8gbW9kdWxlU2lkZUVmZmVjdHMuXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlLm1vZHVsZS5oYXNUcmVlU2hha2luZ1Bhc3NTdGFydGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmlzVERaQWNjZXNzID0gZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZWNsX2lkO1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZS5kZWNsYXJhdGlvbnMgJiZcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGUuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgKGRlY2xfaWQgPSB0aGlzLnZhcmlhYmxlLmRlY2xhcmF0aW9uc1swXSkgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPCBkZWNsX2lkLnN0YXJ0ICYmXG4gICAgICAgICAgICBjbG9zZXN0UGFyZW50RnVuY3Rpb25PclByb2dyYW0odGhpcykgPT09IGNsb3Nlc3RQYXJlbnRGdW5jdGlvbk9yUHJvZ3JhbShkZWNsX2lkKSkge1xuICAgICAgICAgICAgLy8gYSB2YXJpYWJsZSBhY2Nlc3NlZCBiZWZvcmUgaXRzIGRlY2xhcmF0aW9uXG4gICAgICAgICAgICAvLyBpbiB0aGUgc2FtZSBmdW5jdGlvbiBvciBhdCB0b3AgbGV2ZWwgb2YgbW9kdWxlXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuaXNURFpBY2Nlc3MgPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudmFyaWFibGUuaW5pdFJlYWNoZWQpIHtcbiAgICAgICAgICAgIC8vIEVpdGhlciBhIGNvbnN0L2xldCBURFogdmlvbGF0aW9uIG9yXG4gICAgICAgICAgICAvLyB2YXIgdXNlIGJlZm9yZSBkZWNsYXJhdGlvbiB3YXMgZW5jb3VudGVyZWQuXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuaXNURFpBY2Nlc3MgPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuaXNURFpBY2Nlc3MgPSBmYWxzZSk7XG4gICAgfVxuICAgIGFwcGx5RGVvcHRpbWl6YXRpb25zKCkge1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGUgaW5zdGFuY2VvZiBMb2NhbFZhcmlhYmxlKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGFjY2Vzc2luZyBhIHZhcmlhYmxlIGZyb20gYSBtb2R1bGUgd2l0aG91dCBzaWRlIGVmZmVjdHMsIHRoaXNcbiAgICAgICAgICAgIC8vIG1lYW5zIHdlIHVzZSBhbiBleHBvcnQgb2YgdGhhdCBtb2R1bGUgYW5kIHRoZXJlZm9yZSBuZWVkIHRvIHBvdGVudGlhbGx5XG4gICAgICAgICAgICAvLyBpbmNsdWRlIGl0IGluIHRoZSBidW5kbGUuXG4gICAgICAgICAgICBpZiAoIXRoaXMudmFyaWFibGUubW9kdWxlLmlzRXhlY3V0ZWQpIHtcbiAgICAgICAgICAgICAgICBtYXJrTW9kdWxlQW5kSW1wdXJlRGVwZW5kZW5jaWVzQXNFeGVjdXRlZCh0aGlzLnZhcmlhYmxlLm1vZHVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlLmNvbnNvbGlkYXRlSW5pdGlhbGl6ZXJzKCk7XG4gICAgICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVmFyaWFibGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGUuYWRkVXNlZFBsYWNlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zY29wZS5jb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNhbGxvd0ltcG9ydFJlYXNzaWdubWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuY29udGV4dC5lcnJvcihsb2dJbGxlZ2FsSW1wb3J0UmVhc3NpZ25tZW50KHRoaXMubmFtZSwgdGhpcy5zY29wZS5jb250ZXh0Lm1vZHVsZS5pZCksIHRoaXMuc3RhcnQpO1xuICAgIH1cbiAgICBnZXRWYXJpYWJsZVJlc3BlY3RpbmdURFooKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUG9zc2libGVURFooKSkge1xuICAgICAgICAgICAgcmV0dXJuIFVOS05PV05fRVhQUkVTU0lPTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YXJpYWJsZTtcbiAgICB9XG4gICAgaXNQdXJlRnVuY3Rpb24ocGF0aCkge1xuICAgICAgICBsZXQgY3VycmVudFB1cmVGdW5jdGlvbiA9IHRoaXMuc2NvcGUuY29udGV4dC5tYW51YWxQdXJlRnVuY3Rpb25zW3RoaXMubmFtZV07XG4gICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBwYXRoKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFB1cmVGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHVyZUZ1bmN0aW9uW1B1cmVGdW5jdGlvbktleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRQdXJlRnVuY3Rpb24gPSBjdXJyZW50UHVyZUZ1bmN0aW9uW3NlZ21lbnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50UHVyZUZ1bmN0aW9uPy5bUHVyZUZ1bmN0aW9uS2V5XTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbG9zZXN0UGFyZW50RnVuY3Rpb25PclByb2dyYW0obm9kZSkge1xuICAgIHdoaWxlIChub2RlICYmICEvXlByb2dyYW18RnVuY3Rpb24vLnRlc3Qobm9kZS50eXBlKSkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIC8vIG9uZSBvZjogQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24sIEZ1bmN0aW9uRGVjbGFyYXRpb24sIEZ1bmN0aW9uRXhwcmVzc2lvbiBvciBQcm9ncmFtXG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmNsYXNzIElkZW50aWZpZXIgZXh0ZW5kcyBJZGVudGlmaWVyQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmFyaWFibGUgPSBudWxsO1xuICAgIH1cbiAgICBhZGRFeHBvcnRlZFZhcmlhYmxlcyh2YXJpYWJsZXMsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSkge1xuICAgICAgICBpZiAoZXhwb3J0TmFtZXNCeVZhcmlhYmxlLmhhcyh0aGlzLnZhcmlhYmxlKSkge1xuICAgICAgICAgICAgdmFyaWFibGVzLnB1c2godGhpcy52YXJpYWJsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmluZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhcmlhYmxlICYmIGlzX3JlZmVyZW5jZSh0aGlzLCB0aGlzLnBhcmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGUgPSB0aGlzLnNjb3BlLmZpbmRWYXJpYWJsZSh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZS5hZGRSZWZlcmVuY2UodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmlzVmFyaWFibGVSZWZlcmVuY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY2xhcmUoa2luZCwgaW5pdCkge1xuICAgICAgICBsZXQgdmFyaWFibGU7XG4gICAgICAgIGNvbnN0IHsgdHJlZXNoYWtlIH0gPSB0aGlzLnNjb3BlLmNvbnRleHQub3B0aW9ucztcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICBjYXNlICd2YXInOiB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGUgPSB0aGlzLnNjb3BlLmFkZERlY2xhcmF0aW9uKHRoaXMsIHRoaXMuc2NvcGUuY29udGV4dCwgaW5pdCwga2luZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWVzaGFrZSAmJiB0cmVlc2hha2UuY29ycmVjdFZhclZhbHVlQmVmb3JlRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IHRvIG1ha2Ugc3VyZSB0aGUgaW5pdCBpcyBkZW9wdGltaXplZC4gV2UgY2Fubm90IGNhbGwgZGVvcHRpbWl6ZVBhdGggaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUubWFya0luaXRpYWxpemVyc0ZvckRlb3B0aW1pemF0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOiB7XG4gICAgICAgICAgICAgICAgLy8gaW4gc3RyaWN0IG1vZGUsIGZ1bmN0aW9ucyBhcmUgb25seSBob2lzdGVkIHdpdGhpbiBhIHNjb3BlIGJ1dCBub3QgYWNyb3NzIGJsb2NrIHNjb3Blc1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gdGhpcy5zY29wZS5hZGREZWNsYXJhdGlvbih0aGlzLCB0aGlzLnNjb3BlLmNvbnRleHQsIGluaXQsIGtpbmQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbnN0JzpcbiAgICAgICAgICAgIGNhc2UgJ3VzaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ2F3YWl0IHVzaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzoge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gdGhpcy5zY29wZS5hZGREZWNsYXJhdGlvbih0aGlzLCB0aGlzLnNjb3BlLmNvbnRleHQsIGluaXQsIGtpbmQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAncGFyYW1ldGVyJzoge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gdGhpcy5zY29wZS5hZGRQYXJhbWV0ZXJEZWNsYXJhdGlvbih0aGlzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIEVycm9yOiBVbmV4cGVjdGVkIGlkZW50aWZpZXIga2luZCAke2tpbmR9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbKHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZSldO1xuICAgIH1cbiAgICBtYXJrRGVjbGFyYXRpb25SZWFjaGVkKCkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlLmluaXRSZWFjaGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIHsgc25pcHBldHM6IHsgZ2V0UHJvcGVydHlBY2Nlc3MgfSwgdXNlT3JpZ2luYWxOYW1lIH0sIHsgcmVuZGVyZWRQYXJlbnRUeXBlLCBpc0NhbGxlZU9mUmVuZGVyZWRQYXJlbnQsIGlzU2hvcnRoYW5kUHJvcGVydHkgfSA9IEJMQU5LKSB7XG4gICAgICAgIGlmICh0aGlzLnZhcmlhYmxlKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy52YXJpYWJsZS5nZXROYW1lKGdldFByb3BlcnR5QWNjZXNzLCB1c2VPcmlnaW5hbE5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgIT09IHRoaXMubmFtZSkge1xuICAgICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRPbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZU5hbWU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNTaG9ydGhhbmRQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlLnByZXBlbmRSaWdodCh0aGlzLnN0YXJ0LCBgJHt0aGlzLm5hbWV9OiBgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbiBzdHJpY3QgbW9kZSwgYW55IHZhcmlhYmxlIG5hbWVkIFwiZXZhbFwiIG11c3QgYmUgdGhlIGFjdHVhbCBcImV2YWxcIiBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdldmFsJyAmJlxuICAgICAgICAgICAgICAgIHJlbmRlcmVkUGFyZW50VHlwZSA9PT0gQ2FsbEV4cHJlc3Npb24kMSAmJlxuICAgICAgICAgICAgICAgIGlzQ2FsbGVlT2ZSZW5kZXJlZFBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNvZGUuYXBwZW5kUmlnaHQodGhpcy5zdGFydCwgJzAsICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBjaGFycyA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWl8kJztcbmNvbnN0IGJhc2UgPSA2NDtcbmZ1bmN0aW9uIHRvQmFzZTY0KHZhbHVlKSB7XG4gICAgbGV0IG91dFN0cmluZyA9ICcnO1xuICAgIGRvIHtcbiAgICAgICAgY29uc3QgY3VycmVudERpZ2l0ID0gdmFsdWUgJSBiYXNlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAvIGJhc2UpIHwgMDtcbiAgICAgICAgb3V0U3RyaW5nID0gY2hhcnNbY3VycmVudERpZ2l0XSArIG91dFN0cmluZztcbiAgICB9IHdoaWxlICh2YWx1ZSAhPT0gMCk7XG4gICAgcmV0dXJuIG91dFN0cmluZztcbn1cblxuZnVuY3Rpb24gZ2V0U2FmZU5hbWUoYmFzZU5hbWUsIHVzZWROYW1lcywgZm9yYmlkZGVuTmFtZXMpIHtcbiAgICBsZXQgc2FmZU5hbWUgPSBiYXNlTmFtZTtcbiAgICBsZXQgY291bnQgPSAxO1xuICAgIHdoaWxlICh1c2VkTmFtZXMuaGFzKHNhZmVOYW1lKSB8fCBSRVNFUlZFRF9OQU1FUy5oYXMoc2FmZU5hbWUpIHx8IGZvcmJpZGRlbk5hbWVzPy5oYXMoc2FmZU5hbWUpKSB7XG4gICAgICAgIHNhZmVOYW1lID0gYCR7YmFzZU5hbWV9JCR7dG9CYXNlNjQoY291bnQrKyl9YDtcbiAgICB9XG4gICAgdXNlZE5hbWVzLmFkZChzYWZlTmFtZSk7XG4gICAgcmV0dXJuIHNhZmVOYW1lO1xufVxuXG5jbGFzcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qXG4gICAgUmVkZWNsYXJhdGlvbiBydWxlczpcbiAgICAtIHZhciBjYW4gcmVkZWNsYXJlIHZhclxuICAgIC0gaW4gZnVuY3Rpb24gc2NvcGVzLCBmdW5jdGlvbiBhbmQgdmFyIGNhbiByZWRlY2xhcmUgZnVuY3Rpb24gYW5kIHZhclxuICAgIC0gdmFyIGlzIGhvaXN0ZWQgYWNyb3NzIHNjb3BlcywgZnVuY3Rpb24gcmVtYWlucyBpbiB0aGUgc2NvcGUgaXQgaXMgZGVjbGFyZWRcbiAgICAtIHZhciBhbmQgZnVuY3Rpb24gY2FuIHJlZGVjbGFyZSBmdW5jdGlvbiBwYXJhbWV0ZXJzLCBidXQgcGFyYW1ldGVycyBjYW5ub3QgcmVkZWNsYXJlIHBhcmFtZXRlcnNcbiAgICAtIGZ1bmN0aW9uIGNhbm5vdCByZWRlY2xhcmUgY2F0Y2ggc2NvcGUgcGFyYW1ldGVyc1xuICAgIC0gdmFyIGNhbiByZWRlY2xhcmUgY2F0Y2ggc2NvcGUgcGFyYW1ldGVycyBpbiBhIHdheVxuICAgICAgICAtIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYW4gaWRlbnRpZmllciBhbmQgbm90IGEgcGF0dGVyblxuICAgICAgICAtIHRoZW4gdGhlIHZhcmlhYmxlIGlzIHN0aWxsIGRlY2xhcmVkIGluIHRoZSBob2lzdGVkIG91dGVyIHNjb3BlLCBidXQgdGhlIGluaXRpYWxpemVyIGlzIGFzc2lnbmVkIHRvIHRoZSBwYXJhbWV0ZXJcbiAgICAtIGNvbnN0LCBsZXQsIGNsYXNzLCBhbmQgZnVuY3Rpb24gZXhjZXB0IGluIHRoZSBjYXNlcyBhYm92ZSBjYW5ub3QgcmVkZWNsYXJlIGFueXRoaW5nXG4gICAgICovXG4gICAgYWRkRGVjbGFyYXRpb24oaWRlbnRpZmllciwgY29udGV4dCwgaW5pdCwga2luZCkge1xuICAgICAgICBjb25zdCBuYW1lID0gaWRlbnRpZmllci5uYW1lO1xuICAgICAgICBjb25zdCBleGlzdGluZ1ZhcmlhYmxlID0gdGhpcy5ob2lzdGVkVmFyaWFibGVzPy5nZXQobmFtZSkgfHwgdGhpcy52YXJpYWJsZXMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoZXhpc3RpbmdWYXJpYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdLaW5kID0gZXhpc3RpbmdWYXJpYWJsZS5raW5kO1xuICAgICAgICAgICAgaWYgKGtpbmQgPT09ICd2YXInICYmIGV4aXN0aW5nS2luZCA9PT0gJ3ZhcicpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1ZhcmlhYmxlLmFkZERlY2xhcmF0aW9uKGlkZW50aWZpZXIsIGluaXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ1ZhcmlhYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5lcnJvcihsb2dSZWRlY2xhcmF0aW9uRXJyb3IobmFtZSksIGlkZW50aWZpZXIuc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1ZhcmlhYmxlID0gbmV3IExvY2FsVmFyaWFibGUoaWRlbnRpZmllci5uYW1lLCBpZGVudGlmaWVyLCBpbml0LCBjb250ZXh0LCBraW5kKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMuc2V0KG5hbWUsIG5ld1ZhcmlhYmxlKTtcbiAgICAgICAgcmV0dXJuIG5ld1ZhcmlhYmxlO1xuICAgIH1cbiAgICBhZGRIb2lzdGVkVmFyaWFibGUobmFtZSwgdmFyaWFibGUpIHtcbiAgICAgICAgKHRoaXMuaG9pc3RlZFZhcmlhYmxlcyB8fD0gbmV3IE1hcCgpKS5zZXQobmFtZSwgdmFyaWFibGUpO1xuICAgIH1cbiAgICBjb250YWlucyhuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlcy5oYXMobmFtZSk7XG4gICAgfVxuICAgIGZpbmRWYXJpYWJsZShfbmFtZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIEVycm9yOiBmaW5kVmFyaWFibGUgbmVlZHMgdG8gYmUgaW1wbGVtZW50ZWQgYnkgYSBzdWJjbGFzcycpO1xuICAgIH1cbn1cblxuY2xhc3MgQ2hpbGRTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuYWNjZXNzZWRPdXRzaWRlVmFyaWFibGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICB9XG4gICAgYWRkQWNjZXNzZWREeW5hbWljSW1wb3J0KGltcG9ydEV4cHJlc3Npb24pIHtcbiAgICAgICAgKHRoaXMuYWNjZXNzZWREeW5hbWljSW1wb3J0cyB8fCAodGhpcy5hY2Nlc3NlZER5bmFtaWNJbXBvcnRzID0gbmV3IFNldCgpKSkuYWRkKGltcG9ydEV4cHJlc3Npb24pO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBDaGlsZFNjb3BlKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5hZGRBY2Nlc3NlZER5bmFtaWNJbXBvcnQoaW1wb3J0RXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQWNjZXNzZWRHbG9iYWxzKGdsb2JhbHMsIGFjY2Vzc2VkR2xvYmFsc0J5U2NvcGUpIHtcbiAgICAgICAgY29uc3QgYWNjZXNzZWRHbG9iYWxzID0gYWNjZXNzZWRHbG9iYWxzQnlTY29wZS5nZXQodGhpcykgfHwgbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgZ2xvYmFscykge1xuICAgICAgICAgICAgYWNjZXNzZWRHbG9iYWxzLmFkZChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlLnNldCh0aGlzLCBhY2Nlc3NlZEdsb2JhbHMpO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBDaGlsZFNjb3BlKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5hZGRBY2Nlc3NlZEdsb2JhbHMoZ2xvYmFscywgYWNjZXNzZWRHbG9iYWxzQnlTY29wZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkTmFtZXNwYWNlTWVtYmVyQWNjZXNzKG5hbWUsIHZhcmlhYmxlKSB7XG4gICAgICAgIHRoaXMuYWNjZXNzZWRPdXRzaWRlVmFyaWFibGVzLnNldChuYW1lLCB2YXJpYWJsZSk7XG4gICAgICAgIHRoaXMucGFyZW50LmFkZE5hbWVzcGFjZU1lbWJlckFjY2VzcyhuYW1lLCB2YXJpYWJsZSk7XG4gICAgfVxuICAgIGFkZFJldHVybkV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBDaGlsZFNjb3BlKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5hZGRSZXR1cm5FeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFVzZWRPdXRzaWRlTmFtZXModXNlZE5hbWVzLCBmb3JtYXQsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSwgYWNjZXNzZWRHbG9iYWxzQnlTY29wZSkge1xuICAgICAgICBmb3IgKGNvbnN0IHZhcmlhYmxlIG9mIHRoaXMuYWNjZXNzZWRPdXRzaWRlVmFyaWFibGVzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAodmFyaWFibGUuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICB1c2VkTmFtZXMuYWRkKHZhcmlhYmxlLmdldEJhc2VWYXJpYWJsZU5hbWUoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ3N5c3RlbScgJiYgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLmhhcyh2YXJpYWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlZE5hbWVzLmFkZCgnZXhwb3J0cycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2Nlc3NlZEdsb2JhbHMgPSBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKGFjY2Vzc2VkR2xvYmFscykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGFjY2Vzc2VkR2xvYmFscykge1xuICAgICAgICAgICAgICAgIHVzZWROYW1lcy5hZGQobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29udGFpbnMobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YXJpYWJsZXMuaGFzKG5hbWUpIHx8IHRoaXMucGFyZW50LmNvbnRhaW5zKG5hbWUpO1xuICAgIH1cbiAgICBkZWNvbmZsaWN0KGZvcm1hdCwgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlKSB7XG4gICAgICAgIGNvbnN0IHVzZWROYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5hZGRVc2VkT3V0c2lkZU5hbWVzKHVzZWROYW1lcywgZm9ybWF0LCBleHBvcnROYW1lc0J5VmFyaWFibGUsIGFjY2Vzc2VkR2xvYmFsc0J5U2NvcGUpO1xuICAgICAgICBpZiAodGhpcy5hY2Nlc3NlZER5bmFtaWNJbXBvcnRzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGltcG9ydEV4cHJlc3Npb24gb2YgdGhpcy5hY2Nlc3NlZER5bmFtaWNJbXBvcnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltcG9ydEV4cHJlc3Npb24uaW5saW5lTmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZWROYW1lcy5hZGQoaW1wb3J0RXhwcmVzc2lvbi5pbmxpbmVOYW1lc3BhY2UuZ2V0QmFzZVZhcmlhYmxlTmFtZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFyaWFibGVdIG9mIHRoaXMudmFyaWFibGVzKSB7XG4gICAgICAgICAgICBpZiAodmFyaWFibGUuaW5jbHVkZWQgfHwgdmFyaWFibGUuYWx3YXlzUmVuZGVyZWQpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZS5zZXRSZW5kZXJOYW1lcyhudWxsLCBnZXRTYWZlTmFtZShuYW1lLCB1c2VkTmFtZXMsIHZhcmlhYmxlLmZvcmJpZGRlbk5hbWVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBzY29wZSBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBzY29wZS5kZWNvbmZsaWN0KGZvcm1hdCwgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kTGV4aWNhbEJvdW5kYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZmluZExleGljYWxCb3VuZGFyeSgpO1xuICAgIH1cbiAgICBmaW5kR2xvYmFsKG5hbWUpIHtcbiAgICAgICAgY29uc3QgdmFyaWFibGUgPSB0aGlzLnBhcmVudC5maW5kVmFyaWFibGUobmFtZSk7XG4gICAgICAgIHRoaXMuYWNjZXNzZWRPdXRzaWRlVmFyaWFibGVzLnNldChuYW1lLCB2YXJpYWJsZSk7XG4gICAgICAgIHJldHVybiB2YXJpYWJsZTtcbiAgICB9XG4gICAgZmluZFZhcmlhYmxlKG5hbWUpIHtcbiAgICAgICAgY29uc3Qga25vd25WYXJpYWJsZSA9IHRoaXMudmFyaWFibGVzLmdldChuYW1lKSB8fCB0aGlzLmFjY2Vzc2VkT3V0c2lkZVZhcmlhYmxlcy5nZXQobmFtZSk7XG4gICAgICAgIGlmIChrbm93blZhcmlhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4ga25vd25WYXJpYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YXJpYWJsZSA9IHRoaXMucGFyZW50LmZpbmRWYXJpYWJsZShuYW1lKTtcbiAgICAgICAgdGhpcy5hY2Nlc3NlZE91dHNpZGVWYXJpYWJsZXMuc2V0KG5hbWUsIHZhcmlhYmxlKTtcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFZmZlY3RGb3JOb2Rlcyhub2RlcywgY29udGV4dCkge1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICBpZiAobm9kZS5oYXNFZmZlY3RzKGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmNsYXNzIE1ldGhvZEJhc2UgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYWNjZXNzZWRWYWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIGdldCBjb21wdXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhZ1NldCh0aGlzLmZsYWdzLCAxMDI0IC8qIEZsYWcuY29tcHV0ZWQgKi8pO1xuICAgIH1cbiAgICBzZXQgY29tcHV0ZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5mbGFncyA9IHNldEZsYWcodGhpcy5mbGFncywgMTAyNCAvKiBGbGFnLmNvbXB1dGVkICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoLCByZWN1cnNpb25UcmFja2VyKSB7XG4gICAgICAgIGlmIChpbnRlcmFjdGlvbi50eXBlID09PSBJTlRFUkFDVElPTl9BQ0NFU1NFRCAmJiB0aGlzLmtpbmQgPT09ICdnZXQnICYmIHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCh7XG4gICAgICAgICAgICAgICAgYXJnczogaW50ZXJhY3Rpb24uYXJncyxcbiAgICAgICAgICAgICAgICB0eXBlOiBJTlRFUkFDVElPTl9DQUxMRUQsXG4gICAgICAgICAgICAgICAgd2l0aE5ldzogZmFsc2VcbiAgICAgICAgICAgIH0sIEVNUFRZX1BBVEgsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcmFjdGlvbi50eXBlID09PSBJTlRFUkFDVElPTl9BU1NJR05FRCAmJiB0aGlzLmtpbmQgPT09ICdzZXQnICYmIHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCh7XG4gICAgICAgICAgICAgICAgYXJnczogaW50ZXJhY3Rpb24uYXJncyxcbiAgICAgICAgICAgICAgICB0eXBlOiBJTlRFUkFDVElPTl9DQUxMRUQsXG4gICAgICAgICAgICAgICAgd2l0aE5ldzogZmFsc2VcbiAgICAgICAgICAgIH0sIEVNUFRZX1BBVEgsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0QWNjZXNzZWRWYWx1ZSgpWzBdLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoLCByZWN1cnNpb25UcmFja2VyKTtcbiAgICB9XG4gICAgLy8gQXMgZ2V0dGVyIHByb3BlcnRpZXMgZGlyZWN0bHkgcmVjZWl2ZSB0aGVpciB2YWx1ZXMgZnJvbSBmaXhlZCBmdW5jdGlvblxuICAgIC8vIGV4cHJlc3Npb25zLCB0aGVyZSBpcyBubyBrbm93biBzaXR1YXRpb24gd2hlcmUgYSBnZXR0ZXIgaXMgZGVvcHRpbWl6ZWQuXG4gICAgZGVvcHRpbWl6ZUNhY2hlKCkgeyB9XG4gICAgZGVvcHRpbWl6ZVBhdGgocGF0aCkge1xuICAgICAgICB0aGlzLmdldEFjY2Vzc2VkVmFsdWUoKVswXS5kZW9wdGltaXplUGF0aChwYXRoKTtcbiAgICB9XG4gICAgZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBY2Nlc3NlZFZhbHVlKClbMF0uZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWNjZXNzZWRWYWx1ZSgpWzBdLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5Lmhhc0VmZmVjdHMoY29udGV4dCk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09ICdnZXQnICYmIGludGVyYWN0aW9uLnR5cGUgPT09IElOVEVSQUNUSU9OX0FDQ0VTU0VEICYmIHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChFTVBUWV9QQVRILCB7XG4gICAgICAgICAgICAgICAgYXJnczogaW50ZXJhY3Rpb24uYXJncyxcbiAgICAgICAgICAgICAgICB0eXBlOiBJTlRFUkFDVElPTl9DQUxMRUQsXG4gICAgICAgICAgICAgICAgd2l0aE5ldzogZmFsc2VcbiAgICAgICAgICAgIH0sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldHRlcnMgYXJlIG9ubHkgY2FsbGVkIGZvciBlbXB0eSBwYXRoc1xuICAgICAgICBpZiAodGhpcy5raW5kID09PSAnc2V0JyAmJiBpbnRlcmFjdGlvbi50eXBlID09PSBJTlRFUkFDVElPTl9BU1NJR05FRCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoRU1QVFlfUEFUSCwge1xuICAgICAgICAgICAgICAgIGFyZ3M6IGludGVyYWN0aW9uLmFyZ3MsXG4gICAgICAgICAgICAgICAgdHlwZTogSU5URVJBQ1RJT05fQ0FMTEVELFxuICAgICAgICAgICAgICAgIHdpdGhOZXc6IGZhbHNlXG4gICAgICAgICAgICB9LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRBY2Nlc3NlZFZhbHVlKClbMF0uaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHsgfVxuICAgIGdldEFjY2Vzc2VkVmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjY2Vzc2VkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmtpbmQgPT09ICdnZXQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY2Nlc3NlZFZhbHVlID0gVU5LTk9XTl9SRVRVUk5fRVhQUkVTU0lPTjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuYWNjZXNzZWRWYWx1ZSA9IHRoaXMudmFsdWUuZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgoRU1QVFlfUEFUSCwgTk9ERV9JTlRFUkFDVElPTl9VTktOT1dOX0NBTEwsIFNIQVJFRF9SRUNVUlNJT05fVFJBQ0tFUiwgdGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmFjY2Vzc2VkVmFsdWUgPSBbdGhpcy52YWx1ZSwgZmFsc2VdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hY2Nlc3NlZFZhbHVlO1xuICAgIH1cbn1cblxuY2xhc3MgTWV0aG9kRGVmaW5pdGlvbiBleHRlbmRzIE1ldGhvZEJhc2Uge1xuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuaGFzRWZmZWN0cyhjb250ZXh0KSB8fCBjaGVja0VmZmVjdEZvck5vZGVzKHRoaXMuZGVjb3JhdG9ycywgY29udGV4dCk7XG4gICAgfVxuICAgIGFwcGx5RGVvcHRpbWl6YXRpb25zKCkgeyB9XG59XG5cbmNsYXNzIEJsb2NrU2NvcGUgZXh0ZW5kcyBDaGlsZFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBwYXJlbnQuY29udGV4dCk7XG4gICAgfVxuICAgIGFkZERlY2xhcmF0aW9uKGlkZW50aWZpZXIsIGNvbnRleHQsIGluaXQsIGtpbmQpIHtcbiAgICAgICAgaWYgKGtpbmQgPT09ICd2YXInKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gaWRlbnRpZmllci5uYW1lO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdWYXJpYWJsZSA9IHRoaXMuaG9pc3RlZFZhcmlhYmxlcz8uZ2V0KG5hbWUpIHx8IHRoaXMudmFyaWFibGVzLmdldChuYW1lKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1ZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVmFyaWFibGUua2luZCA9PT0gJ3ZhcicgfHxcbiAgICAgICAgICAgICAgICAgICAgKGtpbmQgPT09ICd2YXInICYmIGV4aXN0aW5nVmFyaWFibGUua2luZCA9PT0gJ3BhcmFtZXRlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVmFyaWFibGUuYWRkRGVjbGFyYXRpb24oaWRlbnRpZmllciwgaW5pdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ1ZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihsb2dSZWRlY2xhcmF0aW9uRXJyb3IobmFtZSksIGlkZW50aWZpZXIuc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVjbGFyZWRWYXJpYWJsZSA9IHRoaXMucGFyZW50LmFkZERlY2xhcmF0aW9uKGlkZW50aWZpZXIsIGNvbnRleHQsIGluaXQsIGtpbmQpO1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IHRvIG1ha2Ugc3VyZSB0aGUgaW5pdCBpcyBkZW9wdGltaXplZCBmb3IgY29uZGl0aW9uYWwgZGVjbGFyYXRpb25zLlxuICAgICAgICAgICAgLy8gV2UgY2Fubm90IGNhbGwgZGVvcHRpbWl6ZVBhdGggaGVyZS5cbiAgICAgICAgICAgIGRlY2xhcmVkVmFyaWFibGUubWFya0luaXRpYWxpemVyc0ZvckRlb3B0aW1pemF0aW9uKCk7XG4gICAgICAgICAgICAvLyBXZSBhZGQgdGhlIHZhcmlhYmxlIHRvIHRoaXMgYW5kIGFsbCBwYXJlbnQgc2NvcGVzIHRvIHJlbGlhYmx5IGRldGVjdCBjb25mbGljdHNcbiAgICAgICAgICAgIHRoaXMuYWRkSG9pc3RlZFZhcmlhYmxlKG5hbWUsIGRlY2xhcmVkVmFyaWFibGUpO1xuICAgICAgICAgICAgcmV0dXJuIGRlY2xhcmVkVmFyaWFibGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmFkZERlY2xhcmF0aW9uKGlkZW50aWZpZXIsIGNvbnRleHQsIGluaXQsIGtpbmQpO1xuICAgIH1cbn1cblxuY2xhc3MgU3RhdGljQmxvY2sgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY3JlYXRlU2NvcGUocGFyZW50U2NvcGUpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IG5ldyBCbG9ja1Njb3BlKHBhcmVudFNjb3BlKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLmJvZHkpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5ib2R5KSB7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkgfHwgbm9kZS5zaG91bGRCZUluY2x1ZGVkKGNvbnRleHQpKVxuICAgICAgICAgICAgICAgIG5vZGUuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5U3RhcnRQb3MgPSBmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZS5vcmlnaW5hbC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCksICd7JykgKyAxO1xuICAgICAgICAgICAgcmVuZGVyU3RhdGVtZW50TGlzdCh0aGlzLmJvZHksIGNvZGUsIHRoaXMuc3RhcnQgKyBib2R5U3RhcnRQb3MsIHRoaXMuZW5kIC0gMSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc1N0YXRpY0Jsb2NrKHN0YXRlbWVudCkge1xuICAgIHJldHVybiBzdGF0ZW1lbnQudHlwZSA9PT0gU3RhdGljQmxvY2skMTtcbn1cblxuY2xhc3MgT2JqZWN0TWVtYmVyIGV4dGVuZHMgRXhwcmVzc2lvbkVudGl0eSB7XG4gICAgY29uc3RydWN0b3Iob2JqZWN0LCBrZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIH1cbiAgICBkZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aChpbnRlcmFjdGlvbiwgcGF0aCwgcmVjdXJzaW9uVHJhY2tlcikge1xuICAgICAgICB0aGlzLm9iamVjdC5kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aChpbnRlcmFjdGlvbiwgW3RoaXMua2V5LCAuLi5wYXRoXSwgcmVjdXJzaW9uVHJhY2tlcik7XG4gICAgfVxuICAgIGRlb3B0aW1pemVQYXRoKHBhdGgpIHtcbiAgICAgICAgdGhpcy5vYmplY3QuZGVvcHRpbWl6ZVBhdGgoW3RoaXMua2V5LCAuLi5wYXRoXSk7XG4gICAgfVxuICAgIGdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0LmdldExpdGVyYWxWYWx1ZUF0UGF0aChbdGhpcy5rZXksIC4uLnBhdGhdLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgIH1cbiAgICBnZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9iamVjdC5nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChbdGhpcy5rZXksIC4uLnBhdGhdLCBpbnRlcmFjdGlvbiwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0Lmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKFt0aGlzLmtleSwgLi4ucGF0aF0sIGludGVyYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG59XG5cbmNsYXNzIENsYXNzTm9kZSBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5vYmplY3RFbnRpdHkgPSBudWxsO1xuICAgIH1cbiAgICBjcmVhdGVTY29wZShwYXJlbnRTY29wZSkge1xuICAgICAgICB0aGlzLnNjb3BlID0gbmV3IENoaWxkU2NvcGUocGFyZW50U2NvcGUsIHBhcmVudFNjb3BlLmNvbnRleHQpO1xuICAgIH1cbiAgICBkZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aChpbnRlcmFjdGlvbiwgcGF0aCwgcmVjdXJzaW9uVHJhY2tlcikge1xuICAgICAgICB0aGlzLmdldE9iamVjdEVudGl0eSgpLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoLCByZWN1cnNpb25UcmFja2VyKTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZUNhY2hlKCkge1xuICAgICAgICB0aGlzLmdldE9iamVjdEVudGl0eSgpLmRlb3B0aW1pemVBbGxQcm9wZXJ0aWVzKCk7XG4gICAgfVxuICAgIGRlb3B0aW1pemVQYXRoKHBhdGgpIHtcbiAgICAgICAgdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5kZW9wdGltaXplUGF0aChwYXRoKTtcbiAgICB9XG4gICAgZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5nZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKTtcbiAgICB9XG4gICAgZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgY29uc3QgaW5pdEVmZmVjdCA9IHRoaXMuc3VwZXJDbGFzcz8uaGFzRWZmZWN0cyhjb250ZXh0KSB8fCB0aGlzLmJvZHkuaGFzRWZmZWN0cyhjb250ZXh0KTtcbiAgICAgICAgdGhpcy5pZD8ubWFya0RlY2xhcmF0aW9uUmVhY2hlZCgpO1xuICAgICAgICByZXR1cm4gaW5pdEVmZmVjdCB8fCBzdXBlci5oYXNFZmZlY3RzKGNvbnRleHQpIHx8IGNoZWNrRWZmZWN0Rm9yTm9kZXModGhpcy5kZWNvcmF0b3JzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGludGVyYWN0aW9uLnR5cGUgPT09IElOVEVSQUNUSU9OX0NBTExFRCAmJiBwYXRoLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgPyAhaW50ZXJhY3Rpb24ud2l0aE5ldyB8fFxuICAgICAgICAgICAgICAgICh0aGlzLmNsYXNzQ29uc3RydWN0b3IgPT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnN1cGVyQ2xhc3M/Lmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuY2xhc3NDb25zdHJ1Y3Rvci5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkpIHx8XG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgIDogdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdXBlckNsYXNzPy5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgdGhpcy5ib2R5LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICBmb3IgKGNvbnN0IGRlY29yYXRvciBvZiB0aGlzLmRlY29yYXRvcnMpXG4gICAgICAgICAgICBkZWNvcmF0b3IuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIGlmICh0aGlzLmlkKSB7XG4gICAgICAgICAgICB0aGlzLmlkLm1hcmtEZWNsYXJhdGlvblJlYWNoZWQoKTtcbiAgICAgICAgICAgIHRoaXMuaWQuaW5jbHVkZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRpYWxpc2UoKSB7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpc2UoKTtcbiAgICAgICAgdGhpcy5pZD8uZGVjbGFyZSgnY2xhc3MnLCB0aGlzKTtcbiAgICAgICAgZm9yIChjb25zdCBtZXRob2Qgb2YgdGhpcy5ib2R5LmJvZHkpIHtcbiAgICAgICAgICAgIGlmIChtZXRob2QgaW5zdGFuY2VvZiBNZXRob2REZWZpbml0aW9uICYmIG1ldGhvZC5raW5kID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc0NvbnN0cnVjdG9yID0gbWV0aG9kO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsYXNzQ29uc3RydWN0b3IgPSBudWxsO1xuICAgIH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kZW9wdGltaXplZCA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3QgZGVmaW5pdGlvbiBvZiB0aGlzLmJvZHkuYm9keSkge1xuICAgICAgICAgICAgaWYgKCFpc1N0YXRpY0Jsb2NrKGRlZmluaXRpb24pICYmXG4gICAgICAgICAgICAgICAgIShkZWZpbml0aW9uLnN0YXRpYyB8fFxuICAgICAgICAgICAgICAgICAgICAoZGVmaW5pdGlvbiBpbnN0YW5jZW9mIE1ldGhvZERlZmluaXRpb24gJiYgZGVmaW5pdGlvbi5raW5kID09PSAnY29uc3RydWN0b3InKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxscyB0byBtZXRob2RzIGFyZSBub3QgdHJhY2tlZCwgZW5zdXJlIHRoYXQgdGhlIHJldHVybiB2YWx1ZSBpcyBkZW9wdGltaXplZFxuICAgICAgICAgICAgICAgIGRlZmluaXRpb24uZGVvcHRpbWl6ZVBhdGgoVU5LTk9XTl9QQVRIKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpO1xuICAgIH1cbiAgICBnZXRPYmplY3RFbnRpdHkoKSB7XG4gICAgICAgIGlmICh0aGlzLm9iamVjdEVudGl0eSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0RW50aXR5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXRpY1Byb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZHluYW1pY01ldGhvZHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBkZWZpbml0aW9uIG9mIHRoaXMuYm9keS5ib2R5KSB7XG4gICAgICAgICAgICBpZiAoaXNTdGF0aWNCbG9jayhkZWZpbml0aW9uKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkZWZpbml0aW9uLnN0YXRpYyA/IHN0YXRpY1Byb3BlcnRpZXMgOiBkeW5hbWljTWV0aG9kcztcbiAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb25LaW5kID0gZGVmaW5pdGlvbi5raW5kO1xuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IGNsYXNzIGZpZWxkcyBkbyBub3QgZW5kIHVwIG9uIHRoZSBwcm90b3R5cGVcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzID09PSBkeW5hbWljTWV0aG9kcyAmJiAhZGVmaW5pdGlvbktpbmQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBraW5kID0gZGVmaW5pdGlvbktpbmQgPT09ICdzZXQnIHx8IGRlZmluaXRpb25LaW5kID09PSAnZ2V0JyA/IGRlZmluaXRpb25LaW5kIDogJ2luaXQnO1xuICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgIGlmIChkZWZpbml0aW9uLmNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5VmFsdWUgPSBkZWZpbml0aW9uLmtleS5nZXRMaXRlcmFsVmFsdWVBdFBhdGgoRU1QVFlfUEFUSCwgU0hBUkVEX1JFQ1VSU0lPTl9UUkFDS0VSLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleVZhbHVlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goeyBrZXk6IFVua25vd25LZXksIGtpbmQsIHByb3BlcnR5OiBkZWZpbml0aW9uIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IFN0cmluZyhrZXlWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5ID1cbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5rZXkgaW5zdGFuY2VvZiBJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGRlZmluaXRpb24ua2V5Lm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogU3RyaW5nKGRlZmluaXRpb24ua2V5LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaCh7IGtleSwga2luZCwgcHJvcGVydHk6IGRlZmluaXRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljUHJvcGVydGllcy51bnNoaWZ0KHtcbiAgICAgICAgICAgIGtleTogJ3Byb3RvdHlwZScsXG4gICAgICAgICAgICBraW5kOiAnaW5pdCcsXG4gICAgICAgICAgICBwcm9wZXJ0eTogbmV3IE9iamVjdEVudGl0eShkeW5hbWljTWV0aG9kcywgdGhpcy5zdXBlckNsYXNzID8gbmV3IE9iamVjdE1lbWJlcih0aGlzLnN1cGVyQ2xhc3MsICdwcm90b3R5cGUnKSA6IE9CSkVDVF9QUk9UT1RZUEUpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKHRoaXMub2JqZWN0RW50aXR5ID0gbmV3IE9iamVjdEVudGl0eShzdGF0aWNQcm9wZXJ0aWVzLCB0aGlzLnN1cGVyQ2xhc3MgfHwgT0JKRUNUX1BST1RPVFlQRSkpO1xuICAgIH1cbn1cblxuY2xhc3MgQ2xhc3NEZWNsYXJhdGlvbiBleHRlbmRzIENsYXNzTm9kZSB7XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGlzZSgpO1xuICAgICAgICBpZiAodGhpcy5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pZC52YXJpYWJsZS5pc0lkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZU5vZGUoZXNUcmVlTm9kZSkge1xuICAgICAgICBpZiAoZXNUcmVlTm9kZS5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IG5ldyBJZGVudGlmaWVyKHRoaXMsIHRoaXMuc2NvcGUucGFyZW50KS5wYXJzZU5vZGUoZXNUcmVlTm9kZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlTm9kZShlc1RyZWVOb2RlKTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBleHBvcnROYW1lc0J5VmFyaWFibGUsIGZvcm1hdCwgc25pcHBldHM6IHsgXywgZ2V0UHJvcGVydHlBY2Nlc3MgfSB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdmFyaWFibGUsIG5hbWUgfSA9IHRoaXMuaWQ7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnc3lzdGVtJyAmJiBleHBvcnROYW1lc0J5VmFyaWFibGUuaGFzKHZhcmlhYmxlKSkge1xuICAgICAgICAgICAgICAgIGNvZGUuYXBwZW5kTGVmdCh0aGlzLmVuZCwgYCR7X30ke2dldFN5c3RlbUV4cG9ydFN0YXRlbWVudChbdmFyaWFibGVdLCBvcHRpb25zKX07YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZW5kZXJlZFZhcmlhYmxlID0gdmFyaWFibGUuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2Vzcyk7XG4gICAgICAgICAgICBpZiAocmVuZGVyZWRWYXJpYWJsZSAhPT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdG9ycy5tYXAoZGVjb3JhdG9yID0+IGRlY29yYXRvci5yZW5kZXIoY29kZSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3VwZXJDbGFzcz8ucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5yZW5kZXIoY29kZSwge1xuICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICB1c2VPcmlnaW5hbE5hbWU6IChfdmFyaWFibGUpID0+IF92YXJpYWJsZSA9PT0gdmFyaWFibGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb2RlLnByZXBlbmRSaWdodCh0aGlzLnN0YXJ0LCBgbGV0ICR7cmVuZGVyZWRWYXJpYWJsZX0ke199PSR7X31gKTtcbiAgICAgICAgICAgICAgICBjb2RlLnByZXBlbmRMZWZ0KHRoaXMuZW5kLCAnOycpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFwcGx5RGVvcHRpbWl6YXRpb25zKCkge1xuICAgICAgICBzdXBlci5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICBjb25zdCB7IGlkLCBzY29wZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIHZhcmlhYmxlIH0gPSBpZDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWNjZXNzZWRWYXJpYWJsZSBvZiBzY29wZS5hY2Nlc3NlZE91dHNpZGVWYXJpYWJsZXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWNjZXNzZWRWYXJpYWJsZSAhPT0gdmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzZWRWYXJpYWJsZS5mb3JiaWROYW1lKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQXJndW1lbnRzVmFyaWFibGUgZXh0ZW5kcyBMb2NhbFZhcmlhYmxlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKCdhcmd1bWVudHMnLCBudWxsLCBVTktOT1dOX0VYUFJFU1NJT04sIGNvbnRleHQsICdvdGhlcicpO1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVkQXJndW1lbnRzID0gW107XG4gICAgfVxuICAgIGFkZEFyZ3VtZW50VG9CZURlb3B0aW1pemVkKGFyZ3VtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICBhcmd1bWVudC5kZW9wdGltaXplUGF0aChVTktOT1dOX1BBVEgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZW9wdGltaXplZEFyZ3VtZW50cy5wdXNoKGFyZ3VtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCB7IHR5cGUgfSkge1xuICAgICAgICByZXR1cm4gdHlwZSAhPT0gSU5URVJBQ1RJT05fQUNDRVNTRUQgfHwgcGF0aC5sZW5ndGggPiAxO1xuICAgIH1cbiAgICBpbmNsdWRlKCkge1xuICAgICAgICBzdXBlci5pbmNsdWRlKCk7XG4gICAgICAgIGZvciAoY29uc3QgYXJndW1lbnQgb2YgdGhpcy5kZW9wdGltaXplZEFyZ3VtZW50cykge1xuICAgICAgICAgICAgYXJndW1lbnQuZGVvcHRpbWl6ZVBhdGgoVU5LTk9XTl9QQVRIKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlb3B0aW1pemVkQXJndW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgfVxufVxuXG5jb25zdCBNQVhfVFJBQ0tFRF9JTlRFUkFDVElPTlMgPSAyMDtcbmNvbnN0IE5PX0lOVEVSQUNUSU9OUyA9IEVNUFRZX0FSUkFZO1xuY29uc3QgVU5LTk9XTl9ERU9QVElNSVpFRF9GSUVMRCA9IG5ldyBTZXQoW1Vua25vd25LZXldKTtcbmNvbnN0IEVNUFRZX1BBVEhfVFJBQ0tFUiA9IG5ldyBQYXRoVHJhY2tlcigpO1xuY29uc3QgVU5LTk9XTl9ERU9QVElNSVpFRF9FTlRJVFkgPSBuZXcgU2V0KFtVTktOT1dOX0VYUFJFU1NJT05dKTtcbmNsYXNzIFBhcmFtZXRlclZhcmlhYmxlIGV4dGVuZHMgTG9jYWxWYXJpYWJsZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgZGVjbGFyYXRvciwgY29udGV4dCkge1xuICAgICAgICBzdXBlcihuYW1lLCBkZWNsYXJhdG9yLCBVTktOT1dOX0VYUFJFU1NJT04sIGNvbnRleHQsICdwYXJhbWV0ZXInKTtcbiAgICAgICAgdGhpcy5kZW9wdGltaXphdGlvbkludGVyYWN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmRlb3B0aW1pemF0aW9ucyA9IG5ldyBQYXRoVHJhY2tlcigpO1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVkRmllbGRzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmVudGl0aWVzVG9CZURlb3B0aW1pemVkID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zVXNlVGhlS25vd25WYWx1ZSA9IFtdO1xuICAgICAgICB0aGlzLmtub3duVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLmtub3duVmFsdWVMaXRlcmFsID0gVW5rbm93blZhbHVlO1xuICAgICAgICB0aGlzLmZyb3plblZhbHVlID0gbnVsbDtcbiAgICB9XG4gICAgYWRkRW50aXR5VG9CZURlb3B0aW1pemVkKGVudGl0eSkge1xuICAgICAgICBpZiAoZW50aXR5ID09PSBVTktOT1dOX0VYUFJFU1NJT04pIHtcbiAgICAgICAgICAgIC8vIEFzIHVua25vd24gZXhwcmVzc2lvbnMgZnVsbHkgZGVvcHRpbWl6ZSBhbGwgaW50ZXJhY3Rpb25zLCB3ZSBjYW4gY2xlYXJcbiAgICAgICAgICAgIC8vIHRoZSBpbnRlcmFjdGlvbiBjYWNoZSBhdCB0aGlzIHBvaW50IHByb3ZpZGVkIHdlIGtlZXAgdGhpcyBvcHRpbWl6YXRpb25cbiAgICAgICAgICAgIC8vIGluIG1pbmQgd2hlbiBhZGRpbmcgbmV3IGludGVyYWN0aW9uc1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVudGl0aWVzVG9CZURlb3B0aW1pemVkLmhhcyhVTktOT1dOX0VYUFJFU1NJT04pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRpdGllc1RvQmVEZW9wdGltaXplZC5hZGQoVU5LTk9XTl9FWFBSRVNTSU9OKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgaW50ZXJhY3Rpb24gfSBvZiB0aGlzLmRlb3B0aW1pemF0aW9uSW50ZXJhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlb3B0aW1pemVJbnRlcmFjdGlvbihpbnRlcmFjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGVvcHRpbWl6YXRpb25JbnRlcmFjdGlvbnMgPSBOT19JTlRFUkFDVElPTlM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZW9wdGltaXplZEZpZWxkcy5oYXMoVW5rbm93bktleSkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB3ZSBhbHJlYWR5IGRlb3B0aW1pemVkIGFsbCBpbnRlcmFjdGlvbnMgYW5kIG5vIGxvbmdlclxuICAgICAgICAgICAgLy8gdHJhY2sgdGhlbVxuICAgICAgICAgICAgZW50aXR5LmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuZW50aXRpZXNUb0JlRGVvcHRpbWl6ZWQuaGFzKGVudGl0eSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW50aXRpZXNUb0JlRGVvcHRpbWl6ZWQuYWRkKGVudGl0eSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHRoaXMuZGVvcHRpbWl6ZWRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBlbnRpdHkuZGVvcHRpbWl6ZVBhdGgoW2ZpZWxkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgaW50ZXJhY3Rpb24sIHBhdGggfSBvZiB0aGlzLmRlb3B0aW1pemF0aW9uSW50ZXJhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgZW50aXR5LmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoLCBTSEFSRURfUkVDVVJTSU9OX1RSQUNLRVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1hcmtSZWFzc2lnbmVkKCkge1xuICAgICAgICBpZiAodGhpcy5pc1JlYXNzaWduZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5tYXJrUmVhc3NpZ25lZCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGV4cHJlc3Npb24gb2YgdGhpcy5leHByZXNzaW9uc1VzZVRoZUtub3duVmFsdWUpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZGVvcHRpbWl6ZUNhY2hlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5leHByZXNzaW9uc1VzZVRoZUtub3duVmFsdWUgPSBFTVBUWV9BUlJBWTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZUNhY2hlKCkge1xuICAgICAgICB0aGlzLm1hcmtSZWFzc2lnbmVkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUga25vd24gdmFsdWUgb2YgdGhlIHBhcmFtZXRlciB2YXJpYWJsZS5cbiAgICAgKiBNdXN0IGJlIGNhbGxlZCBmb3IgZXZlcnkgZnVuY3Rpb24gY2FsbCwgc28gaXQgY2FuIHRyYWNrIGFsbCB0aGUgYXJndW1lbnRzLFxuICAgICAqIGFuZCBkZW9wdGltaXplQ2FjaGUgaXRzZWxmIHRvIG1hcmsgcmVhc3NpZ25lZCBpZiB0aGUgYXJndW1lbnQgaXMgY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0gYXJndW1lbnQgVGhlIGFyZ3VtZW50IG9mIHRoZSBmdW5jdGlvbiBjYWxsXG4gICAgICovXG4gICAgdXBkYXRlS25vd25WYWx1ZShhcmd1bWVudCkge1xuICAgICAgICBpZiAodGhpcy5pc1JlYXNzaWduZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5rbm93blZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmtub3duVmFsdWUgPSBhcmd1bWVudDtcbiAgICAgICAgICAgIHRoaXMua25vd25WYWx1ZUxpdGVyYWwgPSBhcmd1bWVudC5nZXRMaXRlcmFsVmFsdWVBdFBhdGgoRU1QVFlfUEFUSCwgU0hBUkVEX1JFQ1VSU0lPTl9UUkFDS0VSLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgc2FtZSBsaXRlcmFsIG9yIGlkZW50aWZpZXIsIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHRoaXMua25vd25WYWx1ZSA9PT0gYXJndW1lbnQgfHxcbiAgICAgICAgICAgICh0aGlzLmtub3duVmFsdWUgaW5zdGFuY2VvZiBJZGVudGlmaWVyICYmXG4gICAgICAgICAgICAgICAgYXJndW1lbnQgaW5zdGFuY2VvZiBJZGVudGlmaWVyICYmXG4gICAgICAgICAgICAgICAgdGhpcy5rbm93blZhbHVlLnZhcmlhYmxlID09PSBhcmd1bWVudC52YXJpYWJsZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMua25vd25WYWx1ZUxpdGVyYWw7XG4gICAgICAgIGlmICh0eXBlb2Ygb2xkVmFsdWUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtSZWFzc2lnbmVkKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHRyYWNraW5nIGZvciB0aGUgbmV3IGFyZ3VtZW50XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gYXJndW1lbnQuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKEVNUFRZX1BBVEgsIFNIQVJFRF9SRUNVUlNJT05fVFJBQ0tFUiwgdGhpcyk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubWFya1JlYXNzaWduZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGZyZWV6ZXMgdGhlIGtub3duIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIgdmFyaWFibGUsXG4gICAgICogc28gdGhlIG9wdGltaXphdGlvbiBzdGFydHMgd2l0aCBhIGNlcnRhaW4gRXhwcmVzc2lvbkVudGl0eS5cbiAgICAgKiBUaGUgb3B0aW1pemF0aW9uIGNhbiBiZSB1bmRvbmUgYnkgY2FsbGluZyBgbWFya1JlYXNzaWduZWRgLlxuICAgICAqIEByZXR1cm5zIHRoZSBmcm96ZW4gdmFsdWVcbiAgICAgKi9cbiAgICBnZXRLbm93blZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5mcm96ZW5WYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5mcm96ZW5WYWx1ZSA9IHRoaXMua25vd25WYWx1ZSB8fCBVTktOT1dOX0VYUFJFU1NJT047XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvemVuVmFsdWU7XG4gICAgfVxuICAgIGdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWFzc2lnbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtub3duVmFsdWUgPSB0aGlzLmdldEtub3duVmFsdWUoKTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uc1VzZVRoZUtub3duVmFsdWUucHVzaChvcmlnaW4pO1xuICAgICAgICByZXR1cm4gcmVjdXJzaW9uVHJhY2tlci53aXRoVHJhY2tlZEVudGl0eUF0UGF0aChwYXRoLCBrbm93blZhbHVlLCAoKSA9PiBrbm93blZhbHVlLmdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pLCBVbmtub3duVmFsdWUpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5pc1JlYXNzaWduZWQgfHwgaW50ZXJhY3Rpb24udHlwZSA9PT0gSU5URVJBQ1RJT05fQVNTSUdORUQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga25vd25WYWx1ZSA9IHRoaXMuZ2V0S25vd25WYWx1ZSgpO1xuICAgICAgICByZXR1cm4ga25vd25WYWx1ZS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoKSB7XG4gICAgICAgIC8vIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBmdWxseSBkZW9wdGltaXplIGFsbCBkZWVwZXIgaW50ZXJhY3Rpb25zXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+PSAyIHx8XG4gICAgICAgICAgICB0aGlzLmVudGl0aWVzVG9CZURlb3B0aW1pemVkLmhhcyhVTktOT1dOX0VYUFJFU1NJT04pIHx8XG4gICAgICAgICAgICB0aGlzLmRlb3B0aW1pemF0aW9uSW50ZXJhY3Rpb25zLmxlbmd0aCA+PSBNQVhfVFJBQ0tFRF9JTlRFUkFDVElPTlMgfHxcbiAgICAgICAgICAgIChwYXRoLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLmRlb3B0aW1pemVkRmllbGRzLmhhcyhVbmtub3duS2V5KSB8fFxuICAgICAgICAgICAgICAgICAgICAoaW50ZXJhY3Rpb24udHlwZSA9PT0gSU5URVJBQ1RJT05fQ0FMTEVEICYmIHRoaXMuZGVvcHRpbWl6ZWRGaWVsZHMuaGFzKHBhdGhbMF0pKSkpKSB7XG4gICAgICAgICAgICBkZW9wdGltaXplSW50ZXJhY3Rpb24oaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5kZW9wdGltaXphdGlvbnMudHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQocGF0aCwgaW50ZXJhY3Rpb24uYXJncykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXNUb0JlRGVvcHRpbWl6ZWQpIHtcbiAgICAgICAgICAgICAgICBlbnRpdHkuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHBhdGgsIFNIQVJFRF9SRUNVUlNJT05fVFJBQ0tFUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZW50aXRpZXNUb0JlRGVvcHRpbWl6ZWQuaGFzKFVOS05PV05fRVhQUkVTU0lPTikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlb3B0aW1pemF0aW9uSW50ZXJhY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcGF0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlb3B0aW1pemVQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtSZWFzc2lnbmVkKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVvcHRpbWl6ZWRGaWVsZHMuaGFzKFVua25vd25LZXkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gcGF0aFswXTtcbiAgICAgICAgaWYgKHRoaXMuZGVvcHRpbWl6ZWRGaWVsZHMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlb3B0aW1pemVkRmllbGRzLmFkZChrZXkpO1xuICAgICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzVG9CZURlb3B0aW1pemVkKSB7XG4gICAgICAgICAgICAvLyBXZSBkbyBub3QgbmVlZCBhIHJlY3Vyc2lvbiB0cmFja2VyIGhlcmUgYXMgd2UgYWxyZWFkeSB0cmFjayB3aGV0aGVyXG4gICAgICAgICAgICAvLyB0aGlzIGZpZWxkIGlzIGRlb3B0aW1pemVkXG4gICAgICAgICAgICBlbnRpdHkuZGVvcHRpbWl6ZVBhdGgoW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09IFVua25vd25LZXkpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgc29tZSBtZW1vcnlcbiAgICAgICAgICAgIHRoaXMuZGVvcHRpbWl6YXRpb25JbnRlcmFjdGlvbnMgPSBOT19JTlRFUkFDVElPTlM7XG4gICAgICAgICAgICB0aGlzLmRlb3B0aW1pemF0aW9ucyA9IEVNUFRZX1BBVEhfVFJBQ0tFUjtcbiAgICAgICAgICAgIHRoaXMuZGVvcHRpbWl6ZWRGaWVsZHMgPSBVTktOT1dOX0RFT1BUSU1JWkVEX0ZJRUxEO1xuICAgICAgICAgICAgdGhpcy5lbnRpdGllc1RvQmVEZW9wdGltaXplZCA9IFVOS05PV05fREVPUFRJTUlaRURfRU5USVRZO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgpIHtcbiAgICAgICAgLy8gV2UgZGVvcHRpbWl6ZSBldmVyeXRoaW5nIHRoYXQgaXMgY2FsbGVkIGFzIHRoYXQgd2lsbCB0cml2aWFsbHkgZGVvcHRpbWl6ZVxuICAgICAgICAvLyB0aGUgY29ycmVzcG9uZGluZyByZXR1cm4gZXhwcmVzc2lvbnMgYXMgd2VsbCBhbmQgYXZvaWQgYmFkbHkgcGVyZm9ybWluZ1xuICAgICAgICAvLyBhbmQgY29tcGxpY2F0ZWQgYWx0ZXJuYXRpdmVzXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZW9wdGltaXplUGF0aChVTktOT1dOX1BBVEgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmRlb3B0aW1pemVkRmllbGRzLmhhcyhwYXRoWzBdKSkge1xuICAgICAgICAgICAgdGhpcy5kZW9wdGltaXplUGF0aChbcGF0aFswXV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVTktOT1dOX1JFVFVSTl9FWFBSRVNTSU9OO1xuICAgIH1cbn1cblxuY2xhc3MgVGhpc1ZhcmlhYmxlIGV4dGVuZHMgUGFyYW1ldGVyVmFyaWFibGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoJ3RoaXMnLCBudWxsLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIChjb250ZXh0LnJlcGxhY2VkVmFyaWFibGVJbml0cy5nZXQodGhpcykgfHwgVU5LTk9XTl9FWFBSRVNTSU9OKS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCk7XG4gICAgfVxufVxuXG5jbGFzcyBDYXRjaEJvZHlTY29wZSBleHRlbmRzIENoaWxkU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgICAgICBzdXBlcihwYXJlbnQsIHBhcmVudC5jb250ZXh0KTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGFkZERlY2xhcmF0aW9uKGlkZW50aWZpZXIsIGNvbnRleHQsIGluaXQsIGtpbmQpIHtcbiAgICAgICAgaWYgKGtpbmQgPT09ICd2YXInKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gaWRlbnRpZmllci5uYW1lO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdWYXJpYWJsZSA9IHRoaXMuaG9pc3RlZFZhcmlhYmxlcz8uZ2V0KG5hbWUpIHx8IHRoaXMudmFyaWFibGVzLmdldChuYW1lKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1ZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdLaW5kID0gZXhpc3RpbmdWYXJpYWJsZS5raW5kO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0tpbmQgPT09ICdwYXJhbWV0ZXInICYmXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBkZXN0cnVjdHVyZWQgcGFyYW1ldGVyLCBpdCBpcyBmb3JiaWRkZW4gdG8gcmVkZWNsYXJlXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVmFyaWFibGUuZGVjbGFyYXRpb25zWzBdLnBhcmVudC50eXBlID09PSBDYXRjaENsYXVzZSQxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSB2YXIgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBjYXRjaCBzY29wZSBwYXJhbWV0ZXIsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhc3NpZ25tZW50IGFjdHVhbGx5IGdvZXMgdG8gdGhlIHBhcmFtZXRlciBhbmQgdGhlIHZhciBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBob2lzdGVkIHdpdGhvdXQgYXNzaWdubWVudC4gTG9jYWxseSwgaXQgaXMgc2hhZG93ZWQgYnkgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcmFtZXRlclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNsYXJlZFZhcmlhYmxlID0gdGhpcy5wYXJlbnQucGFyZW50LmFkZERlY2xhcmF0aW9uKGlkZW50aWZpZXIsIGNvbnRleHQsIFVOREVGSU5FRF9FWFBSRVNTSU9OLCBraW5kKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVG8gYXZvaWQgdGhlIG5lZWQgdG8gcmV3cml0ZSB0aGUgZGVjbGFyYXRpb24sIHdlIGxpbmsgdGhlIHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vIG5hbWVzLiBJZiB3ZSBldmVyIGltcGxlbWVudCBhIGxvZ2ljIHRoYXQgc3BsaXRzIGluaXRpYWxpemF0aW9uIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyBhc3NpZ25tZW50IGZvciBob2lzdGVkIHZhcnMsIHRoZSBcInJlbmRlckxpa2VIb2lzdGVkXCIgbG9naWMgY2FuIGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZWQgYWdhaW4uXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIG5vdCBuZWVkIHRvIGNoZWNrIHdoZXRoZXIgdGhlcmUgYWxyZWFkeSBpcyBhIGxpbmtlZFxuICAgICAgICAgICAgICAgICAgICAvLyB2YXJpYWJsZSBiZWNhdXNlIHRoZW4gZGVjbGFyZWRWYXJpYWJsZSB3b3VsZCBiZSB0aGF0IGxpbmtlZFxuICAgICAgICAgICAgICAgICAgICAvLyB2YXJpYWJsZS5cbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdWYXJpYWJsZS5yZW5kZXJMaWtlSG9pc3RlZChkZWNsYXJlZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRIb2lzdGVkVmFyaWFibGUobmFtZSwgZGVjbGFyZWRWYXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNsYXJlZFZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdLaW5kID09PSAndmFyJykge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1ZhcmlhYmxlLmFkZERlY2xhcmF0aW9uKGlkZW50aWZpZXIsIGluaXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdWYXJpYWJsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IobG9nUmVkZWNsYXJhdGlvbkVycm9yKG5hbWUpLCBpZGVudGlmaWVyLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgYWRkIHBhcmFtZXRlcnMgdG8gcGFyYW1ldGVyIHNjb3Blc1xuICAgICAgICAgICAgY29uc3QgZGVjbGFyZWRWYXJpYWJsZSA9IHRoaXMucGFyZW50LnBhcmVudC5hZGREZWNsYXJhdGlvbihpZGVudGlmaWVyLCBjb250ZXh0LCBpbml0LCBraW5kKTtcbiAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSB0byBtYWtlIHN1cmUgdGhlIGluaXQgaXMgZGVvcHRpbWl6ZWQgZm9yIGNvbmRpdGlvbmFsIGRlY2xhcmF0aW9ucy5cbiAgICAgICAgICAgIC8vIFdlIGNhbm5vdCBjYWxsIGRlb3B0aW1pemVQYXRoIGhlcmUuXG4gICAgICAgICAgICBkZWNsYXJlZFZhcmlhYmxlLm1hcmtJbml0aWFsaXplcnNGb3JEZW9wdGltaXphdGlvbigpO1xuICAgICAgICAgICAgLy8gV2UgYWRkIHRoZSB2YXJpYWJsZSB0byB0aGlzIGFuZCBhbGwgcGFyZW50IHNjb3BlcyB0byByZWxpYWJseSBkZXRlY3QgY29uZmxpY3RzXG4gICAgICAgICAgICB0aGlzLmFkZEhvaXN0ZWRWYXJpYWJsZShuYW1lLCBkZWNsYXJlZFZhcmlhYmxlKTtcbiAgICAgICAgICAgIHJldHVybiBkZWNsYXJlZFZhcmlhYmxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5hZGREZWNsYXJhdGlvbihpZGVudGlmaWVyLCBjb250ZXh0LCBpbml0LCBraW5kKTtcbiAgICB9XG59XG5cbmNsYXNzIEZ1bmN0aW9uQm9keVNjb3BlIGV4dGVuZHMgQ2hpbGRTY29wZSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgcGFyZW50LmNvbnRleHQpO1xuICAgIH1cbiAgICAvLyBUaGVyZSBpcyBzdHVmZiB0aGF0IGlzIG9ubHkgYWxsb3dlZCBpbiBmdW5jdGlvbiBzY29wZXMsIGkuZS4gZnVuY3Rpb25zIGNhblxuICAgIC8vIGJlIHJlZGVjbGFyZWQsIGZ1bmN0aW9ucyBhbmQgdmFyIGNhbiByZWRlY2xhcmUgZWFjaCBvdGhlclxuICAgIGFkZERlY2xhcmF0aW9uKGlkZW50aWZpZXIsIGNvbnRleHQsIGluaXQsIGtpbmQpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGlkZW50aWZpZXIubmFtZTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdWYXJpYWJsZSA9IHRoaXMuaG9pc3RlZFZhcmlhYmxlcz8uZ2V0KG5hbWUpIHx8IHRoaXMudmFyaWFibGVzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nVmFyaWFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nS2luZCA9IGV4aXN0aW5nVmFyaWFibGUua2luZDtcbiAgICAgICAgICAgIGlmICgoa2luZCA9PT0gJ3ZhcicgfHwga2luZCA9PT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICAoZXhpc3RpbmdLaW5kID09PSAndmFyJyB8fCBleGlzdGluZ0tpbmQgPT09ICdmdW5jdGlvbicgfHwgZXhpc3RpbmdLaW5kID09PSAncGFyYW1ldGVyJykpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1ZhcmlhYmxlLmFkZERlY2xhcmF0aW9uKGlkZW50aWZpZXIsIGluaXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ1ZhcmlhYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5lcnJvcihsb2dSZWRlY2xhcmF0aW9uRXJyb3IobmFtZSksIGlkZW50aWZpZXIuc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1ZhcmlhYmxlID0gbmV3IExvY2FsVmFyaWFibGUoaWRlbnRpZmllci5uYW1lLCBpZGVudGlmaWVyLCBpbml0LCBjb250ZXh0LCBraW5kKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMuc2V0KG5hbWUsIG5ld1ZhcmlhYmxlKTtcbiAgICAgICAgcmV0dXJuIG5ld1ZhcmlhYmxlO1xuICAgIH1cbn1cblxuY2xhc3MgUGFyYW1ldGVyU2NvcGUgZXh0ZW5kcyBDaGlsZFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGlzQ2F0Y2hTY29wZSkge1xuICAgICAgICBzdXBlcihwYXJlbnQsIHBhcmVudC5jb250ZXh0KTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHRoaXMuaGFzUmVzdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJvZHlTY29wZSA9IGlzQ2F0Y2hTY29wZSA/IG5ldyBDYXRjaEJvZHlTY29wZSh0aGlzKSA6IG5ldyBGdW5jdGlvbkJvZHlTY29wZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHBhcmFtZXRlciB0byB0aGlzIHNjb3BlLiBQYXJhbWV0ZXJzIG11c3QgYmUgYWRkZWQgaW4gdGhlIGNvcnJlY3RcbiAgICAgKiBvcmRlciwgaS5lLiBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICovXG4gICAgYWRkUGFyYW1ldGVyRGVjbGFyYXRpb24oaWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCB7IG5hbWUsIHN0YXJ0IH0gPSBpZGVudGlmaWVyO1xuICAgICAgICBjb25zdCBleGlzdGluZ1BhcmFtZXRlciA9IHRoaXMudmFyaWFibGVzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nUGFyYW1ldGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmVycm9yKGxvZ0R1cGxpY2F0ZUFyZ3VtZW50TmFtZUVycm9yKG5hbWUpLCBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFyaWFibGUgPSBuZXcgUGFyYW1ldGVyVmFyaWFibGUobmFtZSwgaWRlbnRpZmllciwgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMuc2V0KG5hbWUsIHZhcmlhYmxlKTtcbiAgICAgICAgLy8gV2UgYWxzbyBhZGQgaXQgdG8gdGhlIGJvZHkgc2NvcGUgdG8gZGV0ZWN0IG5hbWUgY29uZmxpY3RzIHdpdGggbG9jYWxcbiAgICAgICAgLy8gdmFyaWFibGVzLiBXZSBzdGlsbCBuZWVkIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUsIHRob3VnaCwgYXMgcGFyYW1ldGVyXG4gICAgICAgIC8vIGRlZmF1bHRzIGFyZSBOT1QgdGFrZW4gZnJvbSB0aGUgYm9keSBzY29wZSBidXQgZnJvbSB0aGUgcGFyYW1ldGVycyBvclxuICAgICAgICAvLyBvdXRzaWRlIHNjb3BlLlxuICAgICAgICB0aGlzLmJvZHlTY29wZS5hZGRIb2lzdGVkVmFyaWFibGUobmFtZSwgdmFyaWFibGUpO1xuICAgICAgICByZXR1cm4gdmFyaWFibGU7XG4gICAgfVxuICAgIGFkZFBhcmFtZXRlclZhcmlhYmxlcyhwYXJhbWV0ZXJzLCBoYXNSZXN0KSB7XG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICAgIGZvciAoY29uc3QgcGFyYW1ldGVyTGlzdCBvZiBwYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcmFtZXRlciBvZiBwYXJhbWV0ZXJMaXN0KSB7XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyLmFsd2F5c1JlbmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc1Jlc3QgPSBoYXNSZXN0O1xuICAgIH1cbiAgICBpbmNsdWRlQ2FsbEFyZ3VtZW50cyhjb250ZXh0LCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGxldCBjYWxsZWRGcm9tVHJ5U3RhdGVtZW50ID0gZmFsc2U7XG4gICAgICAgIGxldCBhcmd1bWVudEluY2x1ZGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHJlc3RQYXJhbWV0ZXIgPSB0aGlzLmhhc1Jlc3QgJiYgdGhpcy5wYXJhbWV0ZXJzW3RoaXMucGFyYW1ldGVycy5sZW5ndGggLSAxXTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVja2VkQXJndW1lbnQgb2YgcGFyYW1ldGVycykge1xuICAgICAgICAgICAgaWYgKGNoZWNrZWRBcmd1bWVudCBpbnN0YW5jZW9mIFNwcmVhZEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFyZ3VtZW50IG9mIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQuaW5jbHVkZShjb250ZXh0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gcGFyYW1ldGVycy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJWYXJpYWJsZXMgPSB0aGlzLnBhcmFtZXRlcnNbaW5kZXhdIHx8IHJlc3RQYXJhbWV0ZXI7XG4gICAgICAgICAgICBjb25zdCBhcmd1bWVudCA9IHBhcmFtZXRlcnNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHBhcmFtZXRlclZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgIGNhbGxlZEZyb21UcnlTdGF0ZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1ldGVyVmFyaWFibGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZW1wdHkgZGVzdHJ1Y3R1cmluZ1xuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudEluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgcGFyYW1ldGVyVmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWFibGUuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudEluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZS5jYWxsZWRGcm9tVHJ5U3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVkRnJvbVRyeVN0YXRlbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50SW5jbHVkZWQgJiYgYXJndW1lbnQuc2hvdWxkQmVJbmNsdWRlZChjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50SW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50SW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICBhcmd1bWVudC5pbmNsdWRlKGNvbnRleHQsIGNhbGxlZEZyb21UcnlTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBSZXR1cm5WYWx1ZVNjb3BlIGV4dGVuZHMgUGFyYW1ldGVyU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnJldHVybkV4cHJlc3Npb24gPSBudWxsO1xuICAgICAgICB0aGlzLnJldHVybkV4cHJlc3Npb25zID0gW107XG4gICAgfVxuICAgIGFkZFJldHVybkV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICAgICAgICB0aGlzLnJldHVybkV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJldHVybkV4cHJlc3Npb24gPT09IG51bGwpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJldHVybkV4cHJlc3Npb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0dXJuRXhwcmVzc2lvbjtcbiAgICB9XG4gICAgdXBkYXRlUmV0dXJuRXhwcmVzc2lvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucmV0dXJuRXhwcmVzc2lvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnJldHVybkV4cHJlc3Npb24gPSB0aGlzLnJldHVybkV4cHJlc3Npb25zWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXR1cm5FeHByZXNzaW9uID0gVU5LTk9XTl9FWFBSRVNTSU9OO1xuICAgICAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIHRoaXMucmV0dXJuRXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uLmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEZ1bmN0aW9uU2NvcGUgZXh0ZW5kcyBSZXR1cm5WYWx1ZVNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZXh0IH0gPSBwYXJlbnQ7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgZmFsc2UpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcy5zZXQoJ2FyZ3VtZW50cycsICh0aGlzLmFyZ3VtZW50c1ZhcmlhYmxlID0gbmV3IEFyZ3VtZW50c1ZhcmlhYmxlKGNvbnRleHQpKSk7XG4gICAgICAgIHRoaXMudmFyaWFibGVzLnNldCgndGhpcycsICh0aGlzLnRoaXNWYXJpYWJsZSA9IG5ldyBUaGlzVmFyaWFibGUoY29udGV4dCkpKTtcbiAgICB9XG4gICAgZmluZExleGljYWxCb3VuZGFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGluY2x1ZGVDYWxsQXJndW1lbnRzKGNvbnRleHQsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgc3VwZXIuaW5jbHVkZUNhbGxBcmd1bWVudHMoY29udGV4dCwgcGFyYW1ldGVycyk7XG4gICAgICAgIGlmICh0aGlzLmFyZ3VtZW50c1ZhcmlhYmxlLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFyZ3VtZW50IG9mIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZ3VtZW50LmluY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50LmluY2x1ZGUoY29udGV4dCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgRXhwcmVzc2lvblN0YXRlbWVudCBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBpbml0aWFsaXNlKCkge1xuICAgICAgICBzdXBlci5pbml0aWFsaXNlKCk7XG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZSAmJlxuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmUgIT09ICd1c2Ugc3RyaWN0JyAmJlxuICAgICAgICAgICAgdGhpcy5wYXJlbnQudHlwZSA9PT0gUHJvZ3JhbSQxKSB7XG4gICAgICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQubG9nKExPR0xFVkVMX1dBUk4sIFxuICAgICAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnksIGJlY2F1c2UgZWl0aGVyIHdheSAoZGVsZXRpbmcgb3Igbm90KSBjYW4gbGVhZCB0byBlcnJvcnMuXG4gICAgICAgICAgICBsb2dNb2R1bGVMZXZlbERpcmVjdGl2ZSh0aGlzLmRpcmVjdGl2ZSwgdGhpcy5zY29wZS5jb250ZXh0Lm1vZHVsZS5pZCksIHRoaXMuc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUFubm90YXRpb25zKGNvZGUpIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uLnJlbW92ZUFubm90YXRpb25zKGNvZGUpO1xuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlci5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChjb2RlLm9yaWdpbmFsW3RoaXMuZW5kIC0gMV0gIT09ICc7Jykge1xuICAgICAgICAgICAgY29kZS5hcHBlbmRMZWZ0KHRoaXMuZW5kLCAnOycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNob3VsZEJlSW5jbHVkZWQoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5kaXJlY3RpdmUgJiYgdGhpcy5kaXJlY3RpdmUgIT09ICd1c2Ugc3RyaWN0JylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC50eXBlICE9PSBQcm9ncmFtJDE7XG4gICAgICAgIHJldHVybiBzdXBlci5zaG91bGRCZUluY2x1ZGVkKGNvbnRleHQpO1xuICAgIH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHsgfVxufVxuXG5jbGFzcyBCbG9ja1N0YXRlbWVudCBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBnZXQgZGVvcHRpbWl6ZUJvZHkoKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYWdTZXQodGhpcy5mbGFncywgMzI3NjggLyogRmxhZy5kZW9wdGltaXplQm9keSAqLyk7XG4gICAgfVxuICAgIHNldCBkZW9wdGltaXplQm9keSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZsYWdzID0gc2V0RmxhZyh0aGlzLmZsYWdzLCAzMjc2OCAvKiBGbGFnLmRlb3B0aW1pemVCb2R5ICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBkaXJlY3RseUluY2x1ZGVkKCkge1xuICAgICAgICByZXR1cm4gaXNGbGFnU2V0KHRoaXMuZmxhZ3MsIDE2Mzg0IC8qIEZsYWcuZGlyZWN0bHlJbmNsdWRlZCAqLyk7XG4gICAgfVxuICAgIHNldCBkaXJlY3RseUluY2x1ZGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBzZXRGbGFnKHRoaXMuZmxhZ3MsIDE2Mzg0IC8qIEZsYWcuZGlyZWN0bHlJbmNsdWRlZCAqLywgdmFsdWUpO1xuICAgIH1cbiAgICBhZGRJbXBsaWNpdFJldHVybkV4cHJlc3Npb25Ub1Njb3BlKCkge1xuICAgICAgICBjb25zdCBsYXN0U3RhdGVtZW50ID0gdGhpcy5ib2R5W3RoaXMuYm9keS5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKCFsYXN0U3RhdGVtZW50IHx8IGxhc3RTdGF0ZW1lbnQudHlwZSAhPT0gUmV0dXJuU3RhdGVtZW50JDEpIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGUuYWRkUmV0dXJuRXhwcmVzc2lvbihVTktOT1dOX0VYUFJFU1NJT04pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVNjb3BlKHBhcmVudFNjb3BlKSB7XG4gICAgICAgIHRoaXMuc2NvcGUgPSB0aGlzLnBhcmVudC5wcmV2ZW50Q2hpbGRCbG9ja1Njb3BlXG4gICAgICAgICAgICA/IHBhcmVudFNjb3BlXG4gICAgICAgICAgICA6IG5ldyBCbG9ja1Njb3BlKHBhcmVudFNjb3BlKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmRlb3B0aW1pemVCb2R5KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLmJvZHkpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmJyb2tlbkZsb3cpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobm9kZS5oYXNFZmZlY3RzKGNvbnRleHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICBpZiAoISh0aGlzLmRlb3B0aW1pemVCb2R5ICYmIHRoaXMuZGlyZWN0bHlJbmNsdWRlZCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RseUluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlb3B0aW1pemVCb2R5KVxuICAgICAgICAgICAgICAgIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLmJvZHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkgfHwgbm9kZS5zaG91bGRCZUluY2x1ZGVkKGNvbnRleHQpKVxuICAgICAgICAgICAgICAgICAgICBub2RlLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRpYWxpc2UoKSB7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpc2UoKTtcbiAgICAgICAgY29uc3QgZmlyc3RCb2R5U3RhdGVtZW50ID0gdGhpcy5ib2R5WzBdO1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVCb2R5ID1cbiAgICAgICAgICAgIGZpcnN0Qm9keVN0YXRlbWVudCBpbnN0YW5jZW9mIEV4cHJlc3Npb25TdGF0ZW1lbnQgJiZcbiAgICAgICAgICAgICAgICBmaXJzdEJvZHlTdGF0ZW1lbnQuZGlyZWN0aXZlID09PSAndXNlIGFzbSc7XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVuZGVyU3RhdGVtZW50TGlzdCh0aGlzLmJvZHksIGNvZGUsIHRoaXMuc3RhcnQgKyAxLCB0aGlzLmVuZCAtIDEsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBSZXN0RWxlbWVudCBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5kZWNsYXJhdGlvbkluaXQgPSBudWxsO1xuICAgIH1cbiAgICBhZGRFeHBvcnRlZFZhcmlhYmxlcyh2YXJpYWJsZXMsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSkge1xuICAgICAgICB0aGlzLmFyZ3VtZW50LmFkZEV4cG9ydGVkVmFyaWFibGVzKHZhcmlhYmxlcywgZXhwb3J0TmFtZXNCeVZhcmlhYmxlKTtcbiAgICB9XG4gICAgZGVjbGFyZShraW5kLCBpbml0KSB7XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25Jbml0ID0gaW5pdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJndW1lbnQuZGVjbGFyZShraW5kLCBVTktOT1dOX0VYUFJFU1NJT04pO1xuICAgIH1cbiAgICBkZW9wdGltaXplUGF0aChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudC5kZW9wdGltaXplUGF0aChFTVBUWV9QQVRIKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gKHBhdGgubGVuZ3RoID4gMCB8fFxuICAgICAgICAgICAgdGhpcy5hcmd1bWVudC5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChFTVBUWV9QQVRILCBpbnRlcmFjdGlvbiwgY29udGV4dCkpO1xuICAgIH1cbiAgICBtYXJrRGVjbGFyYXRpb25SZWFjaGVkKCkge1xuICAgICAgICB0aGlzLmFyZ3VtZW50Lm1hcmtEZWNsYXJhdGlvblJlYWNoZWQoKTtcbiAgICB9XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5kZWNsYXJhdGlvbkluaXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25Jbml0LmRlb3B0aW1pemVQYXRoKFtVbmtub3duS2V5LCBVbmtub3duS2V5XSk7XG4gICAgICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBGdW5jdGlvbkJhc2UgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMub2JqZWN0RW50aXR5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJWYXJpYWJsZVZhbHVlc0Rlb3B0aW1pemVkID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBhc3luYygpIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhZ1NldCh0aGlzLmZsYWdzLCAyNTYgLyogRmxhZy5hc3luYyAqLyk7XG4gICAgfVxuICAgIHNldCBhc3luYyh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZsYWdzID0gc2V0RmxhZyh0aGlzLmZsYWdzLCAyNTYgLyogRmxhZy5hc3luYyAqLywgdmFsdWUpO1xuICAgIH1cbiAgICBnZXQgZGVvcHRpbWl6ZWRSZXR1cm4oKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYWdTZXQodGhpcy5mbGFncywgNTEyIC8qIEZsYWcuZGVvcHRpbWl6ZWRSZXR1cm4gKi8pO1xuICAgIH1cbiAgICBzZXQgZGVvcHRpbWl6ZWRSZXR1cm4odmFsdWUpIHtcbiAgICAgICAgdGhpcy5mbGFncyA9IHNldEZsYWcodGhpcy5mbGFncywgNTEyIC8qIEZsYWcuZGVvcHRpbWl6ZWRSZXR1cm4gKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGdlbmVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhZ1NldCh0aGlzLmZsYWdzLCA0MTk0MzA0IC8qIEZsYWcuZ2VuZXJhdG9yICovKTtcbiAgICB9XG4gICAgc2V0IGdlbmVyYXRvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLmZsYWdzID0gc2V0RmxhZyh0aGlzLmZsYWdzLCA0MTk0MzA0IC8qIEZsYWcuZ2VuZXJhdG9yICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIHVwZGF0ZVBhcmFtZXRlclZhcmlhYmxlVmFsdWVzKF9hcmd1bWVudHMpIHtcbiAgICAgICAgZm9yIChsZXQgcG9zaXRpb24gPSAwOyBwb3NpdGlvbiA8IHRoaXMucGFyYW1zLmxlbmd0aDsgcG9zaXRpb24rKykge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVyID0gdGhpcy5wYXJhbXNbcG9zaXRpb25dO1xuICAgICAgICAgICAgaWYgKCEocGFyYW1ldGVyIGluc3RhbmNlb2YgSWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlclZhcmlhYmxlID0gcGFyYW1ldGVyLnZhcmlhYmxlO1xuICAgICAgICAgICAgY29uc3QgYXJndW1lbnQgPSBfYXJndW1lbnRzW3Bvc2l0aW9uICsgMV0gPz8gVU5ERUZJTkVEX0VYUFJFU1NJT047XG4gICAgICAgICAgICBwYXJhbWV0ZXJWYXJpYWJsZS51cGRhdGVLbm93blZhbHVlKGFyZ3VtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZW9wdGltaXplUGFyYW1ldGVyVmFyaWFibGVWYWx1ZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgcGFyYW1ldGVyIG9mIHRoaXMucGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVyIGluc3RhbmNlb2YgSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlclZhcmlhYmxlID0gcGFyYW1ldGVyLnZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlclZhcmlhYmxlLm1hcmtSZWFzc2lnbmVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIpIHtcbiAgICAgICAgaWYgKGludGVyYWN0aW9uLnR5cGUgPT09IElOVEVSQUNUSU9OX0NBTExFRCkge1xuICAgICAgICAgICAgY29uc3QgeyBwYXJhbWV0ZXJzIH0gPSB0aGlzLnNjb3BlO1xuICAgICAgICAgICAgY29uc3QgeyBhcmdzIH0gPSBpbnRlcmFjdGlvbjtcbiAgICAgICAgICAgIGxldCBoYXNSZXN0ID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBwb3NpdGlvbiA9IDA7IHBvc2l0aW9uIDwgYXJncy5sZW5ndGggLSAxOyBwb3NpdGlvbisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVyID0gdGhpcy5wYXJhbXNbcG9zaXRpb25dO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgdGhlIFwidGhpc1wiIGFyZ3VtZW50IGFyZ1swXSBjYW4gYmUgbnVsbFxuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3VtZW50ID0gYXJnc1twb3NpdGlvbiArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudCBpbnN0YW5jZW9mIFNwcmVhZEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZW9wdGltaXplUGFyYW1ldGVyVmFyaWFibGVWYWx1ZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc1Jlc3QgfHwgcGFyYW1ldGVyIGluc3RhbmNlb2YgUmVzdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzUmVzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50LmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtZXRlciBpbnN0YW5jZW9mIElkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyc1twb3NpdGlvbl1bMF0uYWRkRW50aXR5VG9CZURlb3B0aW1pemVkKGFyZ3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRBcmd1bWVudFRvQmVEZW9wdGltaXplZChhcmd1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtZXRlcikge1xuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudC5kZW9wdGltaXplUGF0aChVTktOT1dOX1BBVEgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRBcmd1bWVudFRvQmVEZW9wdGltaXplZChhcmd1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVQYXJhbWV0ZXJWYXJpYWJsZVZhbHVlcyhhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0T2JqZWN0RW50aXR5KCkuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlb3B0aW1pemVQYXRoKHBhdGgpIHtcbiAgICAgICAgdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5kZW9wdGltaXplUGF0aChwYXRoKTtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxICYmIHBhdGhbMF0gPT09IFVua25vd25LZXkpIHtcbiAgICAgICAgICAgIC8vIEEgcmVhc3NpZ25tZW50IG9mIFVOS05PV05fUEFUSCBpcyBjb25zaWRlcmVkIGVxdWl2YWxlbnQgdG8gaGF2aW5nIGxvc3QgdHJhY2tcbiAgICAgICAgICAgIC8vIHdoaWNoIG1lYW5zIHRoZSByZXR1cm4gZXhwcmVzc2lvbiBhbmQgcGFyYW1ldGVycyBuZWVkIHRvIGJlIHJlYXNzaWduZWRcbiAgICAgICAgICAgIHRoaXMuc2NvcGUuZ2V0UmV0dXJuRXhwcmVzc2lvbigpLmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcmFtZXRlckxpc3Qgb2YgdGhpcy5zY29wZS5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXJhbWV0ZXIgb2YgcGFyYW1ldGVyTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXIuZGVvcHRpbWl6ZVBhdGgoVU5LTk9XTl9QQVRIKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyLm1hcmtSZWFzc2lnbmVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0RW50aXR5KCkuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0RW50aXR5KCkuZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXN5bmMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZFJldHVybikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVvcHRpbWl6ZWRSZXR1cm4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NvcGUuZ2V0UmV0dXJuRXhwcmVzc2lvbigpLmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY29wZS5jb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBVTktOT1dOX1JFVFVSTl9FWFBSRVNTSU9OO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdGhpcy5zY29wZS5nZXRSZXR1cm5FeHByZXNzaW9uKCksIGZhbHNlXTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gMCB8fCBpbnRlcmFjdGlvbi50eXBlICE9PSBJTlRFUkFDVElPTl9DQUxMRUQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdEVudGl0eSgpLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbm5vdGF0aW9uTm9TaWRlRWZmZWN0cykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFzeW5jKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BlcnR5UmVhZFNpZGVFZmZlY3RzIH0gPSB0aGlzLnNjb3BlLmNvbnRleHQub3B0aW9uc1xuICAgICAgICAgICAgICAgIC50cmVlc2hha2U7XG4gICAgICAgICAgICBjb25zdCByZXR1cm5FeHByZXNzaW9uID0gdGhpcy5zY29wZS5nZXRSZXR1cm5FeHByZXNzaW9uKCk7XG4gICAgICAgICAgICBpZiAocmV0dXJuRXhwcmVzc2lvbi5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChbJ3RoZW4nXSwgTk9ERV9JTlRFUkFDVElPTl9VTktOT1dOX0NBTEwsIGNvbnRleHQpIHx8XG4gICAgICAgICAgICAgICAgKHByb3BlcnR5UmVhZFNpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICAgICAgICAgIChwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0cyA9PT0gJ2Fsd2F5cycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkV4cHJlc3Npb24uaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoWyd0aGVuJ10sIE5PREVfSU5URVJBQ1RJT05fVU5LTk9XTl9BQ0NFU1MsIGNvbnRleHQpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHBhcmFtZXRlciBvZiB0aGlzLnBhcmFtcykge1xuICAgICAgICAgICAgaWYgKHBhcmFtZXRlci5oYXNFZmZlY3RzKGNvbnRleHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGZ1bmN0aW9uIChleHByZXNzaW9uIG9yIGRlY2xhcmF0aW9uKSBpcyBvbmx5IHVzZWQgYXMgZnVuY3Rpb24gY2FsbHNcbiAgICAgKi9cbiAgICBvbmx5RnVuY3Rpb25DYWxsVXNlZCgpIHtcbiAgICAgICAgbGV0IHZhcmlhYmxlID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LnR5cGUgPT09IFZhcmlhYmxlRGVjbGFyYXRvciQxKSB7XG4gICAgICAgICAgICB2YXJpYWJsZSA9IHRoaXMucGFyZW50LmlkLnZhcmlhYmxlID8/IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50LnR5cGUgPT09IEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiQxKSB7XG4gICAgICAgICAgICB2YXJpYWJsZSA9IHRoaXMucGFyZW50LnZhcmlhYmxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YXJpYWJsZT8uZ2V0T25seUZ1bmN0aW9uQ2FsbFVzZWQoKSA/PyBmYWxzZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICBpZiAoIXRoaXMucGFyYW1ldGVyVmFyaWFibGVWYWx1ZXNEZW9wdGltaXplZCAmJiAhdGhpcy5vbmx5RnVuY3Rpb25DYWxsVXNlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtZXRlclZhcmlhYmxlVmFsdWVzRGVvcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kZW9wdGltaXplUGFyYW1ldGVyVmFyaWFibGVWYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZGVvcHRpbWl6ZWQpXG4gICAgICAgICAgICB0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCk7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IGJyb2tlbkZsb3cgfSA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnRleHQuYnJva2VuRmxvdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJvZHkuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIGNvbnRleHQuYnJva2VuRmxvdyA9IGJyb2tlbkZsb3c7XG4gICAgfVxuICAgIGluY2x1ZGVDYWxsQXJndW1lbnRzKGNvbnRleHQsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgdGhpcy5zY29wZS5pbmNsdWRlQ2FsbEFyZ3VtZW50cyhjb250ZXh0LCBwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGlzZSgpO1xuICAgICAgICBpZiAodGhpcy5ib2R5IGluc3RhbmNlb2YgQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keS5hZGRJbXBsaWNpdFJldHVybkV4cHJlc3Npb25Ub1Njb3BlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjb3BlLmFkZFJldHVybkV4cHJlc3Npb24odGhpcy5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbm5vdGF0aW9ucyAmJlxuICAgICAgICAgICAgdGhpcy5zY29wZS5jb250ZXh0Lm9wdGlvbnMudHJlZXNoYWtlLmFubm90YXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmFubm90YXRpb25Ob1NpZGVFZmZlY3RzID0gdGhpcy5hbm5vdGF0aW9ucy5zb21lKGNvbW1lbnQgPT4gY29tbWVudC50eXBlID09PSAnbm9TaWRlRWZmZWN0cycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlTm9kZShlc1RyZWVOb2RlKSB7XG4gICAgICAgIGNvbnN0IHsgYm9keSwgcGFyYW1zIH0gPSBlc1RyZWVOb2RlO1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGJvZHlTY29wZSwgY29udGV4dCB9ID0gc2NvcGU7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgcGFyYW1ldGVycyBhcmUgZGVjbGFyZWQgYmVmb3JlIHRoZSBib2R5IGlzIHBhcnNlZFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBzY29wZSBhbHJlYWR5IGtub3dzIGFsbCBwYXJhbWV0ZXJzIGFuZCBjYW4gZGV0ZWN0IGNvbmZsaWN0c1xuICAgICAgICAvLyB3aGVuIHBhcnNpbmcgdGhlIGJvZHkuXG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSAodGhpcy5wYXJhbXMgPSBwYXJhbXMubWFwKChwYXJhbWV0ZXIpID0+IG5ldyAoY29udGV4dC5nZXROb2RlQ29uc3RydWN0b3IocGFyYW1ldGVyLnR5cGUpKSh0aGlzLCBzY29wZSkucGFyc2VOb2RlKHBhcmFtZXRlcikpKTtcbiAgICAgICAgc2NvcGUuYWRkUGFyYW1ldGVyVmFyaWFibGVzKHBhcmFtZXRlcnMubWFwKHBhcmFtZXRlciA9PiBwYXJhbWV0ZXIuZGVjbGFyZSgncGFyYW1ldGVyJywgVU5LTk9XTl9FWFBSRVNTSU9OKSksIHBhcmFtZXRlcnNbcGFyYW1ldGVycy5sZW5ndGggLSAxXSBpbnN0YW5jZW9mIFJlc3RFbGVtZW50KTtcbiAgICAgICAgdGhpcy5ib2R5ID0gbmV3IChjb250ZXh0LmdldE5vZGVDb25zdHJ1Y3Rvcihib2R5LnR5cGUpKSh0aGlzLCBib2R5U2NvcGUpLnBhcnNlTm9kZShib2R5KTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlTm9kZShlc1RyZWVOb2RlKTtcbiAgICB9XG4gICAgYWRkQXJndW1lbnRUb0JlRGVvcHRpbWl6ZWQoX2FyZ3VtZW50KSB7IH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHsgfVxufVxuRnVuY3Rpb25CYXNlLnByb3RvdHlwZS5wcmV2ZW50Q2hpbGRCbG9ja1Njb3BlID0gdHJ1ZTtcblxuY2xhc3MgRnVuY3Rpb25Ob2RlIGV4dGVuZHMgRnVuY3Rpb25CYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5vYmplY3RFbnRpdHkgPSBudWxsO1xuICAgIH1cbiAgICBjcmVhdGVTY29wZShwYXJlbnRTY29wZSkge1xuICAgICAgICB0aGlzLnNjb3BlID0gbmV3IEZ1bmN0aW9uU2NvcGUocGFyZW50U2NvcGUpO1xuICAgICAgICB0aGlzLmNvbnN0cnVjdGVkRW50aXR5ID0gbmV3IE9iamVjdEVudGl0eShPYmplY3QuY3JlYXRlKG51bGwpLCBPQkpFQ1RfUFJPVE9UWVBFKTtcbiAgICAgICAgLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgYWxsIGRlb3B0aW1pemF0aW9ucyBvZiBcInRoaXNcIiBhcmUgYXBwbGllZCB0byB0aGVcbiAgICAgICAgLy8gY29uc3RydWN0ZWQgZW50aXR5LlxuICAgICAgICB0aGlzLnNjb3BlLnRoaXNWYXJpYWJsZS5hZGRFbnRpdHlUb0JlRGVvcHRpbWl6ZWQodGhpcy5jb25zdHJ1Y3RlZEVudGl0eSk7XG4gICAgfVxuICAgIGRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoLCByZWN1cnNpb25UcmFja2VyKSB7XG4gICAgICAgIHN1cGVyLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoLCByZWN1cnNpb25UcmFja2VyKTtcbiAgICAgICAgaWYgKGludGVyYWN0aW9uLnR5cGUgPT09IElOVEVSQUNUSU9OX0NBTExFRCAmJiBwYXRoLmxlbmd0aCA9PT0gMCAmJiBpbnRlcmFjdGlvbi5hcmdzWzBdKSB7XG4gICAgICAgICAgICAvLyBhcmdzWzBdIGlzIHRoZSBcInRoaXNcIiBhcmd1bWVudFxuICAgICAgICAgICAgdGhpcy5zY29wZS50aGlzVmFyaWFibGUuYWRkRW50aXR5VG9CZURlb3B0aW1pemVkKGludGVyYWN0aW9uLmFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICBpZiAoIXRoaXMuZGVvcHRpbWl6ZWQpXG4gICAgICAgICAgICB0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCk7XG4gICAgICAgIGlmICh0aGlzLmFubm90YXRpb25Ob1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhdGhpcy5pZD8uaGFzRWZmZWN0cyhjb250ZXh0KTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHN1cGVyLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5hbm5vdGF0aW9uTm9TaWRlRWZmZWN0cykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcmFjdGlvbi50eXBlID09PSBJTlRFUkFDVElPTl9DQUxMRUQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRoaXNJbml0ID0gY29udGV4dC5yZXBsYWNlZFZhcmlhYmxlSW5pdHMuZ2V0KHRoaXMuc2NvcGUudGhpc1ZhcmlhYmxlKTtcbiAgICAgICAgICAgIGNvbnRleHQucmVwbGFjZWRWYXJpYWJsZUluaXRzLnNldCh0aGlzLnNjb3BlLnRoaXNWYXJpYWJsZSwgaW50ZXJhY3Rpb24ud2l0aE5ldyA/IHRoaXMuY29uc3RydWN0ZWRFbnRpdHkgOiBVTktOT1dOX0VYUFJFU1NJT04pO1xuICAgICAgICAgICAgY29uc3QgeyBicm9rZW5GbG93LCBpZ25vcmUsIHJlcGxhY2VkVmFyaWFibGVJbml0cyB9ID0gY29udGV4dDtcbiAgICAgICAgICAgIGNvbnRleHQuaWdub3JlID0ge1xuICAgICAgICAgICAgICAgIGJyZWFrczogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29udGludWVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYWJlbHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICByZXR1cm5ZaWVsZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0aGlzOiBpbnRlcmFjdGlvbi53aXRoTmV3XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuYm9keS5oYXNFZmZlY3RzKGNvbnRleHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gYnJva2VuRmxvdztcbiAgICAgICAgICAgIGlmICh0aGlzSW5pdCkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VkVmFyaWFibGVJbml0cy5zZXQodGhpcy5zY29wZS50aGlzVmFyaWFibGUsIHRoaXNJbml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VkVmFyaWFibGVJbml0cy5kZWxldGUodGhpcy5zY29wZS50aGlzVmFyaWFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5pZ25vcmUgPSBpZ25vcmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHN1cGVyLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICB0aGlzLmlkPy5pbmNsdWRlKCk7XG4gICAgICAgIGNvbnN0IGhhc0FyZ3VtZW50cyA9IHRoaXMuc2NvcGUuYXJndW1lbnRzVmFyaWFibGUuaW5jbHVkZWQ7XG4gICAgICAgIGZvciAoY29uc3QgcGFyYW1ldGVyIG9mIHRoaXMucGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoIShwYXJhbWV0ZXIgaW5zdGFuY2VvZiBJZGVudGlmaWVyKSB8fCBoYXNBcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXIuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGlzZSgpO1xuICAgICAgICB0aGlzLmlkPy5kZWNsYXJlKCdmdW5jdGlvbicsIHRoaXMpO1xuICAgIH1cbiAgICBhZGRBcmd1bWVudFRvQmVEZW9wdGltaXplZChhcmd1bWVudCkge1xuICAgICAgICB0aGlzLnNjb3BlLmFyZ3VtZW50c1ZhcmlhYmxlLmFkZEFyZ3VtZW50VG9CZURlb3B0aW1pemVkKGFyZ3VtZW50KTtcbiAgICB9XG4gICAgZ2V0T2JqZWN0RW50aXR5KCkge1xuICAgICAgICBpZiAodGhpcy5vYmplY3RFbnRpdHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdEVudGl0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMub2JqZWN0RW50aXR5ID0gbmV3IE9iamVjdEVudGl0eShbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAga2V5OiAncHJvdG90eXBlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnaW5pdCcsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IG5ldyBPYmplY3RFbnRpdHkoW10sIE9CSkVDVF9QUk9UT1RZUEUpXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sIE9CSkVDVF9QUk9UT1RZUEUpKTtcbiAgICB9XG59XG5cbmNsYXNzIEZ1bmN0aW9uRGVjbGFyYXRpb24gZXh0ZW5kcyBGdW5jdGlvbk5vZGUge1xuICAgIGluaXRpYWxpc2UoKSB7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWQudmFyaWFibGUuaXNJZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25seUZ1bmN0aW9uQ2FsbFVzZWQoKSB7XG4gICAgICAgIC8vIGNhbGwgc3VwZXIub25seUZ1bmN0aW9uQ2FsbFVzZWQgZm9yIGV4cG9ydCBkZWZhdWx0IGFub255bW91cyBmdW5jdGlvblxuICAgICAgICByZXR1cm4gdGhpcy5pZD8udmFyaWFibGUuZ2V0T25seUZ1bmN0aW9uQ2FsbFVzZWQoKSA/PyBzdXBlci5vbmx5RnVuY3Rpb25DYWxsVXNlZCgpO1xuICAgIH1cbiAgICBwYXJzZU5vZGUoZXNUcmVlTm9kZSkge1xuICAgICAgICBpZiAoZXNUcmVlTm9kZS5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IG5ldyBJZGVudGlmaWVyKHRoaXMsIHRoaXMuc2NvcGUucGFyZW50KS5wYXJzZU5vZGUoZXNUcmVlTm9kZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlTm9kZShlc1RyZWVOb2RlKTtcbiAgICB9XG59XG5cbi8vIFRoZSBoZWFkZXIgZW5kcyBhdCB0aGUgZmlyc3Qgbm9uLXdoaXRlLXNwYWNlIGFmdGVyIFwiZGVmYXVsdFwiXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvblN0YXJ0KGNvZGUsIHN0YXJ0KSB7XG4gICAgcmV0dXJuIGZpbmROb25XaGl0ZVNwYWNlKGNvZGUsIGZpbmRGaXJzdE9jY3VycmVuY2VPdXRzaWRlQ29tbWVudChjb2RlLCAnZGVmYXVsdCcsIHN0YXJ0KSArIDcpO1xufVxuZnVuY3Rpb24gZ2V0RnVuY3Rpb25JZEluc2VydFBvc2l0aW9uKGNvZGUsIHN0YXJ0KSB7XG4gICAgY29uc3QgZGVjbGFyYXRpb25FbmQgPSBmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZSwgJ2Z1bmN0aW9uJywgc3RhcnQpICsgJ2Z1bmN0aW9uJy5sZW5ndGg7XG4gICAgY29kZSA9IGNvZGUuc2xpY2UoZGVjbGFyYXRpb25FbmQsIGZpbmRGaXJzdE9jY3VycmVuY2VPdXRzaWRlQ29tbWVudChjb2RlLCAnKCcsIGRlY2xhcmF0aW9uRW5kKSk7XG4gICAgY29uc3QgZ2VuZXJhdG9yU3RhclBvcyA9IGZpbmRGaXJzdE9jY3VycmVuY2VPdXRzaWRlQ29tbWVudChjb2RlLCAnKicpO1xuICAgIGlmIChnZW5lcmF0b3JTdGFyUG9zID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZGVjbGFyYXRpb25FbmQ7XG4gICAgfVxuICAgIHJldHVybiBkZWNsYXJhdGlvbkVuZCArIGdlbmVyYXRvclN0YXJQb3MgKyAxO1xufVxuY2xhc3MgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpIHtcbiAgICAgICAgc3VwZXIuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIGlmIChpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICAgICAgdGhpcy5zY29wZS5jb250ZXh0LmluY2x1ZGVWYXJpYWJsZUluTW9kdWxlKHRoaXMudmFyaWFibGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRpYWxpc2UoKSB7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpc2UoKTtcbiAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSB0aGlzLmRlY2xhcmF0aW9uO1xuICAgICAgICB0aGlzLmRlY2xhcmF0aW9uTmFtZSA9XG4gICAgICAgICAgICAoZGVjbGFyYXRpb24uaWQgJiYgZGVjbGFyYXRpb24uaWQubmFtZSkgfHwgdGhpcy5kZWNsYXJhdGlvbi5uYW1lO1xuICAgICAgICB0aGlzLnZhcmlhYmxlID0gdGhpcy5zY29wZS5hZGRFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24odGhpcy5kZWNsYXJhdGlvbk5hbWUgfHwgdGhpcy5zY29wZS5jb250ZXh0LmdldE1vZHVsZU5hbWUoKSwgdGhpcywgdGhpcy5zY29wZS5jb250ZXh0KTtcbiAgICAgICAgdGhpcy5zY29wZS5jb250ZXh0LmFkZEV4cG9ydCh0aGlzKTtcbiAgICB9XG4gICAgcmVtb3ZlQW5ub3RhdGlvbnMoY29kZSkge1xuICAgICAgICB0aGlzLmRlY2xhcmF0aW9uLnJlbW92ZUFubm90YXRpb25zKGNvZGUpO1xuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucywgbm9kZVJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBub2RlUmVuZGVyT3B0aW9ucztcbiAgICAgICAgY29uc3QgZGVjbGFyYXRpb25TdGFydCA9IGdldERlY2xhcmF0aW9uU3RhcnQoY29kZS5vcmlnaW5hbCwgdGhpcy5zdGFydCk7XG4gICAgICAgIGlmICh0aGlzLmRlY2xhcmF0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb25EZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJOYW1lZERlY2xhcmF0aW9uKGNvZGUsIGRlY2xhcmF0aW9uU3RhcnQsIHRoaXMuZGVjbGFyYXRpb24uaWQgPT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGdldEZ1bmN0aW9uSWRJbnNlcnRQb3NpdGlvbihjb2RlLm9yaWdpbmFsLCBkZWNsYXJhdGlvblN0YXJ0KVxuICAgICAgICAgICAgICAgIDogbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZWNsYXJhdGlvbiBpbnN0YW5jZW9mIENsYXNzRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTmFtZWREZWNsYXJhdGlvbihjb2RlLCBkZWNsYXJhdGlvblN0YXJ0LCB0aGlzLmRlY2xhcmF0aW9uLmlkID09PSBudWxsXG4gICAgICAgICAgICAgICAgPyBmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZS5vcmlnaW5hbCwgJ2NsYXNzJywgc3RhcnQpICsgJ2NsYXNzJy5sZW5ndGhcbiAgICAgICAgICAgICAgICA6IG51bGwsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudmFyaWFibGUuZ2V0T3JpZ2luYWxWYXJpYWJsZSgpICE9PSB0aGlzLnZhcmlhYmxlKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYWx0b2dldGhlciB0byBwcmV2ZW50IHJlLWRlY2xhcmluZyB0aGUgc2FtZSB2YXJpYWJsZVxuICAgICAgICAgICAgdHJlZXNoYWtlTm9kZSh0aGlzLCBjb2RlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnZhcmlhYmxlLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclZhcmlhYmxlRGVjbGFyYXRpb24oY29kZSwgZGVjbGFyYXRpb25TdGFydCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2RlLnJlbW92ZSh0aGlzLnN0YXJ0LCBkZWNsYXJhdGlvblN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb24ucmVuZGVyKGNvZGUsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudDogRXhwcmVzc2lvblN0YXRlbWVudCQxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb2RlLm9yaWdpbmFsW3RoaXMuZW5kIC0gMV0gIT09ICc7Jykge1xuICAgICAgICAgICAgICAgIGNvZGUuYXBwZW5kTGVmdCh0aGlzLmVuZCwgJzsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlY2xhcmF0aW9uLnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7IH1cbiAgICByZW5kZXJOYW1lZERlY2xhcmF0aW9uKGNvZGUsIGRlY2xhcmF0aW9uU3RhcnQsIGlkSW5zZXJ0UG9zaXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBleHBvcnROYW1lc0J5VmFyaWFibGUsIGZvcm1hdCwgc25pcHBldHM6IHsgZ2V0UHJvcGVydHlBY2Nlc3MgfSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMudmFyaWFibGUuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2Vzcyk7XG4gICAgICAgIC8vIFJlbW92ZSBgZXhwb3J0IGRlZmF1bHRgXG4gICAgICAgIGNvZGUucmVtb3ZlKHRoaXMuc3RhcnQsIGRlY2xhcmF0aW9uU3RhcnQpO1xuICAgICAgICBpZiAoaWRJbnNlcnRQb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29kZS5hcHBlbmRMZWZ0KGlkSW5zZXJ0UG9zaXRpb24sIGAgJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdzeXN0ZW0nICYmXG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uIGluc3RhbmNlb2YgQ2xhc3NEZWNsYXJhdGlvbiAmJlxuICAgICAgICAgICAgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLmhhcyh0aGlzLnZhcmlhYmxlKSkge1xuICAgICAgICAgICAgY29kZS5hcHBlbmRMZWZ0KHRoaXMuZW5kLCBgICR7Z2V0U3lzdGVtRXhwb3J0U3RhdGVtZW50KFt0aGlzLnZhcmlhYmxlXSwgb3B0aW9ucyl9O2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlclZhcmlhYmxlRGVjbGFyYXRpb24oY29kZSwgZGVjbGFyYXRpb25TdGFydCwgeyBmb3JtYXQsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSwgc25pcHBldHM6IHsgY25zdCwgZ2V0UHJvcGVydHlBY2Nlc3MgfSB9KSB7XG4gICAgICAgIGNvbnN0IGhhc1RyYWlsaW5nU2VtaWNvbG9uID0gY29kZS5vcmlnaW5hbC5jaGFyQ29kZUF0KHRoaXMuZW5kIC0gMSkgPT09IDU5OyAvKlwiO1wiKi9cbiAgICAgICAgY29uc3Qgc3lzdGVtRXhwb3J0TmFtZXMgPSBmb3JtYXQgPT09ICdzeXN0ZW0nICYmIGV4cG9ydE5hbWVzQnlWYXJpYWJsZS5nZXQodGhpcy52YXJpYWJsZSk7XG4gICAgICAgIGlmIChzeXN0ZW1FeHBvcnROYW1lcykge1xuICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUodGhpcy5zdGFydCwgZGVjbGFyYXRpb25TdGFydCwgYCR7Y25zdH0gJHt0aGlzLnZhcmlhYmxlLmdldE5hbWUoZ2V0UHJvcGVydHlBY2Nlc3MpfSA9IGV4cG9ydHMoJHtKU09OLnN0cmluZ2lmeShzeXN0ZW1FeHBvcnROYW1lc1swXSl9LCBgKTtcbiAgICAgICAgICAgIGNvZGUuYXBwZW5kUmlnaHQoaGFzVHJhaWxpbmdTZW1pY29sb24gPyB0aGlzLmVuZCAtIDEgOiB0aGlzLmVuZCwgJyknICsgKGhhc1RyYWlsaW5nU2VtaWNvbG9uID8gJycgOiAnOycpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMuc3RhcnQsIGRlY2xhcmF0aW9uU3RhcnQsIGAke2Nuc3R9ICR7dGhpcy52YXJpYWJsZS5nZXROYW1lKGdldFByb3BlcnR5QWNjZXNzKX0gPSBgKTtcbiAgICAgICAgICAgIGlmICghaGFzVHJhaWxpbmdTZW1pY29sb24pIHtcbiAgICAgICAgICAgICAgICBjb2RlLmFwcGVuZExlZnQodGhpcy5lbmQsICc7Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24ucHJvdG90eXBlLm5lZWRzQm91bmRhcmllcyA9IHRydWU7XG5cbmNvbnN0IG5lZWRzRXNjYXBlUmVnRXggPSAvW1xcblxccidcXFxcXFx1MjAyOFxcdTIwMjldLztcbmNvbnN0IHF1b3RlTmV3bGluZVJlZ0V4ID0gLyhbXFxuXFxyJ1xcdTIwMjhcXHUyMDI5XSkvZztcbmNvbnN0IGJhY2tTbGFzaFJlZ0V4ID0gL1xcXFwvZztcbmZ1bmN0aW9uIGVzY2FwZUlkKGlkKSB7XG4gICAgaWYgKCFuZWVkc0VzY2FwZVJlZ0V4LnRlc3QoaWQpKVxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgcmV0dXJuIGlkLnJlcGxhY2UoYmFja1NsYXNoUmVnRXgsICdcXFxcXFxcXCcpLnJlcGxhY2UocXVvdGVOZXdsaW5lUmVnRXgsICdcXFxcJDEnKTtcbn1cblxuY29uc3QgSU5URVJPUF9ERUZBVUxUX1ZBUklBQkxFID0gJ19pbnRlcm9wRGVmYXVsdCc7XG5jb25zdCBJTlRFUk9QX0RFRkFVTFRfQ09NUEFUX1ZBUklBQkxFID0gJ19pbnRlcm9wRGVmYXVsdENvbXBhdCc7XG5jb25zdCBJTlRFUk9QX05BTUVTUEFDRV9WQVJJQUJMRSA9ICdfaW50ZXJvcE5hbWVzcGFjZSc7XG5jb25zdCBJTlRFUk9QX05BTUVTUEFDRV9DT01QQVRfVkFSSUFCTEUgPSAnX2ludGVyb3BOYW1lc3BhY2VDb21wYXQnO1xuY29uc3QgSU5URVJPUF9OQU1FU1BBQ0VfREVGQVVMVF9WQVJJQUJMRSA9ICdfaW50ZXJvcE5hbWVzcGFjZURlZmF1bHQnO1xuY29uc3QgSU5URVJPUF9OQU1FU1BBQ0VfREVGQVVMVF9PTkxZX1ZBUklBQkxFID0gJ19pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdE9ubHknO1xuY29uc3QgTUVSR0VfTkFNRVNQQUNFU19WQVJJQUJMRSA9ICdfbWVyZ2VOYW1lc3BhY2VzJztcbmNvbnN0IERPQ1VNRU5UX0NVUlJFTlRfU0NSSVBUID0gJ19kb2N1bWVudEN1cnJlbnRTY3JpcHQnO1xuY29uc3QgZGVmYXVsdEludGVyb3BIZWxwZXJzQnlJbnRlcm9wVHlwZSA9IHtcbiAgICBhdXRvOiBJTlRFUk9QX0RFRkFVTFRfVkFSSUFCTEUsXG4gICAgY29tcGF0OiBJTlRFUk9QX0RFRkFVTFRfQ09NUEFUX1ZBUklBQkxFLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgZGVmYXVsdE9ubHk6IG51bGwsXG4gICAgZXNNb2R1bGU6IG51bGxcbn07XG5jb25zdCBpc0RlZmF1bHRBUHJvcGVydHkgPSAoaW50ZXJvcFR5cGUsIGV4dGVybmFsTGl2ZUJpbmRpbmdzKSA9PiBpbnRlcm9wVHlwZSA9PT0gJ2VzTW9kdWxlJyB8fFxuICAgIChleHRlcm5hbExpdmVCaW5kaW5ncyAmJiAoaW50ZXJvcFR5cGUgPT09ICdhdXRvJyB8fCBpbnRlcm9wVHlwZSA9PT0gJ2NvbXBhdCcpKTtcbmNvbnN0IG5hbWVzcGFjZUludGVyb3BIZWxwZXJzQnlJbnRlcm9wVHlwZSA9IHtcbiAgICBhdXRvOiBJTlRFUk9QX05BTUVTUEFDRV9WQVJJQUJMRSxcbiAgICBjb21wYXQ6IElOVEVST1BfTkFNRVNQQUNFX0NPTVBBVF9WQVJJQUJMRSxcbiAgICBkZWZhdWx0OiBJTlRFUk9QX05BTUVTUEFDRV9ERUZBVUxUX1ZBUklBQkxFLFxuICAgIGRlZmF1bHRPbmx5OiBJTlRFUk9QX05BTUVTUEFDRV9ERUZBVUxUX09OTFlfVkFSSUFCTEUsXG4gICAgZXNNb2R1bGU6IG51bGxcbn07XG5jb25zdCBjYW5EZWZhdWx0QmVUYWtlbkZyb21OYW1lc3BhY2UgPSAoaW50ZXJvcFR5cGUsIGV4dGVybmFsTGl2ZUJpbmRpbmdzKSA9PiBpbnRlcm9wVHlwZSAhPT0gJ2VzTW9kdWxlJyAmJiBpc0RlZmF1bHRBUHJvcGVydHkoaW50ZXJvcFR5cGUsIGV4dGVybmFsTGl2ZUJpbmRpbmdzKTtcbmNvbnN0IGdldEhlbHBlcnNCbG9jayA9IChhZGRpdGlvbmFsSGVscGVycywgYWNjZXNzZWRHbG9iYWxzLCBpbmRlbnQsIHNuaXBwZXRzLCBsaXZlQmluZGluZ3MsIGZyZWV6ZSwgc3ltYm9scykgPT4ge1xuICAgIGNvbnN0IHVzZWRIZWxwZXJzID0gbmV3IFNldChhZGRpdGlvbmFsSGVscGVycyk7XG4gICAgZm9yIChjb25zdCB2YXJpYWJsZSBvZiBIRUxQRVJfTkFNRVMpIHtcbiAgICAgICAgaWYgKGFjY2Vzc2VkR2xvYmFscy5oYXModmFyaWFibGUpKSB7XG4gICAgICAgICAgICB1c2VkSGVscGVycy5hZGQodmFyaWFibGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBIRUxQRVJfTkFNRVMubWFwKHZhcmlhYmxlID0+IHVzZWRIZWxwZXJzLmhhcyh2YXJpYWJsZSlcbiAgICAgICAgPyBIRUxQRVJfR0VORVJBVE9SU1t2YXJpYWJsZV0oaW5kZW50LCBzbmlwcGV0cywgbGl2ZUJpbmRpbmdzLCBmcmVlemUsIHN5bWJvbHMsIHVzZWRIZWxwZXJzKVxuICAgICAgICA6ICcnKS5qb2luKCcnKTtcbn07XG5jb25zdCBIRUxQRVJfR0VORVJBVE9SUyA9IHtcbiAgICBbRE9DVU1FTlRfQ1VSUkVOVF9TQ1JJUFRdKF90LCB7IF8sIG4gfSkge1xuICAgICAgICByZXR1cm4gYHZhciAke0RPQ1VNRU5UX0NVUlJFTlRfU0NSSVBUfSR7X309JHtffXR5cGVvZiBkb2N1bWVudCR7X30hPT0ke199J3VuZGVmaW5lZCcke199PyR7X31kb2N1bWVudC5jdXJyZW50U2NyaXB0JHtffToke199bnVsbDske259YDtcbiAgICB9LFxuICAgIFtJTlRFUk9QX0RFRkFVTFRfQ09NUEFUX1ZBUklBQkxFXShfdCwgc25pcHBldHMsIGxpdmVCaW5kaW5ncykge1xuICAgICAgICBjb25zdCB7IF8sIGdldERpcmVjdFJldHVybkZ1bmN0aW9uLCBuIH0gPSBzbmlwcGV0cztcbiAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGdldERpcmVjdFJldHVybkZ1bmN0aW9uKFsnZSddLCB7XG4gICAgICAgICAgICBmdW5jdGlvblJldHVybjogdHJ1ZSxcbiAgICAgICAgICAgIGxpbmVCcmVha0luZGVudDogbnVsbCxcbiAgICAgICAgICAgIG5hbWU6IElOVEVST1BfREVGQVVMVF9DT01QQVRfVkFSSUFCTEVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoYCR7bGVmdH0ke2dldElzQ29tcGF0TmFtZXNwYWNlKHNuaXBwZXRzKX0ke199PyR7X31gICtcbiAgICAgICAgICAgIGAke2xpdmVCaW5kaW5ncyA/IGdldERlZmF1bHRMaXZlQmluZGluZyhzbmlwcGV0cykgOiBnZXREZWZhdWx0U3RhdGljKHNuaXBwZXRzKX0ke3JpZ2h0fSR7bn0ke259YCk7XG4gICAgfSxcbiAgICBbSU5URVJPUF9ERUZBVUxUX1ZBUklBQkxFXShfdCwgc25pcHBldHMsIGxpdmVCaW5kaW5ncykge1xuICAgICAgICBjb25zdCB7IF8sIGdldERpcmVjdFJldHVybkZ1bmN0aW9uLCBuIH0gPSBzbmlwcGV0cztcbiAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGdldERpcmVjdFJldHVybkZ1bmN0aW9uKFsnZSddLCB7XG4gICAgICAgICAgICBmdW5jdGlvblJldHVybjogdHJ1ZSxcbiAgICAgICAgICAgIGxpbmVCcmVha0luZGVudDogbnVsbCxcbiAgICAgICAgICAgIG5hbWU6IElOVEVST1BfREVGQVVMVF9WQVJJQUJMRVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChgJHtsZWZ0fWUke199JiYke199ZS5fX2VzTW9kdWxlJHtffT8ke199YCArXG4gICAgICAgICAgICBgJHtsaXZlQmluZGluZ3MgPyBnZXREZWZhdWx0TGl2ZUJpbmRpbmcoc25pcHBldHMpIDogZ2V0RGVmYXVsdFN0YXRpYyhzbmlwcGV0cyl9JHtyaWdodH0ke259JHtufWApO1xuICAgIH0sXG4gICAgW0lOVEVST1BfTkFNRVNQQUNFX0NPTVBBVF9WQVJJQUJMRV0odCwgc25pcHBldHMsIGxpdmVCaW5kaW5ncywgZnJlZXplLCBzeW1ib2xzLCB1c2VkSGVscGVycykge1xuICAgICAgICBjb25zdCB7IF8sIGdldERpcmVjdFJldHVybkZ1bmN0aW9uLCBuIH0gPSBzbmlwcGV0cztcbiAgICAgICAgaWYgKHVzZWRIZWxwZXJzLmhhcyhJTlRFUk9QX05BTUVTUEFDRV9ERUZBVUxUX1ZBUklBQkxFKSkge1xuICAgICAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGdldERpcmVjdFJldHVybkZ1bmN0aW9uKFsnZSddLCB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25SZXR1cm46IHRydWUsXG4gICAgICAgICAgICAgICAgbGluZUJyZWFrSW5kZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIG5hbWU6IElOVEVST1BfTkFNRVNQQUNFX0NPTVBBVF9WQVJJQUJMRVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYCR7bGVmdH0ke2dldElzQ29tcGF0TmFtZXNwYWNlKHNuaXBwZXRzKX0ke199PyR7X31lJHtffToke199JHtJTlRFUk9QX05BTUVTUEFDRV9ERUZBVUxUX1ZBUklBQkxFfShlKSR7cmlnaHR9JHtufSR7bn1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYGZ1bmN0aW9uICR7SU5URVJPUF9OQU1FU1BBQ0VfQ09NUEFUX1ZBUklBQkxFfShlKSR7X317JHtufWAgK1xuICAgICAgICAgICAgYCR7dH1pZiR7X30oJHtnZXRJc0NvbXBhdE5hbWVzcGFjZShzbmlwcGV0cyl9KSR7X31yZXR1cm4gZTske259YCArXG4gICAgICAgICAgICBjcmVhdGVOYW1lc3BhY2VPYmplY3QodCwgdCwgc25pcHBldHMsIGxpdmVCaW5kaW5ncywgZnJlZXplLCBzeW1ib2xzKSArXG4gICAgICAgICAgICBgfSR7bn0ke259YCk7XG4gICAgfSxcbiAgICBbSU5URVJPUF9OQU1FU1BBQ0VfREVGQVVMVF9PTkxZX1ZBUklBQkxFXShfdCwgc25pcHBldHMsIF9saXZlQmluZGluZ3MsIGZyZWV6ZSwgc3ltYm9scykge1xuICAgICAgICBjb25zdCB7IGdldERpcmVjdFJldHVybkZ1bmN0aW9uLCBnZXRPYmplY3QsIG4sIF8gfSA9IHNuaXBwZXRzO1xuICAgICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb24oWydlJ10sIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uUmV0dXJuOiB0cnVlLFxuICAgICAgICAgICAgbGluZUJyZWFrSW5kZW50OiBudWxsLFxuICAgICAgICAgICAgbmFtZTogSU5URVJPUF9OQU1FU1BBQ0VfREVGQVVMVF9PTkxZX1ZBUklBQkxFXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYCR7bGVmdH0ke2dldEZyb3plbihmcmVlemUsIGdldFdpdGhUb1N0cmluZ1RhZyhzeW1ib2xzLCBnZXRPYmplY3QoW1xuICAgICAgICAgICAgW251bGwsIGBfX3Byb3RvX186JHtffW51bGxgXSxcbiAgICAgICAgICAgIFsnZGVmYXVsdCcsICdlJ11cbiAgICAgICAgXSwgeyBsaW5lQnJlYWtJbmRlbnQ6IG51bGwgfSksIHNuaXBwZXRzKSl9JHtyaWdodH0ke259JHtufWA7XG4gICAgfSxcbiAgICBbSU5URVJPUF9OQU1FU1BBQ0VfREVGQVVMVF9WQVJJQUJMRV0odCwgc25pcHBldHMsIGxpdmVCaW5kaW5ncywgZnJlZXplLCBzeW1ib2xzKSB7XG4gICAgICAgIGNvbnN0IHsgXywgbiB9ID0gc25pcHBldHM7XG4gICAgICAgIHJldHVybiAoYGZ1bmN0aW9uICR7SU5URVJPUF9OQU1FU1BBQ0VfREVGQVVMVF9WQVJJQUJMRX0oZSkke199eyR7bn1gICtcbiAgICAgICAgICAgIGNyZWF0ZU5hbWVzcGFjZU9iamVjdCh0LCB0LCBzbmlwcGV0cywgbGl2ZUJpbmRpbmdzLCBmcmVlemUsIHN5bWJvbHMpICtcbiAgICAgICAgICAgIGB9JHtufSR7bn1gKTtcbiAgICB9LFxuICAgIFtJTlRFUk9QX05BTUVTUEFDRV9WQVJJQUJMRV0odCwgc25pcHBldHMsIGxpdmVCaW5kaW5ncywgZnJlZXplLCBzeW1ib2xzLCB1c2VkSGVscGVycykge1xuICAgICAgICBjb25zdCB7IF8sIGdldERpcmVjdFJldHVybkZ1bmN0aW9uLCBuIH0gPSBzbmlwcGV0cztcbiAgICAgICAgaWYgKHVzZWRIZWxwZXJzLmhhcyhJTlRFUk9QX05BTUVTUEFDRV9ERUZBVUxUX1ZBUklBQkxFKSkge1xuICAgICAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGdldERpcmVjdFJldHVybkZ1bmN0aW9uKFsnZSddLCB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25SZXR1cm46IHRydWUsXG4gICAgICAgICAgICAgICAgbGluZUJyZWFrSW5kZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIG5hbWU6IElOVEVST1BfTkFNRVNQQUNFX1ZBUklBQkxFXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBgJHtsZWZ0fWUke199JiYke199ZS5fX2VzTW9kdWxlJHtffT8ke199ZSR7X306JHtffSR7SU5URVJPUF9OQU1FU1BBQ0VfREVGQVVMVF9WQVJJQUJMRX0oZSkke3JpZ2h0fSR7bn0ke259YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGBmdW5jdGlvbiAke0lOVEVST1BfTkFNRVNQQUNFX1ZBUklBQkxFfShlKSR7X317JHtufWAgK1xuICAgICAgICAgICAgYCR7dH1pZiR7X30oZSR7X30mJiR7X31lLl9fZXNNb2R1bGUpJHtffXJldHVybiBlOyR7bn1gICtcbiAgICAgICAgICAgIGNyZWF0ZU5hbWVzcGFjZU9iamVjdCh0LCB0LCBzbmlwcGV0cywgbGl2ZUJpbmRpbmdzLCBmcmVlemUsIHN5bWJvbHMpICtcbiAgICAgICAgICAgIGB9JHtufSR7bn1gKTtcbiAgICB9LFxuICAgIFtNRVJHRV9OQU1FU1BBQ0VTX1ZBUklBQkxFXSh0LCBzbmlwcGV0cywgbGl2ZUJpbmRpbmdzLCBmcmVlemUsIHN5bWJvbHMpIHtcbiAgICAgICAgY29uc3QgeyBfLCBjbnN0LCBuIH0gPSBzbmlwcGV0cztcbiAgICAgICAgY29uc3QgdXNlRm9yRWFjaCA9IGNuc3QgPT09ICd2YXInICYmIGxpdmVCaW5kaW5ncztcbiAgICAgICAgcmV0dXJuIChgZnVuY3Rpb24gJHtNRVJHRV9OQU1FU1BBQ0VTX1ZBUklBQkxFfShuLCBtKSR7X317JHtufWAgK1xuICAgICAgICAgICAgYCR7dH0ke2xvb3BPdmVyTmFtZXNwYWNlcyhgeyR7bn1gICtcbiAgICAgICAgICAgICAgICBgJHt0fSR7dH0ke3R9aWYke199KGske199IT09JHtffSdkZWZhdWx0JyR7X30mJiR7X30hKGsgaW4gbikpJHtffXske259YCArXG4gICAgICAgICAgICAgICAgKGxpdmVCaW5kaW5nc1xuICAgICAgICAgICAgICAgICAgICA/IHVzZUZvckVhY2hcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29weU93blByb3BlcnR5TGl2ZUJpbmRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29weVByb3BlcnR5TGl2ZUJpbmRpbmdcbiAgICAgICAgICAgICAgICAgICAgOiBjb3B5UHJvcGVydHlTdGF0aWMpKHQsIHQgKyB0ICsgdCArIHQsIHNuaXBwZXRzKSArXG4gICAgICAgICAgICAgICAgYCR7dH0ke3R9JHt0fX0ke259YCArXG4gICAgICAgICAgICAgICAgYCR7dH0ke3R9fWAsIHVzZUZvckVhY2gsIHQsIHNuaXBwZXRzKX0ke259YCArXG4gICAgICAgICAgICBgJHt0fXJldHVybiAke2dldEZyb3plbihmcmVlemUsIGdldFdpdGhUb1N0cmluZ1RhZyhzeW1ib2xzLCAnbicsIHNuaXBwZXRzKSl9OyR7bn1gICtcbiAgICAgICAgICAgIGB9JHtufSR7bn1gKTtcbiAgICB9XG59O1xuY29uc3QgZ2V0RGVmYXVsdExpdmVCaW5kaW5nID0gKHsgXywgZ2V0T2JqZWN0IH0pID0+IGBlJHtffToke199JHtnZXRPYmplY3QoW1snZGVmYXVsdCcsICdlJ11dLCB7IGxpbmVCcmVha0luZGVudDogbnVsbCB9KX1gO1xuY29uc3QgZ2V0RGVmYXVsdFN0YXRpYyA9ICh7IF8sIGdldFByb3BlcnR5QWNjZXNzIH0pID0+IGBlJHtnZXRQcm9wZXJ0eUFjY2VzcygnZGVmYXVsdCcpfSR7X306JHtffWVgO1xuY29uc3QgZ2V0SXNDb21wYXROYW1lc3BhY2UgPSAoeyBfIH0pID0+IGBlJHtffSYmJHtffXR5cGVvZiBlJHtffT09PSR7X30nb2JqZWN0JyR7X30mJiR7X30nZGVmYXVsdCcke199aW4gZWA7XG5jb25zdCBjcmVhdGVOYW1lc3BhY2VPYmplY3QgPSAodCwgaW5kZXgsIHNuaXBwZXRzLCBsaXZlQmluZGluZ3MsIGZyZWV6ZSwgc3ltYm9scykgPT4ge1xuICAgIGNvbnN0IHsgXywgY25zdCwgZ2V0T2JqZWN0LCBnZXRQcm9wZXJ0eUFjY2VzcywgbiwgcyB9ID0gc25pcHBldHM7XG4gICAgY29uc3QgY29weVByb3BlcnR5ID0gYHske259YCArXG4gICAgICAgIChsaXZlQmluZGluZ3MgPyBjb3B5Tm9uRGVmYXVsdE93blByb3BlcnR5TGl2ZUJpbmRpbmcgOiBjb3B5UHJvcGVydHlTdGF0aWMpKHQsIGluZGV4ICsgdCArIHQsIHNuaXBwZXRzKSArXG4gICAgICAgIGAke2luZGV4fSR7dH19YDtcbiAgICByZXR1cm4gKGAke2luZGV4fSR7Y25zdH0gbiR7X309JHtffU9iamVjdC5jcmVhdGUobnVsbCR7c3ltYm9scyA/IGAsJHtffXske199W1N5bWJvbC50b1N0cmluZ1RhZ106JHtffSR7Z2V0VG9TdHJpbmdUYWdWYWx1ZShnZXRPYmplY3QpfSR7X319YCA6ICcnfSk7JHtufWAgK1xuICAgICAgICBgJHtpbmRleH1pZiR7X30oZSkke199eyR7bn1gICtcbiAgICAgICAgYCR7aW5kZXh9JHt0fSR7bG9vcE92ZXJLZXlzKGNvcHlQcm9wZXJ0eSwgIWxpdmVCaW5kaW5ncywgc25pcHBldHMpfSR7bn1gICtcbiAgICAgICAgYCR7aW5kZXh9fSR7bn1gICtcbiAgICAgICAgYCR7aW5kZXh9biR7Z2V0UHJvcGVydHlBY2Nlc3MoJ2RlZmF1bHQnKX0ke199PSR7X31lOyR7bn1gICtcbiAgICAgICAgYCR7aW5kZXh9cmV0dXJuICR7Z2V0RnJvemVuKGZyZWV6ZSwgJ24nKX0ke3N9JHtufWApO1xufTtcbmNvbnN0IGxvb3BPdmVyS2V5cyA9IChib2R5LCBhbGxvd1ZhcmlhYmxlTG9vcFZhcmlhYmxlLCB7IF8sIGNuc3QsIGdldEZ1bmN0aW9uSW50cm8sIHMgfSkgPT4gY25zdCAhPT0gJ3ZhcicgfHwgYWxsb3dWYXJpYWJsZUxvb3BWYXJpYWJsZVxuICAgID8gYGZvciR7X30oJHtjbnN0fSBrIGluIGUpJHtffSR7Ym9keX1gXG4gICAgOiBgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgke2dldEZ1bmN0aW9uSW50cm8oWydrJ10sIHtcbiAgICAgICAgaXNBc3luYzogZmFsc2UsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICB9KX0ke2JvZHl9KSR7c31gO1xuY29uc3QgbG9vcE92ZXJOYW1lc3BhY2VzID0gKGJvZHksIHVzZUZvckVhY2gsIHQsIHsgXywgY25zdCwgZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb24sIGdldEZ1bmN0aW9uSW50cm8sIG4gfSkgPT4ge1xuICAgIGlmICh1c2VGb3JFYWNoKSB7XG4gICAgICAgIGNvbnN0IFtsZWZ0LCByaWdodF0gPSBnZXREaXJlY3RSZXR1cm5GdW5jdGlvbihbJ2UnXSwge1xuICAgICAgICAgICAgZnVuY3Rpb25SZXR1cm46IGZhbHNlLFxuICAgICAgICAgICAgbGluZUJyZWFrSW5kZW50OiB7IGJhc2U6IHQsIHQgfSxcbiAgICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoYG0uZm9yRWFjaCgke2xlZnR9YCArXG4gICAgICAgICAgICBgZSR7X30mJiR7X310eXBlb2YgZSR7X30hPT0ke199J3N0cmluZycke199JiYke199IUFycmF5LmlzQXJyYXkoZSkke199JiYke199T2JqZWN0LmtleXMoZSkuZm9yRWFjaCgke2dldEZ1bmN0aW9uSW50cm8oWydrJ10sIHtcbiAgICAgICAgICAgICAgICBpc0FzeW5jOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBudWxsXG4gICAgICAgICAgICB9KX0ke2JvZHl9KSR7cmlnaHR9KTtgKTtcbiAgICB9XG4gICAgcmV0dXJuIChgZm9yJHtffSh2YXIgaSR7X309JHtffTA7JHtffWkke199PCR7X31tLmxlbmd0aDske199aSsrKSR7X317JHtufWAgK1xuICAgICAgICBgJHt0fSR7dH0ke2Nuc3R9IGUke199PSR7X31tW2ldOyR7bn1gICtcbiAgICAgICAgYCR7dH0ke3R9aWYke199KHR5cGVvZiBlJHtffSE9PSR7X30nc3RyaW5nJyR7X30mJiR7X30hQXJyYXkuaXNBcnJheShlKSkke199eyR7X31mb3Ike199KCR7Y25zdH0gayBpbiBlKSR7X30ke2JvZHl9JHtffX0ke259JHt0fX1gKTtcbn07XG5jb25zdCBjb3B5Tm9uRGVmYXVsdE93blByb3BlcnR5TGl2ZUJpbmRpbmcgPSAodCwgaW5kZXgsIHNuaXBwZXRzKSA9PiB7XG4gICAgY29uc3QgeyBfLCBuIH0gPSBzbmlwcGV0cztcbiAgICByZXR1cm4gKGAke2luZGV4fWlmJHtffShrJHtffSE9PSR7X30nZGVmYXVsdCcpJHtffXske259YCArXG4gICAgICAgIGNvcHlPd25Qcm9wZXJ0eUxpdmVCaW5kaW5nKHQsIGluZGV4ICsgdCwgc25pcHBldHMpICtcbiAgICAgICAgYCR7aW5kZXh9fSR7bn1gKTtcbn07XG5jb25zdCBjb3B5T3duUHJvcGVydHlMaXZlQmluZGluZyA9ICh0LCBpbmRleCwgeyBfLCBjbnN0LCBnZXREaXJlY3RSZXR1cm5GdW5jdGlvbiwgbiB9KSA9PiB7XG4gICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGdldERpcmVjdFJldHVybkZ1bmN0aW9uKFtdLCB7XG4gICAgICAgIGZ1bmN0aW9uUmV0dXJuOiB0cnVlLFxuICAgICAgICBsaW5lQnJlYWtJbmRlbnQ6IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm4gKGAke2luZGV4fSR7Y25zdH0gZCR7X309JHtffU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwke199ayk7JHtufWAgK1xuICAgICAgICBgJHtpbmRleH1PYmplY3QuZGVmaW5lUHJvcGVydHkobiwke199aywke199ZC5nZXQke199PyR7X31kJHtffToke199eyR7bn1gICtcbiAgICAgICAgYCR7aW5kZXh9JHt0fWVudW1lcmFibGU6JHtffXRydWUsJHtufWAgK1xuICAgICAgICBgJHtpbmRleH0ke3R9Z2V0OiR7X30ke2xlZnR9ZVtrXSR7cmlnaHR9JHtufWAgK1xuICAgICAgICBgJHtpbmRleH19KTske259YCk7XG59O1xuY29uc3QgY29weVByb3BlcnR5TGl2ZUJpbmRpbmcgPSAodCwgaW5kZXgsIHsgXywgY25zdCwgZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb24sIG4gfSkgPT4ge1xuICAgIGNvbnN0IFtsZWZ0LCByaWdodF0gPSBnZXREaXJlY3RSZXR1cm5GdW5jdGlvbihbXSwge1xuICAgICAgICBmdW5jdGlvblJldHVybjogdHJ1ZSxcbiAgICAgICAgbGluZUJyZWFrSW5kZW50OiBudWxsLFxuICAgICAgICBuYW1lOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIChgJHtpbmRleH0ke2Nuc3R9IGQke199PSR7X31PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsJHtffWspOyR7bn1gICtcbiAgICAgICAgYCR7aW5kZXh9aWYke199KGQpJHtffXske259YCArXG4gICAgICAgIGAke2luZGV4fSR7dH1PYmplY3QuZGVmaW5lUHJvcGVydHkobiwke199aywke199ZC5nZXQke199PyR7X31kJHtffToke199eyR7bn1gICtcbiAgICAgICAgYCR7aW5kZXh9JHt0fSR7dH1lbnVtZXJhYmxlOiR7X310cnVlLCR7bn1gICtcbiAgICAgICAgYCR7aW5kZXh9JHt0fSR7dH1nZXQ6JHtffSR7bGVmdH1lW2tdJHtyaWdodH0ke259YCArXG4gICAgICAgIGAke2luZGV4fSR7dH19KTske259YCArXG4gICAgICAgIGAke2luZGV4fX0ke259YCk7XG59O1xuY29uc3QgY29weVByb3BlcnR5U3RhdGljID0gKF90LCBpbmRleCwgeyBfLCBuIH0pID0+IGAke2luZGV4fW5ba10ke199PSR7X31lW2tdOyR7bn1gO1xuY29uc3QgZ2V0RnJvemVuID0gKGZyZWV6ZSwgZnJhZ21lbnQpID0+IGZyZWV6ZSA/IGBPYmplY3QuZnJlZXplKCR7ZnJhZ21lbnR9KWAgOiBmcmFnbWVudDtcbmNvbnN0IGdldFdpdGhUb1N0cmluZ1RhZyA9IChzeW1ib2xzLCBmcmFnbWVudCwgeyBfLCBnZXRPYmplY3QgfSkgPT4gc3ltYm9sc1xuICAgID8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgke2ZyYWdtZW50fSwke199U3ltYm9sLnRvU3RyaW5nVGFnLCR7X30ke2dldFRvU3RyaW5nVGFnVmFsdWUoZ2V0T2JqZWN0KX0pYFxuICAgIDogZnJhZ21lbnQ7XG5jb25zdCBIRUxQRVJfTkFNRVMgPSBPYmplY3Qua2V5cyhIRUxQRVJfR0VORVJBVE9SUyk7XG5mdW5jdGlvbiBnZXRUb1N0cmluZ1RhZ1ZhbHVlKGdldE9iamVjdCkge1xuICAgIHJldHVybiBnZXRPYmplY3QoW1sndmFsdWUnLCBcIidNb2R1bGUnXCJdXSwge1xuICAgICAgICBsaW5lQnJlYWtJbmRlbnQ6IG51bGxcbiAgICB9KTtcbn1cblxuY2xhc3MgTGl0ZXJhbCBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBkZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCgpIHsgfVxuICAgIGdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IDAgfHxcbiAgICAgICAgICAgIC8vIHVua25vd24gbGl0ZXJhbHMgY2FuIGFsc28gYmUgbnVsbCBidXQgZG8gbm90IHN0YXJ0IHdpdGggYW4gXCJuXCJcbiAgICAgICAgICAgICh0aGlzLnZhbHVlID09PSBudWxsICYmIHRoaXMuc2NvcGUuY29udGV4dC5jb2RlLmNoYXJDb2RlQXQodGhpcy5zdGFydCkgIT09IDExMCkgfHxcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLnZhbHVlID09PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgLy8gdG8gc3VwcG9ydCBzaGltcyBmb3IgcmVndWxhciBleHByZXNzaW9uc1xuICAgICAgICAgICAgdGhpcy5zY29wZS5jb250ZXh0LmNvZGUuY2hhckNvZGVBdCh0aGlzLnN0YXJ0KSA9PT0gNDcpIHtcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoICE9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIFVOS05PV05fUkVUVVJOX0VYUFJFU1NJT047XG4gICAgICAgIHJldHVybiBnZXRNZW1iZXJSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZCh0aGlzLm1lbWJlcnMsIHBhdGhbMF0pO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICBzd2l0Y2ggKGludGVyYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgSU5URVJBQ1RJT05fQUNDRVNTRUQ6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAodGhpcy52YWx1ZSA9PT0gbnVsbCA/IDAgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgSU5URVJBQ1RJT05fQVNTSUdORUQ6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgSU5URVJBQ1RJT05fQ0FMTEVEOiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5jbHVkZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCAmJlxuICAgICAgICAgICAgICAgICAgICAodGhpcy52YWx1ZS5nbG9iYWwgfHwgdGhpcy52YWx1ZS5zdGlja3kpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKHBhdGgubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgICAgICAgICAgICAgIGhhc01lbWJlckVmZmVjdFdoZW5DYWxsZWQodGhpcy5tZW1iZXJzLCBwYXRoWzBdLCBpbnRlcmFjdGlvbiwgY29udGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRpYWxpc2UoKSB7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpc2UoKTtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gZ2V0TGl0ZXJhbE1lbWJlcnNGb3JWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgcGFyc2VOb2RlKGVzVHJlZU5vZGUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGVzVHJlZU5vZGUudmFsdWU7XG4gICAgICAgIHRoaXMucmVnZXggPSBlc1RyZWVOb2RlLnJlZ2V4O1xuICAgICAgICByZXR1cm4gc3VwZXIucGFyc2VOb2RlKGVzVHJlZU5vZGUpO1xuICAgIH1cbiAgICByZW5kZXIoY29kZSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb2RlLmluZGVudEV4Y2x1c2lvblJhbmdlcy5wdXNoKFt0aGlzLnN0YXJ0ICsgMSwgdGhpcy5lbmQgLSAxXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldENoYWluRWxlbWVudExpdGVyYWxWYWx1ZUF0UGF0aChlbGVtZW50LCBvYmplY3QsIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgIGlmICgnZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoQXNDaGFpbkVsZW1lbnQnIGluIG9iamVjdCkge1xuICAgICAgICBjb25zdCBjYWxsZWVWYWx1ZSA9IG9iamVjdC5nZXRMaXRlcmFsVmFsdWVBdFBhdGhBc0NoYWluRWxlbWVudChFTVBUWV9QQVRILCBTSEFSRURfUkVDVVJTSU9OX1RSQUNLRVIsIG9yaWdpbik7XG4gICAgICAgIGlmIChjYWxsZWVWYWx1ZSA9PT0gSVNfU0tJUFBFRF9DSEFJTiB8fCAoZWxlbWVudC5vcHRpb25hbCAmJiBjYWxsZWVWYWx1ZSA9PSBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIElTX1NLSVBQRURfQ0hBSU47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZWxlbWVudC5vcHRpb25hbCAmJlxuICAgICAgICBvYmplY3QuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKEVNUFRZX1BBVEgsIFNIQVJFRF9SRUNVUlNJT05fVFJBQ0tFUiwgb3JpZ2luKSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBJU19TS0lQUEVEX0NIQUlOO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudC5nZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKTtcbn1cblxuLy8gVG8gYXZvaWQgaW5maW5pdGUgcmVjdXJzaW9uc1xuY29uc3QgTUFYX1BBVEhfREVQVEggPSA3O1xuZnVuY3Rpb24gZ2V0UmVzb2x2YWJsZVByb3BlcnR5S2V5KG1lbWJlckV4cHJlc3Npb24pIHtcbiAgICByZXR1cm4gbWVtYmVyRXhwcmVzc2lvbi5jb21wdXRlZFxuICAgICAgICA/IGdldFJlc29sdmFibGVDb21wdXRlZFByb3BlcnR5S2V5KG1lbWJlckV4cHJlc3Npb24ucHJvcGVydHkpXG4gICAgICAgIDogbWVtYmVyRXhwcmVzc2lvbi5wcm9wZXJ0eS5uYW1lO1xufVxuZnVuY3Rpb24gZ2V0UmVzb2x2YWJsZUNvbXB1dGVkUHJvcGVydHlLZXkocHJvcGVydHlLZXkpIHtcbiAgICBpZiAocHJvcGVydHlLZXkgaW5zdGFuY2VvZiBMaXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcocHJvcGVydHlLZXkudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFBhdGhJZk5vdENvbXB1dGVkKG1lbWJlckV4cHJlc3Npb24pIHtcbiAgICBjb25zdCBuZXh0UGF0aEtleSA9IG1lbWJlckV4cHJlc3Npb24ucHJvcGVydHlLZXk7XG4gICAgY29uc3Qgb2JqZWN0ID0gbWVtYmVyRXhwcmVzc2lvbi5vYmplY3Q7XG4gICAgaWYgKHR5cGVvZiBuZXh0UGF0aEtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIElkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyBrZXk6IG9iamVjdC5uYW1lLCBwb3M6IG9iamVjdC5zdGFydCB9LFxuICAgICAgICAgICAgICAgIHsga2V5OiBuZXh0UGF0aEtleSwgcG9zOiBtZW1iZXJFeHByZXNzaW9uLnByb3BlcnR5LnN0YXJ0IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1lbWJlckV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBnZXRQYXRoSWZOb3RDb21wdXRlZChvYmplY3QpO1xuICAgICAgICAgICAgcmV0dXJuIChwYXJlbnRQYXRoICYmIFsuLi5wYXJlbnRQYXRoLCB7IGtleTogbmV4dFBhdGhLZXksIHBvczogbWVtYmVyRXhwcmVzc2lvbi5wcm9wZXJ0eS5zdGFydCB9XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRTdHJpbmdGcm9tUGF0aChwYXRoKSB7XG4gICAgbGV0IHBhdGhTdHJpbmcgPSBwYXRoWzBdLmtleTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgcGF0aC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgcGF0aFN0cmluZyArPSAnLicgKyBwYXRoW2luZGV4XS5rZXk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoU3RyaW5nO1xufVxuY2xhc3MgTWVtYmVyRXhwcmVzc2lvbiBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQgPSBbXTtcbiAgICB9XG4gICAgZ2V0IGNvbXB1dGVkKCkge1xuICAgICAgICByZXR1cm4gaXNGbGFnU2V0KHRoaXMuZmxhZ3MsIDEwMjQgLyogRmxhZy5jb21wdXRlZCAqLyk7XG4gICAgfVxuICAgIHNldCBjb21wdXRlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZsYWdzID0gc2V0RmxhZyh0aGlzLmZsYWdzLCAxMDI0IC8qIEZsYWcuY29tcHV0ZWQgKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbmFsKCkge1xuICAgICAgICByZXR1cm4gaXNGbGFnU2V0KHRoaXMuZmxhZ3MsIDEyOCAvKiBGbGFnLm9wdGlvbmFsICovKTtcbiAgICB9XG4gICAgc2V0IG9wdGlvbmFsKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBzZXRGbGFnKHRoaXMuZmxhZ3MsIDEyOCAvKiBGbGFnLm9wdGlvbmFsICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBhc3NpZ25tZW50RGVvcHRpbWl6ZWQoKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYWdTZXQodGhpcy5mbGFncywgMTYgLyogRmxhZy5hc3NpZ25tZW50RGVvcHRpbWl6ZWQgKi8pO1xuICAgIH1cbiAgICBzZXQgYXNzaWdubWVudERlb3B0aW1pemVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBzZXRGbGFnKHRoaXMuZmxhZ3MsIDE2IC8qIEZsYWcuYXNzaWdubWVudERlb3B0aW1pemVkICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBib3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhZ1NldCh0aGlzLmZsYWdzLCAzMiAvKiBGbGFnLmJvdW5kICovKTtcbiAgICB9XG4gICAgc2V0IGJvdW5kKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBzZXRGbGFnKHRoaXMuZmxhZ3MsIDMyIC8qIEZsYWcuYm91bmQgKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGlzVW5kZWZpbmVkKCkge1xuICAgICAgICByZXR1cm4gaXNGbGFnU2V0KHRoaXMuZmxhZ3MsIDY0IC8qIEZsYWcuaXNVbmRlZmluZWQgKi8pO1xuICAgIH1cbiAgICBzZXQgaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5mbGFncyA9IHNldEZsYWcodGhpcy5mbGFncywgNjQgLyogRmxhZy5pc1VuZGVmaW5lZCAqLywgdmFsdWUpO1xuICAgIH1cbiAgICBiaW5kKCkge1xuICAgICAgICB0aGlzLmJvdW5kID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGdldFBhdGhJZk5vdENvbXB1dGVkKHRoaXMpO1xuICAgICAgICBjb25zdCBiYXNlVmFyaWFibGUgPSBwYXRoICYmIHRoaXMuc2NvcGUuZmluZFZhcmlhYmxlKHBhdGhbMF0ua2V5KTtcbiAgICAgICAgaWYgKGJhc2VWYXJpYWJsZT8uaXNOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkVmFyaWFibGUgPSByZXNvbHZlTmFtZXNwYWNlVmFyaWFibGVzKGJhc2VWYXJpYWJsZSwgcGF0aC5zbGljZSgxKSwgdGhpcy5zY29wZS5jb250ZXh0KTtcbiAgICAgICAgICAgIGlmICghcmVzb2x2ZWRWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgIHN1cGVyLmJpbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc29sdmVkVmFyaWFibGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1VuZGVmaW5lZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlID0gcmVzb2x2ZWRWYXJpYWJsZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjb3BlLmFkZE5hbWVzcGFjZU1lbWJlckFjY2VzcyhnZXRTdHJpbmdGcm9tUGF0aChwYXRoKSwgcmVzb2x2ZWRWYXJpYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5iaW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIpIHtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGUpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGUuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmlzVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPCBNQVhfUEFUSF9ERVBUSCkge1xuICAgICAgICAgICAgICAgIHRoaXMub2JqZWN0LmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBbdGhpcy5nZXRQcm9wZXJ0eUtleSgpLCAuLi5wYXRoXSwgcmVjdXJzaW9uVHJhY2tlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZW9wdGltaXplSW50ZXJhY3Rpb24oaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlb3B0aW1pemVDYWNoZSgpIHtcbiAgICAgICAgY29uc3QgeyBleHByZXNzaW9uc1RvQmVEZW9wdGltaXplZCwgb2JqZWN0IH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkID0gRU1QVFlfQVJSQVk7XG4gICAgICAgIHRoaXMucHJvcGVydHlLZXkgPSBVbmtub3duS2V5O1xuICAgICAgICBvYmplY3QuZGVvcHRpbWl6ZVBhdGgoVU5LTk9XTl9QQVRIKTtcbiAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIGV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uLmRlb3B0aW1pemVDYWNoZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlb3B0aW1pemVQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhpcy5kaXNhbGxvd05hbWVzcGFjZVJlYXNzaWdubWVudCgpO1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZSkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZS5kZW9wdGltaXplUGF0aChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5pc1VuZGVmaW5lZCAmJiBwYXRoLmxlbmd0aCA8IE1BWF9QQVRIX0RFUFRIKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eUtleSA9IHRoaXMuZ2V0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0LmRlb3B0aW1pemVQYXRoKFtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9PT0gVW5rbm93bktleSA/IFVua25vd25Ob25BY2Nlc3NvcktleSA6IHByb3BlcnR5S2V5LFxuICAgICAgICAgICAgICAgIC4uLnBhdGhcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlLmdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BlcnR5S2V5ICE9PSBVbmtub3duS2V5ICYmIHBhdGgubGVuZ3RoIDwgTUFYX1BBVEhfREVQVEgpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQucHVzaChvcmlnaW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0LmdldExpdGVyYWxWYWx1ZUF0UGF0aChbdGhpcy5nZXRQcm9wZXJ0eUtleSgpLCAuLi5wYXRoXSwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVW5rbm93blZhbHVlO1xuICAgIH1cbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGhBc0NoYWluRWxlbWVudChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlLmdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRDaGFpbkVsZW1lbnRMaXRlcmFsVmFsdWVBdFBhdGgodGhpcywgdGhpcy5vYmplY3QsIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW1VOREVGSU5FRF9FWFBSRVNTSU9OLCBmYWxzZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvcGVydHlLZXkgIT09IFVua25vd25LZXkgJiYgcGF0aC5sZW5ndGggPCBNQVhfUEFUSF9ERVBUSCkge1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZC5wdXNoKG9yaWdpbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmplY3QuZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgoW3RoaXMuZ2V0UHJvcGVydHlLZXkoKSwgLi4ucGF0aF0sIGludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVTktOT1dOX1JFVFVSTl9FWFBSRVNTSU9OO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICByZXR1cm4gKHRoaXMucHJvcGVydHkuaGFzRWZmZWN0cyhjb250ZXh0KSB8fFxuICAgICAgICAgICAgdGhpcy5vYmplY3QuaGFzRWZmZWN0cyhjb250ZXh0KSB8fFxuICAgICAgICAgICAgdGhpcy5oYXNBY2Nlc3NFZmZlY3QoY29udGV4dCkpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzQXNDaGFpbkVsZW1lbnQoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZSB8fCB0aGlzLmlzVW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzRWZmZWN0cyhjb250ZXh0KTtcbiAgICAgICAgY29uc3Qgb2JqZWN0SGFzRWZmZWN0cyA9ICdoYXNFZmZlY3RzQXNDaGFpbkVsZW1lbnQnIGluIHRoaXMub2JqZWN0XG4gICAgICAgICAgICA/IHRoaXMub2JqZWN0Lmhhc0VmZmVjdHNBc0NoYWluRWxlbWVudChjb250ZXh0KVxuICAgICAgICAgICAgOiB0aGlzLm9iamVjdC5oYXNFZmZlY3RzKGNvbnRleHQpO1xuICAgICAgICBpZiAob2JqZWN0SGFzRWZmZWN0cyA9PT0gSVNfU0tJUFBFRF9DSEFJTilcbiAgICAgICAgICAgIHJldHVybiBJU19TS0lQUEVEX0NIQUlOO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbCAmJlxuICAgICAgICAgICAgdGhpcy5vYmplY3QuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKEVNUFRZX1BBVEgsIFNIQVJFRF9SRUNVUlNJT05fVFJBQ0tFUiwgdGhpcykgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdEhhc0VmZmVjdHMgfHwgSVNfU0tJUFBFRF9DSEFJTjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBvbmx5IGFwcGx5IGRlb3B0aW1pemF0aW9ucyBsYXppbHkgb25jZSB3ZSBrbm93IHdlIGFyZSBub3Qgc2tpcHBpbmdcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICByZXR1cm4gb2JqZWN0SGFzRWZmZWN0cyB8fCB0aGlzLnByb3BlcnR5Lmhhc0VmZmVjdHMoY29udGV4dCkgfHwgdGhpcy5oYXNBY2Nlc3NFZmZlY3QoY29udGV4dCk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNBc0Fzc2lnbm1lbnRUYXJnZXQoY29udGV4dCwgY2hlY2tBY2Nlc3MpIHtcbiAgICAgICAgaWYgKGNoZWNrQWNjZXNzICYmICF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICBpZiAoIXRoaXMuYXNzaWdubWVudERlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseUFzc2lnbm1lbnREZW9wdGltaXphdGlvbigpO1xuICAgICAgICByZXR1cm4gKHRoaXMucHJvcGVydHkuaGFzRWZmZWN0cyhjb250ZXh0KSB8fFxuICAgICAgICAgICAgdGhpcy5vYmplY3QuaGFzRWZmZWN0cyhjb250ZXh0KSB8fFxuICAgICAgICAgICAgKGNoZWNrQWNjZXNzICYmIHRoaXMuaGFzQWNjZXNzRWZmZWN0KGNvbnRleHQpKSB8fFxuICAgICAgICAgICAgdGhpcy5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChFTVBUWV9QQVRILCB0aGlzLmFzc2lnbm1lbnRJbnRlcmFjdGlvbiwgY29udGV4dCkpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFyaWFibGUuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPCBNQVhfUEFUSF9ERVBUSCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0Lmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKFt0aGlzLmdldFByb3BlcnR5S2V5KCksIC4uLnBhdGhdLCBpbnRlcmFjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICB0aGlzLmluY2x1ZGVQcm9wZXJ0aWVzKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICB9XG4gICAgaW5jbHVkZUFzQXNzaWdubWVudFRhcmdldChjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSwgZGVvcHRpbWl6ZUFjY2Vzcykge1xuICAgICAgICBpZiAoIXRoaXMuYXNzaWdubWVudERlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseUFzc2lnbm1lbnREZW9wdGltaXphdGlvbigpO1xuICAgICAgICBpZiAoZGVvcHRpbWl6ZUFjY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVByb3BlcnRpZXMoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluY2x1ZGVDYWxsQXJndW1lbnRzKGNvbnRleHQsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGUpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGUuaW5jbHVkZUNhbGxBcmd1bWVudHMoY29udGV4dCwgcGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5pbmNsdWRlQ2FsbEFyZ3VtZW50cyhjb250ZXh0LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0aWFsaXNlKCkge1xuICAgICAgICBzdXBlci5pbml0aWFsaXNlKCk7XG4gICAgICAgIHRoaXMucHJvcGVydHlLZXkgPSBnZXRSZXNvbHZhYmxlUHJvcGVydHlLZXkodGhpcyk7XG4gICAgICAgIHRoaXMuYWNjZXNzSW50ZXJhY3Rpb24gPSB7IGFyZ3M6IFt0aGlzLm9iamVjdF0sIHR5cGU6IElOVEVSQUNUSU9OX0FDQ0VTU0VEIH07XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zLCB7IHJlbmRlcmVkUGFyZW50VHlwZSwgaXNDYWxsZWVPZlJlbmRlcmVkUGFyZW50LCByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudCB9ID0gQkxBTkspIHtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGUgfHwgdGhpcy5pc1VuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgeyBzbmlwcGV0czogeyBnZXRQcm9wZXJ0eUFjY2VzcyB9IH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgbGV0IHJlcGxhY2VtZW50ID0gdGhpcy52YXJpYWJsZSA/IHRoaXMudmFyaWFibGUuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2VzcykgOiAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGlmIChyZW5kZXJlZFBhcmVudFR5cGUgJiYgaXNDYWxsZWVPZlJlbmRlcmVkUGFyZW50KVxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gJzAsICcgKyByZXBsYWNlbWVudDtcbiAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCByZXBsYWNlbWVudCwge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRPbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIHN0b3JlTmFtZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVuZGVyZWRQYXJlbnRUeXBlICYmIGlzQ2FsbGVlT2ZSZW5kZXJlZFBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNvZGUuYXBwZW5kUmlnaHQodGhpcy5zdGFydCwgJzAsICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vYmplY3QucmVuZGVyKGNvZGUsIG9wdGlvbnMsIHsgcmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQgfSk7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5LnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRBc3NpZ25lZFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXNzaWdubWVudEludGVyYWN0aW9uID0ge1xuICAgICAgICAgICAgYXJnczogW3RoaXMub2JqZWN0LCB2YWx1ZV0sXG4gICAgICAgICAgICB0eXBlOiBJTlRFUkFDVElPTl9BU1NJR05FRFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kZW9wdGltaXplZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgcHJvcGVydHlSZWFkU2lkZUVmZmVjdHMgfSA9IHRoaXMuc2NvcGUuY29udGV4dC5vcHRpb25zXG4gICAgICAgICAgICAudHJlZXNoYWtlO1xuICAgICAgICBpZiAoXG4gICAgICAgIC8vIE5hbWVzcGFjZXMgYXJlIG5vdCBib3VuZCBhbmQgc2hvdWxkIG5vdCBiZSBkZW9wdGltaXplZFxuICAgICAgICB0aGlzLmJvdW5kICYmXG4gICAgICAgICAgICBwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgISh0aGlzLnZhcmlhYmxlIHx8IHRoaXMuaXNVbmRlZmluZWQpKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eUtleSA9IHRoaXMuZ2V0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0LmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHRoaXMuYWNjZXNzSW50ZXJhY3Rpb24sIFtwcm9wZXJ0eUtleV0sIFNIQVJFRF9SRUNVUlNJT05fVFJBQ0tFUik7XG4gICAgICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZhcmlhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlLmFkZFVzZWRQbGFjZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2NvcGUuY29udGV4dC5yZXF1ZXN0VHJlZXNoYWtpbmdQYXNzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlBc3NpZ25tZW50RGVvcHRpbWl6YXRpb24oKSB7XG4gICAgICAgIHRoaXMuYXNzaWdubWVudERlb3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0cyB9ID0gdGhpcy5zY29wZS5jb250ZXh0Lm9wdGlvbnNcbiAgICAgICAgICAgIC50cmVlc2hha2U7XG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gTmFtZXNwYWNlcyBhcmUgbm90IGJvdW5kIGFuZCBzaG91bGQgbm90IGJlIGRlb3B0aW1pemVkXG4gICAgICAgIHRoaXMuYm91bmQgJiZcbiAgICAgICAgICAgIHByb3BlcnR5UmVhZFNpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICAhKHRoaXMudmFyaWFibGUgfHwgdGhpcy5pc1VuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0LmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHRoaXMuYXNzaWdubWVudEludGVyYWN0aW9uLCBbdGhpcy5nZXRQcm9wZXJ0eUtleSgpXSwgU0hBUkVEX1JFQ1VSU0lPTl9UUkFDS0VSKTtcbiAgICAgICAgICAgIHRoaXMuc2NvcGUuY29udGV4dC5yZXF1ZXN0VHJlZXNoYWtpbmdQYXNzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzYWxsb3dOYW1lc3BhY2VSZWFzc2lnbm1lbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLm9iamVjdCBpbnN0YW5jZW9mIElkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlID0gdGhpcy5zY29wZS5maW5kVmFyaWFibGUodGhpcy5vYmplY3QubmFtZSk7XG4gICAgICAgICAgICBpZiAodmFyaWFibGUuaXNOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YXJpYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQuaW5jbHVkZVZhcmlhYmxlSW5Nb2R1bGUodGhpcy52YXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2NvcGUuY29udGV4dC5sb2coTE9HTEVWRUxfV0FSTiwgbG9nSWxsZWdhbEltcG9ydFJlYXNzaWdubWVudCh0aGlzLm9iamVjdC5uYW1lLCB0aGlzLnNjb3BlLmNvbnRleHQubW9kdWxlLmlkKSwgdGhpcy5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UHJvcGVydHlLZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BlcnR5S2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5S2V5ID0gVW5rbm93bktleTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wcm9wZXJ0eS5nZXRMaXRlcmFsVmFsdWVBdFBhdGgoRU1QVFlfUEFUSCwgU0hBUkVEX1JFQ1VSU0lPTl9UUkFDS0VSLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5wcm9wZXJ0eUtleSA9XG4gICAgICAgICAgICAgICAgdmFsdWUgPT09IFN5bWJvbFRvU3RyaW5nVGFnXG4gICAgICAgICAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFVua25vd25LZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHlLZXk7XG4gICAgfVxuICAgIGhhc0FjY2Vzc0VmZmVjdChjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcGVydHlSZWFkU2lkZUVmZmVjdHMgfSA9IHRoaXMuc2NvcGUuY29udGV4dC5vcHRpb25zXG4gICAgICAgICAgICAudHJlZXNoYWtlO1xuICAgICAgICByZXR1cm4gKCEodGhpcy52YXJpYWJsZSB8fCB0aGlzLmlzVW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgcHJvcGVydHlSZWFkU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICAgIChwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0cyA9PT0gJ2Fsd2F5cycgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdC5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChbdGhpcy5nZXRQcm9wZXJ0eUtleSgpXSwgdGhpcy5hY2Nlc3NJbnRlcmFjdGlvbiwgY29udGV4dCkpKTtcbiAgICB9XG4gICAgaW5jbHVkZVByb3BlcnRpZXMoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY29wZS5jb250ZXh0LmluY2x1ZGVWYXJpYWJsZUluTW9kdWxlKHRoaXMudmFyaWFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JqZWN0LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICB0aGlzLnByb3BlcnR5LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVOYW1lc3BhY2VWYXJpYWJsZXMoYmFzZVZhcmlhYmxlLCBwYXRoLCBhc3RDb250ZXh0KSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gYmFzZVZhcmlhYmxlO1xuICAgIGlmICghYmFzZVZhcmlhYmxlLmlzTmFtZXNwYWNlIHx8IGJhc2VWYXJpYWJsZSBpbnN0YW5jZW9mIEV4dGVybmFsVmFyaWFibGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGV4cG9ydE5hbWUgPSBwYXRoWzBdLmtleTtcbiAgICBjb25zdCB2YXJpYWJsZSA9IGJhc2VWYXJpYWJsZS5jb250ZXh0LnRyYWNlRXhwb3J0KGV4cG9ydE5hbWUpO1xuICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGJhc2VWYXJpYWJsZS5jb250ZXh0LmZpbGVOYW1lO1xuICAgICAgICAgICAgYXN0Q29udGV4dC5sb2coTE9HTEVWRUxfV0FSTiwgbG9nTWlzc2luZ0V4cG9ydChleHBvcnROYW1lLCBhc3RDb250ZXh0Lm1vZHVsZS5pZCwgZmlsZU5hbWUpLCBwYXRoWzBdLnBvcyk7XG4gICAgICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlTmFtZXNwYWNlVmFyaWFibGVzKHZhcmlhYmxlLCBwYXRoLnNsaWNlKDEpLCBhc3RDb250ZXh0KTtcbn1cblxuY29uc3QgRklMRV9QUkVGSVggPSAnUk9MTFVQX0ZJTEVfVVJMXyc7XG5jb25zdCBJTVBPUlQgPSAnaW1wb3J0JztcbmNsYXNzIE1ldGFQcm9wZXJ0eSBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5tZXRhUHJvcGVydHkgPSBudWxsO1xuICAgICAgICB0aGlzLnByZWxpbWluYXJ5Q2h1bmtJZCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlSWQgPSBudWxsO1xuICAgIH1cbiAgICBnZXRSZWZlcmVuY2VkRmlsZU5hbWUob3V0cHV0UGx1Z2luRHJpdmVyKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0YTogeyBuYW1lIH0sIG1ldGFQcm9wZXJ0eSB9ID0gdGhpcztcbiAgICAgICAgaWYgKG5hbWUgPT09IElNUE9SVCAmJiBtZXRhUHJvcGVydHk/LnN0YXJ0c1dpdGgoRklMRV9QUkVGSVgpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0UGx1Z2luRHJpdmVyLmdldEZpbGVOYW1lKG1ldGFQcm9wZXJ0eS5zbGljZShGSUxFX1BSRUZJWC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaGFzRWZmZWN0cygpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCB7IHR5cGUgfSkge1xuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAxIHx8IHR5cGUgIT09IElOVEVSQUNUSU9OX0FDQ0VTU0VEO1xuICAgIH1cbiAgICBpbmNsdWRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubWV0YS5uYW1lID09PSBJTVBPUlQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQuYWRkSW1wb3J0TWV0YSh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhUHJvcGVydHkgPSAodGhpcy5tZXRhUHJvcGVydHkgPVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgaW5zdGFuY2VvZiBNZW1iZXJFeHByZXNzaW9uICYmIHR5cGVvZiBwYXJlbnQucHJvcGVydHlLZXkgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmVudC5wcm9wZXJ0eUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAobWV0YVByb3BlcnR5Py5zdGFydHNXaXRoKEZJTEVfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZmVyZW5jZUlkID0gbWV0YVByb3BlcnR5LnNsaWNlKEZJTEVfUFJFRklYLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCByZW5kZXJPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgZm9ybWF0LCBwbHVnaW5Ecml2ZXIsIHNuaXBwZXRzIH0gPSByZW5kZXJPcHRpb25zO1xuICAgICAgICBjb25zdCB7IHNjb3BlOiB7IGNvbnRleHQ6IHsgbW9kdWxlIH0gfSwgbWV0YTogeyBuYW1lIH0sIG1ldGFQcm9wZXJ0eSwgcGFyZW50LCBwcmVsaW1pbmFyeUNodW5rSWQsIHJlZmVyZW5jZUlkLCBzdGFydCwgZW5kIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGlkOiBtb2R1bGVJZCB9ID0gbW9kdWxlO1xuICAgICAgICBpZiAobmFtZSAhPT0gSU1QT1JUKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjaHVua0lkID0gcHJlbGltaW5hcnlDaHVua0lkO1xuICAgICAgICBpZiAocmVmZXJlbmNlSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gcGx1Z2luRHJpdmVyLmdldEZpbGVOYW1lKHJlZmVyZW5jZUlkKTtcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5vcm1hbGl6ZShyZWxhdGl2ZShkaXJuYW1lKGNodW5rSWQpLCBmaWxlTmFtZSkpO1xuICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBwbHVnaW5Ecml2ZXIuaG9va0ZpcnN0U3luYygncmVzb2x2ZUZpbGVVcmwnLCBbXG4gICAgICAgICAgICAgICAgeyBjaHVua0lkLCBmaWxlTmFtZSwgZm9ybWF0LCBtb2R1bGVJZCwgcmVmZXJlbmNlSWQsIHJlbGF0aXZlUGF0aCB9XG4gICAgICAgICAgICBdKSB8fCByZWxhdGl2ZVVybE1lY2hhbmlzbXNbZm9ybWF0XShyZWxhdGl2ZVBhdGgpO1xuICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUocGFyZW50LnN0YXJ0LCBwYXJlbnQuZW5kLCByZXBsYWNlbWVudCwgeyBjb250ZW50T25seTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVwbGFjZW1lbnQgPSBwbHVnaW5Ecml2ZXIuaG9va0ZpcnN0U3luYygncmVzb2x2ZUltcG9ydE1ldGEnLCBbXG4gICAgICAgICAgICBtZXRhUHJvcGVydHksXG4gICAgICAgICAgICB7IGNodW5rSWQsIGZvcm1hdCwgbW9kdWxlSWQgfVxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKCFyZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSBpbXBvcnRNZXRhTWVjaGFuaXNtc1tmb3JtYXRdPy4obWV0YVByb3BlcnR5LCB7IGNodW5rSWQsIHNuaXBwZXRzIH0pO1xuICAgICAgICAgICAgcmVuZGVyT3B0aW9ucy5hY2Nlc3NlZERvY3VtZW50Q3VycmVudFNjcmlwdCB8fD1cbiAgICAgICAgICAgICAgICBmb3JtYXRzTWF5YmVBY2Nlc3NEb2N1bWVudEN1cnJlbnRTY3JpcHQuaW5jbHVkZXMoZm9ybWF0KSAmJiByZXBsYWNlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBNZW1iZXJFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUocGFyZW50LnN0YXJ0LCBwYXJlbnQuZW5kLCByZXBsYWNlbWVudCwgeyBjb250ZW50T25seTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHN0YXJ0LCBlbmQsIHJlcGxhY2VtZW50LCB7IGNvbnRlbnRPbmx5OiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldFJlc29sdXRpb24oZm9ybWF0LCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlLCBwcmVsaW1pbmFyeUNodW5rSWQpIHtcbiAgICAgICAgdGhpcy5wcmVsaW1pbmFyeUNodW5rSWQgPSBwcmVsaW1pbmFyeUNodW5rSWQ7XG4gICAgICAgIGNvbnN0IGFjY2Vzc2VkR2xvYmFscyA9ICh0aGlzLm1ldGFQcm9wZXJ0eT8uc3RhcnRzV2l0aChGSUxFX1BSRUZJWCkgPyBhY2Nlc3NlZEZpbGVVcmxHbG9iYWxzIDogYWNjZXNzZWRNZXRhVXJsR2xvYmFscylbZm9ybWF0XTtcbiAgICAgICAgaWYgKGFjY2Vzc2VkR2xvYmFscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnNjb3BlLmFkZEFjY2Vzc2VkR2xvYmFscyhhY2Nlc3NlZEdsb2JhbHMsIGFjY2Vzc2VkR2xvYmFsc0J5U2NvcGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgZm9ybWF0c01heWJlQWNjZXNzRG9jdW1lbnRDdXJyZW50U2NyaXB0ID0gWydjanMnLCAnaWlmZScsICd1bWQnXTtcbmNvbnN0IGFjY2Vzc2VkTWV0YVVybEdsb2JhbHMgPSB7XG4gICAgYW1kOiBbJ2RvY3VtZW50JywgJ21vZHVsZScsICdVUkwnXSxcbiAgICBjanM6IFsnZG9jdW1lbnQnLCAncmVxdWlyZScsICdVUkwnLCBET0NVTUVOVF9DVVJSRU5UX1NDUklQVF0sXG4gICAgZXM6IFtdLFxuICAgIGlpZmU6IFsnZG9jdW1lbnQnLCAnVVJMJywgRE9DVU1FTlRfQ1VSUkVOVF9TQ1JJUFRdLFxuICAgIHN5c3RlbTogWydtb2R1bGUnXSxcbiAgICB1bWQ6IFsnZG9jdW1lbnQnLCAncmVxdWlyZScsICdVUkwnLCBET0NVTUVOVF9DVVJSRU5UX1NDUklQVF1cbn07XG5jb25zdCBhY2Nlc3NlZEZpbGVVcmxHbG9iYWxzID0ge1xuICAgIGFtZDogWydkb2N1bWVudCcsICdyZXF1aXJlJywgJ1VSTCddLFxuICAgIGNqczogWydkb2N1bWVudCcsICdyZXF1aXJlJywgJ1VSTCddLFxuICAgIGVzOiBbXSxcbiAgICBpaWZlOiBbJ2RvY3VtZW50JywgJ1VSTCddLFxuICAgIHN5c3RlbTogWydtb2R1bGUnLCAnVVJMJ10sXG4gICAgdW1kOiBbJ2RvY3VtZW50JywgJ3JlcXVpcmUnLCAnVVJMJ11cbn07XG5jb25zdCBnZXRSZXNvbHZlVXJsID0gKHBhdGgsIFVSTCA9ICdVUkwnKSA9PiBgbmV3ICR7VVJMfSgke3BhdGh9KS5ocmVmYDtcbmNvbnN0IGdldFJlbGF0aXZlVXJsRnJvbURvY3VtZW50ID0gKHJlbGF0aXZlUGF0aCwgdW1kID0gZmFsc2UpID0+IGdldFJlc29sdmVVcmwoYCcke2VzY2FwZUlkKHJlbGF0aXZlUGF0aCl9JywgJHt1bWQgPyBgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IGxvY2F0aW9uLmhyZWYgOiBgIDogJyd9ZG9jdW1lbnQuY3VycmVudFNjcmlwdCAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1NDUklQVCcgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMgfHwgZG9jdW1lbnQuYmFzZVVSSWApO1xuY29uc3QgZ2V0R2VuZXJpY0ltcG9ydE1ldGFNZWNoYW5pc20gPSAoZ2V0VXJsKSA9PiAocHJvcGVydHksIHsgY2h1bmtJZCB9KSA9PiB7XG4gICAgY29uc3QgdXJsTWVjaGFuaXNtID0gZ2V0VXJsKGNodW5rSWQpO1xuICAgIHJldHVybiBwcm9wZXJ0eSA9PT0gbnVsbFxuICAgICAgICA/IGAoeyB1cmw6ICR7dXJsTWVjaGFuaXNtfSB9KWBcbiAgICAgICAgOiBwcm9wZXJ0eSA9PT0gJ3VybCdcbiAgICAgICAgICAgID8gdXJsTWVjaGFuaXNtXG4gICAgICAgICAgICA6ICd1bmRlZmluZWQnO1xufTtcbmNvbnN0IGdldEZpbGVVcmxGcm9tRnVsbFBhdGggPSAocGF0aCkgPT4gYHJlcXVpcmUoJ3UnICsgJ3JsJykucGF0aFRvRmlsZVVSTCgke3BhdGh9KS5ocmVmYDtcbmNvbnN0IGdldEZpbGVVcmxGcm9tUmVsYXRpdmVQYXRoID0gKHBhdGgpID0+IGdldEZpbGVVcmxGcm9tRnVsbFBhdGgoYF9fZGlybmFtZSArICcvJHtlc2NhcGVJZChwYXRoKX0nYCk7XG5jb25zdCBnZXRVcmxGcm9tRG9jdW1lbnQgPSAoY2h1bmtJZCwgdW1kID0gZmFsc2UpID0+IGAke3VtZCA/IGB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8gbG9jYXRpb24uaHJlZiA6IGAgOiAnJ30oJHtET0NVTUVOVF9DVVJSRU5UX1NDUklQVH0gJiYgJHtET0NVTUVOVF9DVVJSRU5UX1NDUklQVH0udGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnU0NSSVBUJyAmJiAke0RPQ1VNRU5UX0NVUlJFTlRfU0NSSVBUfS5zcmMgfHwgbmV3IFVSTCgnJHtlc2NhcGVJZChjaHVua0lkKX0nLCBkb2N1bWVudC5iYXNlVVJJKS5ocmVmKWA7XG5jb25zdCByZWxhdGl2ZVVybE1lY2hhbmlzbXMgPSB7XG4gICAgYW1kOiByZWxhdGl2ZVBhdGggPT4ge1xuICAgICAgICBpZiAocmVsYXRpdmVQYXRoWzBdICE9PSAnLicpXG4gICAgICAgICAgICByZWxhdGl2ZVBhdGggPSAnLi8nICsgcmVsYXRpdmVQYXRoO1xuICAgICAgICByZXR1cm4gZ2V0UmVzb2x2ZVVybChgcmVxdWlyZS50b1VybCgnJHtlc2NhcGVJZChyZWxhdGl2ZVBhdGgpfScpLCBkb2N1bWVudC5iYXNlVVJJYCk7XG4gICAgfSxcbiAgICBjanM6IHJlbGF0aXZlUGF0aCA9PiBgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyAke2dldEZpbGVVcmxGcm9tUmVsYXRpdmVQYXRoKHJlbGF0aXZlUGF0aCl9IDogJHtnZXRSZWxhdGl2ZVVybEZyb21Eb2N1bWVudChyZWxhdGl2ZVBhdGgpfSlgLFxuICAgIGVzOiByZWxhdGl2ZVBhdGggPT4gZ2V0UmVzb2x2ZVVybChgJyR7ZXNjYXBlSWQocmVsYXRpdmVQYXRoKX0nLCBpbXBvcnQubWV0YS51cmxgKSxcbiAgICBpaWZlOiByZWxhdGl2ZVBhdGggPT4gZ2V0UmVsYXRpdmVVcmxGcm9tRG9jdW1lbnQocmVsYXRpdmVQYXRoKSxcbiAgICBzeXN0ZW06IHJlbGF0aXZlUGF0aCA9PiBnZXRSZXNvbHZlVXJsKGAnJHtlc2NhcGVJZChyZWxhdGl2ZVBhdGgpfScsIG1vZHVsZS5tZXRhLnVybGApLFxuICAgIHVtZDogcmVsYXRpdmVQYXRoID0+IGAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbG9jYXRpb24gPT09ICd1bmRlZmluZWQnID8gJHtnZXRGaWxlVXJsRnJvbVJlbGF0aXZlUGF0aChyZWxhdGl2ZVBhdGgpfSA6ICR7Z2V0UmVsYXRpdmVVcmxGcm9tRG9jdW1lbnQocmVsYXRpdmVQYXRoLCB0cnVlKX0pYFxufTtcbmNvbnN0IGltcG9ydE1ldGFNZWNoYW5pc21zID0ge1xuICAgIGFtZDogZ2V0R2VuZXJpY0ltcG9ydE1ldGFNZWNoYW5pc20oKCkgPT4gZ2V0UmVzb2x2ZVVybChgbW9kdWxlLnVyaSwgZG9jdW1lbnQuYmFzZVVSSWApKSxcbiAgICBjanM6IGdldEdlbmVyaWNJbXBvcnRNZXRhTWVjaGFuaXNtKGNodW5rSWQgPT4gYCh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8gJHtnZXRGaWxlVXJsRnJvbUZ1bGxQYXRoKCdfX2ZpbGVuYW1lJyl9IDogJHtnZXRVcmxGcm9tRG9jdW1lbnQoY2h1bmtJZCl9KWApLFxuICAgIGlpZmU6IGdldEdlbmVyaWNJbXBvcnRNZXRhTWVjaGFuaXNtKGNodW5rSWQgPT4gZ2V0VXJsRnJvbURvY3VtZW50KGNodW5rSWQpKSxcbiAgICBzeXN0ZW06IChwcm9wZXJ0eSwgeyBzbmlwcGV0czogeyBnZXRQcm9wZXJ0eUFjY2VzcyB9IH0pID0+IHByb3BlcnR5ID09PSBudWxsID8gYG1vZHVsZS5tZXRhYCA6IGBtb2R1bGUubWV0YSR7Z2V0UHJvcGVydHlBY2Nlc3MocHJvcGVydHkpfWAsXG4gICAgdW1kOiBnZXRHZW5lcmljSW1wb3J0TWV0YU1lY2hhbmlzbShjaHVua0lkID0+IGAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbG9jYXRpb24gPT09ICd1bmRlZmluZWQnID8gJHtnZXRGaWxlVXJsRnJvbUZ1bGxQYXRoKCdfX2ZpbGVuYW1lJyl9IDogJHtnZXRVcmxGcm9tRG9jdW1lbnQoY2h1bmtJZCwgdHJ1ZSl9KWApXG59O1xuXG5jbGFzcyBVbmRlZmluZWRWYXJpYWJsZSBleHRlbmRzIFZhcmlhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3VuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG5jbGFzcyBFeHBvcnREZWZhdWx0VmFyaWFibGUgZXh0ZW5kcyBMb2NhbFZhcmlhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBleHBvcnREZWZhdWx0RGVjbGFyYXRpb24sIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIobmFtZSwgZXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uLCBleHBvcnREZWZhdWx0RGVjbGFyYXRpb24uZGVjbGFyYXRpb24sIGNvbnRleHQsICdvdGhlcicpO1xuICAgICAgICB0aGlzLmhhc0lkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3JpZ2luYWxJZCA9IG51bGw7XG4gICAgICAgIHRoaXMub3JpZ2luYWxWYXJpYWJsZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gZXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uLmRlY2xhcmF0aW9uO1xuICAgICAgICBpZiAoKGRlY2xhcmF0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb25EZWNsYXJhdGlvbiB8fCBkZWNsYXJhdGlvbiBpbnN0YW5jZW9mIENsYXNzRGVjbGFyYXRpb24pICYmXG4gICAgICAgICAgICBkZWNsYXJhdGlvbi5pZCkge1xuICAgICAgICAgICAgdGhpcy5oYXNJZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsSWQgPSBkZWNsYXJhdGlvbi5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWNsYXJhdGlvbiBpbnN0YW5jZW9mIElkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxJZCA9IGRlY2xhcmF0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFJlZmVyZW5jZShpZGVudGlmaWVyKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNJZCkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gaWRlbnRpZmllci5uYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFVzZWRQbGFjZSh1c2VkUGxhY2UpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSB0aGlzLmdldE9yaWdpbmFsVmFyaWFibGUoKTtcbiAgICAgICAgaWYgKG9yaWdpbmFsID09PSB0aGlzKSB7XG4gICAgICAgICAgICBzdXBlci5hZGRVc2VkUGxhY2UodXNlZFBsYWNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9yaWdpbmFsLmFkZFVzZWRQbGFjZSh1c2VkUGxhY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcmJpZE5hbWUobmFtZSkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbCA9IHRoaXMuZ2V0T3JpZ2luYWxWYXJpYWJsZSgpO1xuICAgICAgICBpZiAob3JpZ2luYWwgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHN1cGVyLmZvcmJpZE5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcmlnaW5hbC5mb3JiaWROYW1lKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEFzc2lnbmVkVmFyaWFibGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMub3JpZ2luYWxJZCAmJiB0aGlzLm9yaWdpbmFsSWQubmFtZSkgfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0QmFzZVZhcmlhYmxlTmFtZSgpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSB0aGlzLmdldE9yaWdpbmFsVmFyaWFibGUoKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsID09PSB0aGlzID8gc3VwZXIuZ2V0QmFzZVZhcmlhYmxlTmFtZSgpIDogb3JpZ2luYWwuZ2V0QmFzZVZhcmlhYmxlTmFtZSgpO1xuICAgIH1cbiAgICBnZXREaXJlY3RPcmlnaW5hbFZhcmlhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbElkICYmXG4gICAgICAgICAgICAodGhpcy5oYXNJZCB8fFxuICAgICAgICAgICAgICAgICEodGhpcy5vcmlnaW5hbElkLmlzUG9zc2libGVURFooKSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbmFsSWQudmFyaWFibGUuaXNSZWFzc2lnbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luYWxJZC52YXJpYWJsZSBpbnN0YW5jZW9mIFVuZGVmaW5lZFZhcmlhYmxlIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgYXZvaWRzIGEgY2lyY3VsYXIgZGVwZW5kZW5jeVxuICAgICAgICAgICAgICAgICAgICAnc3ludGhldGljTmFtZXNwYWNlJyBpbiB0aGlzLm9yaWdpbmFsSWQudmFyaWFibGUpKVxuICAgICAgICAgICAgPyB0aGlzLm9yaWdpbmFsSWQudmFyaWFibGVcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2Vzcykge1xuICAgICAgICBjb25zdCBvcmlnaW5hbCA9IHRoaXMuZ2V0T3JpZ2luYWxWYXJpYWJsZSgpO1xuICAgICAgICByZXR1cm4gb3JpZ2luYWwgPT09IHRoaXNcbiAgICAgICAgICAgID8gc3VwZXIuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2VzcylcbiAgICAgICAgICAgIDogb3JpZ2luYWwuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2Vzcyk7XG4gICAgfVxuICAgIGdldE9yaWdpbmFsVmFyaWFibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbmFsVmFyaWFibGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbFZhcmlhYmxlO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgbGV0IG9yaWdpbmFsID0gdGhpcztcbiAgICAgICAgbGV0IGN1cnJlbnRWYXJpYWJsZTtcbiAgICAgICAgY29uc3QgY2hlY2tlZFZhcmlhYmxlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY2hlY2tlZFZhcmlhYmxlcy5hZGQob3JpZ2luYWwpO1xuICAgICAgICAgICAgY3VycmVudFZhcmlhYmxlID0gb3JpZ2luYWw7XG4gICAgICAgICAgICBvcmlnaW5hbCA9IGN1cnJlbnRWYXJpYWJsZS5nZXREaXJlY3RPcmlnaW5hbFZhcmlhYmxlKCk7XG4gICAgICAgIH0gd2hpbGUgKG9yaWdpbmFsIGluc3RhbmNlb2YgRXhwb3J0RGVmYXVsdFZhcmlhYmxlICYmICFjaGVja2VkVmFyaWFibGVzLmhhcyhvcmlnaW5hbCkpO1xuICAgICAgICByZXR1cm4gKHRoaXMub3JpZ2luYWxWYXJpYWJsZSA9IG9yaWdpbmFsIHx8IGN1cnJlbnRWYXJpYWJsZSk7XG4gICAgfVxufVxuXG5jbGFzcyBOYW1lc3BhY2VWYXJpYWJsZSBleHRlbmRzIFZhcmlhYmxlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQuZ2V0TW9kdWxlTmFtZSgpKTtcbiAgICAgICAgdGhpcy5tZW1iZXJWYXJpYWJsZXMgPSBudWxsO1xuICAgICAgICB0aGlzLm1lcmdlZE5hbWVzcGFjZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VkRWFybHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gW107XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMubW9kdWxlID0gY29udGV4dC5tb2R1bGU7XG4gICAgfVxuICAgIGFkZFJlZmVyZW5jZShpZGVudGlmaWVyKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcy5wdXNoKGlkZW50aWZpZXIpO1xuICAgICAgICB0aGlzLm5hbWUgPSBpZGVudGlmaWVyLm5hbWU7XG4gICAgfVxuICAgIGRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoLCByZWN1cnNpb25UcmFja2VyKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IDEgfHwgKHBhdGgubGVuZ3RoID09PSAxICYmIGludGVyYWN0aW9uLnR5cGUgPT09IElOVEVSQUNUSU9OX0NBTExFRCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHBhdGhbMF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldE1lbWJlclZhcmlhYmxlcygpW2tleV0/LmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoLnNsaWNlKDEpLCByZWN1cnNpb25UcmFja2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlb3B0aW1pemVJbnRlcmFjdGlvbihpbnRlcmFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVvcHRpbWl6ZVBhdGgocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBwYXRoWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRNZW1iZXJWYXJpYWJsZXMoKVtrZXldPy5kZW9wdGltaXplUGF0aChwYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCkge1xuICAgICAgICBpZiAocGF0aFswXSA9PT0gU3ltYm9sVG9TdHJpbmdUYWcpIHtcbiAgICAgICAgICAgIHJldHVybiAnTW9kdWxlJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVW5rbm93blZhbHVlO1xuICAgIH1cbiAgICBnZXRNZW1iZXJWYXJpYWJsZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLm1lbWJlclZhcmlhYmxlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVyVmFyaWFibGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lbWJlclZhcmlhYmxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGNvbnN0IHNvcnRlZEV4cG9ydHMgPSBbLi4udGhpcy5jb250ZXh0LmdldEV4cG9ydHMoKSwgLi4udGhpcy5jb250ZXh0LmdldFJlZXhwb3J0cygpXS5zb3J0KCk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBzb3J0ZWRFeHBvcnRzKSB7XG4gICAgICAgICAgICBpZiAobmFtZVswXSAhPT0gJyonICYmIG5hbWUgIT09IHRoaXMubW9kdWxlLmluZm8uc3ludGhldGljTmFtZWRFeHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwb3J0ZWRWYXJpYWJsZSA9IHRoaXMuY29udGV4dC50cmFjZUV4cG9ydChuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwb3J0ZWRWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBtZW1iZXJWYXJpYWJsZXNbbmFtZV0gPSBleHBvcnRlZFZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMubWVtYmVyVmFyaWFibGVzID0gbWVtYmVyVmFyaWFibGVzKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBpbnRlcmFjdGlvbjtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBvbmx5IGJlIGEgY2FsbCBhbnl3YXlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSAmJiB0eXBlICE9PSBJTlRFUkFDVElPTl9DQUxMRUQpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlID09PSBJTlRFUkFDVElPTl9BU1NJR05FRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSBwYXRoWzBdO1xuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lbWJlclZhcmlhYmxlID0gdGhpcy5nZXRNZW1iZXJWYXJpYWJsZXMoKVtrZXldO1xuICAgICAgICByZXR1cm4gKCFtZW1iZXJWYXJpYWJsZSB8fFxuICAgICAgICAgICAgbWVtYmVyVmFyaWFibGUuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aC5zbGljZSgxKSwgaW50ZXJhY3Rpb24sIGNvbnRleHQpKTtcbiAgICB9XG4gICAgaW5jbHVkZSgpIHtcbiAgICAgICAgc3VwZXIuaW5jbHVkZSgpO1xuICAgICAgICB0aGlzLmNvbnRleHQuaW5jbHVkZUFsbEV4cG9ydHMoKTtcbiAgICB9XG4gICAgcHJlcGFyZShhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlKSB7XG4gICAgICAgIGlmICh0aGlzLm1lcmdlZE5hbWVzcGFjZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5tb2R1bGUuc2NvcGUuYWRkQWNjZXNzZWRHbG9iYWxzKFtNRVJHRV9OQU1FU1BBQ0VTX1ZBUklBQkxFXSwgYWNjZXNzZWRHbG9iYWxzQnlTY29wZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyQmxvY2sob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGV4cG9ydE5hbWVzQnlWYXJpYWJsZSwgZm9ybWF0LCBmcmVlemUsIGluZGVudDogdCwgc3ltYm9scywgc25pcHBldHM6IHsgXywgY25zdCwgZ2V0T2JqZWN0LCBnZXRQcm9wZXJ0eUFjY2VzcywgbiwgcyB9IH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBtZW1iZXJWYXJpYWJsZXMgPSB0aGlzLmdldE1lbWJlclZhcmlhYmxlcygpO1xuICAgICAgICBjb25zdCBtZW1iZXJzID0gT2JqZWN0LmVudHJpZXMobWVtYmVyVmFyaWFibGVzKVxuICAgICAgICAgICAgLmZpbHRlcigoW18sIHZhcmlhYmxlXSkgPT4gdmFyaWFibGUuaW5jbHVkZWQpXG4gICAgICAgICAgICAubWFwKChbbmFtZSwgdmFyaWFibGVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWZlcmVuY2VkRWFybHkgfHwgdmFyaWFibGUuaXNSZWFzc2lnbmVkIHx8IHZhcmlhYmxlID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYGdldCAke3N0cmluZ2lmeU9iamVjdEtleUlmTmVlZGVkKG5hbWUpfSR7X30oKSR7X317JHtffXJldHVybiAke3ZhcmlhYmxlLmdldE5hbWUoZ2V0UHJvcGVydHlBY2Nlc3MpfSR7c30ke199fWBcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtuYW1lLCB2YXJpYWJsZS5nZXROYW1lKGdldFByb3BlcnR5QWNjZXNzKV07XG4gICAgICAgIH0pO1xuICAgICAgICBtZW1iZXJzLnVuc2hpZnQoW251bGwsIGBfX3Byb3RvX186JHtffW51bGxgXSk7XG4gICAgICAgIGxldCBvdXRwdXQgPSBnZXRPYmplY3QobWVtYmVycywgeyBsaW5lQnJlYWtJbmRlbnQ6IHsgYmFzZTogJycsIHQgfSB9KTtcbiAgICAgICAgaWYgKHRoaXMubWVyZ2VkTmFtZXNwYWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBhc3NpZ25tZW50QXJndW1lbnRzID0gdGhpcy5tZXJnZWROYW1lc3BhY2VzLm1hcCh2YXJpYWJsZSA9PiB2YXJpYWJsZS5nZXROYW1lKGdldFByb3BlcnR5QWNjZXNzKSk7XG4gICAgICAgICAgICBvdXRwdXQgPSBgLyojX19QVVJFX18qLyR7TUVSR0VfTkFNRVNQQUNFU19WQVJJQUJMRX0oJHtvdXRwdXR9LCR7X31bJHthc3NpZ25tZW50QXJndW1lbnRzLmpvaW4oYCwke199YCl9XSlgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlIGhlbHBlciB0byBtZXJnZSBuYW1lc3BhY2VzIHdpbGwgYWxzbyB0YWtlIGNhcmUgb2YgZnJlZXppbmcgYW5kIHRvU3RyaW5nVGFnXG4gICAgICAgICAgICBpZiAoc3ltYm9scykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IGAvKiNfX1BVUkVfXyovT2JqZWN0LmRlZmluZVByb3BlcnR5KCR7b3V0cHV0fSwke199U3ltYm9sLnRvU3RyaW5nVGFnLCR7X30ke2dldFRvU3RyaW5nVGFnVmFsdWUoZ2V0T2JqZWN0KX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcmVlemUpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBgLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoJHtvdXRwdXR9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2Vzcyk7XG4gICAgICAgIG91dHB1dCA9IGAke2Nuc3R9ICR7bmFtZX0ke199PSR7X30ke291dHB1dH07YDtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ3N5c3RlbScgJiYgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLmhhcyh0aGlzKSkge1xuICAgICAgICAgICAgb3V0cHV0ICs9IGAke259JHtnZXRTeXN0ZW1FeHBvcnRTdGF0ZW1lbnQoW3RoaXNdLCBvcHRpb25zKX07YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICByZW5kZXJGaXJzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlZEVhcmx5O1xuICAgIH1cbiAgICBzZXRNZXJnZWROYW1lc3BhY2VzKG1lcmdlZE5hbWVzcGFjZXMpIHtcbiAgICAgICAgdGhpcy5tZXJnZWROYW1lc3BhY2VzID0gbWVyZ2VkTmFtZXNwYWNlcztcbiAgICAgICAgY29uc3QgbW9kdWxlRXhlY0luZGV4ID0gdGhpcy5jb250ZXh0LmdldE1vZHVsZUV4ZWNJbmRleCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGlkZW50aWZpZXIgb2YgdGhpcy5yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNvbnRleHQgfSA9IGlkZW50aWZpZXIuc2NvcGU7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5nZXRNb2R1bGVFeGVjSW5kZXgoKSA8PSBtb2R1bGVFeGVjSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZmVyZW5jZWRFYXJseSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5OYW1lc3BhY2VWYXJpYWJsZS5wcm90b3R5cGUuaXNOYW1lc3BhY2UgPSB0cnVlO1xuXG5jbGFzcyBTeW50aGV0aWNOYW1lZEV4cG9ydFZhcmlhYmxlIGV4dGVuZHMgVmFyaWFibGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIG5hbWUsIHN5bnRoZXRpY05hbWVzcGFjZSkge1xuICAgICAgICBzdXBlcihuYW1lKTtcbiAgICAgICAgdGhpcy5iYXNlVmFyaWFibGUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLm1vZHVsZSA9IGNvbnRleHQubW9kdWxlO1xuICAgICAgICB0aGlzLnN5bnRoZXRpY05hbWVzcGFjZSA9IHN5bnRoZXRpY05hbWVzcGFjZTtcbiAgICB9XG4gICAgZ2V0QmFzZVZhcmlhYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlVmFyaWFibGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlVmFyaWFibGU7XG4gICAgICAgIGxldCBiYXNlVmFyaWFibGUgPSB0aGlzLnN5bnRoZXRpY05hbWVzcGFjZTtcbiAgICAgICAgd2hpbGUgKGJhc2VWYXJpYWJsZSBpbnN0YW5jZW9mIEV4cG9ydERlZmF1bHRWYXJpYWJsZSB8fFxuICAgICAgICAgICAgYmFzZVZhcmlhYmxlIGluc3RhbmNlb2YgU3ludGhldGljTmFtZWRFeHBvcnRWYXJpYWJsZSkge1xuICAgICAgICAgICAgaWYgKGJhc2VWYXJpYWJsZSBpbnN0YW5jZW9mIEV4cG9ydERlZmF1bHRWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsID0gYmFzZVZhcmlhYmxlLmdldE9yaWdpbmFsVmFyaWFibGUoKTtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWwgPT09IGJhc2VWYXJpYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgYmFzZVZhcmlhYmxlID0gb3JpZ2luYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmFzZVZhcmlhYmxlIGluc3RhbmNlb2YgU3ludGhldGljTmFtZWRFeHBvcnRWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgIGJhc2VWYXJpYWJsZSA9IGJhc2VWYXJpYWJsZS5zeW50aGV0aWNOYW1lc3BhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLmJhc2VWYXJpYWJsZSA9IGJhc2VWYXJpYWJsZSk7XG4gICAgfVxuICAgIGdldEJhc2VWYXJpYWJsZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bnRoZXRpY05hbWVzcGFjZS5nZXRCYXNlVmFyaWFibGVOYW1lKCk7XG4gICAgfVxuICAgIGdldE5hbWUoZ2V0UHJvcGVydHlBY2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuc3ludGhldGljTmFtZXNwYWNlLmdldE5hbWUoZ2V0UHJvcGVydHlBY2Nlc3MpfSR7Z2V0UHJvcGVydHlBY2Nlc3ModGhpcy5uYW1lKX1gO1xuICAgIH1cbiAgICBpbmNsdWRlKCkge1xuICAgICAgICBzdXBlci5pbmNsdWRlKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5pbmNsdWRlVmFyaWFibGVJbk1vZHVsZSh0aGlzLnN5bnRoZXRpY05hbWVzcGFjZSk7XG4gICAgfVxuICAgIHNldFJlbmRlck5hbWVzKGJhc2VOYW1lLCBuYW1lKSB7XG4gICAgICAgIHN1cGVyLnNldFJlbmRlck5hbWVzKGJhc2VOYW1lLCBuYW1lKTtcbiAgICB9XG59XG5cbmNsYXNzIEV4dGVybmFsQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKG1vZHVsZSwgb3B0aW9ucywgaW5wdXRCYXNlKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuaW5wdXRCYXNlID0gaW5wdXRCYXNlO1xuICAgICAgICB0aGlzLmRlZmF1bHRWYXJpYWJsZU5hbWUgPSAnJztcbiAgICAgICAgdGhpcy5uYW1lc3BhY2VWYXJpYWJsZU5hbWUgPSAnJztcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWUgPSAnJztcbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaW1wb3J0QXR0cmlidXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuaWQgPSBtb2R1bGUuaWQ7XG4gICAgICAgIHRoaXMubW9kdWxlSW5mbyA9IG1vZHVsZS5pbmZvO1xuICAgICAgICB0aGlzLnJlbm9ybWFsaXplUmVuZGVyUGF0aCA9IG1vZHVsZS5yZW5vcm1hbGl6ZVJlbmRlclBhdGg7XG4gICAgICAgIHRoaXMuc3VnZ2VzdGVkVmFyaWFibGVOYW1lID0gbW9kdWxlLnN1Z2dlc3RlZFZhcmlhYmxlTmFtZTtcbiAgICB9XG4gICAgZ2V0RmlsZU5hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbGVOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHBhdGhzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHJldHVybiAodGhpcy5maWxlTmFtZSA9XG4gICAgICAgICAgICAodHlwZW9mIHBhdGhzID09PSAnZnVuY3Rpb24nID8gcGF0aHModGhpcy5pZCkgOiBwYXRoc1t0aGlzLmlkXSkgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5yZW5vcm1hbGl6ZVJlbmRlclBhdGggPyBub3JtYWxpemUocmVsYXRpdmUodGhpcy5pbnB1dEJhc2UsIHRoaXMuaWQpKSA6IHRoaXMuaWQpKTtcbiAgICB9XG4gICAgZ2V0SW1wb3J0QXR0cmlidXRlcyhzbmlwcGV0cykge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW1wb3J0QXR0cmlidXRlcyB8fD0gZm9ybWF0QXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuZm9ybWF0ID09PSAnZXMnICYmXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZXh0ZXJuYWxJbXBvcnRBdHRyaWJ1dGVzICYmXG4gICAgICAgICAgICB0aGlzLm1vZHVsZUluZm8uYXR0cmlidXRlcywgc25pcHBldHMpKTtcbiAgICB9XG4gICAgZ2V0SW1wb3J0UGF0aChpbXBvcnRlcikge1xuICAgICAgICByZXR1cm4gZXNjYXBlSWQodGhpcy5yZW5vcm1hbGl6ZVJlbmRlclBhdGhcbiAgICAgICAgICAgID8gZ2V0SW1wb3J0UGF0aChpbXBvcnRlciwgdGhpcy5nZXRGaWxlTmFtZSgpLCB0aGlzLm9wdGlvbnMuZm9ybWF0ID09PSAnYW1kJywgZmFsc2UpXG4gICAgICAgICAgICA6IHRoaXMuZ2V0RmlsZU5hbWUoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZm9ybWF0QXR0cmlidXRlcyhhdHRyaWJ1dGVzLCB7IGdldE9iamVjdCB9KSB7XG4gICAgaWYgKCFhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBhc3NlcnRpb25FbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykubWFwKChba2V5LCB2YWx1ZV0pID0+IFtrZXksIGAnJHt2YWx1ZX0nYF0pO1xuICAgIGlmIChhc3NlcnRpb25FbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGdldE9iamVjdChhc3NlcnRpb25FbnRyaWVzLCB7IGxpbmVCcmVha0luZGVudDogbnVsbCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUpzRXh0ZW5zaW9uKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZS5lbmRzV2l0aCgnLmpzJykgPyBuYW1lLnNsaWNlKDAsIC0zKSA6IG5hbWU7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBsZXRlQW1kSWQob3B0aW9ucywgY2h1bmtJZCkge1xuICAgIGlmIChvcHRpb25zLmF1dG9JZCkge1xuICAgICAgICByZXR1cm4gYCR7b3B0aW9ucy5iYXNlUGF0aCA/IG9wdGlvbnMuYmFzZVBhdGggKyAnLycgOiAnJ30ke3JlbW92ZUpzRXh0ZW5zaW9uKGNodW5rSWQpfWA7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLmlkID8/ICcnO1xufVxuXG5mdW5jdGlvbiBnZXRFeHBvcnRCbG9jayQxKGV4cG9ydHMsIGRlcGVuZGVuY2llcywgbmFtZWRFeHBvcnRzTW9kZSwgaW50ZXJvcCwgc25pcHBldHMsIHQsIGV4dGVybmFsTGl2ZUJpbmRpbmdzLCByZWV4cG9ydFByb3RvRnJvbUV4dGVybmFsLCBtZWNoYW5pc20gPSAncmV0dXJuICcpIHtcbiAgICBjb25zdCB7IF8sIGdldERpcmVjdFJldHVybkZ1bmN0aW9uLCBnZXRGdW5jdGlvbkludHJvLCBnZXRQcm9wZXJ0eUFjY2VzcywgbiwgcyB9ID0gc25pcHBldHM7XG4gICAgaWYgKCFuYW1lZEV4cG9ydHNNb2RlKSB7XG4gICAgICAgIHJldHVybiBgJHtufSR7bn0ke21lY2hhbmlzbX0ke2dldFNpbmdsZURlZmF1bHRFeHBvcnQoZXhwb3J0cywgZGVwZW5kZW5jaWVzLCBpbnRlcm9wLCBleHRlcm5hbExpdmVCaW5kaW5ncywgZ2V0UHJvcGVydHlBY2Nlc3MpfTtgO1xuICAgIH1cbiAgICBsZXQgZXhwb3J0QmxvY2sgPSAnJztcbiAgICBpZiAobmFtZWRFeHBvcnRzTW9kZSkge1xuICAgICAgICBmb3IgKGNvbnN0IHsgZGVmYXVsdFZhcmlhYmxlTmFtZSwgaW1wb3J0UGF0aCwgaXNDaHVuaywgbmFtZSwgbmFtZWRFeHBvcnRzTW9kZTogZGVwTmFtZWRFeHBvcnRzTW9kZSwgbmFtZXNwYWNlVmFyaWFibGVOYW1lLCByZWV4cG9ydHMgfSBvZiBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGlmICghcmVleHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNwZWNpZmllciBvZiByZWV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BlY2lmaWVyLnJlZXhwb3J0ZWQgIT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbXBvcnROYW1lID0gZ2V0UmVleHBvcnRlZEltcG9ydE5hbWUobmFtZSwgc3BlY2lmaWVyLmltcG9ydGVkLCBkZXBOYW1lZEV4cG9ydHNNb2RlLCBpc0NodW5rLCBkZWZhdWx0VmFyaWFibGVOYW1lLCBuYW1lc3BhY2VWYXJpYWJsZU5hbWUsIGludGVyb3AsIGltcG9ydFBhdGgsIGV4dGVybmFsTGl2ZUJpbmRpbmdzLCBnZXRQcm9wZXJ0eUFjY2Vzcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBvcnRCbG9jaylcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydEJsb2NrICs9IG47XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVjaWZpZXIuaW1wb3J0ZWQgIT09ICcqJyAmJiBzcGVjaWZpZXIubmVlZHNMaXZlQmluZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGdldERpcmVjdFJldHVybkZ1bmN0aW9uKFtdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25SZXR1cm46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUJyZWFrSW5kZW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0QmxvY2sgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsJHtffSR7SlNPTi5zdHJpbmdpZnkoc3BlY2lmaWVyLnJlZXhwb3J0ZWQpfSwke199eyR7bn1gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7dH1lbnVtZXJhYmxlOiR7X310cnVlLCR7bn1gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7dH1nZXQ6JHtffSR7bGVmdH0ke2ltcG9ydE5hbWV9JHtyaWdodH0ke259fSk7YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzcGVjaWZpZXIucmVleHBvcnRlZCA9PT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydEJsb2NrICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCR7X31cIl9fcHJvdG9fX1wiLCR7X317JHtufWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHt0fWVudW1lcmFibGU6JHtffXRydWUsJHtufWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHt0fXZhbHVlOiR7X30ke2ltcG9ydE5hbWV9JHtufX0pO2A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRCbG9jayArPSBgZXhwb3J0cyR7Z2V0UHJvcGVydHlBY2Nlc3Moc3BlY2lmaWVyLnJlZXhwb3J0ZWQpfSR7X309JHtffSR7aW1wb3J0TmFtZX07YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHsgZXhwb3J0ZWQsIGxvY2FsIH0gb2YgZXhwb3J0cykge1xuICAgICAgICBjb25zdCBsaHMgPSBgZXhwb3J0cyR7Z2V0UHJvcGVydHlBY2Nlc3MoZXhwb3J0ZWQpfWA7XG4gICAgICAgIGNvbnN0IHJocyA9IGxvY2FsO1xuICAgICAgICBpZiAobGhzICE9PSByaHMpIHtcbiAgICAgICAgICAgIGlmIChleHBvcnRCbG9jaylcbiAgICAgICAgICAgICAgICBleHBvcnRCbG9jayArPSBuO1xuICAgICAgICAgICAgZXhwb3J0QmxvY2sgKz1cbiAgICAgICAgICAgICAgICBleHBvcnRlZCA9PT0gJ19fcHJvdG9fXydcbiAgICAgICAgICAgICAgICAgICAgPyBgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsJHtffVwiX19wcm90b19fXCIsJHtffXske259YCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHt0fWVudW1lcmFibGU6JHtffXRydWUsJHtufWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCR7dH12YWx1ZToke199JHtyaHN9JHtufX0pO2BcbiAgICAgICAgICAgICAgICAgICAgOiBgJHtsaHN9JHtffT0ke199JHtyaHN9O2A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hbWVkRXhwb3J0c01vZGUpIHtcbiAgICAgICAgZm9yIChjb25zdCB7IG5hbWUsIHJlZXhwb3J0cyB9IG9mIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgaWYgKCFyZWV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3BlY2lmaWVyIG9mIHJlZXhwb3J0cykge1xuICAgICAgICAgICAgICAgIGlmIChzcGVjaWZpZXIucmVleHBvcnRlZCA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBvcnRCbG9jaylcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydEJsb2NrICs9IG47XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3BlY2lmaWVyLm5lZWRzTGl2ZUJpbmRpbmcgJiYgcmVleHBvcnRQcm90b0Zyb21FeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvdG9TdHJpbmcgPSBcIidfX3Byb3RvX18nXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRCbG9jayArPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoJHtuYW1lfSwke199JHtwcm90b1N0cmluZ30pJHtffSYmJHtufWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHt0fSFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywke199JHtwcm90b1N0cmluZ30pJHtffSYmJHtufWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHt0fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCR7X30ke3Byb3RvU3RyaW5nfSwke199eyR7bn1gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7dH0ke3R9ZW51bWVyYWJsZToke199dHJ1ZSwke259YCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke3R9JHt0fXZhbHVlOiR7X30ke25hbWV9WyR7cHJvdG9TdHJpbmd9XSR7bn1gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7dH19KTske259JHtufWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29weVByb3BlcnR5SWZOZWNlc3NhcnkgPSBgeyR7bn0ke3R9aWYke199KGske199IT09JHtffSdkZWZhdWx0JyR7X30mJiR7X30hT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsJHtffWspKSR7X30ke2dldERlZmluZVByb3BlcnR5KG5hbWUsIHNwZWNpZmllci5uZWVkc0xpdmVCaW5kaW5nLCB0LCBzbmlwcGV0cyl9JHtzfSR7bn19YDtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QmxvY2sgKz0gYE9iamVjdC5rZXlzKCR7bmFtZX0pLmZvckVhY2goJHtnZXRGdW5jdGlvbkludHJvKFsnayddLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FzeW5jOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSl9JHtjb3B5UHJvcGVydHlJZk5lY2Vzc2FyeX0pO2A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChleHBvcnRCbG9jaykge1xuICAgICAgICByZXR1cm4gYCR7bn0ke259JHtleHBvcnRCbG9ja31gO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5mdW5jdGlvbiBnZXRTaW5nbGVEZWZhdWx0RXhwb3J0KGV4cG9ydHMsIGRlcGVuZGVuY2llcywgaW50ZXJvcCwgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGdldFByb3BlcnR5QWNjZXNzKSB7XG4gICAgaWYgKGV4cG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0c1swXS5sb2NhbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgeyBkZWZhdWx0VmFyaWFibGVOYW1lLCBpbXBvcnRQYXRoLCBpc0NodW5rLCBuYW1lLCBuYW1lZEV4cG9ydHNNb2RlOiBkZXBOYW1lZEV4cG9ydHNNb2RlLCBuYW1lc3BhY2VWYXJpYWJsZU5hbWUsIHJlZXhwb3J0cyB9IG9mIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgaWYgKHJlZXhwb3J0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRSZWV4cG9ydGVkSW1wb3J0TmFtZShuYW1lLCByZWV4cG9ydHNbMF0uaW1wb3J0ZWQsIGRlcE5hbWVkRXhwb3J0c01vZGUsIGlzQ2h1bmssIGRlZmF1bHRWYXJpYWJsZU5hbWUsIG5hbWVzcGFjZVZhcmlhYmxlTmFtZSwgaW50ZXJvcCwgaW1wb3J0UGF0aCwgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGdldFByb3BlcnR5QWNjZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFJlZXhwb3J0ZWRJbXBvcnROYW1lKG1vZHVsZVZhcmlhYmxlTmFtZSwgaW1wb3J0ZWQsIGRlcE5hbWVkRXhwb3J0c01vZGUsIGlzQ2h1bmssIGRlZmF1bHRWYXJpYWJsZU5hbWUsIG5hbWVzcGFjZVZhcmlhYmxlTmFtZSwgaW50ZXJvcCwgbW9kdWxlSWQsIGV4dGVybmFsTGl2ZUJpbmRpbmdzLCBnZXRQcm9wZXJ0eUFjY2Vzcykge1xuICAgIGlmIChpbXBvcnRlZCA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIGlmICghaXNDaHVuaykge1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlSW50ZXJvcCA9IGludGVyb3AobW9kdWxlSWQpO1xuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gZGVmYXVsdEludGVyb3BIZWxwZXJzQnlJbnRlcm9wVHlwZVttb2R1bGVJbnRlcm9wXVxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhcmlhYmxlTmFtZVxuICAgICAgICAgICAgICAgIDogbW9kdWxlVmFyaWFibGVOYW1lO1xuICAgICAgICAgICAgcmV0dXJuIGlzRGVmYXVsdEFQcm9wZXJ0eShtb2R1bGVJbnRlcm9wLCBleHRlcm5hbExpdmVCaW5kaW5ncylcbiAgICAgICAgICAgICAgICA/IGAke3ZhcmlhYmxlTmFtZX0ke2dldFByb3BlcnR5QWNjZXNzKCdkZWZhdWx0Jyl9YFxuICAgICAgICAgICAgICAgIDogdmFyaWFibGVOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXBOYW1lZEV4cG9ydHNNb2RlXG4gICAgICAgICAgICA/IGAke21vZHVsZVZhcmlhYmxlTmFtZX0ke2dldFByb3BlcnR5QWNjZXNzKCdkZWZhdWx0Jyl9YFxuICAgICAgICAgICAgOiBtb2R1bGVWYXJpYWJsZU5hbWU7XG4gICAgfVxuICAgIGlmIChpbXBvcnRlZCA9PT0gJyonKSB7XG4gICAgICAgIHJldHVybiAoaXNDaHVuayA/ICFkZXBOYW1lZEV4cG9ydHNNb2RlIDogbmFtZXNwYWNlSW50ZXJvcEhlbHBlcnNCeUludGVyb3BUeXBlW2ludGVyb3AobW9kdWxlSWQpXSlcbiAgICAgICAgICAgID8gbmFtZXNwYWNlVmFyaWFibGVOYW1lXG4gICAgICAgICAgICA6IG1vZHVsZVZhcmlhYmxlTmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIGAke21vZHVsZVZhcmlhYmxlTmFtZX0ke2dldFByb3BlcnR5QWNjZXNzKGltcG9ydGVkKX1gO1xufVxuZnVuY3Rpb24gZ2V0RXNNb2R1bGVWYWx1ZShnZXRPYmplY3QpIHtcbiAgICByZXR1cm4gZ2V0T2JqZWN0KFtbJ3ZhbHVlJywgJ3RydWUnXV0sIHtcbiAgICAgICAgbGluZUJyZWFrSW5kZW50OiBudWxsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXROYW1lc3BhY2VNYXJrZXJzKGhhc05hbWVkRXhwb3J0cywgYWRkRXNNb2R1bGUsIGFkZE5hbWVzcGFjZVRvU3RyaW5nVGFnLCB7IF8sIGdldE9iamVjdCB9KSB7XG4gICAgaWYgKGhhc05hbWVkRXhwb3J0cykge1xuICAgICAgICBpZiAoYWRkRXNNb2R1bGUpIHtcbiAgICAgICAgICAgIGlmIChhZGROYW1lc3BhY2VUb1N0cmluZ1RhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZXhwb3J0cywke199JHtnZXRPYmplY3QoW1xuICAgICAgICAgICAgICAgICAgICBbJ19fZXNNb2R1bGUnLCBnZXRFc01vZHVsZVZhbHVlKGdldE9iamVjdCldLFxuICAgICAgICAgICAgICAgICAgICBbbnVsbCwgYFtTeW1ib2wudG9TdHJpbmdUYWddOiR7X30ke2dldFRvU3RyaW5nVGFnVmFsdWUoZ2V0T2JqZWN0KX1gXVxuICAgICAgICAgICAgICAgIF0sIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZUJyZWFrSW5kZW50OiBudWxsXG4gICAgICAgICAgICAgICAgfSl9KTtgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywke199J19fZXNNb2R1bGUnLCR7X30ke2dldEVzTW9kdWxlVmFsdWUoZ2V0T2JqZWN0KX0pO2A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZE5hbWVzcGFjZVRvU3RyaW5nVGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCR7X31TeW1ib2wudG9TdHJpbmdUYWcsJHtffSR7Z2V0VG9TdHJpbmdUYWdWYWx1ZShnZXRPYmplY3QpfSk7YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5jb25zdCBnZXREZWZpbmVQcm9wZXJ0eSA9IChuYW1lLCBuZWVkc0xpdmVCaW5kaW5nLCB0LCB7IF8sIGdldERpcmVjdFJldHVybkZ1bmN0aW9uLCBuIH0pID0+IHtcbiAgICBpZiAobmVlZHNMaXZlQmluZGluZykge1xuICAgICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb24oW10sIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uUmV0dXJuOiB0cnVlLFxuICAgICAgICAgICAgbGluZUJyZWFrSW5kZW50OiBudWxsLFxuICAgICAgICAgICAgbmFtZTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsJHtffWssJHtffXske259YCArXG4gICAgICAgICAgICBgJHt0fSR7dH1lbnVtZXJhYmxlOiR7X310cnVlLCR7bn1gICtcbiAgICAgICAgICAgIGAke3R9JHt0fWdldDoke199JHtsZWZ0fSR7bmFtZX1ba10ke3JpZ2h0fSR7bn0ke3R9fSlgKTtcbiAgICB9XG4gICAgcmV0dXJuIGBleHBvcnRzW2tdJHtffT0ke199JHtuYW1lfVtrXWA7XG59O1xuXG5mdW5jdGlvbiBnZXRJbnRlcm9wQmxvY2soZGVwZW5kZW5jaWVzLCBpbnRlcm9wLCBleHRlcm5hbExpdmVCaW5kaW5ncywgZnJlZXplLCBzeW1ib2xzLCBhY2Nlc3NlZEdsb2JhbHMsIGluZGVudCwgc25pcHBldHMpIHtcbiAgICBjb25zdCB7IF8sIGNuc3QsIG4gfSA9IHNuaXBwZXRzO1xuICAgIGNvbnN0IG5lZWRlZEludGVyb3BIZWxwZXJzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGludGVyb3BTdGF0ZW1lbnRzID0gW107XG4gICAgY29uc3QgYWRkSW50ZXJvcFN0YXRlbWVudCA9IChoZWxwZXJWYXJpYWJsZU5hbWUsIGhlbHBlciwgZGVwZW5kZW5jeVZhcmlhYmxlTmFtZSkgPT4ge1xuICAgICAgICBuZWVkZWRJbnRlcm9wSGVscGVycy5hZGQoaGVscGVyKTtcbiAgICAgICAgaW50ZXJvcFN0YXRlbWVudHMucHVzaChgJHtjbnN0fSAke2hlbHBlclZhcmlhYmxlTmFtZX0ke199PSR7X30vKiNfX1BVUkVfXyovJHtoZWxwZXJ9KCR7ZGVwZW5kZW5jeVZhcmlhYmxlTmFtZX0pO2ApO1xuICAgIH07XG4gICAgZm9yIChjb25zdCB7IGRlZmF1bHRWYXJpYWJsZU5hbWUsIGltcG9ydHMsIGltcG9ydFBhdGgsIGlzQ2h1bmssIG5hbWUsIG5hbWVkRXhwb3J0c01vZGUsIG5hbWVzcGFjZVZhcmlhYmxlTmFtZSwgcmVleHBvcnRzIH0gb2YgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGlmIChpc0NodW5rKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgaW1wb3J0ZWQsIHJlZXhwb3J0ZWQgfSBvZiBbXG4gICAgICAgICAgICAgICAgLi4uKGltcG9ydHMgfHwgW10pLFxuICAgICAgICAgICAgICAgIC4uLihyZWV4cG9ydHMgfHwgW10pXG4gICAgICAgICAgICBdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltcG9ydGVkID09PSAnKicgJiYgcmVleHBvcnRlZCAhPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmFtZWRFeHBvcnRzTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSW50ZXJvcFN0YXRlbWVudChuYW1lc3BhY2VWYXJpYWJsZU5hbWUsIElOVEVST1BfTkFNRVNQQUNFX0RFRkFVTFRfT05MWV9WQVJJQUJMRSwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlSW50ZXJvcCA9IGludGVyb3AoaW1wb3J0UGF0aCk7XG4gICAgICAgICAgICBsZXQgaGFzRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGhhc05hbWVzcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IGltcG9ydGVkLCByZWV4cG9ydGVkIH0gb2YgW1xuICAgICAgICAgICAgICAgIC4uLihpbXBvcnRzIHx8IFtdKSxcbiAgICAgICAgICAgICAgICAuLi4ocmVleHBvcnRzIHx8IFtdKVxuICAgICAgICAgICAgXSkge1xuICAgICAgICAgICAgICAgIGxldCBoZWxwZXI7XG4gICAgICAgICAgICAgICAgbGV0IHZhcmlhYmxlTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoaW1wb3J0ZWQgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0RlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRWYXJpYWJsZU5hbWUgIT09IG5hbWVzcGFjZVZhcmlhYmxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlTmFtZSA9IGRlZmF1bHRWYXJpYWJsZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyID0gZGVmYXVsdEludGVyb3BIZWxwZXJzQnlJbnRlcm9wVHlwZVttb2R1bGVJbnRlcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbXBvcnRlZCA9PT0gJyonICYmIHJlZXhwb3J0ZWQgIT09ICcqJyAmJiAhaGFzTmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc05hbWVzcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlciA9IG5hbWVzcGFjZUludGVyb3BIZWxwZXJzQnlJbnRlcm9wVHlwZVttb2R1bGVJbnRlcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVOYW1lID0gbmFtZXNwYWNlVmFyaWFibGVOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGVscGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEludGVyb3BTdGF0ZW1lbnQodmFyaWFibGVOYW1lLCBoZWxwZXIsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYCR7Z2V0SGVscGVyc0Jsb2NrKG5lZWRlZEludGVyb3BIZWxwZXJzLCBhY2Nlc3NlZEdsb2JhbHMsIGluZGVudCwgc25pcHBldHMsIGV4dGVybmFsTGl2ZUJpbmRpbmdzLCBmcmVlemUsIHN5bWJvbHMpfSR7aW50ZXJvcFN0YXRlbWVudHMubGVuZ3RoID4gMCA/IGAke2ludGVyb3BTdGF0ZW1lbnRzLmpvaW4obil9JHtufSR7bn1gIDogJyd9YDtcbn1cblxuZnVuY3Rpb24gYWRkSnNFeHRlbnNpb24obmFtZSkge1xuICAgIHJldHVybiBuYW1lLmVuZHNXaXRoKCcuanMnKSA/IG5hbWUgOiBuYW1lICsgJy5qcyc7XG59XG5cbi8vIEFNRCByZXNvbHV0aW9uIHdpbGwgb25seSByZXNwZWN0IHRoZSBBTUQgYmFzZVVybCBpZiB0aGUgLmpzIGV4dGVuc2lvbiBpcyBvbWl0dGVkLlxuLy8gVGhlIGFzc3VtcHRpb24gaXMgdGhhdCB0aGlzIG1ha2VzIHNlbnNlIGZvciBhbGwgcmVsYXRpdmUgaWRzOlxuLy8gaHR0cHM6Ly9yZXF1aXJlanMub3JnL2RvY3MvYXBpLmh0bWwjanNmaWxlc1xuZnVuY3Rpb24gdXBkYXRlRXh0ZW5zaW9uRm9yUmVsYXRpdmVBbWRJZChpZCwgZm9yY2VKc0V4dGVuc2lvbkZvckltcG9ydHMpIHtcbiAgICBpZiAoaWRbMF0gIT09ICcuJykge1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIHJldHVybiBmb3JjZUpzRXh0ZW5zaW9uRm9ySW1wb3J0cyA/IGFkZEpzRXh0ZW5zaW9uKGlkKSA6IHJlbW92ZUpzRXh0ZW5zaW9uKGlkKTtcbn1cblxuY29uc3QgYnVpbHRpbk1vZHVsZXMgPSBbXG5cdFwiYXNzZXJ0XCIsXG5cdFwiYXNzZXJ0L3N0cmljdFwiLFxuXHRcImFzeW5jX2hvb2tzXCIsXG5cdFwiYnVmZmVyXCIsXG5cdFwiY2hpbGRfcHJvY2Vzc1wiLFxuXHRcImNsdXN0ZXJcIixcblx0XCJjb25zb2xlXCIsXG5cdFwiY29uc3RhbnRzXCIsXG5cdFwiY3J5cHRvXCIsXG5cdFwiZGdyYW1cIixcblx0XCJkaWFnbm9zdGljc19jaGFubmVsXCIsXG5cdFwiZG5zXCIsXG5cdFwiZG5zL3Byb21pc2VzXCIsXG5cdFwiZG9tYWluXCIsXG5cdFwiZXZlbnRzXCIsXG5cdFwiZnNcIixcblx0XCJmcy9wcm9taXNlc1wiLFxuXHRcImh0dHBcIixcblx0XCJodHRwMlwiLFxuXHRcImh0dHBzXCIsXG5cdFwiaW5zcGVjdG9yXCIsXG5cdFwiaW5zcGVjdG9yL3Byb21pc2VzXCIsXG5cdFwibW9kdWxlXCIsXG5cdFwibmV0XCIsXG5cdFwib3NcIixcblx0XCJwYXRoXCIsXG5cdFwicGF0aC9wb3NpeFwiLFxuXHRcInBhdGgvd2luMzJcIixcblx0XCJwZXJmX2hvb2tzXCIsXG5cdFwicHJvY2Vzc1wiLFxuXHRcInB1bnljb2RlXCIsXG5cdFwicXVlcnlzdHJpbmdcIixcblx0XCJyZWFkbGluZVwiLFxuXHRcInJlYWRsaW5lL3Byb21pc2VzXCIsXG5cdFwicmVwbFwiLFxuXHRcInN0cmVhbVwiLFxuXHRcInN0cmVhbS9jb25zdW1lcnNcIixcblx0XCJzdHJlYW0vcHJvbWlzZXNcIixcblx0XCJzdHJlYW0vd2ViXCIsXG5cdFwic3RyaW5nX2RlY29kZXJcIixcblx0XCJ0aW1lcnNcIixcblx0XCJ0aW1lcnMvcHJvbWlzZXNcIixcblx0XCJ0bHNcIixcblx0XCJ0cmFjZV9ldmVudHNcIixcblx0XCJ0dHlcIixcblx0XCJ1cmxcIixcblx0XCJ1dGlsXCIsXG5cdFwidXRpbC90eXBlc1wiLFxuXHRcInY4XCIsXG5cdFwidm1cIixcblx0XCJ3YXNpXCIsXG5cdFwid29ya2VyX3RocmVhZHNcIixcblx0XCJ6bGliXCJcbl07XG5cbmNvbnN0IG5vZGVCdWlsdGlucyA9IG5ldyBTZXQoYnVpbHRpbk1vZHVsZXMpO1xuZnVuY3Rpb24gd2Fybk9uQnVpbHRpbnMobG9nLCBkZXBlbmRlbmNpZXMpIHtcbiAgICBjb25zdCBleHRlcm5hbEJ1aWx0aW5zID0gZGVwZW5kZW5jaWVzXG4gICAgICAgIC5tYXAoKHsgaW1wb3J0UGF0aCB9KSA9PiBpbXBvcnRQYXRoKVxuICAgICAgICAuZmlsdGVyKGltcG9ydFBhdGggPT4gbm9kZUJ1aWx0aW5zLmhhcyhpbXBvcnRQYXRoKSB8fCBpbXBvcnRQYXRoLnN0YXJ0c1dpdGgoJ25vZGU6JykpO1xuICAgIGlmIChleHRlcm5hbEJ1aWx0aW5zLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxvZyhMT0dMRVZFTF9XQVJOLCBsb2dNaXNzaW5nTm9kZUJ1aWx0aW5zKGV4dGVybmFsQnVpbHRpbnMpKTtcbn1cblxuZnVuY3Rpb24gYW1kKG1hZ2ljU3RyaW5nLCB7IGFjY2Vzc2VkR2xvYmFscywgZGVwZW5kZW5jaWVzLCBleHBvcnRzLCBoYXNEZWZhdWx0RXhwb3J0LCBoYXNFeHBvcnRzLCBpZCwgaW5kZW50OiB0LCBpbnRybywgaXNFbnRyeUZhY2FkZSwgaXNNb2R1bGVGYWNhZGUsIG5hbWVkRXhwb3J0c01vZGUsIGxvZywgb3V0cm8sIHNuaXBwZXRzIH0sIHsgYW1kLCBlc01vZHVsZSwgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGZyZWV6ZSwgZ2VuZXJhdGVkQ29kZTogeyBzeW1ib2xzIH0sIGludGVyb3AsIHJlZXhwb3J0UHJvdG9Gcm9tRXh0ZXJuYWwsIHN0cmljdCB9KSB7XG4gICAgd2Fybk9uQnVpbHRpbnMobG9nLCBkZXBlbmRlbmNpZXMpO1xuICAgIGNvbnN0IGRlcHMgPSBkZXBlbmRlbmNpZXMubWFwKG0gPT4gYCcke3VwZGF0ZUV4dGVuc2lvbkZvclJlbGF0aXZlQW1kSWQobS5pbXBvcnRQYXRoLCBhbWQuZm9yY2VKc0V4dGVuc2lvbkZvckltcG9ydHMpfSdgKTtcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gZGVwZW5kZW5jaWVzLm1hcChtID0+IG0ubmFtZSk7XG4gICAgY29uc3QgeyBuLCBnZXROb25BcnJvd0Z1bmN0aW9uSW50cm8sIF8gfSA9IHNuaXBwZXRzO1xuICAgIGlmIChuYW1lZEV4cG9ydHNNb2RlICYmIGhhc0V4cG9ydHMpIHtcbiAgICAgICAgcGFyYW1ldGVycy51bnNoaWZ0KGBleHBvcnRzYCk7XG4gICAgICAgIGRlcHMudW5zaGlmdChgJ2V4cG9ydHMnYCk7XG4gICAgfVxuICAgIGlmIChhY2Nlc3NlZEdsb2JhbHMuaGFzKCdyZXF1aXJlJykpIHtcbiAgICAgICAgcGFyYW1ldGVycy51bnNoaWZ0KCdyZXF1aXJlJyk7XG4gICAgICAgIGRlcHMudW5zaGlmdChgJ3JlcXVpcmUnYCk7XG4gICAgfVxuICAgIGlmIChhY2Nlc3NlZEdsb2JhbHMuaGFzKCdtb2R1bGUnKSkge1xuICAgICAgICBwYXJhbWV0ZXJzLnVuc2hpZnQoJ21vZHVsZScpO1xuICAgICAgICBkZXBzLnVuc2hpZnQoYCdtb2R1bGUnYCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbXBsZXRlQW1kSWQgPSBnZXRDb21wbGV0ZUFtZElkKGFtZCwgaWQpO1xuICAgIGNvbnN0IGRlZmluZVBhcmFtZXRlcnMgPSAoY29tcGxldGVBbWRJZCA/IGAnJHtjb21wbGV0ZUFtZElkfScsJHtffWAgOiBgYCkgK1xuICAgICAgICAoZGVwcy5sZW5ndGggPiAwID8gYFske2RlcHMuam9pbihgLCR7X31gKX1dLCR7X31gIDogYGApO1xuICAgIGNvbnN0IHVzZVN0cmljdCA9IHN0cmljdCA/IGAke199J3VzZSBzdHJpY3QnO2AgOiAnJztcbiAgICBtYWdpY1N0cmluZy5wcmVwZW5kKGAke2ludHJvfSR7Z2V0SW50ZXJvcEJsb2NrKGRlcGVuZGVuY2llcywgaW50ZXJvcCwgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGZyZWV6ZSwgc3ltYm9scywgYWNjZXNzZWRHbG9iYWxzLCB0LCBzbmlwcGV0cyl9YCk7XG4gICAgY29uc3QgZXhwb3J0QmxvY2sgPSBnZXRFeHBvcnRCbG9jayQxKGV4cG9ydHMsIGRlcGVuZGVuY2llcywgbmFtZWRFeHBvcnRzTW9kZSwgaW50ZXJvcCwgc25pcHBldHMsIHQsIGV4dGVybmFsTGl2ZUJpbmRpbmdzLCByZWV4cG9ydFByb3RvRnJvbUV4dGVybmFsKTtcbiAgICBsZXQgbmFtZXNwYWNlTWFya2VycyA9IGdldE5hbWVzcGFjZU1hcmtlcnMobmFtZWRFeHBvcnRzTW9kZSAmJiBoYXNFeHBvcnRzLCBpc0VudHJ5RmFjYWRlICYmIChlc01vZHVsZSA9PT0gdHJ1ZSB8fCAoZXNNb2R1bGUgPT09ICdpZi1kZWZhdWx0LXByb3AnICYmIGhhc0RlZmF1bHRFeHBvcnQpKSwgaXNNb2R1bGVGYWNhZGUgJiYgc3ltYm9scywgc25pcHBldHMpO1xuICAgIGlmIChuYW1lc3BhY2VNYXJrZXJzKSB7XG4gICAgICAgIG5hbWVzcGFjZU1hcmtlcnMgPSBuICsgbiArIG5hbWVzcGFjZU1hcmtlcnM7XG4gICAgfVxuICAgIG1hZ2ljU3RyaW5nXG4gICAgICAgIC5hcHBlbmQoYCR7ZXhwb3J0QmxvY2t9JHtuYW1lc3BhY2VNYXJrZXJzfSR7b3V0cm99YClcbiAgICAgICAgLmluZGVudCh0KVxuICAgICAgICAvLyBmYWN0b3J5IGZ1bmN0aW9uIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHBhcmVudGhlc2VzIHRvIGF2b2lkIGxhenkgcGFyc2luZyxcbiAgICAgICAgLy8gY2YuIGh0dHBzOi8vdjguZGV2L2Jsb2cvcHJlcGFyc2VyI3BpZmVcbiAgICAgICAgLnByZXBlbmQoYCR7YW1kLmRlZmluZX0oJHtkZWZpbmVQYXJhbWV0ZXJzfSgke2dldE5vbkFycm93RnVuY3Rpb25JbnRybyhwYXJhbWV0ZXJzLCB7XG4gICAgICAgIGlzQXN5bmM6IGZhbHNlLFxuICAgICAgICBuYW1lOiBudWxsXG4gICAgfSl9eyR7dXNlU3RyaWN0fSR7bn0ke259YClcbiAgICAgICAgLmFwcGVuZChgJHtufSR7bn19KSk7YCk7XG59XG5cbmZ1bmN0aW9uIGNqcyhtYWdpY1N0cmluZywgeyBhY2Nlc3NlZEdsb2JhbHMsIGRlcGVuZGVuY2llcywgZXhwb3J0cywgaGFzRGVmYXVsdEV4cG9ydCwgaGFzRXhwb3J0cywgaW5kZW50OiB0LCBpbnRybywgaXNFbnRyeUZhY2FkZSwgaXNNb2R1bGVGYWNhZGUsIG5hbWVkRXhwb3J0c01vZGUsIG91dHJvLCBzbmlwcGV0cyB9LCB7IGNvbXBhY3QsIGVzTW9kdWxlLCBleHRlcm5hbExpdmVCaW5kaW5ncywgZnJlZXplLCBpbnRlcm9wLCBnZW5lcmF0ZWRDb2RlOiB7IHN5bWJvbHMgfSwgcmVleHBvcnRQcm90b0Zyb21FeHRlcm5hbCwgc3RyaWN0IH0pIHtcbiAgICBjb25zdCB7IF8sIG4gfSA9IHNuaXBwZXRzO1xuICAgIGNvbnN0IHVzZVN0cmljdCA9IHN0cmljdCA/IGAndXNlIHN0cmljdCc7JHtufSR7bn1gIDogJyc7XG4gICAgbGV0IG5hbWVzcGFjZU1hcmtlcnMgPSBnZXROYW1lc3BhY2VNYXJrZXJzKG5hbWVkRXhwb3J0c01vZGUgJiYgaGFzRXhwb3J0cywgaXNFbnRyeUZhY2FkZSAmJiAoZXNNb2R1bGUgPT09IHRydWUgfHwgKGVzTW9kdWxlID09PSAnaWYtZGVmYXVsdC1wcm9wJyAmJiBoYXNEZWZhdWx0RXhwb3J0KSksIGlzTW9kdWxlRmFjYWRlICYmIHN5bWJvbHMsIHNuaXBwZXRzKTtcbiAgICBpZiAobmFtZXNwYWNlTWFya2Vycykge1xuICAgICAgICBuYW1lc3BhY2VNYXJrZXJzICs9IG4gKyBuO1xuICAgIH1cbiAgICBjb25zdCBpbXBvcnRCbG9jayA9IGdldEltcG9ydEJsb2NrJDEoZGVwZW5kZW5jaWVzLCBzbmlwcGV0cywgY29tcGFjdCk7XG4gICAgY29uc3QgaW50ZXJvcEJsb2NrID0gZ2V0SW50ZXJvcEJsb2NrKGRlcGVuZGVuY2llcywgaW50ZXJvcCwgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGZyZWV6ZSwgc3ltYm9scywgYWNjZXNzZWRHbG9iYWxzLCB0LCBzbmlwcGV0cyk7XG4gICAgbWFnaWNTdHJpbmcucHJlcGVuZChgJHt1c2VTdHJpY3R9JHtpbnRyb30ke25hbWVzcGFjZU1hcmtlcnN9JHtpbXBvcnRCbG9ja30ke2ludGVyb3BCbG9ja31gKTtcbiAgICBjb25zdCBleHBvcnRCbG9jayA9IGdldEV4cG9ydEJsb2NrJDEoZXhwb3J0cywgZGVwZW5kZW5jaWVzLCBuYW1lZEV4cG9ydHNNb2RlLCBpbnRlcm9wLCBzbmlwcGV0cywgdCwgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIHJlZXhwb3J0UHJvdG9Gcm9tRXh0ZXJuYWwsIGBtb2R1bGUuZXhwb3J0cyR7X309JHtffWApO1xuICAgIG1hZ2ljU3RyaW5nLmFwcGVuZChgJHtleHBvcnRCbG9ja30ke291dHJvfWApO1xufVxuZnVuY3Rpb24gZ2V0SW1wb3J0QmxvY2skMShkZXBlbmRlbmNpZXMsIHsgXywgY25zdCwgbiB9LCBjb21wYWN0KSB7XG4gICAgbGV0IGltcG9ydEJsb2NrID0gJyc7XG4gICAgbGV0IGRlZmluaW5nVmFyaWFibGUgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHsgaW1wb3J0UGF0aCwgbmFtZSwgcmVleHBvcnRzLCBpbXBvcnRzIH0gb2YgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGlmICghcmVleHBvcnRzICYmICFpbXBvcnRzKSB7XG4gICAgICAgICAgICBpZiAoaW1wb3J0QmxvY2spIHtcbiAgICAgICAgICAgICAgICBpbXBvcnRCbG9jayArPSBjb21wYWN0ICYmICFkZWZpbmluZ1ZhcmlhYmxlID8gJywnIDogYDske259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmluaW5nVmFyaWFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGltcG9ydEJsb2NrICs9IGByZXF1aXJlKCcke2ltcG9ydFBhdGh9JylgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW1wb3J0QmxvY2sgKz0gY29tcGFjdCAmJiBkZWZpbmluZ1ZhcmlhYmxlID8gJywnIDogYCR7aW1wb3J0QmxvY2sgPyBgOyR7bn1gIDogJyd9JHtjbnN0fSBgO1xuICAgICAgICAgICAgZGVmaW5pbmdWYXJpYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBpbXBvcnRCbG9jayArPSBgJHtuYW1lfSR7X309JHtffXJlcXVpcmUoJyR7aW1wb3J0UGF0aH0nKWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGltcG9ydEJsb2NrKSB7XG4gICAgICAgIHJldHVybiBgJHtpbXBvcnRCbG9ja307JHtufSR7bn1gO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGVzKG1hZ2ljU3RyaW5nLCB7IGFjY2Vzc2VkR2xvYmFscywgaW5kZW50OiB0LCBpbnRybywgb3V0cm8sIGRlcGVuZGVuY2llcywgZXhwb3J0cywgc25pcHBldHMgfSwgeyBleHRlcm5hbExpdmVCaW5kaW5ncywgZnJlZXplLCBnZW5lcmF0ZWRDb2RlOiB7IHN5bWJvbHMgfSwgaW1wb3J0QXR0cmlidXRlc0tleSB9KSB7XG4gICAgY29uc3QgeyBuIH0gPSBzbmlwcGV0cztcbiAgICBjb25zdCBpbXBvcnRCbG9jayA9IGdldEltcG9ydEJsb2NrKGRlcGVuZGVuY2llcywgaW1wb3J0QXR0cmlidXRlc0tleSwgc25pcHBldHMpO1xuICAgIGlmIChpbXBvcnRCbG9jay5sZW5ndGggPiAwKVxuICAgICAgICBpbnRybyArPSBpbXBvcnRCbG9jay5qb2luKG4pICsgbiArIG47XG4gICAgaW50cm8gKz0gZ2V0SGVscGVyc0Jsb2NrKG51bGwsIGFjY2Vzc2VkR2xvYmFscywgdCwgc25pcHBldHMsIGV4dGVybmFsTGl2ZUJpbmRpbmdzLCBmcmVlemUsIHN5bWJvbHMpO1xuICAgIGlmIChpbnRybylcbiAgICAgICAgbWFnaWNTdHJpbmcucHJlcGVuZChpbnRybyk7XG4gICAgY29uc3QgZXhwb3J0QmxvY2sgPSBnZXRFeHBvcnRCbG9jayhleHBvcnRzLCBzbmlwcGV0cyk7XG4gICAgaWYgKGV4cG9ydEJsb2NrLmxlbmd0aCA+IDApXG4gICAgICAgIG1hZ2ljU3RyaW5nLmFwcGVuZChuICsgbiArIGV4cG9ydEJsb2NrLmpvaW4obikudHJpbSgpKTtcbiAgICBpZiAob3V0cm8pXG4gICAgICAgIG1hZ2ljU3RyaW5nLmFwcGVuZChvdXRybyk7XG4gICAgbWFnaWNTdHJpbmcudHJpbSgpO1xufVxuZnVuY3Rpb24gZ2V0SW1wb3J0QmxvY2soZGVwZW5kZW5jaWVzLCBpbXBvcnRBdHRyaWJ1dGVzS2V5LCB7IF8gfSkge1xuICAgIGNvbnN0IGltcG9ydEJsb2NrID0gW107XG4gICAgZm9yIChjb25zdCB7IGltcG9ydFBhdGgsIHJlZXhwb3J0cywgaW1wb3J0cywgbmFtZSwgYXR0cmlidXRlcyB9IG9mIGRlcGVuZGVuY2llcykge1xuICAgICAgICBjb25zdCBhc3NlcnRpb24gPSBhdHRyaWJ1dGVzID8gYCR7X30ke2ltcG9ydEF0dHJpYnV0ZXNLZXl9JHtffSR7YXR0cmlidXRlc31gIDogJyc7XG4gICAgICAgIGNvbnN0IHBhdGhXaXRoQXNzZXJ0aW9uID0gYCcke2ltcG9ydFBhdGh9JyR7YXNzZXJ0aW9ufTtgO1xuICAgICAgICBpZiAoIXJlZXhwb3J0cyAmJiAhaW1wb3J0cykge1xuICAgICAgICAgICAgaW1wb3J0QmxvY2sucHVzaChgaW1wb3J0JHtffSR7cGF0aFdpdGhBc3NlcnRpb259YCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1wb3J0cykge1xuICAgICAgICAgICAgbGV0IGRlZmF1bHRJbXBvcnQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHN0YXJJbXBvcnQgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgaW1wb3J0ZWROYW1lcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzcGVjaWZpZXIgb2YgaW1wb3J0cykge1xuICAgICAgICAgICAgICAgIGlmIChzcGVjaWZpZXIuaW1wb3J0ZWQgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0SW1wb3J0ID0gc3BlY2lmaWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzcGVjaWZpZXIuaW1wb3J0ZWQgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICBzdGFySW1wb3J0ID0gc3BlY2lmaWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWROYW1lcy5wdXNoKHNwZWNpZmllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJJbXBvcnQpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnRCbG9jay5wdXNoKGBpbXBvcnQke199KiR7X31hcyAke3N0YXJJbXBvcnQubG9jYWx9IGZyb20ke199JHtwYXRoV2l0aEFzc2VydGlvbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWZhdWx0SW1wb3J0ICYmIGltcG9ydGVkTmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0QmxvY2sucHVzaChgaW1wb3J0ICR7ZGVmYXVsdEltcG9ydC5sb2NhbH0gZnJvbSR7X30ke3BhdGhXaXRoQXNzZXJ0aW9ufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW1wb3J0ZWROYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0QmxvY2sucHVzaChgaW1wb3J0ICR7ZGVmYXVsdEltcG9ydCA/IGAke2RlZmF1bHRJbXBvcnQubG9jYWx9LCR7X31gIDogJyd9eyR7X30ke2ltcG9ydGVkTmFtZXNcbiAgICAgICAgICAgICAgICAgICAgLm1hcChzcGVjaWZpZXIgPT4gc3BlY2lmaWVyLmltcG9ydGVkID09PSBzcGVjaWZpZXIubG9jYWxcbiAgICAgICAgICAgICAgICAgICAgPyBzcGVjaWZpZXIuaW1wb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgOiBgJHtzdHJpbmdpZnlJZGVudGlmaWVySWZOZWVkZWQoc3BlY2lmaWVyLmltcG9ydGVkKX0gYXMgJHtzcGVjaWZpZXIubG9jYWx9YClcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oYCwke199YCl9JHtffX0ke199ZnJvbSR7X30ke3BhdGhXaXRoQXNzZXJ0aW9ufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWV4cG9ydHMpIHtcbiAgICAgICAgICAgIGxldCBzdGFyRXhwb3J0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZVJlZXhwb3J0cyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgbmFtZWRSZWV4cG9ydHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3BlY2lmaWVyIG9mIHJlZXhwb3J0cykge1xuICAgICAgICAgICAgICAgIGlmIChzcGVjaWZpZXIucmVleHBvcnRlZCA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJFeHBvcnQgPSBzcGVjaWZpZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNwZWNpZmllci5pbXBvcnRlZCA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVJlZXhwb3J0cy5wdXNoKHNwZWNpZmllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuYW1lZFJlZXhwb3J0cy5wdXNoKHNwZWNpZmllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJFeHBvcnQpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnRCbG9jay5wdXNoKGBleHBvcnQke199KiR7X31mcm9tJHtffSR7cGF0aFdpdGhBc3NlcnRpb259YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZXNwYWNlUmVleHBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWltcG9ydHMgfHxcbiAgICAgICAgICAgICAgICAgICAgIWltcG9ydHMuc29tZShzcGVjaWZpZXIgPT4gc3BlY2lmaWVyLmltcG9ydGVkID09PSAnKicgJiYgc3BlY2lmaWVyLmxvY2FsID09PSBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRCbG9jay5wdXNoKGBpbXBvcnQke199KiR7X31hcyAke25hbWV9IGZyb20ke199JHtwYXRoV2l0aEFzc2VydGlvbn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzcGVjaWZpZXIgb2YgbmFtZXNwYWNlUmVleHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydEJsb2NrLnB1c2goYGV4cG9ydCR7X317JHtffSR7bmFtZSA9PT0gc3BlY2lmaWVyLnJlZXhwb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgJHtuYW1lfSBhcyAke3N0cmluZ2lmeUlkZW50aWZpZXJJZk5lZWRlZChzcGVjaWZpZXIucmVleHBvcnRlZCl9YH0gfTtgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZWRSZWV4cG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGltcG9ydEJsb2NrLnB1c2goYGV4cG9ydCR7X317JHtffSR7bmFtZWRSZWV4cG9ydHNcbiAgICAgICAgICAgICAgICAgICAgLm1hcChzcGVjaWZpZXIgPT4gc3BlY2lmaWVyLmltcG9ydGVkID09PSBzcGVjaWZpZXIucmVleHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICA/IHN0cmluZ2lmeUlkZW50aWZpZXJJZk5lZWRlZChzcGVjaWZpZXIuaW1wb3J0ZWQpXG4gICAgICAgICAgICAgICAgICAgIDogYCR7c3RyaW5naWZ5SWRlbnRpZmllcklmTmVlZGVkKHNwZWNpZmllci5pbXBvcnRlZCl9IGFzICR7c3RyaW5naWZ5SWRlbnRpZmllcklmTmVlZGVkKHNwZWNpZmllci5yZWV4cG9ydGVkKX1gKVxuICAgICAgICAgICAgICAgICAgICAuam9pbihgLCR7X31gKX0ke199fSR7X31mcm9tJHtffSR7cGF0aFdpdGhBc3NlcnRpb259YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGltcG9ydEJsb2NrO1xufVxuZnVuY3Rpb24gZ2V0RXhwb3J0QmxvY2soZXhwb3J0cywgeyBfLCBjbnN0IH0pIHtcbiAgICBjb25zdCBleHBvcnRCbG9jayA9IFtdO1xuICAgIGNvbnN0IGV4cG9ydERlY2xhcmF0aW9uID0gbmV3IEFycmF5KGV4cG9ydHMubGVuZ3RoKTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3Qgc3BlY2lmaWVyIG9mIGV4cG9ydHMpIHtcbiAgICAgICAgaWYgKHNwZWNpZmllci5leHByZXNzaW9uKSB7XG4gICAgICAgICAgICBleHBvcnRCbG9jay5wdXNoKGAke2Nuc3R9ICR7c3BlY2lmaWVyLmxvY2FsfSR7X309JHtffSR7c3BlY2lmaWVyLmV4cHJlc3Npb259O2ApO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydERlY2xhcmF0aW9uW2luZGV4KytdID1cbiAgICAgICAgICAgIHNwZWNpZmllci5leHBvcnRlZCA9PT0gc3BlY2lmaWVyLmxvY2FsXG4gICAgICAgICAgICAgICAgPyBzcGVjaWZpZXIubG9jYWxcbiAgICAgICAgICAgICAgICA6IGAke3NwZWNpZmllci5sb2NhbH0gYXMgJHtzdHJpbmdpZnlJZGVudGlmaWVySWZOZWVkZWQoc3BlY2lmaWVyLmV4cG9ydGVkKX1gO1xuICAgIH1cbiAgICBpZiAoZXhwb3J0RGVjbGFyYXRpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICBleHBvcnRCbG9jay5wdXNoKGBleHBvcnQke199eyR7X30ke2V4cG9ydERlY2xhcmF0aW9uLmpvaW4oYCwke199YCl9JHtffX07YCk7XG4gICAgfVxuICAgIHJldHVybiBleHBvcnRCbG9jaztcbn1cblxuY29uc3Qga2V5cGF0aCA9IChrZXlwYXRoLCBnZXRQcm9wZXJ0eUFjY2VzcykgPT4ga2V5cGF0aC5zcGxpdCgnLicpLm1hcChnZXRQcm9wZXJ0eUFjY2Vzcykuam9pbignJyk7XG5cbmZ1bmN0aW9uIHNldHVwTmFtZXNwYWNlKG5hbWUsIHJvb3QsIGdsb2JhbHMsIHsgXywgZ2V0UHJvcGVydHlBY2Nlc3MsIHMgfSwgY29tcGFjdCwgbG9nKSB7XG4gICAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGtleSBleGlzdHMgaW4gdGhlIG9iamVjdCdzIHByb3RvdHlwZS5cbiAgICBjb25zdCBpc1Jlc2VydmVkID0gcGFydHNbMF0gaW4gT2JqZWN0LnByb3RvdHlwZTtcbiAgICBpZiAobG9nICYmIGlzUmVzZXJ2ZWQpIHtcbiAgICAgICAgbG9nKExPR0xFVkVMX1dBUk4sIGxvZ1Jlc2VydmVkTmFtZXNwYWNlKHBhcnRzWzBdKSk7XG4gICAgfVxuICAgIHBhcnRzWzBdID1cbiAgICAgICAgKHR5cGVvZiBnbG9iYWxzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGdsb2JhbHMocGFydHNbMF0pXG4gICAgICAgICAgICA6IGlzUmVzZXJ2ZWRcbiAgICAgICAgICAgICAgICA/IHBhcnRzWzBdXG4gICAgICAgICAgICAgICAgOiBnbG9iYWxzW3BhcnRzWzBdXSkgfHwgcGFydHNbMF07XG4gICAgcGFydHMucG9wKCk7XG4gICAgbGV0IHByb3BlcnR5UGF0aCA9IHJvb3Q7XG4gICAgcmV0dXJuIChwYXJ0c1xuICAgICAgICAubWFwKHBhcnQgPT4ge1xuICAgICAgICBwcm9wZXJ0eVBhdGggKz0gZ2V0UHJvcGVydHlBY2Nlc3MocGFydCk7XG4gICAgICAgIHJldHVybiBgJHtwcm9wZXJ0eVBhdGh9JHtffT0ke199JHtwcm9wZXJ0eVBhdGh9JHtffXx8JHtffXt9JHtzfWA7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oY29tcGFjdCA/ICcsJyA6ICdcXG4nKSArIChjb21wYWN0ICYmIHBhcnRzLmxlbmd0aCA+IDAgPyAnOycgOiAnXFxuJykpO1xufVxuZnVuY3Rpb24gYXNzaWduVG9EZWVwVmFyaWFibGUoZGVlcE5hbWUsIHJvb3QsIGdsb2JhbHMsIGFzc2lnbm1lbnQsIHsgXywgZ2V0UHJvcGVydHlBY2Nlc3MgfSwgbG9nKSB7XG4gICAgY29uc3QgcGFydHMgPSBkZWVwTmFtZS5zcGxpdCgnLicpO1xuICAgIC8vIENoZWNrIGlmIHRoZSBrZXkgZXhpc3RzIGluIHRoZSBvYmplY3QncyBwcm90b3R5cGUuXG4gICAgY29uc3QgaXNSZXNlcnZlZCA9IHBhcnRzWzBdIGluIE9iamVjdC5wcm90b3R5cGU7XG4gICAgaWYgKGxvZyAmJiBpc1Jlc2VydmVkKSB7XG4gICAgICAgIGxvZyhMT0dMRVZFTF9XQVJOLCBsb2dSZXNlcnZlZE5hbWVzcGFjZShwYXJ0c1swXSkpO1xuICAgIH1cbiAgICBwYXJ0c1swXSA9XG4gICAgICAgICh0eXBlb2YgZ2xvYmFscyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBnbG9iYWxzKHBhcnRzWzBdKVxuICAgICAgICAgICAgOiBpc1Jlc2VydmVkXG4gICAgICAgICAgICAgICAgPyBwYXJ0c1swXVxuICAgICAgICAgICAgICAgIDogZ2xvYmFsc1twYXJ0c1swXV0pIHx8IHBhcnRzWzBdO1xuICAgIGNvbnN0IGxhc3QgPSBwYXJ0cy5wb3AoKTtcbiAgICBsZXQgcHJvcGVydHlQYXRoID0gcm9vdDtcbiAgICBsZXQgZGVlcEFzc2lnbm1lbnQgPSBbXG4gICAgICAgIC4uLnBhcnRzLm1hcChwYXJ0ID0+IHtcbiAgICAgICAgICAgIHByb3BlcnR5UGF0aCArPSBnZXRQcm9wZXJ0eUFjY2VzcyhwYXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBgJHtwcm9wZXJ0eVBhdGh9JHtffT0ke199JHtwcm9wZXJ0eVBhdGh9JHtffXx8JHtffXt9YDtcbiAgICAgICAgfSksXG4gICAgICAgIGAke3Byb3BlcnR5UGF0aH0ke2dldFByb3BlcnR5QWNjZXNzKGxhc3QpfWBcbiAgICBdLmpvaW4oYCwke199YCkgKyBgJHtffT0ke199JHthc3NpZ25tZW50fWA7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVlcEFzc2lnbm1lbnQgPSBgKCR7ZGVlcEFzc2lnbm1lbnR9KWA7XG4gICAgfVxuICAgIHJldHVybiBkZWVwQXNzaWdubWVudDtcbn1cblxuZnVuY3Rpb24gdHJpbUVtcHR5SW1wb3J0cyhkZXBlbmRlbmNpZXMpIHtcbiAgICBsZXQgaW5kZXggPSBkZXBlbmRlbmNpZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGNvbnN0IHsgaW1wb3J0cywgcmVleHBvcnRzIH0gPSBkZXBlbmRlbmNpZXNbaW5kZXhdO1xuICAgICAgICBpZiAoaW1wb3J0cyB8fCByZWV4cG9ydHMpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXMuc2xpY2UoMCwgaW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIGlpZmUobWFnaWNTdHJpbmcsIHsgYWNjZXNzZWRHbG9iYWxzLCBkZXBlbmRlbmNpZXMsIGV4cG9ydHMsIGhhc0RlZmF1bHRFeHBvcnQsIGhhc0V4cG9ydHMsIGluZGVudDogdCwgaW50cm8sIG5hbWVkRXhwb3J0c01vZGUsIGxvZywgb3V0cm8sIHNuaXBwZXRzIH0sIHsgY29tcGFjdCwgZXNNb2R1bGUsIGV4dGVuZCwgZnJlZXplLCBleHRlcm5hbExpdmVCaW5kaW5ncywgcmVleHBvcnRQcm90b0Zyb21FeHRlcm5hbCwgZ2xvYmFscywgaW50ZXJvcCwgbmFtZSwgZ2VuZXJhdGVkQ29kZTogeyBzeW1ib2xzIH0sIHN0cmljdCB9KSB7XG4gICAgY29uc3QgeyBfLCBnZXROb25BcnJvd0Z1bmN0aW9uSW50cm8sIGdldFByb3BlcnR5QWNjZXNzLCBuIH0gPSBzbmlwcGV0cztcbiAgICBjb25zdCBpc05hbWVzcGFjZWQgPSBuYW1lICYmIG5hbWUuaW5jbHVkZXMoJy4nKTtcbiAgICBjb25zdCB1c2VWYXJpYWJsZUFzc2lnbm1lbnQgPSAhZXh0ZW5kICYmICFpc05hbWVzcGFjZWQ7XG4gICAgaWYgKG5hbWUgJiYgdXNlVmFyaWFibGVBc3NpZ25tZW50ICYmICFpc0xlZ2FsKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihsb2dJbGxlZ2FsSWRlbnRpZmllckFzTmFtZShuYW1lKSk7XG4gICAgfVxuICAgIHdhcm5PbkJ1aWx0aW5zKGxvZywgZGVwZW5kZW5jaWVzKTtcbiAgICBjb25zdCBleHRlcm5hbCA9IHRyaW1FbXB0eUltcG9ydHMoZGVwZW5kZW5jaWVzKTtcbiAgICBjb25zdCBkZXBzID0gZXh0ZXJuYWwubWFwKGRlcCA9PiBkZXAuZ2xvYmFsTmFtZSB8fCAnbnVsbCcpO1xuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBleHRlcm5hbC5tYXAobSA9PiBtLm5hbWUpO1xuICAgIGlmIChoYXNFeHBvcnRzICYmICFuYW1lKSB7XG4gICAgICAgIGxvZyhMT0dMRVZFTF9XQVJOLCBsb2dNaXNzaW5nTmFtZU9wdGlvbkZvcklpZmVFeHBvcnQoKSk7XG4gICAgfVxuICAgIGlmIChuYW1lZEV4cG9ydHNNb2RlICYmIGhhc0V4cG9ydHMpIHtcbiAgICAgICAgaWYgKGV4dGVuZCkge1xuICAgICAgICAgICAgZGVwcy51bnNoaWZ0KGB0aGlzJHtrZXlwYXRoKG5hbWUsIGdldFByb3BlcnR5QWNjZXNzKX0ke199PSR7X310aGlzJHtrZXlwYXRoKG5hbWUsIGdldFByb3BlcnR5QWNjZXNzKX0ke199fHwke199e31gKTtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMudW5zaGlmdCgnZXhwb3J0cycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVwcy51bnNoaWZ0KCd7fScpO1xuICAgICAgICAgICAgcGFyYW1ldGVycy51bnNoaWZ0KCdleHBvcnRzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXNlU3RyaWN0ID0gc3RyaWN0ID8gYCR7dH0ndXNlIHN0cmljdCc7JHtufWAgOiAnJztcbiAgICBjb25zdCBpbnRlcm9wQmxvY2sgPSBnZXRJbnRlcm9wQmxvY2soZGVwZW5kZW5jaWVzLCBpbnRlcm9wLCBleHRlcm5hbExpdmVCaW5kaW5ncywgZnJlZXplLCBzeW1ib2xzLCBhY2Nlc3NlZEdsb2JhbHMsIHQsIHNuaXBwZXRzKTtcbiAgICBtYWdpY1N0cmluZy5wcmVwZW5kKGAke2ludHJvfSR7aW50ZXJvcEJsb2NrfWApO1xuICAgIGxldCB3cmFwcGVySW50cm8gPSBgKCR7Z2V0Tm9uQXJyb3dGdW5jdGlvbkludHJvKHBhcmFtZXRlcnMsIHtcbiAgICAgICAgaXNBc3luYzogZmFsc2UsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICB9KX17JHtufSR7dXNlU3RyaWN0fSR7bn1gO1xuICAgIGlmIChoYXNFeHBvcnRzKSB7XG4gICAgICAgIGlmIChuYW1lICYmICEoZXh0ZW5kICYmIG5hbWVkRXhwb3J0c01vZGUpKSB7XG4gICAgICAgICAgICB3cmFwcGVySW50cm8gPVxuICAgICAgICAgICAgICAgICh1c2VWYXJpYWJsZUFzc2lnbm1lbnQgPyBgdmFyICR7bmFtZX1gIDogYHRoaXMke2tleXBhdGgobmFtZSwgZ2V0UHJvcGVydHlBY2Nlc3MpfWApICtcbiAgICAgICAgICAgICAgICAgICAgYCR7X309JHtffSR7d3JhcHBlckludHJvfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFtZXNwYWNlZCkge1xuICAgICAgICAgICAgd3JhcHBlckludHJvID0gc2V0dXBOYW1lc3BhY2UobmFtZSwgJ3RoaXMnLCBnbG9iYWxzLCBzbmlwcGV0cywgY29tcGFjdCwgbG9nKSArIHdyYXBwZXJJbnRybztcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgd3JhcHBlck91dHJvID0gYCR7bn0ke259fSkoJHtkZXBzLmpvaW4oYCwke199YCl9KTtgO1xuICAgIGlmIChoYXNFeHBvcnRzICYmICFleHRlbmQgJiYgbmFtZWRFeHBvcnRzTW9kZSkge1xuICAgICAgICB3cmFwcGVyT3V0cm8gPSBgJHtufSR7bn0ke3R9cmV0dXJuIGV4cG9ydHM7JHt3cmFwcGVyT3V0cm99YDtcbiAgICB9XG4gICAgY29uc3QgZXhwb3J0QmxvY2sgPSBnZXRFeHBvcnRCbG9jayQxKGV4cG9ydHMsIGRlcGVuZGVuY2llcywgbmFtZWRFeHBvcnRzTW9kZSwgaW50ZXJvcCwgc25pcHBldHMsIHQsIGV4dGVybmFsTGl2ZUJpbmRpbmdzLCByZWV4cG9ydFByb3RvRnJvbUV4dGVybmFsKTtcbiAgICBsZXQgbmFtZXNwYWNlTWFya2VycyA9IGdldE5hbWVzcGFjZU1hcmtlcnMobmFtZWRFeHBvcnRzTW9kZSAmJiBoYXNFeHBvcnRzLCBlc01vZHVsZSA9PT0gdHJ1ZSB8fCAoZXNNb2R1bGUgPT09ICdpZi1kZWZhdWx0LXByb3AnICYmIGhhc0RlZmF1bHRFeHBvcnQpLCBzeW1ib2xzLCBzbmlwcGV0cyk7XG4gICAgaWYgKG5hbWVzcGFjZU1hcmtlcnMpIHtcbiAgICAgICAgbmFtZXNwYWNlTWFya2VycyA9IG4gKyBuICsgbmFtZXNwYWNlTWFya2VycztcbiAgICB9XG4gICAgbWFnaWNTdHJpbmdcbiAgICAgICAgLmFwcGVuZChgJHtleHBvcnRCbG9ja30ke25hbWVzcGFjZU1hcmtlcnN9JHtvdXRyb31gKVxuICAgICAgICAuaW5kZW50KHQpXG4gICAgICAgIC5wcmVwZW5kKHdyYXBwZXJJbnRybylcbiAgICAgICAgLmFwcGVuZCh3cmFwcGVyT3V0cm8pO1xufVxuXG5jb25zdCBNSVNTSU5HX0VYUE9SVF9TSElNX1ZBUklBQkxFID0gJ19taXNzaW5nRXhwb3J0U2hpbSc7XG5cbmZ1bmN0aW9uIHN5c3RlbShtYWdpY1N0cmluZywgeyBhY2Nlc3NlZEdsb2JhbHMsIGRlcGVuZGVuY2llcywgZXhwb3J0cywgaGFzRXhwb3J0cywgaW5kZW50OiB0LCBpbnRybywgc25pcHBldHMsIG91dHJvLCB1c2VzVG9wTGV2ZWxBd2FpdCB9LCB7IGV4dGVybmFsTGl2ZUJpbmRpbmdzLCBmcmVlemUsIG5hbWUsIGdlbmVyYXRlZENvZGU6IHsgc3ltYm9scyB9LCBzdHJpY3QsIHN5c3RlbU51bGxTZXR0ZXJzIH0pIHtcbiAgICBjb25zdCB7IF8sIGdldEZ1bmN0aW9uSW50cm8sIGdldE5vbkFycm93RnVuY3Rpb25JbnRybywgbiwgcyB9ID0gc25pcHBldHM7XG4gICAgY29uc3QgeyBpbXBvcnRCaW5kaW5ncywgc2V0dGVycywgc3RhckV4Y2x1ZGVzIH0gPSBhbmFseXplRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcywgZXhwb3J0cywgdCwgc25pcHBldHMpO1xuICAgIGNvbnN0IHJlZ2lzdGVyZWROYW1lID0gbmFtZSA/IGAnJHtuYW1lfScsJHtffWAgOiAnJztcbiAgICBjb25zdCB3cmFwcGVyUGFyYW1ldGVycyA9IGFjY2Vzc2VkR2xvYmFscy5oYXMoJ21vZHVsZScpXG4gICAgICAgID8gWydleHBvcnRzJywgJ21vZHVsZSddXG4gICAgICAgIDogaGFzRXhwb3J0c1xuICAgICAgICAgICAgPyBbJ2V4cG9ydHMnXVxuICAgICAgICAgICAgOiBbXTtcbiAgICAvLyBmYWN0b3J5IGZ1bmN0aW9uIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHBhcmVudGhlc2VzIHRvIGF2b2lkIGxhenkgcGFyc2luZyxcbiAgICAvLyBjZi4gaHR0cHM6Ly92OC5kZXYvYmxvZy9wcmVwYXJzZXIjcGlmZVxuICAgIGxldCB3cmFwcGVyU3RhcnQgPSBgU3lzdGVtLnJlZ2lzdGVyKCR7cmVnaXN0ZXJlZE5hbWV9W2AgK1xuICAgICAgICBkZXBlbmRlbmNpZXMubWFwKCh7IGltcG9ydFBhdGggfSkgPT4gYCcke2ltcG9ydFBhdGh9J2ApLmpvaW4oYCwke199YCkgK1xuICAgICAgICBgXSwke199KCR7Z2V0Tm9uQXJyb3dGdW5jdGlvbkludHJvKHdyYXBwZXJQYXJhbWV0ZXJzLCB7XG4gICAgICAgICAgICBpc0FzeW5jOiBmYWxzZSxcbiAgICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgfSl9eyR7bn0ke3R9JHtzdHJpY3QgPyBcIid1c2Ugc3RyaWN0JztcIiA6ICcnfWAgK1xuICAgICAgICBnZXRTdGFyRXhjbHVkZXNCbG9jayhzdGFyRXhjbHVkZXMsIHQsIHNuaXBwZXRzKSArXG4gICAgICAgIGdldEltcG9ydEJpbmRpbmdzQmxvY2soaW1wb3J0QmluZGluZ3MsIHQsIHNuaXBwZXRzKSArXG4gICAgICAgIGAke259JHt0fXJldHVybiR7X317JHtzZXR0ZXJzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gYCR7bn0ke3R9JHt0fXNldHRlcnM6JHtffVske3NldHRlcnNcbiAgICAgICAgICAgICAgICAubWFwKHNldHRlciA9PiBzZXR0ZXJcbiAgICAgICAgICAgICAgICA/IGAke2dldEZ1bmN0aW9uSW50cm8oWydtb2R1bGUnXSwge1xuICAgICAgICAgICAgICAgICAgICBpc0FzeW5jOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbnVsbFxuICAgICAgICAgICAgICAgIH0pfXske259JHt0fSR7dH0ke3R9JHtzZXR0ZXJ9JHtufSR7dH0ke3R9fWBcbiAgICAgICAgICAgICAgICA6IHN5c3RlbU51bGxTZXR0ZXJzXG4gICAgICAgICAgICAgICAgICAgID8gYG51bGxgXG4gICAgICAgICAgICAgICAgICAgIDogYCR7Z2V0RnVuY3Rpb25JbnRybyhbXSwgeyBpc0FzeW5jOiBmYWxzZSwgbmFtZTogbnVsbCB9KX17fWApXG4gICAgICAgICAgICAgICAgLmpvaW4oYCwke199YCl9XSxgXG4gICAgICAgICAgICA6ICcnfSR7bn1gO1xuICAgIHdyYXBwZXJTdGFydCArPSBgJHt0fSR7dH1leGVjdXRlOiR7X30oJHtnZXROb25BcnJvd0Z1bmN0aW9uSW50cm8oW10sIHtcbiAgICAgICAgaXNBc3luYzogdXNlc1RvcExldmVsQXdhaXQsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICB9KX17JHtufSR7bn1gO1xuICAgIGNvbnN0IHdyYXBwZXJFbmQgPSBgJHt0fSR7dH19KSR7bn0ke3R9fSR7c30ke259fSkpO2A7XG4gICAgbWFnaWNTdHJpbmdcbiAgICAgICAgLnByZXBlbmQoaW50cm8gK1xuICAgICAgICBnZXRIZWxwZXJzQmxvY2sobnVsbCwgYWNjZXNzZWRHbG9iYWxzLCB0LCBzbmlwcGV0cywgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGZyZWV6ZSwgc3ltYm9scykgK1xuICAgICAgICBnZXRIb2lzdGVkRXhwb3J0c0Jsb2NrKGV4cG9ydHMsIHQsIHNuaXBwZXRzKSlcbiAgICAgICAgLmFwcGVuZChgJHtvdXRyb30ke259JHtufWAgK1xuICAgICAgICBnZXRTeW50aGV0aWNFeHBvcnRzQmxvY2soZXhwb3J0cywgdCwgc25pcHBldHMpICtcbiAgICAgICAgZ2V0TWlzc2luZ0V4cG9ydHNCbG9jayhleHBvcnRzLCB0LCBzbmlwcGV0cykpXG4gICAgICAgIC5pbmRlbnQoYCR7dH0ke3R9JHt0fWApXG4gICAgICAgIC5hcHBlbmQod3JhcHBlckVuZClcbiAgICAgICAgLnByZXBlbmQod3JhcHBlclN0YXJ0KTtcbn1cbmZ1bmN0aW9uIGFuYWx5emVEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzLCBleHBvcnRzLCB0LCB7IF8sIGNuc3QsIGdldE9iamVjdCwgZ2V0UHJvcGVydHlBY2Nlc3MsIG4gfSkge1xuICAgIGNvbnN0IGltcG9ydEJpbmRpbmdzID0gW107XG4gICAgY29uc3Qgc2V0dGVycyA9IFtdO1xuICAgIGxldCBzdGFyRXhjbHVkZXMgPSBudWxsO1xuICAgIGZvciAoY29uc3QgeyBpbXBvcnRzLCByZWV4cG9ydHMgfSBvZiBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgY29uc3Qgc2V0dGVyID0gW107XG4gICAgICAgIGlmIChpbXBvcnRzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNwZWNpZmllciBvZiBpbXBvcnRzKSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0QmluZGluZ3MucHVzaChzcGVjaWZpZXIubG9jYWwpO1xuICAgICAgICAgICAgICAgIGlmIChzcGVjaWZpZXIuaW1wb3J0ZWQgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICBzZXR0ZXIucHVzaChgJHtzcGVjaWZpZXIubG9jYWx9JHtffT0ke199bW9kdWxlO2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGVyLnB1c2goYCR7c3BlY2lmaWVyLmxvY2FsfSR7X309JHtffW1vZHVsZSR7Z2V0UHJvcGVydHlBY2Nlc3Moc3BlY2lmaWVyLmltcG9ydGVkKX07YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWV4cG9ydHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZXhwb3J0ZWROYW1lcyA9IFtdO1xuICAgICAgICAgICAgbGV0IGhhc1N0YXJSZWV4cG9ydCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IGltcG9ydGVkLCByZWV4cG9ydGVkIH0gb2YgcmVleHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZXhwb3J0ZWQgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICBoYXNTdGFyUmVleHBvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVleHBvcnRlZE5hbWVzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVleHBvcnRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGVkID09PSAnKicgPyAnbW9kdWxlJyA6IGBtb2R1bGUke2dldFByb3BlcnR5QWNjZXNzKGltcG9ydGVkKX1gXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWV4cG9ydGVkTmFtZXMubGVuZ3RoID4gMSB8fCBoYXNTdGFyUmVleHBvcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzU3RhclJlZXhwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhckV4Y2x1ZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFyRXhjbHVkZXMgPSBnZXRTdGFyRXhjbHVkZXMoeyBkZXBlbmRlbmNpZXMsIGV4cG9ydHMgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVleHBvcnRlZE5hbWVzLnVuc2hpZnQoW251bGwsIGBfX3Byb3RvX186JHtffW51bGxgXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cG9ydE1hcHBpbmcgPSBnZXRPYmplY3QocmVleHBvcnRlZE5hbWVzLCB7IGxpbmVCcmVha0luZGVudDogbnVsbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGVyLnB1c2goYCR7Y25zdH0gc2V0dGVyJHtffT0ke199JHtleHBvcnRNYXBwaW5nfTtgLCBgZm9yJHtffSgke2Nuc3R9IG5hbWUgaW4gbW9kdWxlKSR7X317YCwgYCR7dH1pZiR7X30oIV9zdGFyRXhjbHVkZXNbbmFtZV0pJHtffXNldHRlcltuYW1lXSR7X309JHtffW1vZHVsZVtuYW1lXTtgLCAnfScsICdleHBvcnRzKHNldHRlcik7Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBvcnRNYXBwaW5nID0gZ2V0T2JqZWN0KHJlZXhwb3J0ZWROYW1lcywgeyBsaW5lQnJlYWtJbmRlbnQ6IG51bGwgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNldHRlci5wdXNoKGBleHBvcnRzKCR7ZXhwb3J0TWFwcGluZ30pO2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHJlZXhwb3J0ZWROYW1lc1swXTtcbiAgICAgICAgICAgICAgICBzZXR0ZXIucHVzaChgZXhwb3J0cygke0pTT04uc3RyaW5naWZ5KGtleSl9LCR7X30ke3ZhbHVlfSk7YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0dGVycy5wdXNoKHNldHRlci5qb2luKGAke259JHt0fSR7dH0ke3R9YCkpO1xuICAgIH1cbiAgICByZXR1cm4geyBpbXBvcnRCaW5kaW5ncywgc2V0dGVycywgc3RhckV4Y2x1ZGVzIH07XG59XG5jb25zdCBnZXRTdGFyRXhjbHVkZXMgPSAoeyBkZXBlbmRlbmNpZXMsIGV4cG9ydHMgfSkgPT4ge1xuICAgIGNvbnN0IHN0YXJFeGNsdWRlcyA9IG5ldyBTZXQoZXhwb3J0cy5tYXAoZXhwdCA9PiBleHB0LmV4cG9ydGVkKSk7XG4gICAgc3RhckV4Y2x1ZGVzLmFkZCgnZGVmYXVsdCcpO1xuICAgIGZvciAoY29uc3QgeyByZWV4cG9ydHMgfSBvZiBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgaWYgKHJlZXhwb3J0cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWV4cG9ydCBvZiByZWV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVleHBvcnQucmVleHBvcnRlZCAhPT0gJyonKVxuICAgICAgICAgICAgICAgICAgICBzdGFyRXhjbHVkZXMuYWRkKHJlZXhwb3J0LnJlZXhwb3J0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGFyRXhjbHVkZXM7XG59O1xuY29uc3QgZ2V0U3RhckV4Y2x1ZGVzQmxvY2sgPSAoc3RhckV4Y2x1ZGVzLCB0LCB7IF8sIGNuc3QsIGdldE9iamVjdCwgbiB9KSA9PiB7XG4gICAgaWYgKHN0YXJFeGNsdWRlcykge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBbLi4uc3RhckV4Y2x1ZGVzXS5tYXAocHJvcGVydHkgPT4gW1xuICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAnMSdcbiAgICAgICAgXSk7XG4gICAgICAgIGZpZWxkcy51bnNoaWZ0KFtudWxsLCBgX19wcm90b19fOiR7X31udWxsYF0pO1xuICAgICAgICByZXR1cm4gYCR7bn0ke3R9JHtjbnN0fSBfc3RhckV4Y2x1ZGVzJHtffT0ke199JHtnZXRPYmplY3QoZmllbGRzLCB7XG4gICAgICAgICAgICBsaW5lQnJlYWtJbmRlbnQ6IHsgYmFzZTogdCwgdCB9XG4gICAgICAgIH0pfTtgO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59O1xuY29uc3QgZ2V0SW1wb3J0QmluZGluZ3NCbG9jayA9IChpbXBvcnRCaW5kaW5ncywgdCwgeyBfLCBuIH0pID0+IChpbXBvcnRCaW5kaW5ncy5sZW5ndGggPiAwID8gYCR7bn0ke3R9dmFyICR7aW1wb3J0QmluZGluZ3Muam9pbihgLCR7X31gKX07YCA6ICcnKTtcbmNvbnN0IGdldEhvaXN0ZWRFeHBvcnRzQmxvY2sgPSAoZXhwb3J0cywgdCwgc25pcHBldHMpID0+IGdldEV4cG9ydHNCbG9jayhleHBvcnRzLmZpbHRlcihleHB0ID0+IGV4cHQuaG9pc3RlZCkubWFwKGV4cHQgPT4gKHsgbmFtZTogZXhwdC5leHBvcnRlZCwgdmFsdWU6IGV4cHQubG9jYWwgfSkpLCB0LCBzbmlwcGV0cyk7XG5mdW5jdGlvbiBnZXRFeHBvcnRzQmxvY2soZXhwb3J0cywgdCwgeyBfLCBuIH0pIHtcbiAgICBpZiAoZXhwb3J0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAoZXhwb3J0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGBleHBvcnRzKCR7SlNPTi5zdHJpbmdpZnkoZXhwb3J0c1swXS5uYW1lKX0sJHtffSR7ZXhwb3J0c1swXS52YWx1ZX0pOyR7bn0ke259YDtcbiAgICB9XG4gICAgcmV0dXJuIChgZXhwb3J0cyh7JHtufWAgK1xuICAgICAgICBleHBvcnRzXG4gICAgICAgICAgICAubWFwKCh7IG5hbWUsIHZhbHVlIH0pID0+IGAke3R9JHtzdHJpbmdpZnlPYmplY3RLZXlJZk5lZWRlZChuYW1lKX06JHtffSR7dmFsdWV9YClcbiAgICAgICAgICAgIC5qb2luKGAsJHtufWApICtcbiAgICAgICAgYCR7bn19KTske259JHtufWApO1xufVxuY29uc3QgZ2V0U3ludGhldGljRXhwb3J0c0Jsb2NrID0gKGV4cG9ydHMsIHQsIHNuaXBwZXRzKSA9PiBnZXRFeHBvcnRzQmxvY2soZXhwb3J0c1xuICAgIC5maWx0ZXIoZXhwdCA9PiBleHB0LmV4cHJlc3Npb24pXG4gICAgLm1hcChleHB0ID0+ICh7IG5hbWU6IGV4cHQuZXhwb3J0ZWQsIHZhbHVlOiBleHB0LmxvY2FsIH0pKSwgdCwgc25pcHBldHMpO1xuY29uc3QgZ2V0TWlzc2luZ0V4cG9ydHNCbG9jayA9IChleHBvcnRzLCB0LCBzbmlwcGV0cykgPT4gZ2V0RXhwb3J0c0Jsb2NrKGV4cG9ydHNcbiAgICAuZmlsdGVyKGV4cHQgPT4gZXhwdC5sb2NhbCA9PT0gTUlTU0lOR19FWFBPUlRfU0hJTV9WQVJJQUJMRSlcbiAgICAubWFwKGV4cHQgPT4gKHsgbmFtZTogZXhwdC5leHBvcnRlZCwgdmFsdWU6IE1JU1NJTkdfRVhQT1JUX1NISU1fVkFSSUFCTEUgfSkpLCB0LCBzbmlwcGV0cyk7XG5cbmZ1bmN0aW9uIGdsb2JhbFByb3BlcnR5KG5hbWUsIGdsb2JhbFZhcmlhYmxlLCBnZXRQcm9wZXJ0eUFjY2Vzcykge1xuICAgIGlmICghbmFtZSlcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICByZXR1cm4gYCR7Z2xvYmFsVmFyaWFibGV9JHtrZXlwYXRoKG5hbWUsIGdldFByb3BlcnR5QWNjZXNzKX1gO1xufVxuZnVuY3Rpb24gc2FmZUFjY2VzcyhuYW1lLCBnbG9iYWxWYXJpYWJsZSwgeyBfLCBnZXRQcm9wZXJ0eUFjY2VzcyB9KSB7XG4gICAgbGV0IHByb3BlcnR5UGF0aCA9IGdsb2JhbFZhcmlhYmxlO1xuICAgIHJldHVybiBuYW1lXG4gICAgICAgIC5zcGxpdCgnLicpXG4gICAgICAgIC5tYXAocGFydCA9PiAocHJvcGVydHlQYXRoICs9IGdldFByb3BlcnR5QWNjZXNzKHBhcnQpKSlcbiAgICAgICAgLmpvaW4oYCR7X30mJiR7X31gKTtcbn1cbmZ1bmN0aW9uIHVtZChtYWdpY1N0cmluZywgeyBhY2Nlc3NlZEdsb2JhbHMsIGRlcGVuZGVuY2llcywgZXhwb3J0cywgaGFzRGVmYXVsdEV4cG9ydCwgaGFzRXhwb3J0cywgaWQsIGluZGVudDogdCwgaW50cm8sIG5hbWVkRXhwb3J0c01vZGUsIGxvZywgb3V0cm8sIHNuaXBwZXRzIH0sIHsgYW1kLCBjb21wYWN0LCBlc01vZHVsZSwgZXh0ZW5kLCBleHRlcm5hbExpdmVCaW5kaW5ncywgZnJlZXplLCBpbnRlcm9wLCBuYW1lLCBnZW5lcmF0ZWRDb2RlOiB7IHN5bWJvbHMgfSwgZ2xvYmFscywgbm9Db25mbGljdCwgcmVleHBvcnRQcm90b0Zyb21FeHRlcm5hbCwgc3RyaWN0IH0pIHtcbiAgICBjb25zdCB7IF8sIGNuc3QsIGdldEZ1bmN0aW9uSW50cm8sIGdldE5vbkFycm93RnVuY3Rpb25JbnRybywgZ2V0UHJvcGVydHlBY2Nlc3MsIG4sIHMgfSA9IHNuaXBwZXRzO1xuICAgIGNvbnN0IGZhY3RvcnlWYXJpYWJsZSA9IGNvbXBhY3QgPyAnZicgOiAnZmFjdG9yeSc7XG4gICAgY29uc3QgZ2xvYmFsVmFyaWFibGUgPSBjb21wYWN0ID8gJ2cnIDogJ2dsb2JhbCc7XG4gICAgaWYgKGhhc0V4cG9ydHMgJiYgIW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKGxvZ01pc3NpbmdOYW1lT3B0aW9uRm9yVW1kRXhwb3J0KCkpO1xuICAgIH1cbiAgICB3YXJuT25CdWlsdGlucyhsb2csIGRlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgYW1kRGVwcyA9IGRlcGVuZGVuY2llcy5tYXAobSA9PiBgJyR7dXBkYXRlRXh0ZW5zaW9uRm9yUmVsYXRpdmVBbWRJZChtLmltcG9ydFBhdGgsIGFtZC5mb3JjZUpzRXh0ZW5zaW9uRm9ySW1wb3J0cyl9J2ApO1xuICAgIGNvbnN0IGNqc0RlcHMgPSBkZXBlbmRlbmNpZXMubWFwKG0gPT4gYHJlcXVpcmUoJyR7bS5pbXBvcnRQYXRofScpYCk7XG4gICAgY29uc3QgdHJpbW1lZEltcG9ydHMgPSB0cmltRW1wdHlJbXBvcnRzKGRlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgZ2xvYmFsRGVwcyA9IHRyaW1tZWRJbXBvcnRzLm1hcChtb2R1bGUgPT4gZ2xvYmFsUHJvcGVydHkobW9kdWxlLmdsb2JhbE5hbWUsIGdsb2JhbFZhcmlhYmxlLCBnZXRQcm9wZXJ0eUFjY2VzcykpO1xuICAgIGNvbnN0IGZhY3RvcnlQYXJhbWV0ZXJzID0gdHJpbW1lZEltcG9ydHMubWFwKG0gPT4gbS5uYW1lKTtcbiAgICBpZiAobmFtZWRFeHBvcnRzTW9kZSAmJiAoaGFzRXhwb3J0cyB8fCBub0NvbmZsaWN0KSkge1xuICAgICAgICBhbWREZXBzLnVuc2hpZnQoYCdleHBvcnRzJ2ApO1xuICAgICAgICBjanNEZXBzLnVuc2hpZnQoYGV4cG9ydHNgKTtcbiAgICAgICAgZ2xvYmFsRGVwcy51bnNoaWZ0KGFzc2lnblRvRGVlcFZhcmlhYmxlKG5hbWUsIGdsb2JhbFZhcmlhYmxlLCBnbG9iYWxzLCBgJHtleHRlbmQgPyBgJHtnbG9iYWxQcm9wZXJ0eShuYW1lLCBnbG9iYWxWYXJpYWJsZSwgZ2V0UHJvcGVydHlBY2Nlc3MpfSR7X318fCR7X31gIDogJyd9e31gLCBzbmlwcGV0cywgbG9nKSk7XG4gICAgICAgIGZhY3RvcnlQYXJhbWV0ZXJzLnVuc2hpZnQoJ2V4cG9ydHMnKTtcbiAgICB9XG4gICAgY29uc3QgY29tcGxldGVBbWRJZCA9IGdldENvbXBsZXRlQW1kSWQoYW1kLCBpZCk7XG4gICAgY29uc3QgYW1kUGFyYW1ldGVycyA9IChjb21wbGV0ZUFtZElkID8gYCcke2NvbXBsZXRlQW1kSWR9Jywke199YCA6IGBgKSArXG4gICAgICAgIChhbWREZXBzLmxlbmd0aCA+IDAgPyBgWyR7YW1kRGVwcy5qb2luKGAsJHtffWApfV0sJHtffWAgOiBgYCk7XG4gICAgY29uc3QgZGVmaW5lID0gYW1kLmRlZmluZTtcbiAgICBjb25zdCBjanNFeHBvcnQgPSAhbmFtZWRFeHBvcnRzTW9kZSAmJiBoYXNFeHBvcnRzID8gYG1vZHVsZS5leHBvcnRzJHtffT0ke199YCA6IGBgO1xuICAgIGNvbnN0IHVzZVN0cmljdCA9IHN0cmljdCA/IGAke199J3VzZSBzdHJpY3QnOyR7bn1gIDogYGA7XG4gICAgbGV0IGlpZmVFeHBvcnQ7XG4gICAgaWYgKG5vQ29uZmxpY3QpIHtcbiAgICAgICAgY29uc3Qgbm9Db25mbGljdEV4cG9ydHNWYXJpYWJsZSA9IGNvbXBhY3QgPyAnZScgOiAnZXhwb3J0cyc7XG4gICAgICAgIGxldCBmYWN0b3J5O1xuICAgICAgICBpZiAoIW5hbWVkRXhwb3J0c01vZGUgJiYgaGFzRXhwb3J0cykge1xuICAgICAgICAgICAgZmFjdG9yeSA9IGAke2Nuc3R9ICR7bm9Db25mbGljdEV4cG9ydHNWYXJpYWJsZX0ke199PSR7X30ke2Fzc2lnblRvRGVlcFZhcmlhYmxlKG5hbWUsIGdsb2JhbFZhcmlhYmxlLCBnbG9iYWxzLCBgJHtmYWN0b3J5VmFyaWFibGV9KCR7Z2xvYmFsRGVwcy5qb2luKGAsJHtffWApfSlgLCBzbmlwcGV0cywgbG9nKX07YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IGdsb2JhbERlcHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGZhY3RvcnkgPVxuICAgICAgICAgICAgICAgIGAke2Nuc3R9ICR7bm9Db25mbGljdEV4cG9ydHNWYXJpYWJsZX0ke199PSR7X30ke21vZHVsZX07JHtufWAgK1xuICAgICAgICAgICAgICAgICAgICBgJHt0fSR7dH0ke2ZhY3RvcnlWYXJpYWJsZX0oJHtbbm9Db25mbGljdEV4cG9ydHNWYXJpYWJsZSwgLi4uZ2xvYmFsRGVwc10uam9pbihgLCR7X31gKX0pO2A7XG4gICAgICAgIH1cbiAgICAgICAgaWlmZUV4cG9ydCA9XG4gICAgICAgICAgICBgKCR7Z2V0RnVuY3Rpb25JbnRybyhbXSwgeyBpc0FzeW5jOiBmYWxzZSwgbmFtZTogbnVsbCB9KX17JHtufWAgK1xuICAgICAgICAgICAgICAgIGAke3R9JHt0fSR7Y25zdH0gY3VycmVudCR7X309JHtffSR7c2FmZUFjY2VzcyhuYW1lLCBnbG9iYWxWYXJpYWJsZSwgc25pcHBldHMpfTske259YCArXG4gICAgICAgICAgICAgICAgYCR7dH0ke3R9JHtmYWN0b3J5fSR7bn1gICtcbiAgICAgICAgICAgICAgICBgJHt0fSR7dH0ke25vQ29uZmxpY3RFeHBvcnRzVmFyaWFibGV9Lm5vQ29uZmxpY3Qke199PSR7X30ke2dldEZ1bmN0aW9uSW50cm8oW10sIHtcbiAgICAgICAgICAgICAgICAgICAgaXNBc3luYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgICAgICAgICB9KX17JHtffWAgK1xuICAgICAgICAgICAgICAgIGAke2dsb2JhbFByb3BlcnR5KG5hbWUsIGdsb2JhbFZhcmlhYmxlLCBnZXRQcm9wZXJ0eUFjY2Vzcyl9JHtffT0ke199Y3VycmVudDske199cmV0dXJuICR7bm9Db25mbGljdEV4cG9ydHNWYXJpYWJsZX0ke3N9JHtffX07JHtufWAgK1xuICAgICAgICAgICAgICAgIGAke3R9fSkoKWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpaWZlRXhwb3J0ID0gYCR7ZmFjdG9yeVZhcmlhYmxlfSgke2dsb2JhbERlcHMuam9pbihgLCR7X31gKX0pYDtcbiAgICAgICAgaWYgKCFuYW1lZEV4cG9ydHNNb2RlICYmIGhhc0V4cG9ydHMpIHtcbiAgICAgICAgICAgIGlpZmVFeHBvcnQgPSBhc3NpZ25Ub0RlZXBWYXJpYWJsZShuYW1lLCBnbG9iYWxWYXJpYWJsZSwgZ2xvYmFscywgaWlmZUV4cG9ydCwgc25pcHBldHMsIGxvZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaWlmZU5lZWRzR2xvYmFsID0gaGFzRXhwb3J0cyB8fCAobm9Db25mbGljdCAmJiBuYW1lZEV4cG9ydHNNb2RlKSB8fCBnbG9iYWxEZXBzLmxlbmd0aCA+IDA7XG4gICAgY29uc3Qgd3JhcHBlclBhcmFtZXRlcnMgPSBbZmFjdG9yeVZhcmlhYmxlXTtcbiAgICBpZiAoaWlmZU5lZWRzR2xvYmFsKSB7XG4gICAgICAgIHdyYXBwZXJQYXJhbWV0ZXJzLnVuc2hpZnQoZ2xvYmFsVmFyaWFibGUpO1xuICAgIH1cbiAgICBjb25zdCBnbG9iYWxBcmd1bWVudCA9IGlpZmVOZWVkc0dsb2JhbCA/IGB0aGlzLCR7X31gIDogJyc7XG4gICAgY29uc3QgaWlmZVN0YXJ0ID0gaWlmZU5lZWRzR2xvYmFsXG4gICAgICAgID8gYCgke2dsb2JhbFZhcmlhYmxlfSR7X309JHtffXR5cGVvZiBnbG9iYWxUaGlzJHtffSE9PSR7X30ndW5kZWZpbmVkJyR7X30/JHtffWdsb2JhbFRoaXMke199OiR7X30ke2dsb2JhbFZhcmlhYmxlfSR7X318fCR7X31zZWxmLCR7X31gXG4gICAgICAgIDogJyc7XG4gICAgY29uc3QgaWlmZUVuZCA9IGlpZmVOZWVkc0dsb2JhbCA/ICcpJyA6ICcnO1xuICAgIGNvbnN0IGNqc0ludHJvID0gaWlmZU5lZWRzR2xvYmFsXG4gICAgICAgID8gYCR7dH10eXBlb2YgZXhwb3J0cyR7X309PT0ke199J29iamVjdCcke199JiYke199dHlwZW9mIG1vZHVsZSR7X30hPT0ke199J3VuZGVmaW5lZCcke199P2AgK1xuICAgICAgICAgICAgYCR7X30ke2Nqc0V4cG9ydH0ke2ZhY3RvcnlWYXJpYWJsZX0oJHtjanNEZXBzLmpvaW4oYCwke199YCl9KSR7X306JHtufWBcbiAgICAgICAgOiAnJztcbiAgICBjb25zdCB3cmFwcGVySW50cm8gPSBgKCR7Z2V0Tm9uQXJyb3dGdW5jdGlvbkludHJvKHdyYXBwZXJQYXJhbWV0ZXJzLCB7IGlzQXN5bmM6IGZhbHNlLCBuYW1lOiBudWxsIH0pfXske259YCArXG4gICAgICAgIGNqc0ludHJvICtcbiAgICAgICAgYCR7dH10eXBlb2YgJHtkZWZpbmV9JHtffT09PSR7X30nZnVuY3Rpb24nJHtffSYmJHtffSR7ZGVmaW5lfS5hbWQke199PyR7X30ke2RlZmluZX0oJHthbWRQYXJhbWV0ZXJzfSR7ZmFjdG9yeVZhcmlhYmxlfSkke199OiR7bn1gICtcbiAgICAgICAgYCR7dH0ke2lpZmVTdGFydH0ke2lpZmVFeHBvcnR9JHtpaWZlRW5kfTske259YCArXG4gICAgICAgIC8vIGZhY3RvcnkgZnVuY3Rpb24gc2hvdWxkIGJlIHdyYXBwZWQgYnkgcGFyZW50aGVzZXMgdG8gYXZvaWQgbGF6eSBwYXJzaW5nLFxuICAgICAgICAvLyBjZi4gaHR0cHM6Ly92OC5kZXYvYmxvZy9wcmVwYXJzZXIjcGlmZVxuICAgICAgICBgfSkoJHtnbG9iYWxBcmd1bWVudH0oJHtnZXROb25BcnJvd0Z1bmN0aW9uSW50cm8oZmFjdG9yeVBhcmFtZXRlcnMsIHtcbiAgICAgICAgICAgIGlzQXN5bmM6IGZhbHNlLFxuICAgICAgICAgICAgbmFtZTogbnVsbFxuICAgICAgICB9KX17JHt1c2VTdHJpY3R9JHtufWA7XG4gICAgY29uc3Qgd3JhcHBlck91dHJvID0gbiArIG4gKyAnfSkpOyc7XG4gICAgbWFnaWNTdHJpbmcucHJlcGVuZChgJHtpbnRyb30ke2dldEludGVyb3BCbG9jayhkZXBlbmRlbmNpZXMsIGludGVyb3AsIGV4dGVybmFsTGl2ZUJpbmRpbmdzLCBmcmVlemUsIHN5bWJvbHMsIGFjY2Vzc2VkR2xvYmFscywgdCwgc25pcHBldHMpfWApO1xuICAgIGNvbnN0IGV4cG9ydEJsb2NrID0gZ2V0RXhwb3J0QmxvY2skMShleHBvcnRzLCBkZXBlbmRlbmNpZXMsIG5hbWVkRXhwb3J0c01vZGUsIGludGVyb3AsIHNuaXBwZXRzLCB0LCBleHRlcm5hbExpdmVCaW5kaW5ncywgcmVleHBvcnRQcm90b0Zyb21FeHRlcm5hbCk7XG4gICAgbGV0IG5hbWVzcGFjZU1hcmtlcnMgPSBnZXROYW1lc3BhY2VNYXJrZXJzKG5hbWVkRXhwb3J0c01vZGUgJiYgaGFzRXhwb3J0cywgZXNNb2R1bGUgPT09IHRydWUgfHwgKGVzTW9kdWxlID09PSAnaWYtZGVmYXVsdC1wcm9wJyAmJiBoYXNEZWZhdWx0RXhwb3J0KSwgc3ltYm9scywgc25pcHBldHMpO1xuICAgIGlmIChuYW1lc3BhY2VNYXJrZXJzKSB7XG4gICAgICAgIG5hbWVzcGFjZU1hcmtlcnMgPSBuICsgbiArIG5hbWVzcGFjZU1hcmtlcnM7XG4gICAgfVxuICAgIG1hZ2ljU3RyaW5nXG4gICAgICAgIC5hcHBlbmQoYCR7ZXhwb3J0QmxvY2t9JHtuYW1lc3BhY2VNYXJrZXJzfSR7b3V0cm99YClcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAuaW5kZW50KHQpXG4gICAgICAgIC5hcHBlbmQod3JhcHBlck91dHJvKVxuICAgICAgICAucHJlcGVuZCh3cmFwcGVySW50cm8pO1xufVxuXG5jb25zdCBmaW5hbGlzZXJzID0geyBhbWQsIGNqcywgZXMsIGlpZmUsIHN5c3RlbSwgdW1kIH07XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbmZ1bmN0aW9uIGdldEF1Z21lbnRlZE5hbWVzcGFjZShuKSB7XG4gIGlmIChuLl9fZXNNb2R1bGUpIHJldHVybiBuO1xuICB2YXIgZiA9IG4uZGVmYXVsdDtcblx0aWYgKHR5cGVvZiBmID09IFwiZnVuY3Rpb25cIikge1xuXHRcdHZhciBhID0gZnVuY3Rpb24gYSAoKSB7XG5cdFx0XHRpZiAodGhpcyBpbnN0YW5jZW9mIGEpIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuY29uc3RydWN0KGYsIGFyZ3VtZW50cywgdGhpcy5jb25zdHJ1Y3Rvcik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0YS5wcm90b3R5cGUgPSBmLnByb3RvdHlwZTtcbiAgfSBlbHNlIGEgPSB7fTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsICdfX2VzTW9kdWxlJywge3ZhbHVlOiB0cnVlfSk7XG5cdE9iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0XHR2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobiwgayk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIGssIGQuZ2V0ID8gZCA6IHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIG5ba107XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRyZXR1cm4gYTtcbn1cblxudmFyIHV0aWxzID0ge307XG5cbnZhciBjb25zdGFudHM7XG52YXIgaGFzUmVxdWlyZWRDb25zdGFudHM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDb25zdGFudHMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRDb25zdGFudHMpIHJldHVybiBjb25zdGFudHM7XG5cdGhhc1JlcXVpcmVkQ29uc3RhbnRzID0gMTtcblxuXHRjb25zdCBXSU5fU0xBU0ggPSAnXFxcXFxcXFwvJztcblx0Y29uc3QgV0lOX05PX1NMQVNIID0gYFteJHtXSU5fU0xBU0h9XWA7XG5cblx0LyoqXG5cdCAqIFBvc2l4IGdsb2IgcmVnZXhcblx0ICovXG5cblx0Y29uc3QgRE9UX0xJVEVSQUwgPSAnXFxcXC4nO1xuXHRjb25zdCBQTFVTX0xJVEVSQUwgPSAnXFxcXCsnO1xuXHRjb25zdCBRTUFSS19MSVRFUkFMID0gJ1xcXFw/Jztcblx0Y29uc3QgU0xBU0hfTElURVJBTCA9ICdcXFxcLyc7XG5cdGNvbnN0IE9ORV9DSEFSID0gJyg/PS4pJztcblx0Y29uc3QgUU1BUksgPSAnW14vXSc7XG5cdGNvbnN0IEVORF9BTkNIT1IgPSBgKD86JHtTTEFTSF9MSVRFUkFMfXwkKWA7XG5cdGNvbnN0IFNUQVJUX0FOQ0hPUiA9IGAoPzpefCR7U0xBU0hfTElURVJBTH0pYDtcblx0Y29uc3QgRE9UU19TTEFTSCA9IGAke0RPVF9MSVRFUkFMfXsxLDJ9JHtFTkRfQU5DSE9SfWA7XG5cdGNvbnN0IE5PX0RPVCA9IGAoPyEke0RPVF9MSVRFUkFMfSlgO1xuXHRjb25zdCBOT19ET1RTID0gYCg/ISR7U1RBUlRfQU5DSE9SfSR7RE9UU19TTEFTSH0pYDtcblx0Y29uc3QgTk9fRE9UX1NMQVNIID0gYCg/ISR7RE9UX0xJVEVSQUx9ezAsMX0ke0VORF9BTkNIT1J9KWA7XG5cdGNvbnN0IE5PX0RPVFNfU0xBU0ggPSBgKD8hJHtET1RTX1NMQVNIfSlgO1xuXHRjb25zdCBRTUFSS19OT19ET1QgPSBgW14uJHtTTEFTSF9MSVRFUkFMfV1gO1xuXHRjb25zdCBTVEFSID0gYCR7UU1BUkt9Kj9gO1xuXHRjb25zdCBTRVAgPSAnLyc7XG5cblx0Y29uc3QgUE9TSVhfQ0hBUlMgPSB7XG5cdCAgRE9UX0xJVEVSQUwsXG5cdCAgUExVU19MSVRFUkFMLFxuXHQgIFFNQVJLX0xJVEVSQUwsXG5cdCAgU0xBU0hfTElURVJBTCxcblx0ICBPTkVfQ0hBUixcblx0ICBRTUFSSyxcblx0ICBFTkRfQU5DSE9SLFxuXHQgIERPVFNfU0xBU0gsXG5cdCAgTk9fRE9ULFxuXHQgIE5PX0RPVFMsXG5cdCAgTk9fRE9UX1NMQVNILFxuXHQgIE5PX0RPVFNfU0xBU0gsXG5cdCAgUU1BUktfTk9fRE9ULFxuXHQgIFNUQVIsXG5cdCAgU1RBUlRfQU5DSE9SLFxuXHQgIFNFUFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBXaW5kb3dzIGdsb2IgcmVnZXhcblx0ICovXG5cblx0Y29uc3QgV0lORE9XU19DSEFSUyA9IHtcblx0ICAuLi5QT1NJWF9DSEFSUyxcblxuXHQgIFNMQVNIX0xJVEVSQUw6IGBbJHtXSU5fU0xBU0h9XWAsXG5cdCAgUU1BUks6IFdJTl9OT19TTEFTSCxcblx0ICBTVEFSOiBgJHtXSU5fTk9fU0xBU0h9Kj9gLFxuXHQgIERPVFNfU0xBU0g6IGAke0RPVF9MSVRFUkFMfXsxLDJ9KD86WyR7V0lOX1NMQVNIfV18JClgLFxuXHQgIE5PX0RPVDogYCg/ISR7RE9UX0xJVEVSQUx9KWAsXG5cdCAgTk9fRE9UUzogYCg/ISg/Ol58WyR7V0lOX1NMQVNIfV0pJHtET1RfTElURVJBTH17MSwyfSg/Olske1dJTl9TTEFTSH1dfCQpKWAsXG5cdCAgTk9fRE9UX1NMQVNIOiBgKD8hJHtET1RfTElURVJBTH17MCwxfSg/Olske1dJTl9TTEFTSH1dfCQpKWAsXG5cdCAgTk9fRE9UU19TTEFTSDogYCg/ISR7RE9UX0xJVEVSQUx9ezEsMn0oPzpbJHtXSU5fU0xBU0h9XXwkKSlgLFxuXHQgIFFNQVJLX05PX0RPVDogYFteLiR7V0lOX1NMQVNIfV1gLFxuXHQgIFNUQVJUX0FOQ0hPUjogYCg/Ol58WyR7V0lOX1NMQVNIfV0pYCxcblx0ICBFTkRfQU5DSE9SOiBgKD86WyR7V0lOX1NMQVNIfV18JClgLFxuXHQgIFNFUDogJ1xcXFwnXG5cdH07XG5cblx0LyoqXG5cdCAqIFBPU0lYIEJyYWNrZXQgUmVnZXhcblx0ICovXG5cblx0Y29uc3QgUE9TSVhfUkVHRVhfU09VUkNFID0ge1xuXHQgIGFsbnVtOiAnYS16QS1aMC05Jyxcblx0ICBhbHBoYTogJ2EtekEtWicsXG5cdCAgYXNjaWk6ICdcXFxceDAwLVxcXFx4N0YnLFxuXHQgIGJsYW5rOiAnIFxcXFx0Jyxcblx0ICBjbnRybDogJ1xcXFx4MDAtXFxcXHgxRlxcXFx4N0YnLFxuXHQgIGRpZ2l0OiAnMC05Jyxcblx0ICBncmFwaDogJ1xcXFx4MjEtXFxcXHg3RScsXG5cdCAgbG93ZXI6ICdhLXonLFxuXHQgIHByaW50OiAnXFxcXHgyMC1cXFxceDdFICcsXG5cdCAgcHVuY3Q6ICdcXFxcLSFcIiMkJSZcXCcoKVxcXFwqKywuLzo7PD0+P0BbXFxcXF1eX2B7fH1+Jyxcblx0ICBzcGFjZTogJyBcXFxcdFxcXFxyXFxcXG5cXFxcdlxcXFxmJyxcblx0ICB1cHBlcjogJ0EtWicsXG5cdCAgd29yZDogJ0EtWmEtejAtOV8nLFxuXHQgIHhkaWdpdDogJ0EtRmEtZjAtOSdcblx0fTtcblxuXHRjb25zdGFudHMgPSB7XG5cdCAgTUFYX0xFTkdUSDogMTAyNCAqIDY0LFxuXHQgIFBPU0lYX1JFR0VYX1NPVVJDRSxcblxuXHQgIC8vIHJlZ3VsYXIgZXhwcmVzc2lvbnNcblx0ICBSRUdFWF9CQUNLU0xBU0g6IC9cXFxcKD8hWyorP14ke30ofClbXFxdXSkvZyxcblx0ICBSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzogL15bXkAhW1xcXS4sJCorP157fSgpfFxcXFwvXSsvLFxuXHQgIFJFR0VYX1NQRUNJQUxfQ0hBUlM6IC9bLSorPy5eJHt9KHwpW1xcXV0vLFxuXHQgIFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjogLyhcXFxcPykoKFxcVykoXFwzKikpL2csXG5cdCAgUkVHRVhfU1BFQ0lBTF9DSEFSU19HTE9CQUw6IC8oWy0qKz8uXiR7fSh8KVtcXF1dKS9nLFxuXHQgIFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6IC8oPzpcXFsuKj9bXlxcXFxdXFxdfFxcXFwoPz0uKSkvZyxcblxuXHQgIC8vIFJlcGxhY2UgZ2xvYnMgd2l0aCBlcXVpdmFsZW50IHBhdHRlcm5zIHRvIHJlZHVjZSBwYXJzaW5nIHRpbWUuXG5cdCAgUkVQTEFDRU1FTlRTOiB7XG5cdCAgICAnKioqJzogJyonLFxuXHQgICAgJyoqLyoqJzogJyoqJyxcblx0ICAgICcqKi8qKi8qKic6ICcqKidcblx0ICB9LFxuXG5cdCAgLy8gRGlnaXRzXG5cdCAgQ0hBUl8wOiA0OCwgLyogMCAqL1xuXHQgIENIQVJfOTogNTcsIC8qIDkgKi9cblxuXHQgIC8vIEFscGhhYmV0IGNoYXJzLlxuXHQgIENIQVJfVVBQRVJDQVNFX0E6IDY1LCAvKiBBICovXG5cdCAgQ0hBUl9MT1dFUkNBU0VfQTogOTcsIC8qIGEgKi9cblx0ICBDSEFSX1VQUEVSQ0FTRV9aOiA5MCwgLyogWiAqL1xuXHQgIENIQVJfTE9XRVJDQVNFX1o6IDEyMiwgLyogeiAqL1xuXG5cdCAgQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOiA0MCwgLyogKCAqL1xuXHQgIENIQVJfUklHSFRfUEFSRU5USEVTRVM6IDQxLCAvKiApICovXG5cblx0ICBDSEFSX0FTVEVSSVNLOiA0MiwgLyogKiAqL1xuXG5cdCAgLy8gTm9uLWFscGhhYmV0aWMgY2hhcnMuXG5cdCAgQ0hBUl9BTVBFUlNBTkQ6IDM4LCAvKiAmICovXG5cdCAgQ0hBUl9BVDogNjQsIC8qIEAgKi9cblx0ICBDSEFSX0JBQ0tXQVJEX1NMQVNIOiA5MiwgLyogXFwgKi9cblx0ICBDSEFSX0NBUlJJQUdFX1JFVFVSTjogMTMsIC8qIFxcciAqL1xuXHQgIENIQVJfQ0lSQ1VNRkxFWF9BQ0NFTlQ6IDk0LCAvKiBeICovXG5cdCAgQ0hBUl9DT0xPTjogNTgsIC8qIDogKi9cblx0ICBDSEFSX0NPTU1BOiA0NCwgLyogLCAqL1xuXHQgIENIQVJfRE9UOiA0NiwgLyogLiAqL1xuXHQgIENIQVJfRE9VQkxFX1FVT1RFOiAzNCwgLyogXCIgKi9cblx0ICBDSEFSX0VRVUFMOiA2MSwgLyogPSAqL1xuXHQgIENIQVJfRVhDTEFNQVRJT05fTUFSSzogMzMsIC8qICEgKi9cblx0ICBDSEFSX0ZPUk1fRkVFRDogMTIsIC8qIFxcZiAqL1xuXHQgIENIQVJfRk9SV0FSRF9TTEFTSDogNDcsIC8qIC8gKi9cblx0ICBDSEFSX0dSQVZFX0FDQ0VOVDogOTYsIC8qIGAgKi9cblx0ICBDSEFSX0hBU0g6IDM1LCAvKiAjICovXG5cdCAgQ0hBUl9IWVBIRU5fTUlOVVM6IDQ1LCAvKiAtICovXG5cdCAgQ0hBUl9MRUZUX0FOR0xFX0JSQUNLRVQ6IDYwLCAvKiA8ICovXG5cdCAgQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOiAxMjMsIC8qIHsgKi9cblx0ICBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQ6IDkxLCAvKiBbICovXG5cdCAgQ0hBUl9MSU5FX0ZFRUQ6IDEwLCAvKiBcXG4gKi9cblx0ICBDSEFSX05PX0JSRUFLX1NQQUNFOiAxNjAsIC8qIFxcdTAwQTAgKi9cblx0ICBDSEFSX1BFUkNFTlQ6IDM3LCAvKiAlICovXG5cdCAgQ0hBUl9QTFVTOiA0MywgLyogKyAqL1xuXHQgIENIQVJfUVVFU1RJT05fTUFSSzogNjMsIC8qID8gKi9cblx0ICBDSEFSX1JJR0hUX0FOR0xFX0JSQUNLRVQ6IDYyLCAvKiA+ICovXG5cdCAgQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTogMTI1LCAvKiB9ICovXG5cdCAgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDogOTMsIC8qIF0gKi9cblx0ICBDSEFSX1NFTUlDT0xPTjogNTksIC8qIDsgKi9cblx0ICBDSEFSX1NJTkdMRV9RVU9URTogMzksIC8qICcgKi9cblx0ICBDSEFSX1NQQUNFOiAzMiwgLyogICAqL1xuXHQgIENIQVJfVEFCOiA5LCAvKiBcXHQgKi9cblx0ICBDSEFSX1VOREVSU0NPUkU6IDk1LCAvKiBfICovXG5cdCAgQ0hBUl9WRVJUSUNBTF9MSU5FOiAxMjQsIC8qIHwgKi9cblx0ICBDSEFSX1pFUk9fV0lEVEhfTk9CUkVBS19TUEFDRTogNjUyNzksIC8qIFxcdUZFRkYgKi9cblxuXHQgIC8qKlxuXHQgICAqIENyZWF0ZSBFWFRHTE9CX0NIQVJTXG5cdCAgICovXG5cblx0ICBleHRnbG9iQ2hhcnMoY2hhcnMpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICchJzogeyB0eXBlOiAnbmVnYXRlJywgb3BlbjogJyg/Oig/ISg/OicsIGNsb3NlOiBgKSkke2NoYXJzLlNUQVJ9KWAgfSxcblx0ICAgICAgJz8nOiB7IHR5cGU6ICdxbWFyaycsIG9wZW46ICcoPzonLCBjbG9zZTogJyk/JyB9LFxuXHQgICAgICAnKyc6IHsgdHlwZTogJ3BsdXMnLCBvcGVuOiAnKD86JywgY2xvc2U6ICcpKycgfSxcblx0ICAgICAgJyonOiB7IHR5cGU6ICdzdGFyJywgb3BlbjogJyg/OicsIGNsb3NlOiAnKSonIH0sXG5cdCAgICAgICdAJzogeyB0eXBlOiAnYXQnLCBvcGVuOiAnKD86JywgY2xvc2U6ICcpJyB9XG5cdCAgICB9O1xuXHQgIH0sXG5cblx0ICAvKipcblx0ICAgKiBDcmVhdGUgR0xPQl9DSEFSU1xuXHQgICAqL1xuXG5cdCAgZ2xvYkNoYXJzKHdpbjMyKSB7XG5cdCAgICByZXR1cm4gd2luMzIgPT09IHRydWUgPyBXSU5ET1dTX0NIQVJTIDogUE9TSVhfQ0hBUlM7XG5cdCAgfVxuXHR9O1xuXHRyZXR1cm4gY29uc3RhbnRzO1xufVxuXG4vKmdsb2JhbCBuYXZpZ2F0b3IqL1xuXG52YXIgaGFzUmVxdWlyZWRVdGlscztcblxuZnVuY3Rpb24gcmVxdWlyZVV0aWxzICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkVXRpbHMpIHJldHVybiB1dGlscztcblx0aGFzUmVxdWlyZWRVdGlscyA9IDE7XG5cdChmdW5jdGlvbiAoZXhwb3J0cykge1xuXG5cdFx0Y29uc3Qge1xuXHRcdCAgUkVHRVhfQkFDS1NMQVNILFxuXHRcdCAgUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSCxcblx0XHQgIFJFR0VYX1NQRUNJQUxfQ0hBUlMsXG5cdFx0ICBSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTFxuXHRcdH0gPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVDb25zdGFudHMoKTtcblxuXHRcdGV4cG9ydHMuaXNPYmplY3QgPSB2YWwgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbCk7XG5cdFx0ZXhwb3J0cy5oYXNSZWdleENoYXJzID0gc3RyID0+IFJFR0VYX1NQRUNJQUxfQ0hBUlMudGVzdChzdHIpO1xuXHRcdGV4cG9ydHMuaXNSZWdleENoYXIgPSBzdHIgPT4gc3RyLmxlbmd0aCA9PT0gMSAmJiBleHBvcnRzLmhhc1JlZ2V4Q2hhcnMoc3RyKTtcblx0XHRleHBvcnRzLmVzY2FwZVJlZ2V4ID0gc3RyID0+IHN0ci5yZXBsYWNlKFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMLCAnXFxcXCQxJyk7XG5cdFx0ZXhwb3J0cy50b1Bvc2l4U2xhc2hlcyA9IHN0ciA9PiBzdHIucmVwbGFjZShSRUdFWF9CQUNLU0xBU0gsICcvJyk7XG5cblx0XHRleHBvcnRzLmlzV2luZG93cyA9ICgpID0+IHtcblx0XHQgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucGxhdGZvcm0pIHtcblx0XHQgICAgY29uc3QgcGxhdGZvcm0gPSBuYXZpZ2F0b3IucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcblx0XHQgICAgcmV0dXJuIHBsYXRmb3JtID09PSAnd2luMzInIHx8IHBsYXRmb3JtID09PSAnd2luZG93cyc7XG5cdFx0ICB9XG5cblx0XHQgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5wbGF0Zm9ybSkge1xuXHRcdCAgICByZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHRleHBvcnRzLnJlbW92ZUJhY2tzbGFzaGVzID0gc3RyID0+IHtcblx0XHQgIHJldHVybiBzdHIucmVwbGFjZShSRUdFWF9SRU1PVkVfQkFDS1NMQVNILCBtYXRjaCA9PiB7XG5cdFx0ICAgIHJldHVybiBtYXRjaCA9PT0gJ1xcXFwnID8gJycgOiBtYXRjaDtcblx0XHQgIH0pO1xuXHRcdH07XG5cblx0XHRleHBvcnRzLmVzY2FwZUxhc3QgPSAoaW5wdXQsIGNoYXIsIGxhc3RJZHgpID0+IHtcblx0XHQgIGNvbnN0IGlkeCA9IGlucHV0Lmxhc3RJbmRleE9mKGNoYXIsIGxhc3RJZHgpO1xuXHRcdCAgaWYgKGlkeCA9PT0gLTEpIHJldHVybiBpbnB1dDtcblx0XHQgIGlmIChpbnB1dFtpZHggLSAxXSA9PT0gJ1xcXFwnKSByZXR1cm4gZXhwb3J0cy5lc2NhcGVMYXN0KGlucHV0LCBjaGFyLCBpZHggLSAxKTtcblx0XHQgIHJldHVybiBgJHtpbnB1dC5zbGljZSgwLCBpZHgpfVxcXFwke2lucHV0LnNsaWNlKGlkeCl9YDtcblx0XHR9O1xuXG5cdFx0ZXhwb3J0cy5yZW1vdmVQcmVmaXggPSAoaW5wdXQsIHN0YXRlID0ge30pID0+IHtcblx0XHQgIGxldCBvdXRwdXQgPSBpbnB1dDtcblx0XHQgIGlmIChvdXRwdXQuc3RhcnRzV2l0aCgnLi8nKSkge1xuXHRcdCAgICBvdXRwdXQgPSBvdXRwdXQuc2xpY2UoMik7XG5cdFx0ICAgIHN0YXRlLnByZWZpeCA9ICcuLyc7XG5cdFx0ICB9XG5cdFx0ICByZXR1cm4gb3V0cHV0O1xuXHRcdH07XG5cblx0XHRleHBvcnRzLndyYXBPdXRwdXQgPSAoaW5wdXQsIHN0YXRlID0ge30sIG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRcdCAgY29uc3QgcHJlcGVuZCA9IG9wdGlvbnMuY29udGFpbnMgPyAnJyA6ICdeJztcblx0XHQgIGNvbnN0IGFwcGVuZCA9IG9wdGlvbnMuY29udGFpbnMgPyAnJyA6ICckJztcblxuXHRcdCAgbGV0IG91dHB1dCA9IGAke3ByZXBlbmR9KD86JHtpbnB1dH0pJHthcHBlbmR9YDtcblx0XHQgIGlmIChzdGF0ZS5uZWdhdGVkID09PSB0cnVlKSB7XG5cdFx0ICAgIG91dHB1dCA9IGAoPzpeKD8hJHtvdXRwdXR9KS4qJClgO1xuXHRcdCAgfVxuXHRcdCAgcmV0dXJuIG91dHB1dDtcblx0XHR9O1xuXG5cdFx0ZXhwb3J0cy5iYXNlbmFtZSA9IChwYXRoLCB7IHdpbmRvd3MgfSA9IHt9KSA9PiB7XG5cdFx0ICBjb25zdCBzZWdzID0gcGF0aC5zcGxpdCh3aW5kb3dzID8gL1tcXFxcL10vIDogJy8nKTtcblx0XHQgIGNvbnN0IGxhc3QgPSBzZWdzW3NlZ3MubGVuZ3RoIC0gMV07XG5cblx0XHQgIGlmIChsYXN0ID09PSAnJykge1xuXHRcdCAgICByZXR1cm4gc2Vnc1tzZWdzLmxlbmd0aCAtIDJdO1xuXHRcdCAgfVxuXG5cdFx0ICByZXR1cm4gbGFzdDtcblx0XHR9OyBcblx0fSAodXRpbHMpKTtcblx0cmV0dXJuIHV0aWxzO1xufVxuXG52YXIgc2Nhbl8xO1xudmFyIGhhc1JlcXVpcmVkU2NhbjtcblxuZnVuY3Rpb24gcmVxdWlyZVNjYW4gKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRTY2FuKSByZXR1cm4gc2Nhbl8xO1xuXHRoYXNSZXF1aXJlZFNjYW4gPSAxO1xuXG5cdGNvbnN0IHV0aWxzID0gLypAX19QVVJFX18qLyByZXF1aXJlVXRpbHMoKTtcblx0Y29uc3Qge1xuXHQgIENIQVJfQVNURVJJU0ssICAgICAgICAgICAgIC8qICogKi9cblx0ICBDSEFSX0FULCAgICAgICAgICAgICAgICAgICAvKiBAICovXG5cdCAgQ0hBUl9CQUNLV0FSRF9TTEFTSCwgICAgICAgLyogXFwgKi9cblx0ICBDSEFSX0NPTU1BLCAgICAgICAgICAgICAgICAvKiAsICovXG5cdCAgQ0hBUl9ET1QsICAgICAgICAgICAgICAgICAgLyogLiAqL1xuXHQgIENIQVJfRVhDTEFNQVRJT05fTUFSSywgICAgIC8qICEgKi9cblx0ICBDSEFSX0ZPUldBUkRfU0xBU0gsICAgICAgICAvKiAvICovXG5cdCAgQ0hBUl9MRUZUX0NVUkxZX0JSQUNFLCAgICAgLyogeyAqL1xuXHQgIENIQVJfTEVGVF9QQVJFTlRIRVNFUywgICAgIC8qICggKi9cblx0ICBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQsICAvKiBbICovXG5cdCAgQ0hBUl9QTFVTLCAgICAgICAgICAgICAgICAgLyogKyAqL1xuXHQgIENIQVJfUVVFU1RJT05fTUFSSywgICAgICAgIC8qID8gKi9cblx0ICBDSEFSX1JJR0hUX0NVUkxZX0JSQUNFLCAgICAvKiB9ICovXG5cdCAgQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUywgICAgLyogKSAqL1xuXHQgIENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQgIC8qIF0gKi9cblx0fSA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZUNvbnN0YW50cygpO1xuXG5cdGNvbnN0IGlzUGF0aFNlcGFyYXRvciA9IGNvZGUgPT4ge1xuXHQgIHJldHVybiBjb2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0ggfHwgY29kZSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSDtcblx0fTtcblxuXHRjb25zdCBkZXB0aCA9IHRva2VuID0+IHtcblx0ICBpZiAodG9rZW4uaXNQcmVmaXggIT09IHRydWUpIHtcblx0ICAgIHRva2VuLmRlcHRoID0gdG9rZW4uaXNHbG9ic3RhciA/IEluZmluaXR5IDogMTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFF1aWNrbHkgc2NhbnMgYSBnbG9iIHBhdHRlcm4gYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggYSBoYW5kZnVsIG9mXG5cdCAqIHVzZWZ1bCBwcm9wZXJ0aWVzLCBsaWtlIGBpc0dsb2JgLCBgcGF0aGAgKHRoZSBsZWFkaW5nIG5vbi1nbG9iLCBpZiBpdCBleGlzdHMpLFxuXHQgKiBgZ2xvYmAgKHRoZSBhY3R1YWwgcGF0dGVybiksIGBuZWdhdGVkYCAodHJ1ZSBpZiB0aGUgcGF0aCBzdGFydHMgd2l0aCBgIWAgYnV0IG5vdFxuXHQgKiB3aXRoIGAhKGApIGFuZCBgbmVnYXRlZEV4dGdsb2JgICh0cnVlIGlmIHRoZSBwYXRoIHN0YXJ0cyB3aXRoIGAhKGApLlxuXHQgKlxuXHQgKiBgYGBqc1xuXHQgKiBjb25zdCBwbSA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuXHQgKiBjb25zb2xlLmxvZyhwbS5zY2FuKCdmb28vYmFyLyouanMnKSk7XG5cdCAqIHsgaXNHbG9iOiB0cnVlLCBpbnB1dDogJ2Zvby9iYXIvKi5qcycsIGJhc2U6ICdmb28vYmFyJywgZ2xvYjogJyouanMnIH1cblx0ICogYGBgXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyYFxuXHQgKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG5cdCAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0b2tlbnMgYW5kIHJlZ2V4IHNvdXJjZSBzdHJpbmcuXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGNvbnN0IHNjYW4gPSAoaW5wdXQsIG9wdGlvbnMpID0+IHtcblx0ICBjb25zdCBvcHRzID0gb3B0aW9ucyB8fCB7fTtcblxuXHQgIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aCAtIDE7XG5cdCAgY29uc3Qgc2NhblRvRW5kID0gb3B0cy5wYXJ0cyA9PT0gdHJ1ZSB8fCBvcHRzLnNjYW5Ub0VuZCA9PT0gdHJ1ZTtcblx0ICBjb25zdCBzbGFzaGVzID0gW107XG5cdCAgY29uc3QgdG9rZW5zID0gW107XG5cdCAgY29uc3QgcGFydHMgPSBbXTtcblxuXHQgIGxldCBzdHIgPSBpbnB1dDtcblx0ICBsZXQgaW5kZXggPSAtMTtcblx0ICBsZXQgc3RhcnQgPSAwO1xuXHQgIGxldCBsYXN0SW5kZXggPSAwO1xuXHQgIGxldCBpc0JyYWNlID0gZmFsc2U7XG5cdCAgbGV0IGlzQnJhY2tldCA9IGZhbHNlO1xuXHQgIGxldCBpc0dsb2IgPSBmYWxzZTtcblx0ICBsZXQgaXNFeHRnbG9iID0gZmFsc2U7XG5cdCAgbGV0IGlzR2xvYnN0YXIgPSBmYWxzZTtcblx0ICBsZXQgYnJhY2VFc2NhcGVkID0gZmFsc2U7XG5cdCAgbGV0IGJhY2tzbGFzaGVzID0gZmFsc2U7XG5cdCAgbGV0IG5lZ2F0ZWQgPSBmYWxzZTtcblx0ICBsZXQgbmVnYXRlZEV4dGdsb2IgPSBmYWxzZTtcblx0ICBsZXQgZmluaXNoZWQgPSBmYWxzZTtcblx0ICBsZXQgYnJhY2VzID0gMDtcblx0ICBsZXQgcHJldjtcblx0ICBsZXQgY29kZTtcblx0ICBsZXQgdG9rZW4gPSB7IHZhbHVlOiAnJywgZGVwdGg6IDAsIGlzR2xvYjogZmFsc2UgfTtcblxuXHQgIGNvbnN0IGVvcyA9ICgpID0+IGluZGV4ID49IGxlbmd0aDtcblx0ICBjb25zdCBwZWVrID0gKCkgPT4gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblx0ICBjb25zdCBhZHZhbmNlID0gKCkgPT4ge1xuXHQgICAgcHJldiA9IGNvZGU7XG5cdCAgICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCk7XG5cdCAgfTtcblxuXHQgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgY29kZSA9IGFkdmFuY2UoKTtcblx0ICAgIGxldCBuZXh0O1xuXG5cdCAgICBpZiAoY29kZSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuXHQgICAgICBiYWNrc2xhc2hlcyA9IHRva2VuLmJhY2tzbGFzaGVzID0gdHJ1ZTtcblx0ICAgICAgY29kZSA9IGFkdmFuY2UoKTtcblxuXHQgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNFKSB7XG5cdCAgICAgICAgYnJhY2VFc2NhcGVkID0gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGJyYWNlRXNjYXBlZCA9PT0gdHJ1ZSB8fCBjb2RlID09PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0UpIHtcblx0ICAgICAgYnJhY2VzKys7XG5cblx0ICAgICAgd2hpbGUgKGVvcygpICE9PSB0cnVlICYmIChjb2RlID0gYWR2YW5jZSgpKSkge1xuXHQgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG5cdCAgICAgICAgICBiYWNrc2xhc2hlcyA9IHRva2VuLmJhY2tzbGFzaGVzID0gdHJ1ZTtcblx0ICAgICAgICAgIGFkdmFuY2UoKTtcblx0ICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0UpIHtcblx0ICAgICAgICAgIGJyYWNlcysrO1xuXHQgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGJyYWNlRXNjYXBlZCAhPT0gdHJ1ZSAmJiBjb2RlID09PSBDSEFSX0RPVCAmJiAoY29kZSA9IGFkdmFuY2UoKSkgPT09IENIQVJfRE9UKSB7XG5cdCAgICAgICAgICBpc0JyYWNlID0gdG9rZW4uaXNCcmFjZSA9IHRydWU7XG5cdCAgICAgICAgICBpc0dsb2IgPSB0b2tlbi5pc0dsb2IgPSB0cnVlO1xuXHQgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuXG5cdCAgICAgICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoYnJhY2VFc2NhcGVkICE9PSB0cnVlICYmIGNvZGUgPT09IENIQVJfQ09NTUEpIHtcblx0ICAgICAgICAgIGlzQnJhY2UgPSB0b2tlbi5pc0JyYWNlID0gdHJ1ZTtcblx0ICAgICAgICAgIGlzR2xvYiA9IHRva2VuLmlzR2xvYiA9IHRydWU7XG5cdCAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG5cblx0ICAgICAgICAgIGlmIChzY2FuVG9FbmQgPT09IHRydWUpIHtcblx0ICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChjb2RlID09PSBDSEFSX1JJR0hUX0NVUkxZX0JSQUNFKSB7XG5cdCAgICAgICAgICBicmFjZXMtLTtcblxuXHQgICAgICAgICAgaWYgKGJyYWNlcyA9PT0gMCkge1xuXHQgICAgICAgICAgICBicmFjZUVzY2FwZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgaXNCcmFjZSA9IHRva2VuLmlzQnJhY2UgPSB0cnVlO1xuXHQgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChzY2FuVG9FbmQgPT09IHRydWUpIHtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XG5cdCAgICAgIHNsYXNoZXMucHVzaChpbmRleCk7XG5cdCAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcblx0ICAgICAgdG9rZW4gPSB7IHZhbHVlOiAnJywgZGVwdGg6IDAsIGlzR2xvYjogZmFsc2UgfTtcblxuXHQgICAgICBpZiAoZmluaXNoZWQgPT09IHRydWUpIGNvbnRpbnVlO1xuXHQgICAgICBpZiAocHJldiA9PT0gQ0hBUl9ET1QgJiYgaW5kZXggPT09IChzdGFydCArIDEpKSB7XG5cdCAgICAgICAgc3RhcnQgKz0gMjtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cblx0ICAgIGlmIChvcHRzLm5vZXh0ICE9PSB0cnVlKSB7XG5cdCAgICAgIGNvbnN0IGlzRXh0Z2xvYkNoYXIgPSBjb2RlID09PSBDSEFSX1BMVVNcblx0ICAgICAgICB8fCBjb2RlID09PSBDSEFSX0FUXG5cdCAgICAgICAgfHwgY29kZSA9PT0gQ0hBUl9BU1RFUklTS1xuXHQgICAgICAgIHx8IGNvZGUgPT09IENIQVJfUVVFU1RJT05fTUFSS1xuXHQgICAgICAgIHx8IGNvZGUgPT09IENIQVJfRVhDTEFNQVRJT05fTUFSSztcblxuXHQgICAgICBpZiAoaXNFeHRnbG9iQ2hhciA9PT0gdHJ1ZSAmJiBwZWVrKCkgPT09IENIQVJfTEVGVF9QQVJFTlRIRVNFUykge1xuXHQgICAgICAgIGlzR2xvYiA9IHRva2VuLmlzR2xvYiA9IHRydWU7XG5cdCAgICAgICAgaXNFeHRnbG9iID0gdG9rZW4uaXNFeHRnbG9iID0gdHJ1ZTtcblx0ICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG5cdCAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfRVhDTEFNQVRJT05fTUFSSyAmJiBpbmRleCA9PT0gc3RhcnQpIHtcblx0ICAgICAgICAgIG5lZ2F0ZWRFeHRnbG9iID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG5cdCAgICAgICAgICB3aGlsZSAoZW9zKCkgIT09IHRydWUgJiYgKGNvZGUgPSBhZHZhbmNlKCkpKSB7XG5cdCAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG5cdCAgICAgICAgICAgICAgYmFja3NsYXNoZXMgPSB0b2tlbi5iYWNrc2xhc2hlcyA9IHRydWU7XG5cdCAgICAgICAgICAgICAgY29kZSA9IGFkdmFuY2UoKTtcblx0ICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX1JJR0hUX1BBUkVOVEhFU0VTKSB7XG5cdCAgICAgICAgICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoY29kZSA9PT0gQ0hBUl9BU1RFUklTSykge1xuXHQgICAgICBpZiAocHJldiA9PT0gQ0hBUl9BU1RFUklTSykgaXNHbG9ic3RhciA9IHRva2VuLmlzR2xvYnN0YXIgPSB0cnVlO1xuXHQgICAgICBpc0dsb2IgPSB0b2tlbi5pc0dsb2IgPSB0cnVlO1xuXHQgICAgICBmaW5pc2hlZCA9IHRydWU7XG5cblx0ICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICB9XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoY29kZSA9PT0gQ0hBUl9RVUVTVElPTl9NQVJLKSB7XG5cdCAgICAgIGlzR2xvYiA9IHRva2VuLmlzR2xvYiA9IHRydWU7XG5cdCAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcblxuXHQgICAgICBpZiAoc2NhblRvRW5kID09PSB0cnVlKSB7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblx0ICAgICAgYnJlYWs7XG5cdCAgICB9XG5cblx0ICAgIGlmIChjb2RlID09PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQpIHtcblx0ICAgICAgd2hpbGUgKGVvcygpICE9PSB0cnVlICYmIChuZXh0ID0gYWR2YW5jZSgpKSkge1xuXHQgICAgICAgIGlmIChuZXh0ID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG5cdCAgICAgICAgICBiYWNrc2xhc2hlcyA9IHRva2VuLmJhY2tzbGFzaGVzID0gdHJ1ZTtcblx0ICAgICAgICAgIGFkdmFuY2UoKTtcblx0ICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChuZXh0ID09PSBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUKSB7XG5cdCAgICAgICAgICBpc0JyYWNrZXQgPSB0b2tlbi5pc0JyYWNrZXQgPSB0cnVlO1xuXHQgICAgICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcblx0ICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChzY2FuVG9FbmQgPT09IHRydWUpIHtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXG5cdCAgICBpZiAob3B0cy5ub25lZ2F0ZSAhPT0gdHJ1ZSAmJiBjb2RlID09PSBDSEFSX0VYQ0xBTUFUSU9OX01BUksgJiYgaW5kZXggPT09IHN0YXJ0KSB7XG5cdCAgICAgIG5lZ2F0ZWQgPSB0b2tlbi5uZWdhdGVkID0gdHJ1ZTtcblx0ICAgICAgc3RhcnQrKztcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cblx0ICAgIGlmIChvcHRzLm5vcGFyZW4gIT09IHRydWUgJiYgY29kZSA9PT0gQ0hBUl9MRUZUX1BBUkVOVEhFU0VTKSB7XG5cdCAgICAgIGlzR2xvYiA9IHRva2VuLmlzR2xvYiA9IHRydWU7XG5cblx0ICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuXHQgICAgICAgIHdoaWxlIChlb3MoKSAhPT0gdHJ1ZSAmJiAoY29kZSA9IGFkdmFuY2UoKSkpIHtcblx0ICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0xFRlRfUEFSRU5USEVTRVMpIHtcblx0ICAgICAgICAgICAgYmFja3NsYXNoZXMgPSB0b2tlbi5iYWNrc2xhc2hlcyA9IHRydWU7XG5cdCAgICAgICAgICAgIGNvZGUgPSBhZHZhbmNlKCk7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUykge1xuXHQgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXHQgICAgICBicmVhaztcblx0ICAgIH1cblxuXHQgICAgaWYgKGlzR2xvYiA9PT0gdHJ1ZSkge1xuXHQgICAgICBmaW5pc2hlZCA9IHRydWU7XG5cblx0ICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKG9wdHMubm9leHQgPT09IHRydWUpIHtcblx0ICAgIGlzRXh0Z2xvYiA9IGZhbHNlO1xuXHQgICAgaXNHbG9iID0gZmFsc2U7XG5cdCAgfVxuXG5cdCAgbGV0IGJhc2UgPSBzdHI7XG5cdCAgbGV0IHByZWZpeCA9ICcnO1xuXHQgIGxldCBnbG9iID0gJyc7XG5cblx0ICBpZiAoc3RhcnQgPiAwKSB7XG5cdCAgICBwcmVmaXggPSBzdHIuc2xpY2UoMCwgc3RhcnQpO1xuXHQgICAgc3RyID0gc3RyLnNsaWNlKHN0YXJ0KTtcblx0ICAgIGxhc3RJbmRleCAtPSBzdGFydDtcblx0ICB9XG5cblx0ICBpZiAoYmFzZSAmJiBpc0dsb2IgPT09IHRydWUgJiYgbGFzdEluZGV4ID4gMCkge1xuXHQgICAgYmFzZSA9IHN0ci5zbGljZSgwLCBsYXN0SW5kZXgpO1xuXHQgICAgZ2xvYiA9IHN0ci5zbGljZShsYXN0SW5kZXgpO1xuXHQgIH0gZWxzZSBpZiAoaXNHbG9iID09PSB0cnVlKSB7XG5cdCAgICBiYXNlID0gJyc7XG5cdCAgICBnbG9iID0gc3RyO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBiYXNlID0gc3RyO1xuXHQgIH1cblxuXHQgIGlmIChiYXNlICYmIGJhc2UgIT09ICcnICYmIGJhc2UgIT09ICcvJyAmJiBiYXNlICE9PSBzdHIpIHtcblx0ICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoYmFzZS5jaGFyQ29kZUF0KGJhc2UubGVuZ3RoIC0gMSkpKSB7XG5cdCAgICAgIGJhc2UgPSBiYXNlLnNsaWNlKDAsIC0xKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAob3B0cy51bmVzY2FwZSA9PT0gdHJ1ZSkge1xuXHQgICAgaWYgKGdsb2IpIGdsb2IgPSB1dGlscy5yZW1vdmVCYWNrc2xhc2hlcyhnbG9iKTtcblxuXHQgICAgaWYgKGJhc2UgJiYgYmFja3NsYXNoZXMgPT09IHRydWUpIHtcblx0ICAgICAgYmFzZSA9IHV0aWxzLnJlbW92ZUJhY2tzbGFzaGVzKGJhc2UpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGNvbnN0IHN0YXRlID0ge1xuXHQgICAgcHJlZml4LFxuXHQgICAgaW5wdXQsXG5cdCAgICBzdGFydCxcblx0ICAgIGJhc2UsXG5cdCAgICBnbG9iLFxuXHQgICAgaXNCcmFjZSxcblx0ICAgIGlzQnJhY2tldCxcblx0ICAgIGlzR2xvYixcblx0ICAgIGlzRXh0Z2xvYixcblx0ICAgIGlzR2xvYnN0YXIsXG5cdCAgICBuZWdhdGVkLFxuXHQgICAgbmVnYXRlZEV4dGdsb2Jcblx0ICB9O1xuXG5cdCAgaWYgKG9wdHMudG9rZW5zID09PSB0cnVlKSB7XG5cdCAgICBzdGF0ZS5tYXhEZXB0aCA9IDA7XG5cdCAgICBpZiAoIWlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xuXHQgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG5cdCAgICB9XG5cdCAgICBzdGF0ZS50b2tlbnMgPSB0b2tlbnM7XG5cdCAgfVxuXG5cdCAgaWYgKG9wdHMucGFydHMgPT09IHRydWUgfHwgb3B0cy50b2tlbnMgPT09IHRydWUpIHtcblx0ICAgIGxldCBwcmV2SW5kZXg7XG5cblx0ICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNsYXNoZXMubGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICBjb25zdCBuID0gcHJldkluZGV4ID8gcHJldkluZGV4ICsgMSA6IHN0YXJ0O1xuXHQgICAgICBjb25zdCBpID0gc2xhc2hlc1tpZHhdO1xuXHQgICAgICBjb25zdCB2YWx1ZSA9IGlucHV0LnNsaWNlKG4sIGkpO1xuXHQgICAgICBpZiAob3B0cy50b2tlbnMpIHtcblx0ICAgICAgICBpZiAoaWR4ID09PSAwICYmIHN0YXJ0ICE9PSAwKSB7XG5cdCAgICAgICAgICB0b2tlbnNbaWR4XS5pc1ByZWZpeCA9IHRydWU7XG5cdCAgICAgICAgICB0b2tlbnNbaWR4XS52YWx1ZSA9IHByZWZpeDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdG9rZW5zW2lkeF0udmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZGVwdGgodG9rZW5zW2lkeF0pO1xuXHQgICAgICAgIHN0YXRlLm1heERlcHRoICs9IHRva2Vuc1tpZHhdLmRlcHRoO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChpZHggIT09IDAgfHwgdmFsdWUgIT09ICcnKSB7XG5cdCAgICAgICAgcGFydHMucHVzaCh2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgICAgcHJldkluZGV4ID0gaTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHByZXZJbmRleCAmJiBwcmV2SW5kZXggKyAxIDwgaW5wdXQubGVuZ3RoKSB7XG5cdCAgICAgIGNvbnN0IHZhbHVlID0gaW5wdXQuc2xpY2UocHJldkluZGV4ICsgMSk7XG5cdCAgICAgIHBhcnRzLnB1c2godmFsdWUpO1xuXG5cdCAgICAgIGlmIChvcHRzLnRva2Vucykge1xuXHQgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgICBkZXB0aCh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKTtcblx0ICAgICAgICBzdGF0ZS5tYXhEZXB0aCArPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLmRlcHRoO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHN0YXRlLnNsYXNoZXMgPSBzbGFzaGVzO1xuXHQgICAgc3RhdGUucGFydHMgPSBwYXJ0cztcblx0ICB9XG5cblx0ICByZXR1cm4gc3RhdGU7XG5cdH07XG5cblx0c2Nhbl8xID0gc2Nhbjtcblx0cmV0dXJuIHNjYW5fMTtcbn1cblxudmFyIHBhcnNlXzE7XG52YXIgaGFzUmVxdWlyZWRQYXJzZTtcblxuZnVuY3Rpb24gcmVxdWlyZVBhcnNlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkUGFyc2UpIHJldHVybiBwYXJzZV8xO1xuXHRoYXNSZXF1aXJlZFBhcnNlID0gMTtcblxuXHRjb25zdCBjb25zdGFudHMgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVDb25zdGFudHMoKTtcblx0Y29uc3QgdXRpbHMgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVVdGlscygpO1xuXG5cdC8qKlxuXHQgKiBDb25zdGFudHNcblx0ICovXG5cblx0Y29uc3Qge1xuXHQgIE1BWF9MRU5HVEgsXG5cdCAgUE9TSVhfUkVHRVhfU09VUkNFLFxuXHQgIFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTLFxuXHQgIFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRixcblx0ICBSRVBMQUNFTUVOVFNcblx0fSA9IGNvbnN0YW50cztcblxuXHQvKipcblx0ICogSGVscGVyc1xuXHQgKi9cblxuXHRjb25zdCBleHBhbmRSYW5nZSA9IChhcmdzLCBvcHRpb25zKSA9PiB7XG5cdCAgaWYgKHR5cGVvZiBvcHRpb25zLmV4cGFuZFJhbmdlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICByZXR1cm4gb3B0aW9ucy5leHBhbmRSYW5nZSguLi5hcmdzLCBvcHRpb25zKTtcblx0ICB9XG5cblx0ICBhcmdzLnNvcnQoKTtcblx0ICBjb25zdCB2YWx1ZSA9IGBbJHthcmdzLmpvaW4oJy0nKX1dYDtcblxuXHQgIHJldHVybiB2YWx1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIHRoZSBtZXNzYWdlIGZvciBhIHN5bnRheCBlcnJvclxuXHQgKi9cblxuXHRjb25zdCBzeW50YXhFcnJvciA9ICh0eXBlLCBjaGFyKSA9PiB7XG5cdCAgcmV0dXJuIGBNaXNzaW5nICR7dHlwZX06IFwiJHtjaGFyfVwiIC0gdXNlIFwiXFxcXFxcXFwke2NoYXJ9XCIgdG8gbWF0Y2ggbGl0ZXJhbCBjaGFyYWN0ZXJzYDtcblx0fTtcblxuXHQvKipcblx0ICogUGFyc2UgdGhlIGdpdmVuIGlucHV0IHN0cmluZy5cblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICovXG5cblx0Y29uc3QgcGFyc2UgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHtcblx0ICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcblx0ICB9XG5cblx0ICBpbnB1dCA9IFJFUExBQ0VNRU5UU1tpbnB1dF0gfHwgaW5wdXQ7XG5cblx0ICBjb25zdCBvcHRzID0geyAuLi5vcHRpb25zIH07XG5cdCAgY29uc3QgbWF4ID0gdHlwZW9mIG9wdHMubWF4TGVuZ3RoID09PSAnbnVtYmVyJyA/IE1hdGgubWluKE1BWF9MRU5HVEgsIG9wdHMubWF4TGVuZ3RoKSA6IE1BWF9MRU5HVEg7XG5cblx0ICBsZXQgbGVuID0gaW5wdXQubGVuZ3RoO1xuXHQgIGlmIChsZW4gPiBtYXgpIHtcblx0ICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke2xlbn0sIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIGxlbmd0aDogJHttYXh9YCk7XG5cdCAgfVxuXG5cdCAgY29uc3QgYm9zID0geyB0eXBlOiAnYm9zJywgdmFsdWU6ICcnLCBvdXRwdXQ6IG9wdHMucHJlcGVuZCB8fCAnJyB9O1xuXHQgIGNvbnN0IHRva2VucyA9IFtib3NdO1xuXG5cdCAgY29uc3QgY2FwdHVyZSA9IG9wdHMuY2FwdHVyZSA/ICcnIDogJz86JztcblxuXHQgIC8vIGNyZWF0ZSBjb25zdGFudHMgYmFzZWQgb24gcGxhdGZvcm0sIGZvciB3aW5kb3dzIG9yIHBvc2l4XG5cdCAgY29uc3QgUExBVEZPUk1fQ0hBUlMgPSBjb25zdGFudHMuZ2xvYkNoYXJzKG9wdHMud2luZG93cyk7XG5cdCAgY29uc3QgRVhUR0xPQl9DSEFSUyA9IGNvbnN0YW50cy5leHRnbG9iQ2hhcnMoUExBVEZPUk1fQ0hBUlMpO1xuXG5cdCAgY29uc3Qge1xuXHQgICAgRE9UX0xJVEVSQUwsXG5cdCAgICBQTFVTX0xJVEVSQUwsXG5cdCAgICBTTEFTSF9MSVRFUkFMLFxuXHQgICAgT05FX0NIQVIsXG5cdCAgICBET1RTX1NMQVNILFxuXHQgICAgTk9fRE9ULFxuXHQgICAgTk9fRE9UX1NMQVNILFxuXHQgICAgTk9fRE9UU19TTEFTSCxcblx0ICAgIFFNQVJLLFxuXHQgICAgUU1BUktfTk9fRE9ULFxuXHQgICAgU1RBUixcblx0ICAgIFNUQVJUX0FOQ0hPUlxuXHQgIH0gPSBQTEFURk9STV9DSEFSUztcblxuXHQgIGNvbnN0IGdsb2JzdGFyID0gb3B0cyA9PiB7XG5cdCAgICByZXR1cm4gYCgke2NhcHR1cmV9KD86KD8hJHtTVEFSVF9BTkNIT1J9JHtvcHRzLmRvdCA/IERPVFNfU0xBU0ggOiBET1RfTElURVJBTH0pLikqPylgO1xuXHQgIH07XG5cblx0ICBjb25zdCBub2RvdCA9IG9wdHMuZG90ID8gJycgOiBOT19ET1Q7XG5cdCAgY29uc3QgcW1hcmtOb0RvdCA9IG9wdHMuZG90ID8gUU1BUksgOiBRTUFSS19OT19ET1Q7XG5cdCAgbGV0IHN0YXIgPSBvcHRzLmJhc2ggPT09IHRydWUgPyBnbG9ic3RhcihvcHRzKSA6IFNUQVI7XG5cblx0ICBpZiAob3B0cy5jYXB0dXJlKSB7XG5cdCAgICBzdGFyID0gYCgke3N0YXJ9KWA7XG5cdCAgfVxuXG5cdCAgLy8gbWluaW1hdGNoIG9wdGlvbnMgc3VwcG9ydFxuXHQgIGlmICh0eXBlb2Ygb3B0cy5ub2V4dCA9PT0gJ2Jvb2xlYW4nKSB7XG5cdCAgICBvcHRzLm5vZXh0Z2xvYiA9IG9wdHMubm9leHQ7XG5cdCAgfVxuXG5cdCAgY29uc3Qgc3RhdGUgPSB7XG5cdCAgICBpbnB1dCxcblx0ICAgIGluZGV4OiAtMSxcblx0ICAgIHN0YXJ0OiAwLFxuXHQgICAgZG90OiBvcHRzLmRvdCA9PT0gdHJ1ZSxcblx0ICAgIGNvbnN1bWVkOiAnJyxcblx0ICAgIG91dHB1dDogJycsXG5cdCAgICBwcmVmaXg6ICcnLFxuXHQgICAgYmFja3RyYWNrOiBmYWxzZSxcblx0ICAgIG5lZ2F0ZWQ6IGZhbHNlLFxuXHQgICAgYnJhY2tldHM6IDAsXG5cdCAgICBicmFjZXM6IDAsXG5cdCAgICBwYXJlbnM6IDAsXG5cdCAgICBxdW90ZXM6IDAsXG5cdCAgICBnbG9ic3RhcjogZmFsc2UsXG5cdCAgICB0b2tlbnNcblx0ICB9O1xuXG5cdCAgaW5wdXQgPSB1dGlscy5yZW1vdmVQcmVmaXgoaW5wdXQsIHN0YXRlKTtcblx0ICBsZW4gPSBpbnB1dC5sZW5ndGg7XG5cblx0ICBjb25zdCBleHRnbG9icyA9IFtdO1xuXHQgIGNvbnN0IGJyYWNlcyA9IFtdO1xuXHQgIGNvbnN0IHN0YWNrID0gW107XG5cdCAgbGV0IHByZXYgPSBib3M7XG5cdCAgbGV0IHZhbHVlO1xuXG5cdCAgLyoqXG5cdCAgICogVG9rZW5pemluZyBoZWxwZXJzXG5cdCAgICovXG5cblx0ICBjb25zdCBlb3MgPSAoKSA9PiBzdGF0ZS5pbmRleCA9PT0gbGVuIC0gMTtcblx0ICBjb25zdCBwZWVrID0gc3RhdGUucGVlayA9IChuID0gMSkgPT4gaW5wdXRbc3RhdGUuaW5kZXggKyBuXTtcblx0ICBjb25zdCBhZHZhbmNlID0gc3RhdGUuYWR2YW5jZSA9ICgpID0+IGlucHV0Wysrc3RhdGUuaW5kZXhdIHx8ICcnO1xuXHQgIGNvbnN0IHJlbWFpbmluZyA9ICgpID0+IGlucHV0LnNsaWNlKHN0YXRlLmluZGV4ICsgMSk7XG5cdCAgY29uc3QgY29uc3VtZSA9ICh2YWx1ZSA9ICcnLCBudW0gPSAwKSA9PiB7XG5cdCAgICBzdGF0ZS5jb25zdW1lZCArPSB2YWx1ZTtcblx0ICAgIHN0YXRlLmluZGV4ICs9IG51bTtcblx0ICB9O1xuXG5cdCAgY29uc3QgYXBwZW5kID0gdG9rZW4gPT4ge1xuXHQgICAgc3RhdGUub3V0cHV0ICs9IHRva2VuLm91dHB1dCAhPSBudWxsID8gdG9rZW4ub3V0cHV0IDogdG9rZW4udmFsdWU7XG5cdCAgICBjb25zdW1lKHRva2VuLnZhbHVlKTtcblx0ICB9O1xuXG5cdCAgY29uc3QgbmVnYXRlID0gKCkgPT4ge1xuXHQgICAgbGV0IGNvdW50ID0gMTtcblxuXHQgICAgd2hpbGUgKHBlZWsoKSA9PT0gJyEnICYmIChwZWVrKDIpICE9PSAnKCcgfHwgcGVlaygzKSA9PT0gJz8nKSkge1xuXHQgICAgICBhZHZhbmNlKCk7XG5cdCAgICAgIHN0YXRlLnN0YXJ0Kys7XG5cdCAgICAgIGNvdW50Kys7XG5cdCAgICB9XG5cblx0ICAgIGlmIChjb3VudCAlIDIgPT09IDApIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICBzdGF0ZS5uZWdhdGVkID0gdHJ1ZTtcblx0ICAgIHN0YXRlLnN0YXJ0Kys7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9O1xuXG5cdCAgY29uc3QgaW5jcmVtZW50ID0gdHlwZSA9PiB7XG5cdCAgICBzdGF0ZVt0eXBlXSsrO1xuXHQgICAgc3RhY2sucHVzaCh0eXBlKTtcblx0ICB9O1xuXG5cdCAgY29uc3QgZGVjcmVtZW50ID0gdHlwZSA9PiB7XG5cdCAgICBzdGF0ZVt0eXBlXS0tO1xuXHQgICAgc3RhY2sucG9wKCk7XG5cdCAgfTtcblxuXHQgIC8qKlxuXHQgICAqIFB1c2ggdG9rZW5zIG9udG8gdGhlIHRva2VucyBhcnJheS4gVGhpcyBoZWxwZXIgc3BlZWRzIHVwXG5cdCAgICogdG9rZW5pemluZyBieSAxKSBoZWxwaW5nIHVzIGF2b2lkIGJhY2t0cmFja2luZyBhcyBtdWNoIGFzIHBvc3NpYmxlLFxuXHQgICAqIGFuZCAyKSBoZWxwaW5nIHVzIGF2b2lkIGNyZWF0aW5nIGV4dHJhIHRva2VucyB3aGVuIGNvbnNlY3V0aXZlXG5cdCAgICogY2hhcmFjdGVycyBhcmUgcGxhaW4gdGV4dC4gVGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBhbmQgc2ltcGxpZmllc1xuXHQgICAqIGxvb2tiZWhpbmRzLlxuXHQgICAqL1xuXG5cdCAgY29uc3QgcHVzaCA9IHRvayA9PiB7XG5cdCAgICBpZiAocHJldi50eXBlID09PSAnZ2xvYnN0YXInKSB7XG5cdCAgICAgIGNvbnN0IGlzQnJhY2UgPSBzdGF0ZS5icmFjZXMgPiAwICYmICh0b2sudHlwZSA9PT0gJ2NvbW1hJyB8fCB0b2sudHlwZSA9PT0gJ2JyYWNlJyk7XG5cdCAgICAgIGNvbnN0IGlzRXh0Z2xvYiA9IHRvay5leHRnbG9iID09PSB0cnVlIHx8IChleHRnbG9icy5sZW5ndGggJiYgKHRvay50eXBlID09PSAncGlwZScgfHwgdG9rLnR5cGUgPT09ICdwYXJlbicpKTtcblxuXHQgICAgICBpZiAodG9rLnR5cGUgIT09ICdzbGFzaCcgJiYgdG9rLnR5cGUgIT09ICdwYXJlbicgJiYgIWlzQnJhY2UgJiYgIWlzRXh0Z2xvYikge1xuXHQgICAgICAgIHN0YXRlLm91dHB1dCA9IHN0YXRlLm91dHB1dC5zbGljZSgwLCAtcHJldi5vdXRwdXQubGVuZ3RoKTtcblx0ICAgICAgICBwcmV2LnR5cGUgPSAnc3Rhcic7XG5cdCAgICAgICAgcHJldi52YWx1ZSA9ICcqJztcblx0ICAgICAgICBwcmV2Lm91dHB1dCA9IHN0YXI7XG5cdCAgICAgICAgc3RhdGUub3V0cHV0ICs9IHByZXYub3V0cHV0O1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChleHRnbG9icy5sZW5ndGggJiYgdG9rLnR5cGUgIT09ICdwYXJlbicpIHtcblx0ICAgICAgZXh0Z2xvYnNbZXh0Z2xvYnMubGVuZ3RoIC0gMV0uaW5uZXIgKz0gdG9rLnZhbHVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodG9rLnZhbHVlIHx8IHRvay5vdXRwdXQpIGFwcGVuZCh0b2spO1xuXHQgICAgaWYgKHByZXYgJiYgcHJldi50eXBlID09PSAndGV4dCcgJiYgdG9rLnR5cGUgPT09ICd0ZXh0Jykge1xuXHQgICAgICBwcmV2Lm91dHB1dCA9IChwcmV2Lm91dHB1dCB8fCBwcmV2LnZhbHVlKSArIHRvay52YWx1ZTtcblx0ICAgICAgcHJldi52YWx1ZSArPSB0b2sudmFsdWU7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdG9rLnByZXYgPSBwcmV2O1xuXHQgICAgdG9rZW5zLnB1c2godG9rKTtcblx0ICAgIHByZXYgPSB0b2s7XG5cdCAgfTtcblxuXHQgIGNvbnN0IGV4dGdsb2JPcGVuID0gKHR5cGUsIHZhbHVlKSA9PiB7XG5cdCAgICBjb25zdCB0b2tlbiA9IHsgLi4uRVhUR0xPQl9DSEFSU1t2YWx1ZV0sIGNvbmRpdGlvbnM6IDEsIGlubmVyOiAnJyB9O1xuXG5cdCAgICB0b2tlbi5wcmV2ID0gcHJldjtcblx0ICAgIHRva2VuLnBhcmVucyA9IHN0YXRlLnBhcmVucztcblx0ICAgIHRva2VuLm91dHB1dCA9IHN0YXRlLm91dHB1dDtcblx0ICAgIGNvbnN0IG91dHB1dCA9IChvcHRzLmNhcHR1cmUgPyAnKCcgOiAnJykgKyB0b2tlbi5vcGVuO1xuXG5cdCAgICBpbmNyZW1lbnQoJ3BhcmVucycpO1xuXHQgICAgcHVzaCh7IHR5cGUsIHZhbHVlLCBvdXRwdXQ6IHN0YXRlLm91dHB1dCA/ICcnIDogT05FX0NIQVIgfSk7XG5cdCAgICBwdXNoKHsgdHlwZTogJ3BhcmVuJywgZXh0Z2xvYjogdHJ1ZSwgdmFsdWU6IGFkdmFuY2UoKSwgb3V0cHV0IH0pO1xuXHQgICAgZXh0Z2xvYnMucHVzaCh0b2tlbik7XG5cdCAgfTtcblxuXHQgIGNvbnN0IGV4dGdsb2JDbG9zZSA9IHRva2VuID0+IHtcblx0ICAgIGxldCBvdXRwdXQgPSB0b2tlbi5jbG9zZSArIChvcHRzLmNhcHR1cmUgPyAnKScgOiAnJyk7XG5cdCAgICBsZXQgcmVzdDtcblxuXHQgICAgaWYgKHRva2VuLnR5cGUgPT09ICduZWdhdGUnKSB7XG5cdCAgICAgIGxldCBleHRnbG9iU3RhciA9IHN0YXI7XG5cblx0ICAgICAgaWYgKHRva2VuLmlubmVyICYmIHRva2VuLmlubmVyLmxlbmd0aCA+IDEgJiYgdG9rZW4uaW5uZXIuaW5jbHVkZXMoJy8nKSkge1xuXHQgICAgICAgIGV4dGdsb2JTdGFyID0gZ2xvYnN0YXIob3B0cyk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoZXh0Z2xvYlN0YXIgIT09IHN0YXIgfHwgZW9zKCkgfHwgL15cXCkrJC8udGVzdChyZW1haW5pbmcoKSkpIHtcblx0ICAgICAgICBvdXRwdXQgPSB0b2tlbi5jbG9zZSA9IGApJCkpJHtleHRnbG9iU3Rhcn1gO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHRva2VuLmlubmVyLmluY2x1ZGVzKCcqJykgJiYgKHJlc3QgPSByZW1haW5pbmcoKSkgJiYgL15cXC5bXlxcXFwvLl0rJC8udGVzdChyZXN0KSkge1xuXHQgICAgICAgIC8vIEFueSBub24tbWFnaWNhbCBzdHJpbmcgKGAudHNgKSBvciBldmVuIG5lc3RlZCBleHByZXNzaW9uIChgLnt0cyx0c3h9YCkgY2FuIGZvbGxvdyBhZnRlciB0aGUgY2xvc2luZyBwYXJlbnRoZXNpcy5cblx0ICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIG5lZWQgdG8gcGFyc2UgdGhlIHN0cmluZyBhbmQgdXNlIGl0IGluIHRoZSBvdXRwdXQgb2YgdGhlIG9yaWdpbmFsIHBhdHRlcm4uXG5cdCAgICAgICAgLy8gU3VpdGFibGUgcGF0dGVybnM6IGAvISgqLmQpLnRzYCwgYC8hKCouZCkue3RzLHRzeH1gLCBgKiovISgqLWRiZykuQChqcylgLlxuXHQgICAgICAgIC8vXG5cdCAgICAgICAgLy8gRGlzYWJsaW5nIHRoZSBgZmFzdHBhdGhzYCBvcHRpb24gZHVlIHRvIGEgcHJvYmxlbSB3aXRoIHBhcnNpbmcgc3RyaW5ncyBhcyBgLnRzYCBpbiB0aGUgcGF0dGVybiBsaWtlIGAqKi8hKCouZCkudHNgLlxuXHQgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBwYXJzZShyZXN0LCB7IC4uLm9wdGlvbnMsIGZhc3RwYXRoczogZmFsc2UgfSkub3V0cHV0O1xuXG5cdCAgICAgICAgb3V0cHV0ID0gdG9rZW4uY2xvc2UgPSBgKSR7ZXhwcmVzc2lvbn0pJHtleHRnbG9iU3Rhcn0pYDtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0b2tlbi5wcmV2LnR5cGUgPT09ICdib3MnKSB7XG5cdCAgICAgICAgc3RhdGUubmVnYXRlZEV4dGdsb2IgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHB1c2goeyB0eXBlOiAncGFyZW4nLCBleHRnbG9iOiB0cnVlLCB2YWx1ZSwgb3V0cHV0IH0pO1xuXHQgICAgZGVjcmVtZW50KCdwYXJlbnMnKTtcblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogRmFzdCBwYXRoc1xuXHQgICAqL1xuXG5cdCAgaWYgKG9wdHMuZmFzdHBhdGhzICE9PSBmYWxzZSAmJiAhLyheWyohXXxbLygpW1xcXXt9XCJdKS8udGVzdChpbnB1dCkpIHtcblx0ICAgIGxldCBiYWNrc2xhc2hlcyA9IGZhbHNlO1xuXG5cdCAgICBsZXQgb3V0cHV0ID0gaW5wdXQucmVwbGFjZShSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUYsIChtLCBlc2MsIGNoYXJzLCBmaXJzdCwgcmVzdCwgaW5kZXgpID0+IHtcblx0ICAgICAgaWYgKGZpcnN0ID09PSAnXFxcXCcpIHtcblx0ICAgICAgICBiYWNrc2xhc2hlcyA9IHRydWU7XG5cdCAgICAgICAgcmV0dXJuIG07XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoZmlyc3QgPT09ICc/Jykge1xuXHQgICAgICAgIGlmIChlc2MpIHtcblx0ICAgICAgICAgIHJldHVybiBlc2MgKyBmaXJzdCArIChyZXN0ID8gUU1BUksucmVwZWF0KHJlc3QubGVuZ3RoKSA6ICcnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG5cdCAgICAgICAgICByZXR1cm4gcW1hcmtOb0RvdCArIChyZXN0ID8gUU1BUksucmVwZWF0KHJlc3QubGVuZ3RoKSA6ICcnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFFNQVJLLnJlcGVhdChjaGFycy5sZW5ndGgpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGZpcnN0ID09PSAnLicpIHtcblx0ICAgICAgICByZXR1cm4gRE9UX0xJVEVSQUwucmVwZWF0KGNoYXJzLmxlbmd0aCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoZmlyc3QgPT09ICcqJykge1xuXHQgICAgICAgIGlmIChlc2MpIHtcblx0ICAgICAgICAgIHJldHVybiBlc2MgKyBmaXJzdCArIChyZXN0ID8gc3RhciA6ICcnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHN0YXI7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGVzYyA/IG0gOiBgXFxcXCR7bX1gO1xuXHQgICAgfSk7XG5cblx0ICAgIGlmIChiYWNrc2xhc2hlcyA9PT0gdHJ1ZSkge1xuXHQgICAgICBpZiAob3B0cy51bmVzY2FwZSA9PT0gdHJ1ZSkge1xuXHQgICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSgvXFxcXCsvZywgbSA9PiB7XG5cdCAgICAgICAgICByZXR1cm4gbS5sZW5ndGggJSAyID09PSAwID8gJ1xcXFxcXFxcJyA6IChtID8gJ1xcXFwnIDogJycpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChvdXRwdXQgPT09IGlucHV0ICYmIG9wdHMuY29udGFpbnMgPT09IHRydWUpIHtcblx0ICAgICAgc3RhdGUub3V0cHV0ID0gaW5wdXQ7XG5cdCAgICAgIHJldHVybiBzdGF0ZTtcblx0ICAgIH1cblxuXHQgICAgc3RhdGUub3V0cHV0ID0gdXRpbHMud3JhcE91dHB1dChvdXRwdXQsIHN0YXRlLCBvcHRpb25zKTtcblx0ICAgIHJldHVybiBzdGF0ZTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBUb2tlbml6ZSBpbnB1dCB1bnRpbCB3ZSByZWFjaCBlbmQtb2Ytc3RyaW5nXG5cdCAgICovXG5cblx0ICB3aGlsZSAoIWVvcygpKSB7XG5cdCAgICB2YWx1ZSA9IGFkdmFuY2UoKTtcblxuXHQgICAgaWYgKHZhbHVlID09PSAnXFx1MDAwMCcpIHtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogRXNjYXBlZCBjaGFyYWN0ZXJzXG5cdCAgICAgKi9cblxuXHQgICAgaWYgKHZhbHVlID09PSAnXFxcXCcpIHtcblx0ICAgICAgY29uc3QgbmV4dCA9IHBlZWsoKTtcblxuXHQgICAgICBpZiAobmV4dCA9PT0gJy8nICYmIG9wdHMuYmFzaCAhPT0gdHJ1ZSkge1xuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKG5leHQgPT09ICcuJyB8fCBuZXh0ID09PSAnOycpIHtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICghbmV4dCkge1xuXHQgICAgICAgIHZhbHVlICs9ICdcXFxcJztcblx0ICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9KTtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIGNvbGxhcHNlIHNsYXNoZXMgdG8gcmVkdWNlIHBvdGVudGlhbCBmb3IgZXhwbG9pdHNcblx0ICAgICAgY29uc3QgbWF0Y2ggPSAvXlxcXFwrLy5leGVjKHJlbWFpbmluZygpKTtcblx0ICAgICAgbGV0IHNsYXNoZXMgPSAwO1xuXG5cdCAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFswXS5sZW5ndGggPiAyKSB7XG5cdCAgICAgICAgc2xhc2hlcyA9IG1hdGNoWzBdLmxlbmd0aDtcblx0ICAgICAgICBzdGF0ZS5pbmRleCArPSBzbGFzaGVzO1xuXHQgICAgICAgIGlmIChzbGFzaGVzICUgMiAhPT0gMCkge1xuXHQgICAgICAgICAgdmFsdWUgKz0gJ1xcXFwnO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChvcHRzLnVuZXNjYXBlID09PSB0cnVlKSB7XG5cdCAgICAgICAgdmFsdWUgPSBhZHZhbmNlKCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFsdWUgKz0gYWR2YW5jZSgpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHN0YXRlLmJyYWNrZXRzID09PSAwKSB7XG5cdCAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBJZiB3ZSdyZSBpbnNpZGUgYSByZWdleCBjaGFyYWN0ZXIgY2xhc3MsIGNvbnRpbnVlXG5cdCAgICAgKiB1bnRpbCB3ZSByZWFjaCB0aGUgY2xvc2luZyBicmFja2V0LlxuXHQgICAgICovXG5cblx0ICAgIGlmIChzdGF0ZS5icmFja2V0cyA+IDAgJiYgKHZhbHVlICE9PSAnXScgfHwgcHJldi52YWx1ZSA9PT0gJ1snIHx8IHByZXYudmFsdWUgPT09ICdbXicpKSB7XG5cdCAgICAgIGlmIChvcHRzLnBvc2l4ICE9PSBmYWxzZSAmJiB2YWx1ZSA9PT0gJzonKSB7XG5cdCAgICAgICAgY29uc3QgaW5uZXIgPSBwcmV2LnZhbHVlLnNsaWNlKDEpO1xuXHQgICAgICAgIGlmIChpbm5lci5pbmNsdWRlcygnWycpKSB7XG5cdCAgICAgICAgICBwcmV2LnBvc2l4ID0gdHJ1ZTtcblxuXHQgICAgICAgICAgaWYgKGlubmVyLmluY2x1ZGVzKCc6JykpIHtcblx0ICAgICAgICAgICAgY29uc3QgaWR4ID0gcHJldi52YWx1ZS5sYXN0SW5kZXhPZignWycpO1xuXHQgICAgICAgICAgICBjb25zdCBwcmUgPSBwcmV2LnZhbHVlLnNsaWNlKDAsIGlkeCk7XG5cdCAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBwcmV2LnZhbHVlLnNsaWNlKGlkeCArIDIpO1xuXHQgICAgICAgICAgICBjb25zdCBwb3NpeCA9IFBPU0lYX1JFR0VYX1NPVVJDRVtyZXN0XTtcblx0ICAgICAgICAgICAgaWYgKHBvc2l4KSB7XG5cdCAgICAgICAgICAgICAgcHJldi52YWx1ZSA9IHByZSArIHBvc2l4O1xuXHQgICAgICAgICAgICAgIHN0YXRlLmJhY2t0cmFjayA9IHRydWU7XG5cdCAgICAgICAgICAgICAgYWR2YW5jZSgpO1xuXG5cdCAgICAgICAgICAgICAgaWYgKCFib3Mub3V0cHV0ICYmIHRva2Vucy5pbmRleE9mKHByZXYpID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICBib3Mub3V0cHV0ID0gT05FX0NIQVI7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKCh2YWx1ZSA9PT0gJ1snICYmIHBlZWsoKSAhPT0gJzonKSB8fCAodmFsdWUgPT09ICctJyAmJiBwZWVrKCkgPT09ICddJykpIHtcblx0ICAgICAgICB2YWx1ZSA9IGBcXFxcJHt2YWx1ZX1gO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHZhbHVlID09PSAnXScgJiYgKHByZXYudmFsdWUgPT09ICdbJyB8fCBwcmV2LnZhbHVlID09PSAnW14nKSkge1xuXHQgICAgICAgIHZhbHVlID0gYFxcXFwke3ZhbHVlfWA7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAob3B0cy5wb3NpeCA9PT0gdHJ1ZSAmJiB2YWx1ZSA9PT0gJyEnICYmIHByZXYudmFsdWUgPT09ICdbJykge1xuXHQgICAgICAgIHZhbHVlID0gJ14nO1xuXHQgICAgICB9XG5cblx0ICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcblx0ICAgICAgYXBwZW5kKHsgdmFsdWUgfSk7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIElmIHdlJ3JlIGluc2lkZSBhIHF1b3RlZCBzdHJpbmcsIGNvbnRpbnVlXG5cdCAgICAgKiB1bnRpbCB3ZSByZWFjaCB0aGUgY2xvc2luZyBkb3VibGUgcXVvdGUuXG5cdCAgICAgKi9cblxuXHQgICAgaWYgKHN0YXRlLnF1b3RlcyA9PT0gMSAmJiB2YWx1ZSAhPT0gJ1wiJykge1xuXHQgICAgICB2YWx1ZSA9IHV0aWxzLmVzY2FwZVJlZ2V4KHZhbHVlKTtcblx0ICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcblx0ICAgICAgYXBwZW5kKHsgdmFsdWUgfSk7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIERvdWJsZSBxdW90ZXNcblx0ICAgICAqL1xuXG5cdCAgICBpZiAodmFsdWUgPT09ICdcIicpIHtcblx0ICAgICAgc3RhdGUucXVvdGVzID0gc3RhdGUucXVvdGVzID09PSAxID8gMCA6IDE7XG5cdCAgICAgIGlmIChvcHRzLmtlZXBRdW90ZXMgPT09IHRydWUpIHtcblx0ICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9KTtcblx0ICAgICAgfVxuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBQYXJlbnRoZXNlc1xuXHQgICAgICovXG5cblx0ICAgIGlmICh2YWx1ZSA9PT0gJygnKSB7XG5cdCAgICAgIGluY3JlbWVudCgncGFyZW5zJyk7XG5cdCAgICAgIHB1c2goeyB0eXBlOiAncGFyZW4nLCB2YWx1ZSB9KTtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cblx0ICAgIGlmICh2YWx1ZSA9PT0gJyknKSB7XG5cdCAgICAgIGlmIChzdGF0ZS5wYXJlbnMgPT09IDAgJiYgb3B0cy5zdHJpY3RCcmFja2V0cyA9PT0gdHJ1ZSkge1xuXHQgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcignb3BlbmluZycsICcoJykpO1xuXHQgICAgICB9XG5cblx0ICAgICAgY29uc3QgZXh0Z2xvYiA9IGV4dGdsb2JzW2V4dGdsb2JzLmxlbmd0aCAtIDFdO1xuXHQgICAgICBpZiAoZXh0Z2xvYiAmJiBzdGF0ZS5wYXJlbnMgPT09IGV4dGdsb2IucGFyZW5zICsgMSkge1xuXHQgICAgICAgIGV4dGdsb2JDbG9zZShleHRnbG9icy5wb3AoKSk7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBwdXNoKHsgdHlwZTogJ3BhcmVuJywgdmFsdWUsIG91dHB1dDogc3RhdGUucGFyZW5zID8gJyknIDogJ1xcXFwpJyB9KTtcblx0ICAgICAgZGVjcmVtZW50KCdwYXJlbnMnKTtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogU3F1YXJlIGJyYWNrZXRzXG5cdCAgICAgKi9cblxuXHQgICAgaWYgKHZhbHVlID09PSAnWycpIHtcblx0ICAgICAgaWYgKG9wdHMubm9icmFja2V0ID09PSB0cnVlIHx8ICFyZW1haW5pbmcoKS5pbmNsdWRlcygnXScpKSB7XG5cdCAgICAgICAgaWYgKG9wdHMubm9icmFja2V0ICE9PSB0cnVlICYmIG9wdHMuc3RyaWN0QnJhY2tldHMgPT09IHRydWUpIHtcblx0ICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcignY2xvc2luZycsICddJykpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhbHVlID0gYFxcXFwke3ZhbHVlfWA7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaW5jcmVtZW50KCdicmFja2V0cycpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcHVzaCh7IHR5cGU6ICdicmFja2V0JywgdmFsdWUgfSk7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodmFsdWUgPT09ICddJykge1xuXHQgICAgICBpZiAob3B0cy5ub2JyYWNrZXQgPT09IHRydWUgfHwgKHByZXYgJiYgcHJldi50eXBlID09PSAnYnJhY2tldCcgJiYgcHJldi52YWx1ZS5sZW5ndGggPT09IDEpKSB7XG5cdCAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUsIG91dHB1dDogYFxcXFwke3ZhbHVlfWAgfSk7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoc3RhdGUuYnJhY2tldHMgPT09IDApIHtcblx0ICAgICAgICBpZiAob3B0cy5zdHJpY3RCcmFja2V0cyA9PT0gdHJ1ZSkge1xuXHQgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKCdvcGVuaW5nJywgJ1snKSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUsIG91dHB1dDogYFxcXFwke3ZhbHVlfWAgfSk7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBkZWNyZW1lbnQoJ2JyYWNrZXRzJyk7XG5cblx0ICAgICAgY29uc3QgcHJldlZhbHVlID0gcHJldi52YWx1ZS5zbGljZSgxKTtcblx0ICAgICAgaWYgKHByZXYucG9zaXggIT09IHRydWUgJiYgcHJldlZhbHVlWzBdID09PSAnXicgJiYgIXByZXZWYWx1ZS5pbmNsdWRlcygnLycpKSB7XG5cdCAgICAgICAgdmFsdWUgPSBgLyR7dmFsdWV9YDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG5cdCAgICAgIGFwcGVuZCh7IHZhbHVlIH0pO1xuXG5cdCAgICAgIC8vIHdoZW4gbGl0ZXJhbCBicmFja2V0cyBhcmUgZXhwbGljaXRseSBkaXNhYmxlZFxuXHQgICAgICAvLyBhc3N1bWUgd2Ugc2hvdWxkIG1hdGNoIHdpdGggYSByZWdleCBjaGFyYWN0ZXIgY2xhc3Ncblx0ICAgICAgaWYgKG9wdHMubGl0ZXJhbEJyYWNrZXRzID09PSBmYWxzZSB8fCB1dGlscy5oYXNSZWdleENoYXJzKHByZXZWYWx1ZSkpIHtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGNvbnN0IGVzY2FwZWQgPSB1dGlscy5lc2NhcGVSZWdleChwcmV2LnZhbHVlKTtcblx0ICAgICAgc3RhdGUub3V0cHV0ID0gc3RhdGUub3V0cHV0LnNsaWNlKDAsIC1wcmV2LnZhbHVlLmxlbmd0aCk7XG5cblx0ICAgICAgLy8gd2hlbiBsaXRlcmFsIGJyYWNrZXRzIGFyZSBleHBsaWNpdGx5IGVuYWJsZWRcblx0ICAgICAgLy8gYXNzdW1lIHdlIHNob3VsZCBlc2NhcGUgdGhlIGJyYWNrZXRzIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc1xuXHQgICAgICBpZiAob3B0cy5saXRlcmFsQnJhY2tldHMgPT09IHRydWUpIHtcblx0ICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gZXNjYXBlZDtcblx0ICAgICAgICBwcmV2LnZhbHVlID0gZXNjYXBlZDtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIHdoZW4gdGhlIHVzZXIgc3BlY2lmaWVzIG5vdGhpbmcsIHRyeSB0byBtYXRjaCBib3RoXG5cdCAgICAgIHByZXYudmFsdWUgPSBgKCR7Y2FwdHVyZX0ke2VzY2FwZWR9fCR7cHJldi52YWx1ZX0pYDtcblx0ICAgICAgc3RhdGUub3V0cHV0ICs9IHByZXYudmFsdWU7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIEJyYWNlc1xuXHQgICAgICovXG5cblx0ICAgIGlmICh2YWx1ZSA9PT0gJ3snICYmIG9wdHMubm9icmFjZSAhPT0gdHJ1ZSkge1xuXHQgICAgICBpbmNyZW1lbnQoJ2JyYWNlcycpO1xuXG5cdCAgICAgIGNvbnN0IG9wZW4gPSB7XG5cdCAgICAgICAgdHlwZTogJ2JyYWNlJyxcblx0ICAgICAgICB2YWx1ZSxcblx0ICAgICAgICBvdXRwdXQ6ICcoJyxcblx0ICAgICAgICBvdXRwdXRJbmRleDogc3RhdGUub3V0cHV0Lmxlbmd0aCxcblx0ICAgICAgICB0b2tlbnNJbmRleDogc3RhdGUudG9rZW5zLmxlbmd0aFxuXHQgICAgICB9O1xuXG5cdCAgICAgIGJyYWNlcy5wdXNoKG9wZW4pO1xuXHQgICAgICBwdXNoKG9wZW4pO1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHZhbHVlID09PSAnfScpIHtcblx0ICAgICAgY29uc3QgYnJhY2UgPSBicmFjZXNbYnJhY2VzLmxlbmd0aCAtIDFdO1xuXG5cdCAgICAgIGlmIChvcHRzLm5vYnJhY2UgPT09IHRydWUgfHwgIWJyYWNlKSB7XG5cdCAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUsIG91dHB1dDogdmFsdWUgfSk7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBsZXQgb3V0cHV0ID0gJyknO1xuXG5cdCAgICAgIGlmIChicmFjZS5kb3RzID09PSB0cnVlKSB7XG5cdCAgICAgICAgY29uc3QgYXJyID0gdG9rZW5zLnNsaWNlKCk7XG5cdCAgICAgICAgY29uc3QgcmFuZ2UgPSBbXTtcblxuXHQgICAgICAgIGZvciAobGV0IGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICAgIHRva2Vucy5wb3AoKTtcblx0ICAgICAgICAgIGlmIChhcnJbaV0udHlwZSA9PT0gJ2JyYWNlJykge1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGlmIChhcnJbaV0udHlwZSAhPT0gJ2RvdHMnKSB7XG5cdCAgICAgICAgICAgIHJhbmdlLnVuc2hpZnQoYXJyW2ldLnZhbHVlKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBvdXRwdXQgPSBleHBhbmRSYW5nZShyYW5nZSwgb3B0cyk7XG5cdCAgICAgICAgc3RhdGUuYmFja3RyYWNrID0gdHJ1ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChicmFjZS5jb21tYSAhPT0gdHJ1ZSAmJiBicmFjZS5kb3RzICE9PSB0cnVlKSB7XG5cdCAgICAgICAgY29uc3Qgb3V0ID0gc3RhdGUub3V0cHV0LnNsaWNlKDAsIGJyYWNlLm91dHB1dEluZGV4KTtcblx0ICAgICAgICBjb25zdCB0b2tzID0gc3RhdGUudG9rZW5zLnNsaWNlKGJyYWNlLnRva2Vuc0luZGV4KTtcblx0ICAgICAgICBicmFjZS52YWx1ZSA9IGJyYWNlLm91dHB1dCA9ICdcXFxceyc7XG5cdCAgICAgICAgdmFsdWUgPSBvdXRwdXQgPSAnXFxcXH0nO1xuXHQgICAgICAgIHN0YXRlLm91dHB1dCA9IG91dDtcblx0ICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdG9rcykge1xuXHQgICAgICAgICAgc3RhdGUub3V0cHV0ICs9ICh0Lm91dHB1dCB8fCB0LnZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBwdXNoKHsgdHlwZTogJ2JyYWNlJywgdmFsdWUsIG91dHB1dCB9KTtcblx0ICAgICAgZGVjcmVtZW50KCdicmFjZXMnKTtcblx0ICAgICAgYnJhY2VzLnBvcCgpO1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBQaXBlc1xuXHQgICAgICovXG5cblx0ICAgIGlmICh2YWx1ZSA9PT0gJ3wnKSB7XG5cdCAgICAgIGlmIChleHRnbG9icy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgZXh0Z2xvYnNbZXh0Z2xvYnMubGVuZ3RoIC0gMV0uY29uZGl0aW9ucysrO1xuXHQgICAgICB9XG5cdCAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlIH0pO1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBDb21tYXNcblx0ICAgICAqL1xuXG5cdCAgICBpZiAodmFsdWUgPT09ICcsJykge1xuXHQgICAgICBsZXQgb3V0cHV0ID0gdmFsdWU7XG5cblx0ICAgICAgY29uc3QgYnJhY2UgPSBicmFjZXNbYnJhY2VzLmxlbmd0aCAtIDFdO1xuXHQgICAgICBpZiAoYnJhY2UgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09ICdicmFjZXMnKSB7XG5cdCAgICAgICAgYnJhY2UuY29tbWEgPSB0cnVlO1xuXHQgICAgICAgIG91dHB1dCA9ICd8Jztcblx0ICAgICAgfVxuXG5cdCAgICAgIHB1c2goeyB0eXBlOiAnY29tbWEnLCB2YWx1ZSwgb3V0cHV0IH0pO1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTbGFzaGVzXG5cdCAgICAgKi9cblxuXHQgICAgaWYgKHZhbHVlID09PSAnLycpIHtcblx0ICAgICAgLy8gaWYgdGhlIGJlZ2lubmluZyBvZiB0aGUgZ2xvYiBpcyBcIi4vXCIsIGFkdmFuY2UgdGhlIHN0YXJ0XG5cdCAgICAgIC8vIHRvIHRoZSBjdXJyZW50IGluZGV4LCBhbmQgZG9uJ3QgYWRkIHRoZSBcIi4vXCIgY2hhcmFjdGVyc1xuXHQgICAgICAvLyB0byB0aGUgc3RhdGUuIFRoaXMgZ3JlYXRseSBzaW1wbGlmaWVzIGxvb2tiZWhpbmRzIHdoZW5cblx0ICAgICAgLy8gY2hlY2tpbmcgZm9yIEJPUyBjaGFyYWN0ZXJzIGxpa2UgXCIhXCIgYW5kIFwiLlwiIChub3QgXCIuL1wiKVxuXHQgICAgICBpZiAocHJldi50eXBlID09PSAnZG90JyAmJiBzdGF0ZS5pbmRleCA9PT0gc3RhdGUuc3RhcnQgKyAxKSB7XG5cdCAgICAgICAgc3RhdGUuc3RhcnQgPSBzdGF0ZS5pbmRleCArIDE7XG5cdCAgICAgICAgc3RhdGUuY29uc3VtZWQgPSAnJztcblx0ICAgICAgICBzdGF0ZS5vdXRwdXQgPSAnJztcblx0ICAgICAgICB0b2tlbnMucG9wKCk7XG5cdCAgICAgICAgcHJldiA9IGJvczsgLy8gcmVzZXQgXCJwcmV2XCIgdG8gdGhlIGZpcnN0IHRva2VuXG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBwdXNoKHsgdHlwZTogJ3NsYXNoJywgdmFsdWUsIG91dHB1dDogU0xBU0hfTElURVJBTCB9KTtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogRG90c1xuXHQgICAgICovXG5cblx0ICAgIGlmICh2YWx1ZSA9PT0gJy4nKSB7XG5cdCAgICAgIGlmIChzdGF0ZS5icmFjZXMgPiAwICYmIHByZXYudHlwZSA9PT0gJ2RvdCcpIHtcblx0ICAgICAgICBpZiAocHJldi52YWx1ZSA9PT0gJy4nKSBwcmV2Lm91dHB1dCA9IERPVF9MSVRFUkFMO1xuXHQgICAgICAgIGNvbnN0IGJyYWNlID0gYnJhY2VzW2JyYWNlcy5sZW5ndGggLSAxXTtcblx0ICAgICAgICBwcmV2LnR5cGUgPSAnZG90cyc7XG5cdCAgICAgICAgcHJldi5vdXRwdXQgKz0gdmFsdWU7XG5cdCAgICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcblx0ICAgICAgICBicmFjZS5kb3RzID0gdHJ1ZTtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICgoc3RhdGUuYnJhY2VzICsgc3RhdGUucGFyZW5zKSA9PT0gMCAmJiBwcmV2LnR5cGUgIT09ICdib3MnICYmIHByZXYudHlwZSAhPT0gJ3NsYXNoJykge1xuXHQgICAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlLCBvdXRwdXQ6IERPVF9MSVRFUkFMIH0pO1xuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgcHVzaCh7IHR5cGU6ICdkb3QnLCB2YWx1ZSwgb3V0cHV0OiBET1RfTElURVJBTCB9KTtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogUXVlc3Rpb24gbWFya3Ncblx0ICAgICAqL1xuXG5cdCAgICBpZiAodmFsdWUgPT09ICc/Jykge1xuXHQgICAgICBjb25zdCBpc0dyb3VwID0gcHJldiAmJiBwcmV2LnZhbHVlID09PSAnKCc7XG5cdCAgICAgIGlmICghaXNHcm91cCAmJiBvcHRzLm5vZXh0Z2xvYiAhPT0gdHJ1ZSAmJiBwZWVrKCkgPT09ICcoJyAmJiBwZWVrKDIpICE9PSAnPycpIHtcblx0ICAgICAgICBleHRnbG9iT3BlbigncW1hcmsnLCB2YWx1ZSk7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAocHJldiAmJiBwcmV2LnR5cGUgPT09ICdwYXJlbicpIHtcblx0ICAgICAgICBjb25zdCBuZXh0ID0gcGVlaygpO1xuXHQgICAgICAgIGxldCBvdXRwdXQgPSB2YWx1ZTtcblxuXHQgICAgICAgIGlmICgocHJldi52YWx1ZSA9PT0gJygnICYmICEvWyE9PDpdLy50ZXN0KG5leHQpKSB8fCAobmV4dCA9PT0gJzwnICYmICEvPChbIT1dfFxcdys+KS8udGVzdChyZW1haW5pbmcoKSkpKSB7XG5cdCAgICAgICAgICBvdXRwdXQgPSBgXFxcXCR7dmFsdWV9YDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSwgb3V0cHV0IH0pO1xuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKG9wdHMuZG90ICE9PSB0cnVlICYmIChwcmV2LnR5cGUgPT09ICdzbGFzaCcgfHwgcHJldi50eXBlID09PSAnYm9zJykpIHtcblx0ICAgICAgICBwdXNoKHsgdHlwZTogJ3FtYXJrJywgdmFsdWUsIG91dHB1dDogUU1BUktfTk9fRE9UIH0pO1xuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgcHVzaCh7IHR5cGU6ICdxbWFyaycsIHZhbHVlLCBvdXRwdXQ6IFFNQVJLIH0pO1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBFeGNsYW1hdGlvblxuXHQgICAgICovXG5cblx0ICAgIGlmICh2YWx1ZSA9PT0gJyEnKSB7XG5cdCAgICAgIGlmIChvcHRzLm5vZXh0Z2xvYiAhPT0gdHJ1ZSAmJiBwZWVrKCkgPT09ICcoJykge1xuXHQgICAgICAgIGlmIChwZWVrKDIpICE9PSAnPycgfHwgIS9bIT08Ol0vLnRlc3QocGVlaygzKSkpIHtcblx0ICAgICAgICAgIGV4dGdsb2JPcGVuKCduZWdhdGUnLCB2YWx1ZSk7XG5cdCAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAob3B0cy5ub25lZ2F0ZSAhPT0gdHJ1ZSAmJiBzdGF0ZS5pbmRleCA9PT0gMCkge1xuXHQgICAgICAgIG5lZ2F0ZSgpO1xuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogUGx1c1xuXHQgICAgICovXG5cblx0ICAgIGlmICh2YWx1ZSA9PT0gJysnKSB7XG5cdCAgICAgIGlmIChvcHRzLm5vZXh0Z2xvYiAhPT0gdHJ1ZSAmJiBwZWVrKCkgPT09ICcoJyAmJiBwZWVrKDIpICE9PSAnPycpIHtcblx0ICAgICAgICBleHRnbG9iT3BlbigncGx1cycsIHZhbHVlKTtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICgocHJldiAmJiBwcmV2LnZhbHVlID09PSAnKCcpIHx8IG9wdHMucmVnZXggPT09IGZhbHNlKSB7XG5cdCAgICAgICAgcHVzaCh7IHR5cGU6ICdwbHVzJywgdmFsdWUsIG91dHB1dDogUExVU19MSVRFUkFMIH0pO1xuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKChwcmV2ICYmIChwcmV2LnR5cGUgPT09ICdicmFja2V0JyB8fCBwcmV2LnR5cGUgPT09ICdwYXJlbicgfHwgcHJldi50eXBlID09PSAnYnJhY2UnKSkgfHwgc3RhdGUucGFyZW5zID4gMCkge1xuXHQgICAgICAgIHB1c2goeyB0eXBlOiAncGx1cycsIHZhbHVlIH0pO1xuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgcHVzaCh7IHR5cGU6ICdwbHVzJywgdmFsdWU6IFBMVVNfTElURVJBTCB9KTtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogUGxhaW4gdGV4dFxuXHQgICAgICovXG5cblx0ICAgIGlmICh2YWx1ZSA9PT0gJ0AnKSB7XG5cdCAgICAgIGlmIChvcHRzLm5vZXh0Z2xvYiAhPT0gdHJ1ZSAmJiBwZWVrKCkgPT09ICcoJyAmJiBwZWVrKDIpICE9PSAnPycpIHtcblx0ICAgICAgICBwdXNoKHsgdHlwZTogJ2F0JywgZXh0Z2xvYjogdHJ1ZSwgdmFsdWUsIG91dHB1dDogJycgfSk7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9KTtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogUGxhaW4gdGV4dFxuXHQgICAgICovXG5cblx0ICAgIGlmICh2YWx1ZSAhPT0gJyonKSB7XG5cdCAgICAgIGlmICh2YWx1ZSA9PT0gJyQnIHx8IHZhbHVlID09PSAnXicpIHtcblx0ICAgICAgICB2YWx1ZSA9IGBcXFxcJHt2YWx1ZX1gO1xuXHQgICAgICB9XG5cblx0ICAgICAgY29uc3QgbWF0Y2ggPSBSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUy5leGVjKHJlbWFpbmluZygpKTtcblx0ICAgICAgaWYgKG1hdGNoKSB7XG5cdCAgICAgICAgdmFsdWUgKz0gbWF0Y2hbMF07XG5cdCAgICAgICAgc3RhdGUuaW5kZXggKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuXHQgICAgICB9XG5cblx0ICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIFN0YXJzXG5cdCAgICAgKi9cblxuXHQgICAgaWYgKHByZXYgJiYgKHByZXYudHlwZSA9PT0gJ2dsb2JzdGFyJyB8fCBwcmV2LnN0YXIgPT09IHRydWUpKSB7XG5cdCAgICAgIHByZXYudHlwZSA9ICdzdGFyJztcblx0ICAgICAgcHJldi5zdGFyID0gdHJ1ZTtcblx0ICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcblx0ICAgICAgcHJldi5vdXRwdXQgPSBzdGFyO1xuXHQgICAgICBzdGF0ZS5iYWNrdHJhY2sgPSB0cnVlO1xuXHQgICAgICBzdGF0ZS5nbG9ic3RhciA9IHRydWU7XG5cdCAgICAgIGNvbnN1bWUodmFsdWUpO1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgbGV0IHJlc3QgPSByZW1haW5pbmcoKTtcblx0ICAgIGlmIChvcHRzLm5vZXh0Z2xvYiAhPT0gdHJ1ZSAmJiAvXlxcKFteP10vLnRlc3QocmVzdCkpIHtcblx0ICAgICAgZXh0Z2xvYk9wZW4oJ3N0YXInLCB2YWx1ZSk7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAocHJldi50eXBlID09PSAnc3RhcicpIHtcblx0ICAgICAgaWYgKG9wdHMubm9nbG9ic3RhciA9PT0gdHJ1ZSkge1xuXHQgICAgICAgIGNvbnN1bWUodmFsdWUpO1xuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgY29uc3QgcHJpb3IgPSBwcmV2LnByZXY7XG5cdCAgICAgIGNvbnN0IGJlZm9yZSA9IHByaW9yLnByZXY7XG5cdCAgICAgIGNvbnN0IGlzU3RhcnQgPSBwcmlvci50eXBlID09PSAnc2xhc2gnIHx8IHByaW9yLnR5cGUgPT09ICdib3MnO1xuXHQgICAgICBjb25zdCBhZnRlclN0YXIgPSBiZWZvcmUgJiYgKGJlZm9yZS50eXBlID09PSAnc3RhcicgfHwgYmVmb3JlLnR5cGUgPT09ICdnbG9ic3RhcicpO1xuXG5cdCAgICAgIGlmIChvcHRzLmJhc2ggPT09IHRydWUgJiYgKCFpc1N0YXJ0IHx8IChyZXN0WzBdICYmIHJlc3RbMF0gIT09ICcvJykpKSB7XG5cdCAgICAgICAgcHVzaCh7IHR5cGU6ICdzdGFyJywgdmFsdWUsIG91dHB1dDogJycgfSk7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBjb25zdCBpc0JyYWNlID0gc3RhdGUuYnJhY2VzID4gMCAmJiAocHJpb3IudHlwZSA9PT0gJ2NvbW1hJyB8fCBwcmlvci50eXBlID09PSAnYnJhY2UnKTtcblx0ICAgICAgY29uc3QgaXNFeHRnbG9iID0gZXh0Z2xvYnMubGVuZ3RoICYmIChwcmlvci50eXBlID09PSAncGlwZScgfHwgcHJpb3IudHlwZSA9PT0gJ3BhcmVuJyk7XG5cdCAgICAgIGlmICghaXNTdGFydCAmJiBwcmlvci50eXBlICE9PSAncGFyZW4nICYmICFpc0JyYWNlICYmICFpc0V4dGdsb2IpIHtcblx0ICAgICAgICBwdXNoKHsgdHlwZTogJ3N0YXInLCB2YWx1ZSwgb3V0cHV0OiAnJyB9KTtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIHN0cmlwIGNvbnNlY3V0aXZlIGAvKiovYFxuXHQgICAgICB3aGlsZSAocmVzdC5zbGljZSgwLCAzKSA9PT0gJy8qKicpIHtcblx0ICAgICAgICBjb25zdCBhZnRlciA9IGlucHV0W3N0YXRlLmluZGV4ICsgNF07XG5cdCAgICAgICAgaWYgKGFmdGVyICYmIGFmdGVyICE9PSAnLycpIHtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN0ID0gcmVzdC5zbGljZSgzKTtcblx0ICAgICAgICBjb25zdW1lKCcvKionLCAzKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChwcmlvci50eXBlID09PSAnYm9zJyAmJiBlb3MoKSkge1xuXHQgICAgICAgIHByZXYudHlwZSA9ICdnbG9ic3Rhcic7XG5cdCAgICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcblx0ICAgICAgICBwcmV2Lm91dHB1dCA9IGdsb2JzdGFyKG9wdHMpO1xuXHQgICAgICAgIHN0YXRlLm91dHB1dCA9IHByZXYub3V0cHV0O1xuXHQgICAgICAgIHN0YXRlLmdsb2JzdGFyID0gdHJ1ZTtcblx0ICAgICAgICBjb25zdW1lKHZhbHVlKTtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChwcmlvci50eXBlID09PSAnc2xhc2gnICYmIHByaW9yLnByZXYudHlwZSAhPT0gJ2JvcycgJiYgIWFmdGVyU3RhciAmJiBlb3MoKSkge1xuXHQgICAgICAgIHN0YXRlLm91dHB1dCA9IHN0YXRlLm91dHB1dC5zbGljZSgwLCAtKHByaW9yLm91dHB1dCArIHByZXYub3V0cHV0KS5sZW5ndGgpO1xuXHQgICAgICAgIHByaW9yLm91dHB1dCA9IGAoPzoke3ByaW9yLm91dHB1dH1gO1xuXG5cdCAgICAgICAgcHJldi50eXBlID0gJ2dsb2JzdGFyJztcblx0ICAgICAgICBwcmV2Lm91dHB1dCA9IGdsb2JzdGFyKG9wdHMpICsgKG9wdHMuc3RyaWN0U2xhc2hlcyA/ICcpJyA6ICd8JCknKTtcblx0ICAgICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuXHQgICAgICAgIHN0YXRlLmdsb2JzdGFyID0gdHJ1ZTtcblx0ICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gcHJpb3Iub3V0cHV0ICsgcHJldi5vdXRwdXQ7XG5cdCAgICAgICAgY29uc3VtZSh2YWx1ZSk7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAocHJpb3IudHlwZSA9PT0gJ3NsYXNoJyAmJiBwcmlvci5wcmV2LnR5cGUgIT09ICdib3MnICYmIHJlc3RbMF0gPT09ICcvJykge1xuXHQgICAgICAgIGNvbnN0IGVuZCA9IHJlc3RbMV0gIT09IHZvaWQgMCA/ICd8JCcgOiAnJztcblxuXHQgICAgICAgIHN0YXRlLm91dHB1dCA9IHN0YXRlLm91dHB1dC5zbGljZSgwLCAtKHByaW9yLm91dHB1dCArIHByZXYub3V0cHV0KS5sZW5ndGgpO1xuXHQgICAgICAgIHByaW9yLm91dHB1dCA9IGAoPzoke3ByaW9yLm91dHB1dH1gO1xuXG5cdCAgICAgICAgcHJldi50eXBlID0gJ2dsb2JzdGFyJztcblx0ICAgICAgICBwcmV2Lm91dHB1dCA9IGAke2dsb2JzdGFyKG9wdHMpfSR7U0xBU0hfTElURVJBTH18JHtTTEFTSF9MSVRFUkFMfSR7ZW5kfSlgO1xuXHQgICAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG5cblx0ICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gcHJpb3Iub3V0cHV0ICsgcHJldi5vdXRwdXQ7XG5cdCAgICAgICAgc3RhdGUuZ2xvYnN0YXIgPSB0cnVlO1xuXG5cdCAgICAgICAgY29uc3VtZSh2YWx1ZSArIGFkdmFuY2UoKSk7XG5cblx0ICAgICAgICBwdXNoKHsgdHlwZTogJ3NsYXNoJywgdmFsdWU6ICcvJywgb3V0cHV0OiAnJyB9KTtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChwcmlvci50eXBlID09PSAnYm9zJyAmJiByZXN0WzBdID09PSAnLycpIHtcblx0ICAgICAgICBwcmV2LnR5cGUgPSAnZ2xvYnN0YXInO1xuXHQgICAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG5cdCAgICAgICAgcHJldi5vdXRwdXQgPSBgKD86Xnwke1NMQVNIX0xJVEVSQUx9fCR7Z2xvYnN0YXIob3B0cyl9JHtTTEFTSF9MSVRFUkFMfSlgO1xuXHQgICAgICAgIHN0YXRlLm91dHB1dCA9IHByZXYub3V0cHV0O1xuXHQgICAgICAgIHN0YXRlLmdsb2JzdGFyID0gdHJ1ZTtcblx0ICAgICAgICBjb25zdW1lKHZhbHVlICsgYWR2YW5jZSgpKTtcblx0ICAgICAgICBwdXNoKHsgdHlwZTogJ3NsYXNoJywgdmFsdWU6ICcvJywgb3V0cHV0OiAnJyB9KTtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIHJlbW92ZSBzaW5nbGUgc3RhciBmcm9tIG91dHB1dFxuXHQgICAgICBzdGF0ZS5vdXRwdXQgPSBzdGF0ZS5vdXRwdXQuc2xpY2UoMCwgLXByZXYub3V0cHV0Lmxlbmd0aCk7XG5cblx0ICAgICAgLy8gcmVzZXQgcHJldmlvdXMgdG9rZW4gdG8gZ2xvYnN0YXJcblx0ICAgICAgcHJldi50eXBlID0gJ2dsb2JzdGFyJztcblx0ICAgICAgcHJldi5vdXRwdXQgPSBnbG9ic3RhcihvcHRzKTtcblx0ICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcblxuXHQgICAgICAvLyByZXNldCBvdXRwdXQgd2l0aCBnbG9ic3RhclxuXHQgICAgICBzdGF0ZS5vdXRwdXQgKz0gcHJldi5vdXRwdXQ7XG5cdCAgICAgIHN0YXRlLmdsb2JzdGFyID0gdHJ1ZTtcblx0ICAgICAgY29uc3VtZSh2YWx1ZSk7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXG5cdCAgICBjb25zdCB0b2tlbiA9IHsgdHlwZTogJ3N0YXInLCB2YWx1ZSwgb3V0cHV0OiBzdGFyIH07XG5cblx0ICAgIGlmIChvcHRzLmJhc2ggPT09IHRydWUpIHtcblx0ICAgICAgdG9rZW4ub3V0cHV0ID0gJy4qPyc7XG5cdCAgICAgIGlmIChwcmV2LnR5cGUgPT09ICdib3MnIHx8IHByZXYudHlwZSA9PT0gJ3NsYXNoJykge1xuXHQgICAgICAgIHRva2VuLm91dHB1dCA9IG5vZG90ICsgdG9rZW4ub3V0cHV0O1xuXHQgICAgICB9XG5cdCAgICAgIHB1c2godG9rZW4pO1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHByZXYgJiYgKHByZXYudHlwZSA9PT0gJ2JyYWNrZXQnIHx8IHByZXYudHlwZSA9PT0gJ3BhcmVuJykgJiYgb3B0cy5yZWdleCA9PT0gdHJ1ZSkge1xuXHQgICAgICB0b2tlbi5vdXRwdXQgPSB2YWx1ZTtcblx0ICAgICAgcHVzaCh0b2tlbik7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoc3RhdGUuaW5kZXggPT09IHN0YXRlLnN0YXJ0IHx8IHByZXYudHlwZSA9PT0gJ3NsYXNoJyB8fCBwcmV2LnR5cGUgPT09ICdkb3QnKSB7XG5cdCAgICAgIGlmIChwcmV2LnR5cGUgPT09ICdkb3QnKSB7XG5cdCAgICAgICAgc3RhdGUub3V0cHV0ICs9IE5PX0RPVF9TTEFTSDtcblx0ICAgICAgICBwcmV2Lm91dHB1dCArPSBOT19ET1RfU0xBU0g7XG5cblx0ICAgICAgfSBlbHNlIGlmIChvcHRzLmRvdCA9PT0gdHJ1ZSkge1xuXHQgICAgICAgIHN0YXRlLm91dHB1dCArPSBOT19ET1RTX1NMQVNIO1xuXHQgICAgICAgIHByZXYub3V0cHV0ICs9IE5PX0RPVFNfU0xBU0g7XG5cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gbm9kb3Q7XG5cdCAgICAgICAgcHJldi5vdXRwdXQgKz0gbm9kb3Q7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAocGVlaygpICE9PSAnKicpIHtcblx0ICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gT05FX0NIQVI7XG5cdCAgICAgICAgcHJldi5vdXRwdXQgKz0gT05FX0NIQVI7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcHVzaCh0b2tlbik7XG5cdCAgfVxuXG5cdCAgd2hpbGUgKHN0YXRlLmJyYWNrZXRzID4gMCkge1xuXHQgICAgaWYgKG9wdHMuc3RyaWN0QnJhY2tldHMgPT09IHRydWUpIHRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcignY2xvc2luZycsICddJykpO1xuXHQgICAgc3RhdGUub3V0cHV0ID0gdXRpbHMuZXNjYXBlTGFzdChzdGF0ZS5vdXRwdXQsICdbJyk7XG5cdCAgICBkZWNyZW1lbnQoJ2JyYWNrZXRzJyk7XG5cdCAgfVxuXG5cdCAgd2hpbGUgKHN0YXRlLnBhcmVucyA+IDApIHtcblx0ICAgIGlmIChvcHRzLnN0cmljdEJyYWNrZXRzID09PSB0cnVlKSB0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoJ2Nsb3NpbmcnLCAnKScpKTtcblx0ICAgIHN0YXRlLm91dHB1dCA9IHV0aWxzLmVzY2FwZUxhc3Qoc3RhdGUub3V0cHV0LCAnKCcpO1xuXHQgICAgZGVjcmVtZW50KCdwYXJlbnMnKTtcblx0ICB9XG5cblx0ICB3aGlsZSAoc3RhdGUuYnJhY2VzID4gMCkge1xuXHQgICAgaWYgKG9wdHMuc3RyaWN0QnJhY2tldHMgPT09IHRydWUpIHRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcignY2xvc2luZycsICd9JykpO1xuXHQgICAgc3RhdGUub3V0cHV0ID0gdXRpbHMuZXNjYXBlTGFzdChzdGF0ZS5vdXRwdXQsICd7Jyk7XG5cdCAgICBkZWNyZW1lbnQoJ2JyYWNlcycpO1xuXHQgIH1cblxuXHQgIGlmIChvcHRzLnN0cmljdFNsYXNoZXMgIT09IHRydWUgJiYgKHByZXYudHlwZSA9PT0gJ3N0YXInIHx8IHByZXYudHlwZSA9PT0gJ2JyYWNrZXQnKSkge1xuXHQgICAgcHVzaCh7IHR5cGU6ICdtYXliZV9zbGFzaCcsIHZhbHVlOiAnJywgb3V0cHV0OiBgJHtTTEFTSF9MSVRFUkFMfT9gIH0pO1xuXHQgIH1cblxuXHQgIC8vIHJlYnVpbGQgdGhlIG91dHB1dCBpZiB3ZSBoYWQgdG8gYmFja3RyYWNrIGF0IGFueSBwb2ludFxuXHQgIGlmIChzdGF0ZS5iYWNrdHJhY2sgPT09IHRydWUpIHtcblx0ICAgIHN0YXRlLm91dHB1dCA9ICcnO1xuXG5cdCAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHN0YXRlLnRva2Vucykge1xuXHQgICAgICBzdGF0ZS5vdXRwdXQgKz0gdG9rZW4ub3V0cHV0ICE9IG51bGwgPyB0b2tlbi5vdXRwdXQgOiB0b2tlbi52YWx1ZTtcblxuXHQgICAgICBpZiAodG9rZW4uc3VmZml4KSB7XG5cdCAgICAgICAgc3RhdGUub3V0cHV0ICs9IHRva2VuLnN1ZmZpeDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBzdGF0ZTtcblx0fTtcblxuXHQvKipcblx0ICogRmFzdCBwYXRocyBmb3IgY3JlYXRpbmcgcmVndWxhciBleHByZXNzaW9ucyBmb3IgY29tbW9uIGdsb2IgcGF0dGVybnMuXG5cdCAqIFRoaXMgY2FuIHNpZ25pZmljYW50bHkgc3BlZWQgdXAgcHJvY2Vzc2luZyBhbmQgaGFzIHZlcnkgbGl0dGxlIGRvd25zaWRlXG5cdCAqIGltcGFjdCB3aGVuIG5vbmUgb2YgdGhlIGZhc3QgcGF0aHMgbWF0Y2guXG5cdCAqL1xuXG5cdHBhcnNlLmZhc3RwYXRocyA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuXHQgIGNvbnN0IG9wdHMgPSB7IC4uLm9wdGlvbnMgfTtcblx0ICBjb25zdCBtYXggPSB0eXBlb2Ygb3B0cy5tYXhMZW5ndGggPT09ICdudW1iZXInID8gTWF0aC5taW4oTUFYX0xFTkdUSCwgb3B0cy5tYXhMZW5ndGgpIDogTUFYX0xFTkdUSDtcblx0ICBjb25zdCBsZW4gPSBpbnB1dC5sZW5ndGg7XG5cdCAgaWYgKGxlbiA+IG1heCkge1xuXHQgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGg6ICR7bGVufSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke21heH1gKTtcblx0ICB9XG5cblx0ICBpbnB1dCA9IFJFUExBQ0VNRU5UU1tpbnB1dF0gfHwgaW5wdXQ7XG5cblx0ICAvLyBjcmVhdGUgY29uc3RhbnRzIGJhc2VkIG9uIHBsYXRmb3JtLCBmb3Igd2luZG93cyBvciBwb3NpeFxuXHQgIGNvbnN0IHtcblx0ICAgIERPVF9MSVRFUkFMLFxuXHQgICAgU0xBU0hfTElURVJBTCxcblx0ICAgIE9ORV9DSEFSLFxuXHQgICAgRE9UU19TTEFTSCxcblx0ICAgIE5PX0RPVCxcblx0ICAgIE5PX0RPVFMsXG5cdCAgICBOT19ET1RTX1NMQVNILFxuXHQgICAgU1RBUixcblx0ICAgIFNUQVJUX0FOQ0hPUlxuXHQgIH0gPSBjb25zdGFudHMuZ2xvYkNoYXJzKG9wdHMud2luZG93cyk7XG5cblx0ICBjb25zdCBub2RvdCA9IG9wdHMuZG90ID8gTk9fRE9UUyA6IE5PX0RPVDtcblx0ICBjb25zdCBzbGFzaERvdCA9IG9wdHMuZG90ID8gTk9fRE9UU19TTEFTSCA6IE5PX0RPVDtcblx0ICBjb25zdCBjYXB0dXJlID0gb3B0cy5jYXB0dXJlID8gJycgOiAnPzonO1xuXHQgIGNvbnN0IHN0YXRlID0geyBuZWdhdGVkOiBmYWxzZSwgcHJlZml4OiAnJyB9O1xuXHQgIGxldCBzdGFyID0gb3B0cy5iYXNoID09PSB0cnVlID8gJy4qPycgOiBTVEFSO1xuXG5cdCAgaWYgKG9wdHMuY2FwdHVyZSkge1xuXHQgICAgc3RhciA9IGAoJHtzdGFyfSlgO1xuXHQgIH1cblxuXHQgIGNvbnN0IGdsb2JzdGFyID0gb3B0cyA9PiB7XG5cdCAgICBpZiAob3B0cy5ub2dsb2JzdGFyID09PSB0cnVlKSByZXR1cm4gc3Rhcjtcblx0ICAgIHJldHVybiBgKCR7Y2FwdHVyZX0oPzooPyEke1NUQVJUX0FOQ0hPUn0ke29wdHMuZG90ID8gRE9UU19TTEFTSCA6IERPVF9MSVRFUkFMfSkuKSo/KWA7XG5cdCAgfTtcblxuXHQgIGNvbnN0IGNyZWF0ZSA9IHN0ciA9PiB7XG5cdCAgICBzd2l0Y2ggKHN0cikge1xuXHQgICAgICBjYXNlICcqJzpcblx0ICAgICAgICByZXR1cm4gYCR7bm9kb3R9JHtPTkVfQ0hBUn0ke3N0YXJ9YDtcblxuXHQgICAgICBjYXNlICcuKic6XG5cdCAgICAgICAgcmV0dXJuIGAke0RPVF9MSVRFUkFMfSR7T05FX0NIQVJ9JHtzdGFyfWA7XG5cblx0ICAgICAgY2FzZSAnKi4qJzpcblx0ICAgICAgICByZXR1cm4gYCR7bm9kb3R9JHtzdGFyfSR7RE9UX0xJVEVSQUx9JHtPTkVfQ0hBUn0ke3N0YXJ9YDtcblxuXHQgICAgICBjYXNlICcqLyonOlxuXHQgICAgICAgIHJldHVybiBgJHtub2RvdH0ke3N0YXJ9JHtTTEFTSF9MSVRFUkFMfSR7T05FX0NIQVJ9JHtzbGFzaERvdH0ke3N0YXJ9YDtcblxuXHQgICAgICBjYXNlICcqKic6XG5cdCAgICAgICAgcmV0dXJuIG5vZG90ICsgZ2xvYnN0YXIob3B0cyk7XG5cblx0ICAgICAgY2FzZSAnKiovKic6XG5cdCAgICAgICAgcmV0dXJuIGAoPzoke25vZG90fSR7Z2xvYnN0YXIob3B0cyl9JHtTTEFTSF9MSVRFUkFMfSk/JHtzbGFzaERvdH0ke09ORV9DSEFSfSR7c3Rhcn1gO1xuXG5cdCAgICAgIGNhc2UgJyoqLyouKic6XG5cdCAgICAgICAgcmV0dXJuIGAoPzoke25vZG90fSR7Z2xvYnN0YXIob3B0cyl9JHtTTEFTSF9MSVRFUkFMfSk/JHtzbGFzaERvdH0ke3N0YXJ9JHtET1RfTElURVJBTH0ke09ORV9DSEFSfSR7c3Rhcn1gO1xuXG5cdCAgICAgIGNhc2UgJyoqLy4qJzpcblx0ICAgICAgICByZXR1cm4gYCg/OiR7bm9kb3R9JHtnbG9ic3RhcihvcHRzKX0ke1NMQVNIX0xJVEVSQUx9KT8ke0RPVF9MSVRFUkFMfSR7T05FX0NIQVJ9JHtzdGFyfWA7XG5cblx0ICAgICAgZGVmYXVsdDoge1xuXHQgICAgICAgIGNvbnN0IG1hdGNoID0gL14oLio/KVxcLihcXHcrKSQvLmV4ZWMoc3RyKTtcblx0ICAgICAgICBpZiAoIW1hdGNoKSByZXR1cm47XG5cblx0ICAgICAgICBjb25zdCBzb3VyY2UgPSBjcmVhdGUobWF0Y2hbMV0pO1xuXHQgICAgICAgIGlmICghc291cmNlKSByZXR1cm47XG5cblx0ICAgICAgICByZXR1cm4gc291cmNlICsgRE9UX0xJVEVSQUwgKyBtYXRjaFsyXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICBjb25zdCBvdXRwdXQgPSB1dGlscy5yZW1vdmVQcmVmaXgoaW5wdXQsIHN0YXRlKTtcblx0ICBsZXQgc291cmNlID0gY3JlYXRlKG91dHB1dCk7XG5cblx0ICBpZiAoc291cmNlICYmIG9wdHMuc3RyaWN0U2xhc2hlcyAhPT0gdHJ1ZSkge1xuXHQgICAgc291cmNlICs9IGAke1NMQVNIX0xJVEVSQUx9P2A7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHNvdXJjZTtcblx0fTtcblxuXHRwYXJzZV8xID0gcGFyc2U7XG5cdHJldHVybiBwYXJzZV8xO1xufVxuXG52YXIgcGljb21hdGNoXzEkMTtcbnZhciBoYXNSZXF1aXJlZFBpY29tYXRjaCQxO1xuXG5mdW5jdGlvbiByZXF1aXJlUGljb21hdGNoJDEgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRQaWNvbWF0Y2gkMSkgcmV0dXJuIHBpY29tYXRjaF8xJDE7XG5cdGhhc1JlcXVpcmVkUGljb21hdGNoJDEgPSAxO1xuXG5cdGNvbnN0IHNjYW4gPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVTY2FuKCk7XG5cdGNvbnN0IHBhcnNlID0gLypAX19QVVJFX18qLyByZXF1aXJlUGFyc2UoKTtcblx0Y29uc3QgdXRpbHMgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVVdGlscygpO1xuXHRjb25zdCBjb25zdGFudHMgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVDb25zdGFudHMoKTtcblx0Y29uc3QgaXNPYmplY3QgPSB2YWwgPT4gdmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbCk7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBtYXRjaGVyIGZ1bmN0aW9uIGZyb20gb25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucy4gVGhlXG5cdCAqIHJldHVybmVkIGZ1bmN0aW9uIHRha2VzIGEgc3RyaW5nIHRvIG1hdGNoIGFzIGl0cyBmaXJzdCBhcmd1bWVudCxcblx0ICogYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGEgbWF0Y2guIFRoZSByZXR1cm5lZCBtYXRjaGVyXG5cdCAqIGZ1bmN0aW9uIGFsc28gdGFrZXMgYSBib29sZWFuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdGhhdCwgd2hlbiB0cnVlLFxuXHQgKiByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXG5cdCAqXG5cdCAqIGBgYGpzXG5cdCAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuXHQgKiAvLyBwaWNvbWF0Y2goZ2xvYlssIG9wdGlvbnNdKTtcblx0ICpcblx0ICogY29uc3QgaXNNYXRjaCA9IHBpY29tYXRjaCgnKi4hKCphKScpO1xuXHQgKiBjb25zb2xlLmxvZyhpc01hdGNoKCdhLmEnKSk7IC8vPT4gZmFsc2Vcblx0ICogY29uc29sZS5sb2coaXNNYXRjaCgnYS5iJykpOyAvLz0+IHRydWVcblx0ICogYGBgXG5cdCAqIEBuYW1lIHBpY29tYXRjaFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYGdsb2JzYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zLlxuXHQgKiBAcGFyYW0ge09iamVjdD19IGBvcHRpb25zYFxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbj19IFJldHVybnMgYSBtYXRjaGVyIGZ1bmN0aW9uLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRjb25zdCBwaWNvbWF0Y2ggPSAoZ2xvYiwgb3B0aW9ucywgcmV0dXJuU3RhdGUgPSBmYWxzZSkgPT4ge1xuXHQgIGlmIChBcnJheS5pc0FycmF5KGdsb2IpKSB7XG5cdCAgICBjb25zdCBmbnMgPSBnbG9iLm1hcChpbnB1dCA9PiBwaWNvbWF0Y2goaW5wdXQsIG9wdGlvbnMsIHJldHVyblN0YXRlKSk7XG5cdCAgICBjb25zdCBhcnJheU1hdGNoZXIgPSBzdHIgPT4ge1xuXHQgICAgICBmb3IgKGNvbnN0IGlzTWF0Y2ggb2YgZm5zKSB7XG5cdCAgICAgICAgY29uc3Qgc3RhdGUgPSBpc01hdGNoKHN0cik7XG5cdCAgICAgICAgaWYgKHN0YXRlKSByZXR1cm4gc3RhdGU7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBhcnJheU1hdGNoZXI7XG5cdCAgfVxuXG5cdCAgY29uc3QgaXNTdGF0ZSA9IGlzT2JqZWN0KGdsb2IpICYmIGdsb2IudG9rZW5zICYmIGdsb2IuaW5wdXQ7XG5cblx0ICBpZiAoZ2xvYiA9PT0gJycgfHwgKHR5cGVvZiBnbG9iICE9PSAnc3RyaW5nJyAmJiAhaXNTdGF0ZSkpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdCAgfVxuXG5cdCAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgfHwge307XG5cdCAgY29uc3QgcG9zaXggPSBvcHRzLndpbmRvd3M7XG5cdCAgY29uc3QgcmVnZXggPSBpc1N0YXRlXG5cdCAgICA/IHBpY29tYXRjaC5jb21waWxlUmUoZ2xvYiwgb3B0aW9ucylcblx0ICAgIDogcGljb21hdGNoLm1ha2VSZShnbG9iLCBvcHRpb25zLCBmYWxzZSwgdHJ1ZSk7XG5cblx0ICBjb25zdCBzdGF0ZSA9IHJlZ2V4LnN0YXRlO1xuXHQgIGRlbGV0ZSByZWdleC5zdGF0ZTtcblxuXHQgIGxldCBpc0lnbm9yZWQgPSAoKSA9PiBmYWxzZTtcblx0ICBpZiAob3B0cy5pZ25vcmUpIHtcblx0ICAgIGNvbnN0IGlnbm9yZU9wdHMgPSB7IC4uLm9wdGlvbnMsIGlnbm9yZTogbnVsbCwgb25NYXRjaDogbnVsbCwgb25SZXN1bHQ6IG51bGwgfTtcblx0ICAgIGlzSWdub3JlZCA9IHBpY29tYXRjaChvcHRzLmlnbm9yZSwgaWdub3JlT3B0cywgcmV0dXJuU3RhdGUpO1xuXHQgIH1cblxuXHQgIGNvbnN0IG1hdGNoZXIgPSAoaW5wdXQsIHJldHVybk9iamVjdCA9IGZhbHNlKSA9PiB7XG5cdCAgICBjb25zdCB7IGlzTWF0Y2gsIG1hdGNoLCBvdXRwdXQgfSA9IHBpY29tYXRjaC50ZXN0KGlucHV0LCByZWdleCwgb3B0aW9ucywgeyBnbG9iLCBwb3NpeCB9KTtcblx0ICAgIGNvbnN0IHJlc3VsdCA9IHsgZ2xvYiwgc3RhdGUsIHJlZ2V4LCBwb3NpeCwgaW5wdXQsIG91dHB1dCwgbWF0Y2gsIGlzTWF0Y2ggfTtcblxuXHQgICAgaWYgKHR5cGVvZiBvcHRzLm9uUmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIG9wdHMub25SZXN1bHQocmVzdWx0KTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGlzTWF0Y2ggPT09IGZhbHNlKSB7XG5cdCAgICAgIHJlc3VsdC5pc01hdGNoID0gZmFsc2U7XG5cdCAgICAgIHJldHVybiByZXR1cm5PYmplY3QgPyByZXN1bHQgOiBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGlzSWdub3JlZChpbnB1dCkpIHtcblx0ICAgICAgaWYgKHR5cGVvZiBvcHRzLm9uSWdub3JlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgb3B0cy5vbklnbm9yZShyZXN1bHQpO1xuXHQgICAgICB9XG5cdCAgICAgIHJlc3VsdC5pc01hdGNoID0gZmFsc2U7XG5cdCAgICAgIHJldHVybiByZXR1cm5PYmplY3QgPyByZXN1bHQgOiBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBvcHRzLm9uTWF0Y2ggPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgb3B0cy5vbk1hdGNoKHJlc3VsdCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmV0dXJuT2JqZWN0ID8gcmVzdWx0IDogdHJ1ZTtcblx0ICB9O1xuXG5cdCAgaWYgKHJldHVyblN0YXRlKSB7XG5cdCAgICBtYXRjaGVyLnN0YXRlID0gc3RhdGU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG1hdGNoZXI7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRlc3QgYGlucHV0YCB3aXRoIHRoZSBnaXZlbiBgcmVnZXhgLiBUaGlzIGlzIHVzZWQgYnkgdGhlIG1haW5cblx0ICogYHBpY29tYXRjaCgpYCBmdW5jdGlvbiB0byB0ZXN0IHRoZSBpbnB1dCBzdHJpbmcuXG5cdCAqXG5cdCAqIGBgYGpzXG5cdCAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuXHQgKiAvLyBwaWNvbWF0Y2gudGVzdChpbnB1dCwgcmVnZXhbLCBvcHRpb25zXSk7XG5cdCAqXG5cdCAqIGNvbnNvbGUubG9nKHBpY29tYXRjaC50ZXN0KCdmb28vYmFyJywgL14oPzooW14vXSo/KVxcLyhbXi9dKj8pKSQvKSk7XG5cdCAqIC8vIHsgaXNNYXRjaDogdHJ1ZSwgbWF0Y2g6IFsgJ2Zvby8nLCAnZm9vJywgJ2JhcicgXSwgb3V0cHV0OiAnZm9vL2JhcicgfVxuXHQgKiBgYGBcblx0ICogQHBhcmFtIHtTdHJpbmd9IGBpbnB1dGAgU3RyaW5nIHRvIHRlc3QuXG5cdCAqIEBwYXJhbSB7UmVnRXhwfSBgcmVnZXhgXG5cdCAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBtYXRjaGluZyBpbmZvLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRwaWNvbWF0Y2gudGVzdCA9IChpbnB1dCwgcmVnZXgsIG9wdGlvbnMsIHsgZ2xvYiwgcG9zaXggfSA9IHt9KSA9PiB7XG5cdCAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGlucHV0IHRvIGJlIGEgc3RyaW5nJyk7XG5cdCAgfVxuXG5cdCAgaWYgKGlucHV0ID09PSAnJykge1xuXHQgICAgcmV0dXJuIHsgaXNNYXRjaDogZmFsc2UsIG91dHB1dDogJycgfTtcblx0ICB9XG5cblx0ICBjb25zdCBvcHRzID0gb3B0aW9ucyB8fCB7fTtcblx0ICBjb25zdCBmb3JtYXQgPSBvcHRzLmZvcm1hdCB8fCAocG9zaXggPyB1dGlscy50b1Bvc2l4U2xhc2hlcyA6IG51bGwpO1xuXHQgIGxldCBtYXRjaCA9IGlucHV0ID09PSBnbG9iO1xuXHQgIGxldCBvdXRwdXQgPSAobWF0Y2ggJiYgZm9ybWF0KSA/IGZvcm1hdChpbnB1dCkgOiBpbnB1dDtcblxuXHQgIGlmIChtYXRjaCA9PT0gZmFsc2UpIHtcblx0ICAgIG91dHB1dCA9IGZvcm1hdCA/IGZvcm1hdChpbnB1dCkgOiBpbnB1dDtcblx0ICAgIG1hdGNoID0gb3V0cHV0ID09PSBnbG9iO1xuXHQgIH1cblxuXHQgIGlmIChtYXRjaCA9PT0gZmFsc2UgfHwgb3B0cy5jYXB0dXJlID09PSB0cnVlKSB7XG5cdCAgICBpZiAob3B0cy5tYXRjaEJhc2UgPT09IHRydWUgfHwgb3B0cy5iYXNlbmFtZSA9PT0gdHJ1ZSkge1xuXHQgICAgICBtYXRjaCA9IHBpY29tYXRjaC5tYXRjaEJhc2UoaW5wdXQsIHJlZ2V4LCBvcHRpb25zLCBwb3NpeCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMob3V0cHV0KTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4geyBpc01hdGNoOiBCb29sZWFuKG1hdGNoKSwgbWF0Y2gsIG91dHB1dCB9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNYXRjaCB0aGUgYmFzZW5hbWUgb2YgYSBmaWxlcGF0aC5cblx0ICpcblx0ICogYGBganNcblx0ICogY29uc3QgcGljb21hdGNoID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG5cdCAqIC8vIHBpY29tYXRjaC5tYXRjaEJhc2UoaW5wdXQsIGdsb2JbLCBvcHRpb25zXSk7XG5cdCAqIGNvbnNvbGUubG9nKHBpY29tYXRjaC5tYXRjaEJhc2UoJ2Zvby9iYXIuanMnLCAnKi5qcycpOyAvLyB0cnVlXG5cdCAqIGBgYFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYGlucHV0YCBTdHJpbmcgdG8gdGVzdC5cblx0ICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBgZ2xvYmAgR2xvYiBwYXR0ZXJuIG9yIHJlZ2V4IGNyZWF0ZWQgYnkgWy5tYWtlUmVdKCNtYWtlUmUpLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRwaWNvbWF0Y2gubWF0Y2hCYXNlID0gKGlucHV0LCBnbG9iLCBvcHRpb25zKSA9PiB7XG5cdCAgY29uc3QgcmVnZXggPSBnbG9iIGluc3RhbmNlb2YgUmVnRXhwID8gZ2xvYiA6IHBpY29tYXRjaC5tYWtlUmUoZ2xvYiwgb3B0aW9ucyk7XG5cdCAgcmV0dXJuIHJlZ2V4LnRlc3QodXRpbHMuYmFzZW5hbWUoaW5wdXQpKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmICoqYW55Kiogb2YgdGhlIGdpdmVuIGdsb2IgYHBhdHRlcm5zYCBtYXRjaCB0aGUgc3BlY2lmaWVkIGBzdHJpbmdgLlxuXHQgKlxuXHQgKiBgYGBqc1xuXHQgKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcblx0ICogLy8gcGljb21hdGNoLmlzTWF0Y2goc3RyaW5nLCBwYXR0ZXJuc1ssIG9wdGlvbnNdKTtcblx0ICpcblx0ICogY29uc29sZS5sb2cocGljb21hdGNoLmlzTWF0Y2goJ2EuYScsIFsnYi4qJywgJyouYSddKSk7IC8vPT4gdHJ1ZVxuXHQgKiBjb25zb2xlLmxvZyhwaWNvbWF0Y2guaXNNYXRjaCgnYS5hJywgJ2IuKicpKTsgLy89PiBmYWxzZVxuXHQgKiBgYGBcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHN0ciBUaGUgc3RyaW5nIHRvIHRlc3QuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBwYXR0ZXJucyBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zIHRvIHVzZSBmb3IgbWF0Y2hpbmcuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW55IHBhdHRlcm5zIG1hdGNoIGBzdHJgXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdHBpY29tYXRjaC5pc01hdGNoID0gKHN0ciwgcGF0dGVybnMsIG9wdGlvbnMpID0+IHBpY29tYXRjaChwYXR0ZXJucywgb3B0aW9ucykoc3RyKTtcblxuXHQvKipcblx0ICogUGFyc2UgYSBnbG9iIHBhdHRlcm4gdG8gY3JlYXRlIHRoZSBzb3VyY2Ugc3RyaW5nIGZvciBhIHJlZ3VsYXJcblx0ICogZXhwcmVzc2lvbi5cblx0ICpcblx0ICogYGBganNcblx0ICogY29uc3QgcGljb21hdGNoID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG5cdCAqIGNvbnN0IHJlc3VsdCA9IHBpY29tYXRjaC5wYXJzZShwYXR0ZXJuWywgb3B0aW9uc10pO1xuXHQgKiBgYGBcblx0ICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYFxuXHQgKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG5cdCAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB1c2VmdWwgcHJvcGVydGllcyBhbmQgb3V0cHV0IHRvIGJlIHVzZWQgYXMgYSByZWdleCBzb3VyY2Ugc3RyaW5nLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRwaWNvbWF0Y2gucGFyc2UgPSAocGF0dGVybiwgb3B0aW9ucykgPT4ge1xuXHQgIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSByZXR1cm4gcGF0dGVybi5tYXAocCA9PiBwaWNvbWF0Y2gucGFyc2UocCwgb3B0aW9ucykpO1xuXHQgIHJldHVybiBwYXJzZShwYXR0ZXJuLCB7IC4uLm9wdGlvbnMsIGZhc3RwYXRoczogZmFsc2UgfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNjYW4gYSBnbG9iIHBhdHRlcm4gdG8gc2VwYXJhdGUgdGhlIHBhdHRlcm4gaW50byBzZWdtZW50cy5cblx0ICpcblx0ICogYGBganNcblx0ICogY29uc3QgcGljb21hdGNoID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG5cdCAqIC8vIHBpY29tYXRjaC5zY2FuKGlucHV0Wywgb3B0aW9uc10pO1xuXHQgKlxuXHQgKiBjb25zdCByZXN1bHQgPSBwaWNvbWF0Y2guc2NhbignIS4vZm9vLyouanMnKTtcblx0ICogY29uc29sZS5sb2cocmVzdWx0KTtcblx0ICogeyBwcmVmaXg6ICchLi8nLFxuXHQgKiAgIGlucHV0OiAnIS4vZm9vLyouanMnLFxuXHQgKiAgIHN0YXJ0OiAzLFxuXHQgKiAgIGJhc2U6ICdmb28nLFxuXHQgKiAgIGdsb2I6ICcqLmpzJyxcblx0ICogICBpc0JyYWNlOiBmYWxzZSxcblx0ICogICBpc0JyYWNrZXQ6IGZhbHNlLFxuXHQgKiAgIGlzR2xvYjogdHJ1ZSxcblx0ICogICBpc0V4dGdsb2I6IGZhbHNlLFxuXHQgKiAgIGlzR2xvYnN0YXI6IGZhbHNlLFxuXHQgKiAgIG5lZ2F0ZWQ6IHRydWUgfVxuXHQgKiBgYGBcblx0ICogQHBhcmFtIHtTdHJpbmd9IGBpbnB1dGAgR2xvYiBwYXR0ZXJuIHRvIHNjYW4uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2Bcblx0ICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdHBpY29tYXRjaC5zY2FuID0gKGlucHV0LCBvcHRpb25zKSA9PiBzY2FuKGlucHV0LCBvcHRpb25zKTtcblxuXHQvKipcblx0ICogQ29tcGlsZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIHRoZSBgc3RhdGVgIG9iamVjdCByZXR1cm5lZCBieSB0aGVcblx0ICogW3BhcnNlKCldKCNwYXJzZSkgbWV0aG9kLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYHN0YXRlYFxuXHQgKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYHJldHVybk91dHB1dGAgSW50ZW5kZWQgZm9yIGltcGxlbWVudG9ycywgdGhpcyBhcmd1bWVudCBhbGxvd3MgeW91IHRvIHJldHVybiB0aGUgcmF3IG91dHB1dCBmcm9tIHRoZSBwYXJzZXIuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYHJldHVyblN0YXRlYCBBZGRzIHRoZSBzdGF0ZSB0byBhIGBzdGF0ZWAgcHJvcGVydHkgb24gdGhlIHJldHVybmVkIHJlZ2V4LiBVc2VmdWwgZm9yIGltcGxlbWVudG9ycyBhbmQgZGVidWdnaW5nLlxuXHQgKiBAcmV0dXJuIHtSZWdFeHB9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdHBpY29tYXRjaC5jb21waWxlUmUgPSAoc3RhdGUsIG9wdGlvbnMsIHJldHVybk91dHB1dCA9IGZhbHNlLCByZXR1cm5TdGF0ZSA9IGZhbHNlKSA9PiB7XG5cdCAgaWYgKHJldHVybk91dHB1dCA9PT0gdHJ1ZSkge1xuXHQgICAgcmV0dXJuIHN0YXRlLm91dHB1dDtcblx0ICB9XG5cblx0ICBjb25zdCBvcHRzID0gb3B0aW9ucyB8fCB7fTtcblx0ICBjb25zdCBwcmVwZW5kID0gb3B0cy5jb250YWlucyA/ICcnIDogJ14nO1xuXHQgIGNvbnN0IGFwcGVuZCA9IG9wdHMuY29udGFpbnMgPyAnJyA6ICckJztcblxuXHQgIGxldCBzb3VyY2UgPSBgJHtwcmVwZW5kfSg/OiR7c3RhdGUub3V0cHV0fSkke2FwcGVuZH1gO1xuXHQgIGlmIChzdGF0ZSAmJiBzdGF0ZS5uZWdhdGVkID09PSB0cnVlKSB7XG5cdCAgICBzb3VyY2UgPSBgXig/ISR7c291cmNlfSkuKiRgO1xuXHQgIH1cblxuXHQgIGNvbnN0IHJlZ2V4ID0gcGljb21hdGNoLnRvUmVnZXgoc291cmNlLCBvcHRpb25zKTtcblx0ICBpZiAocmV0dXJuU3RhdGUgPT09IHRydWUpIHtcblx0ICAgIHJlZ2V4LnN0YXRlID0gc3RhdGU7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHJlZ2V4O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSBhIHBhcnNlZCBnbG9iIHBhdHRlcm4uXG5cdCAqXG5cdCAqIGBgYGpzXG5cdCAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuXHQgKiBjb25zdCBzdGF0ZSA9IHBpY29tYXRjaC5wYXJzZSgnKi5qcycpO1xuXHQgKiAvLyBwaWNvbWF0Y2guY29tcGlsZVJlKHN0YXRlWywgb3B0aW9uc10pO1xuXHQgKlxuXHQgKiBjb25zb2xlLmxvZyhwaWNvbWF0Y2guY29tcGlsZVJlKHN0YXRlKSk7XG5cdCAqIC8vPT4gL14oPzooPyFcXC4pKD89LilbXi9dKj9cXC5qcykkL1xuXHQgKiBgYGBcblx0ICogQHBhcmFtIHtTdHJpbmd9IGBzdGF0ZWAgVGhlIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSBgLnBhcnNlYCBtZXRob2QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2Bcblx0ICogQHBhcmFtIHtCb29sZWFufSBgcmV0dXJuT3V0cHV0YCBJbXBsZW1lbnRvcnMgbWF5IHVzZSB0aGlzIGFyZ3VtZW50IHRvIHJldHVybiB0aGUgY29tcGlsZWQgb3V0cHV0LCBpbnN0ZWFkIG9mIGEgcmVndWxhciBleHByZXNzaW9uLiBUaGlzIGlzIG5vdCBleHBvc2VkIG9uIHRoZSBvcHRpb25zIHRvIHByZXZlbnQgZW5kLXVzZXJzIGZyb20gbXV0YXRpbmcgdGhlIHJlc3VsdC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBgcmV0dXJuU3RhdGVgIEltcGxlbWVudG9ycyBtYXkgdXNlIHRoaXMgYXJndW1lbnQgdG8gcmV0dXJuIHRoZSBzdGF0ZSBmcm9tIHRoZSBwYXJzZWQgZ2xvYiB3aXRoIHRoZSByZXR1cm5lZCByZWd1bGFyIGV4cHJlc3Npb24uXG5cdCAqIEByZXR1cm4ge1JlZ0V4cH0gUmV0dXJucyBhIHJlZ2V4IGNyZWF0ZWQgZnJvbSB0aGUgZ2l2ZW4gcGF0dGVybi5cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0cGljb21hdGNoLm1ha2VSZSA9IChpbnB1dCwgb3B0aW9ucyA9IHt9LCByZXR1cm5PdXRwdXQgPSBmYWxzZSwgcmV0dXJuU3RhdGUgPSBmYWxzZSkgPT4ge1xuXHQgIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdCAgfVxuXG5cdCAgbGV0IHBhcnNlZCA9IHsgbmVnYXRlZDogZmFsc2UsIGZhc3RwYXRoczogdHJ1ZSB9O1xuXG5cdCAgaWYgKG9wdGlvbnMuZmFzdHBhdGhzICE9PSBmYWxzZSAmJiAoaW5wdXRbMF0gPT09ICcuJyB8fCBpbnB1dFswXSA9PT0gJyonKSkge1xuXHQgICAgcGFyc2VkLm91dHB1dCA9IHBhcnNlLmZhc3RwYXRocyhpbnB1dCwgb3B0aW9ucyk7XG5cdCAgfVxuXG5cdCAgaWYgKCFwYXJzZWQub3V0cHV0KSB7XG5cdCAgICBwYXJzZWQgPSBwYXJzZShpbnB1dCwgb3B0aW9ucyk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHBpY29tYXRjaC5jb21waWxlUmUocGFyc2VkLCBvcHRpb25zLCByZXR1cm5PdXRwdXQsIHJldHVyblN0YXRlKTtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgcmVndWxhciBleHByZXNzaW9uIGZyb20gdGhlIGdpdmVuIHJlZ2V4IHNvdXJjZSBzdHJpbmcuXG5cdCAqXG5cdCAqIGBgYGpzXG5cdCAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuXHQgKiAvLyBwaWNvbWF0Y2gudG9SZWdleChzb3VyY2VbLCBvcHRpb25zXSk7XG5cdCAqXG5cdCAqIGNvbnN0IHsgb3V0cHV0IH0gPSBwaWNvbWF0Y2gucGFyc2UoJyouanMnKTtcblx0ICogY29uc29sZS5sb2cocGljb21hdGNoLnRvUmVnZXgob3V0cHV0KSk7XG5cdCAqIC8vPT4gL14oPzooPyFcXC4pKD89LilbXi9dKj9cXC5qcykkL1xuXHQgKiBgYGBcblx0ICogQHBhcmFtIHtTdHJpbmd9IGBzb3VyY2VgIFJlZ3VsYXIgZXhwcmVzc2lvbiBzb3VyY2Ugc3RyaW5nLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG5cdCAqIEByZXR1cm4ge1JlZ0V4cH1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0cGljb21hdGNoLnRvUmVnZXggPSAoc291cmNlLCBvcHRpb25zKSA9PiB7XG5cdCAgdHJ5IHtcblx0ICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuXHQgICAgcmV0dXJuIG5ldyBSZWdFeHAoc291cmNlLCBvcHRzLmZsYWdzIHx8IChvcHRzLm5vY2FzZSA/ICdpJyA6ICcnKSk7XG5cdCAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnID09PSB0cnVlKSB0aHJvdyBlcnI7XG5cdCAgICByZXR1cm4gLyReLztcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFBpY29tYXRjaCBjb25zdGFudHMuXG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICovXG5cblx0cGljb21hdGNoLmNvbnN0YW50cyA9IGNvbnN0YW50cztcblxuXHQvKipcblx0ICogRXhwb3NlIFwicGljb21hdGNoXCJcblx0ICovXG5cblx0cGljb21hdGNoXzEkMSA9IHBpY29tYXRjaDtcblx0cmV0dXJuIHBpY29tYXRjaF8xJDE7XG59XG5cbnZhciBwaWNvbWF0Y2hfMTtcbnZhciBoYXNSZXF1aXJlZFBpY29tYXRjaDtcblxuZnVuY3Rpb24gcmVxdWlyZVBpY29tYXRjaCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFBpY29tYXRjaCkgcmV0dXJuIHBpY29tYXRjaF8xO1xuXHRoYXNSZXF1aXJlZFBpY29tYXRjaCA9IDE7XG5cblx0Y29uc3QgcGljbyA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZVBpY29tYXRjaCQxKCk7XG5cdGNvbnN0IHV0aWxzID0gLypAX19QVVJFX18qLyByZXF1aXJlVXRpbHMoKTtcblxuXHRmdW5jdGlvbiBwaWNvbWF0Y2goZ2xvYiwgb3B0aW9ucywgcmV0dXJuU3RhdGUgPSBmYWxzZSkge1xuXHQgIC8vIGRlZmF1bHQgdG8gb3MucGxhdGZvcm0oKVxuXHQgIGlmIChvcHRpb25zICYmIChvcHRpb25zLndpbmRvd3MgPT09IG51bGwgfHwgb3B0aW9ucy53aW5kb3dzID09PSB1bmRlZmluZWQpKSB7XG5cdCAgICAvLyBkb24ndCBtdXRhdGUgdGhlIG9yaWdpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdCAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCB3aW5kb3dzOiB1dGlscy5pc1dpbmRvd3MoKSB9O1xuXHQgIH1cblxuXHQgIHJldHVybiBwaWNvKGdsb2IsIG9wdGlvbnMsIHJldHVyblN0YXRlKTtcblx0fVxuXG5cdE9iamVjdC5hc3NpZ24ocGljb21hdGNoLCBwaWNvKTtcblx0cGljb21hdGNoXzEgPSBwaWNvbWF0Y2g7XG5cdHJldHVybiBwaWNvbWF0Y2hfMTtcbn1cblxudmFyIHBpY29tYXRjaEV4cG9ydHMgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVQaWNvbWF0Y2goKTtcbmNvbnN0IHBtID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHBpY29tYXRjaEV4cG9ydHMpO1xuXG5jb25zdCBleHRyYWN0b3JzID0ge1xuICAgIEFycmF5UGF0dGVybihuYW1lcywgcGFyYW0pIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHBhcmFtLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudClcbiAgICAgICAgICAgICAgICBleHRyYWN0b3JzW2VsZW1lbnQudHlwZV0obmFtZXMsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBBc3NpZ25tZW50UGF0dGVybihuYW1lcywgcGFyYW0pIHtcbiAgICAgICAgZXh0cmFjdG9yc1twYXJhbS5sZWZ0LnR5cGVdKG5hbWVzLCBwYXJhbS5sZWZ0KTtcbiAgICB9LFxuICAgIElkZW50aWZpZXIobmFtZXMsIHBhcmFtKSB7XG4gICAgICAgIG5hbWVzLnB1c2gocGFyYW0ubmFtZSk7XG4gICAgfSxcbiAgICBNZW1iZXJFeHByZXNzaW9uKCkgeyB9LFxuICAgIE9iamVjdFBhdHRlcm4obmFtZXMsIHBhcmFtKSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwYXJhbS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIFR5cGVzY3JpcHQgcmVwb3J0cyB0aGF0IHRoaXMgaXMgbm90IGEgdmFsaWQgdHlwZVxuICAgICAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gJ1Jlc3RFbGVtZW50Jykge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RvcnMuUmVzdEVsZW1lbnQobmFtZXMsIHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdG9yc1twcm9wLnZhbHVlLnR5cGVdKG5hbWVzLCBwcm9wLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgUmVzdEVsZW1lbnQobmFtZXMsIHBhcmFtKSB7XG4gICAgICAgIGV4dHJhY3RvcnNbcGFyYW0uYXJndW1lbnQudHlwZV0obmFtZXMsIHBhcmFtLmFyZ3VtZW50KTtcbiAgICB9XG59O1xuY29uc3QgZXh0cmFjdEFzc2lnbmVkTmFtZXMgPSBmdW5jdGlvbiBleHRyYWN0QXNzaWduZWROYW1lcyhwYXJhbSkge1xuICAgIGNvbnN0IG5hbWVzID0gW107XG4gICAgZXh0cmFjdG9yc1twYXJhbS50eXBlXShuYW1lcywgcGFyYW0pO1xuICAgIHJldHVybiBuYW1lcztcbn07XG5cbi8vIEhlbHBlciBzaW5jZSBUeXBlc2NyaXB0IGNhbid0IGRldGVjdCByZWFkb25seSBhcnJheXMgd2l0aCBBcnJheS5pc0FycmF5XG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG59XG5mdW5jdGlvbiBlbnN1cmVBcnJheSQxKHRoaW5nKSB7XG4gICAgaWYgKGlzQXJyYXkodGhpbmcpKVxuICAgICAgICByZXR1cm4gdGhpbmc7XG4gICAgaWYgKHRoaW5nID09IG51bGwpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICByZXR1cm4gW3RoaW5nXTtcbn1cblxuY29uc3Qgbm9ybWFsaXplUGF0aFJlZ0V4cCA9IG5ldyBSZWdFeHAoYFxcXFwke3dpbjMyLnNlcH1gLCAnZycpO1xuY29uc3Qgbm9ybWFsaXplUGF0aCA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGgoZmlsZW5hbWUpIHtcbiAgICByZXR1cm4gZmlsZW5hbWUucmVwbGFjZShub3JtYWxpemVQYXRoUmVnRXhwLCBwb3NpeC5zZXApO1xufTtcblxuZnVuY3Rpb24gZ2V0TWF0Y2hlclN0cmluZyhpZCwgcmVzb2x1dGlvbkJhc2UpIHtcbiAgICBpZiAocmVzb2x1dGlvbkJhc2UgPT09IGZhbHNlIHx8IGlzQWJzb2x1dGUoaWQpIHx8IGlkLnN0YXJ0c1dpdGgoJyoqJykpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgoaWQpO1xuICAgIH1cbiAgICAvLyByZXNvbHZlKCcnKSBpcyB2YWxpZCBhbmQgd2lsbCBkZWZhdWx0IHRvIHByb2Nlc3MuY3dkKClcbiAgICBjb25zdCBiYXNlUGF0aCA9IG5vcm1hbGl6ZVBhdGgocmVzb2x2ZShyZXNvbHV0aW9uQmFzZSB8fCAnJykpXG4gICAgICAgIC8vIGVzY2FwZSBhbGwgcG9zc2libGUgKHBvc2l4ICsgd2luKSBwYXRoIGNoYXJhY3RlcnMgdGhhdCBtaWdodCBpbnRlcmZlcmUgd2l0aCByZWdleFxuICAgICAgICAucmVwbGFjZSgvWy1eJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbiAgICAvLyBOb3RlIHRoYXQgd2UgdXNlIHBvc2l4LmpvaW4gYmVjYXVzZTpcbiAgICAvLyAxLiB0aGUgYmFzZVBhdGggaGFzIGJlZW4gbm9ybWFsaXplZCB0byB1c2UgL1xuICAgIC8vIDIuIHRoZSBpbmNvbWluZyBnbG9iIChpZCkgbWF0Y2hlciwgYWxzbyB1c2VzIC9cbiAgICAvLyBvdGhlcndpc2UgTm9kZSB3aWxsIGZvcmNlIGJhY2tzbGFzaCAoXFwpIG9uIHdpbmRvd3NcbiAgICByZXR1cm4gcG9zaXguam9pbihiYXNlUGF0aCwgbm9ybWFsaXplUGF0aChpZCkpO1xufVxuY29uc3QgY3JlYXRlRmlsdGVyID0gZnVuY3Rpb24gY3JlYXRlRmlsdGVyKGluY2x1ZGUsIGV4Y2x1ZGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uQmFzZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yZXNvbHZlO1xuICAgIGNvbnN0IGdldE1hdGNoZXIgPSAoaWQpID0+IGlkIGluc3RhbmNlb2YgUmVnRXhwXG4gICAgICAgID8gaWRcbiAgICAgICAgOiB7XG4gICAgICAgICAgICB0ZXN0OiAod2hhdCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgcmVmYWN0b3IgaXMgYSB0YWQgb3Zlcmx5IHZlcmJvc2UgYnV0IG1ha2VzIGZvciBlYXN5IGRlYnVnZ2luZ1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBnZXRNYXRjaGVyU3RyaW5nKGlkLCByZXNvbHV0aW9uQmFzZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZm4gPSBwbShwYXR0ZXJuLCB7IGRvdDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmbih3aGF0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIGNvbnN0IGluY2x1ZGVNYXRjaGVycyA9IGVuc3VyZUFycmF5JDEoaW5jbHVkZSkubWFwKGdldE1hdGNoZXIpO1xuICAgIGNvbnN0IGV4Y2x1ZGVNYXRjaGVycyA9IGVuc3VyZUFycmF5JDEoZXhjbHVkZSkubWFwKGdldE1hdGNoZXIpO1xuICAgIGlmICghaW5jbHVkZU1hdGNoZXJzLmxlbmd0aCAmJiAhZXhjbHVkZU1hdGNoZXJzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIChpZCkgPT4gdHlwZW9mIGlkID09PSAnc3RyaW5nJyAmJiAhaWQuaW5jbHVkZXMoJ1xcMCcpO1xuICAgIHJldHVybiBmdW5jdGlvbiByZXN1bHQoaWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChpZC5pbmNsdWRlcygnXFwwJykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHBhdGhJZCA9IG5vcm1hbGl6ZVBhdGgoaWQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4Y2x1ZGVNYXRjaGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlciA9IGV4Y2x1ZGVNYXRjaGVyc1tpXTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVyLnRlc3QocGF0aElkKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmNsdWRlTWF0Y2hlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXIgPSBpbmNsdWRlTWF0Y2hlcnNbaV07XG4gICAgICAgICAgICBpZiAobWF0Y2hlci50ZXN0KHBhdGhJZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFpbmNsdWRlTWF0Y2hlcnMubGVuZ3RoO1xuICAgIH07XG59O1xuXG5jb25zdCByZXNlcnZlZFdvcmRzID0gJ2JyZWFrIGNhc2UgY2xhc3MgY2F0Y2ggY29uc3QgY29udGludWUgZGVidWdnZXIgZGVmYXVsdCBkZWxldGUgZG8gZWxzZSBleHBvcnQgZXh0ZW5kcyBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiBpbXBvcnQgaW4gaW5zdGFuY2VvZiBsZXQgbmV3IHJldHVybiBzdXBlciBzd2l0Y2ggdGhpcyB0aHJvdyB0cnkgdHlwZW9mIHZhciB2b2lkIHdoaWxlIHdpdGggeWllbGQgZW51bSBhd2FpdCBpbXBsZW1lbnRzIHBhY2thZ2UgcHJvdGVjdGVkIHN0YXRpYyBpbnRlcmZhY2UgcHJpdmF0ZSBwdWJsaWMnO1xuY29uc3QgYnVpbHRpbnMgPSAnYXJndW1lbnRzIEluZmluaXR5IE5hTiB1bmRlZmluZWQgbnVsbCB0cnVlIGZhbHNlIGV2YWwgdW5ldmFsIGlzRmluaXRlIGlzTmFOIHBhcnNlRmxvYXQgcGFyc2VJbnQgZGVjb2RlVVJJIGRlY29kZVVSSUNvbXBvbmVudCBlbmNvZGVVUkkgZW5jb2RlVVJJQ29tcG9uZW50IGVzY2FwZSB1bmVzY2FwZSBPYmplY3QgRnVuY3Rpb24gQm9vbGVhbiBTeW1ib2wgRXJyb3IgRXZhbEVycm9yIEludGVybmFsRXJyb3IgUmFuZ2VFcnJvciBSZWZlcmVuY2VFcnJvciBTeW50YXhFcnJvciBUeXBlRXJyb3IgVVJJRXJyb3IgTnVtYmVyIE1hdGggRGF0ZSBTdHJpbmcgUmVnRXhwIEFycmF5IEludDhBcnJheSBVaW50OEFycmF5IFVpbnQ4Q2xhbXBlZEFycmF5IEludDE2QXJyYXkgVWludDE2QXJyYXkgSW50MzJBcnJheSBVaW50MzJBcnJheSBGbG9hdDMyQXJyYXkgRmxvYXQ2NEFycmF5IE1hcCBTZXQgV2Vha01hcCBXZWFrU2V0IFNJTUQgQXJyYXlCdWZmZXIgRGF0YVZpZXcgSlNPTiBQcm9taXNlIEdlbmVyYXRvciBHZW5lcmF0b3JGdW5jdGlvbiBSZWZsZWN0IFByb3h5IEludGwnO1xuY29uc3QgZm9yYmlkZGVuSWRlbnRpZmllcnMgPSBuZXcgU2V0KGAke3Jlc2VydmVkV29yZHN9ICR7YnVpbHRpbnN9YC5zcGxpdCgnICcpKTtcbmZvcmJpZGRlbklkZW50aWZpZXJzLmFkZCgnJyk7XG5cbmNsYXNzIEFycmF5UGF0dGVybiBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBhZGRFeHBvcnRlZFZhcmlhYmxlcyh2YXJpYWJsZXMsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgICAgICAgZWxlbWVudD8uYWRkRXhwb3J0ZWRWYXJpYWJsZXModmFyaWFibGVzLCBleHBvcnROYW1lc0J5VmFyaWFibGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY2xhcmUoa2luZCkge1xuICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGVzLnB1c2goLi4uZWxlbWVudC5kZWNsYXJlKGtpbmQsIFVOS05PV05fRVhQUkVTU0lPTikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YXJpYWJsZXM7XG4gICAgfVxuICAgIC8vIFBhdHRlcm5zIGNhbiBvbmx5IGJlIGRlb3B0aW1pemVkIGF0IHRoZSBlbXB0eSBwYXRoIGF0IHRoZSBtb21lbnRcbiAgICBkZW9wdGltaXplUGF0aCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGVsZW1lbnQ/LmRlb3B0aW1pemVQYXRoKEVNUFRZX1BBVEgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFBhdHRlcm5zIGFyZSBvbmx5IGNoZWNrZWQgYXQgdGhlIGVtcHR5IHBhdGggYXQgdGhlIG1vbWVudFxuICAgIGhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKF9wYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQ/Lmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKEVNUFRZX1BBVEgsIGludGVyYWN0aW9uLCBjb250ZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1hcmtEZWNsYXJhdGlvblJlYWNoZWQoKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICBlbGVtZW50Py5tYXJrRGVjbGFyYXRpb25SZWFjaGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEFycm93RnVuY3Rpb25FeHByZXNzaW9uIGV4dGVuZHMgRnVuY3Rpb25CYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5vYmplY3RFbnRpdHkgPSBudWxsO1xuICAgIH1cbiAgICBnZXQgZXhwcmVzc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhZ1NldCh0aGlzLmZsYWdzLCA4Mzg4NjA4IC8qIEZsYWcuZXhwcmVzc2lvbiAqLyk7XG4gICAgfVxuICAgIHNldCBleHByZXNzaW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBzZXRGbGFnKHRoaXMuZmxhZ3MsIDgzODg2MDggLyogRmxhZy5leHByZXNzaW9uICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIGNyZWF0ZVNjb3BlKHBhcmVudFNjb3BlKSB7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBuZXcgUmV0dXJuVmFsdWVTY29wZShwYXJlbnRTY29wZSwgZmFsc2UpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGVvcHRpbWl6ZWQpXG4gICAgICAgICAgICB0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHN1cGVyLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYW5ub3RhdGlvbk5vU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJhY3Rpb24udHlwZSA9PT0gSU5URVJBQ1RJT05fQ0FMTEVEKSB7XG4gICAgICAgICAgICBjb25zdCB7IGlnbm9yZSwgYnJva2VuRmxvdyB9ID0gY29udGV4dDtcbiAgICAgICAgICAgIGNvbnRleHQuaWdub3JlID0ge1xuICAgICAgICAgICAgICAgIGJyZWFrczogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29udGludWVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYWJlbHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICByZXR1cm5ZaWVsZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0aGlzOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvZHkuaGFzRWZmZWN0cyhjb250ZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRleHQuaWdub3JlID0gaWdub3JlO1xuICAgICAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gYnJva2VuRmxvdztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9ubHlGdW5jdGlvbkNhbGxVc2VkKCkge1xuICAgICAgICBjb25zdCBpc0lJRkUgPSB0aGlzLnBhcmVudC50eXBlID09PSBDYWxsRXhwcmVzc2lvbiQxICYmXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5jYWxsZWUgPT09IHRoaXM7XG4gICAgICAgIHJldHVybiBpc0lJRkUgfHwgc3VwZXIub25seUZ1bmN0aW9uQ2FsbFVzZWQoKTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICBzdXBlci5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJhbWV0ZXIgb2YgdGhpcy5wYXJhbXMpIHtcbiAgICAgICAgICAgIGlmICghKHBhcmFtZXRlciBpbnN0YW5jZW9mIElkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldE9iamVjdEVudGl0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMub2JqZWN0RW50aXR5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RFbnRpdHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLm9iamVjdEVudGl0eSA9IG5ldyBPYmplY3RFbnRpdHkoW10sIE9CSkVDVF9QUk9UT1RZUEUpKTtcbiAgICB9XG59XG5cbmNsYXNzIE9iamVjdFBhdHRlcm4gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgYWRkRXhwb3J0ZWRWYXJpYWJsZXModmFyaWFibGVzLCBleHBvcnROYW1lc0J5VmFyaWFibGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eS50eXBlID09PSBQcm9wZXJ0eSQxKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkudmFsdWUuYWRkRXhwb3J0ZWRWYXJpYWJsZXModmFyaWFibGVzLCBleHBvcnROYW1lc0J5VmFyaWFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkuYXJndW1lbnQuYWRkRXhwb3J0ZWRWYXJpYWJsZXModmFyaWFibGVzLCBleHBvcnROYW1lc0J5VmFyaWFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlY2xhcmUoa2luZCwgaW5pdCkge1xuICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKC4uLnByb3BlcnR5LmRlY2xhcmUoa2luZCwgaW5pdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YXJpYWJsZXM7XG4gICAgfVxuICAgIGRlb3B0aW1pemVQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHRoaXMucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5LmRlb3B0aW1pemVQYXRoKHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKFxuICAgIC8vIEF0IHRoZSBtb21lbnQsIHRoaXMgaXMgb25seSB0cmlnZ2VyZWQgZm9yIGFzc2lnbm1lbnQgbGVmdC1oYW5kIHNpZGVzLFxuICAgIC8vIHdoZXJlIHRoZSBwYXRoIGlzIGVtcHR5XG4gICAgX3BhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgdGhpcy5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydHkuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoRU1QVFlfUEFUSCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbWFya0RlY2xhcmF0aW9uUmVhY2hlZCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHByb3BlcnR5Lm1hcmtEZWNsYXJhdGlvblJlYWNoZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQXNzaWdubWVudEV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHsgZGVvcHRpbWl6ZWQsIGxlZnQsIG9wZXJhdG9yLCByaWdodCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFkZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgLy8gTWVtYmVyRXhwcmVzc2lvbnMgZG8gbm90IGFjY2VzcyB0aGUgcHJvcGVydHkgYmVmb3JlIGFzc2lnbm1lbnRzIGlmIHRoZVxuICAgICAgICAvLyBvcGVyYXRvciBpcyAnPScuXG4gICAgICAgIHJldHVybiAocmlnaHQuaGFzRWZmZWN0cyhjb250ZXh0KSB8fCBsZWZ0Lmhhc0VmZmVjdHNBc0Fzc2lnbm1lbnRUYXJnZXQoY29udGV4dCwgb3BlcmF0b3IgIT09ICc9JykpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpIHtcbiAgICAgICAgY29uc3QgeyBkZW9wdGltaXplZCwgbGVmdCwgcmlnaHQsIG9wZXJhdG9yIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5IHx8XG4gICAgICAgICAgICBvcGVyYXRvciAhPT0gJz0nIHx8XG4gICAgICAgICAgICBsZWZ0LmluY2x1ZGVkIHx8XG4gICAgICAgICAgICBsZWZ0Lmhhc0VmZmVjdHNBc0Fzc2lnbm1lbnRUYXJnZXQoY3JlYXRlSGFzRWZmZWN0c0NvbnRleHQoKSwgZmFsc2UpKSB7XG4gICAgICAgICAgICBsZWZ0LmluY2x1ZGVBc0Fzc2lnbm1lbnRUYXJnZXQoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHksIG9wZXJhdG9yICE9PSAnPScpO1xuICAgICAgICB9XG4gICAgICAgIHJpZ2h0LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgIH1cbiAgICBpbml0aWFsaXNlKCkge1xuICAgICAgICBzdXBlci5pbml0aWFsaXNlKCk7XG4gICAgICAgIGlmICh0aGlzLmxlZnQgaW5zdGFuY2VvZiBJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBjb25zdCB2YXJpYWJsZSA9IHRoaXMuc2NvcGUudmFyaWFibGVzLmdldCh0aGlzLmxlZnQubmFtZSk7XG4gICAgICAgICAgICBpZiAodmFyaWFibGU/LmtpbmQgPT09ICdjb25zdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQuZXJyb3IobG9nQ29uc3RWYXJpYWJsZVJlYXNzaWduRXJyb3IoKSwgdGhpcy5sZWZ0LnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlZnQuc2V0QXNzaWduZWRWYWx1ZSh0aGlzLnJpZ2h0KTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMsIHsgcHJldmVudEFTSSwgcmVuZGVyZWRQYXJlbnRUeXBlLCByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudCB9ID0gQkxBTkspIHtcbiAgICAgICAgY29uc3QgeyBsZWZ0LCByaWdodCwgc3RhcnQsIGVuZCwgcGFyZW50IH0gPSB0aGlzO1xuICAgICAgICBpZiAobGVmdC5pbmNsdWRlZCkge1xuICAgICAgICAgICAgbGVmdC5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICByaWdodC5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpbmNsdXNpb25TdGFydCA9IGZpbmROb25XaGl0ZVNwYWNlKGNvZGUub3JpZ2luYWwsIGZpbmRGaXJzdE9jY3VycmVuY2VPdXRzaWRlQ29tbWVudChjb2RlLm9yaWdpbmFsLCAnPScsIGxlZnQuZW5kKSArIDEpO1xuICAgICAgICAgICAgY29kZS5yZW1vdmUoc3RhcnQsIGluY2x1c2lvblN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChwcmV2ZW50QVNJKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTGluZUJyZWFrcyhjb2RlLCBpbmNsdXNpb25TdGFydCwgcmlnaHQuc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmlnaHQucmVuZGVyKGNvZGUsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZFBhcmVudFR5cGU6IHJlbmRlcmVkUGFyZW50VHlwZSB8fCBwYXJlbnQudHlwZSxcbiAgICAgICAgICAgICAgICByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudDogcmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQgfHwgcGFyZW50LnR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZvcm1hdCA9PT0gJ3N5c3RlbScpIHtcbiAgICAgICAgICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlID0gbGVmdC52YXJpYWJsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBvcnROYW1lcyA9IG9wdGlvbnMuZXhwb3J0TmFtZXNCeVZhcmlhYmxlLmdldCh2YXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9ydE5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBvcnROYW1lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclN5c3RlbUV4cG9ydEV4cHJlc3Npb24odmFyaWFibGUsIHN0YXJ0LCBlbmQsIGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3lzdGVtRXhwb3J0U2VxdWVuY2VBZnRlckV4cHJlc3Npb24odmFyaWFibGUsIHN0YXJ0LCBlbmQsIHBhcmVudC50eXBlICE9PSBFeHByZXNzaW9uU3RhdGVtZW50JDEsIGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeXN0ZW1QYXR0ZXJuRXhwb3J0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGxlZnQuYWRkRXhwb3J0ZWRWYXJpYWJsZXMoc3lzdGVtUGF0dGVybkV4cG9ydHMsIG9wdGlvbnMuZXhwb3J0TmFtZXNCeVZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3lzdGVtUGF0dGVybkV4cG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJTeXN0ZW1FeHBvcnRGdW5jdGlvbihzeXN0ZW1QYXR0ZXJuRXhwb3J0cywgc3RhcnQsIGVuZCwgcmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQgPT09IEV4cHJlc3Npb25TdGF0ZW1lbnQkMSwgY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQuaW5jbHVkZWQgJiZcbiAgICAgICAgICAgIGxlZnQgaW5zdGFuY2VvZiBPYmplY3RQYXR0ZXJuICYmXG4gICAgICAgICAgICAocmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQgPT09IEV4cHJlc3Npb25TdGF0ZW1lbnQkMSB8fFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50ID09PSBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiQxKSkge1xuICAgICAgICAgICAgY29kZS5hcHBlbmRSaWdodChzdGFydCwgJygnKTtcbiAgICAgICAgICAgIGNvZGUucHJlcGVuZExlZnQoZW5kLCAnKScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5RGVvcHRpbWl6YXRpb25zKCkge1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sZWZ0LmRlb3B0aW1pemVQYXRoKEVNUFRZX1BBVEgpO1xuICAgICAgICB0aGlzLnJpZ2h0LmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgIHRoaXMuc2NvcGUuY29udGV4dC5yZXF1ZXN0VHJlZXNoYWtpbmdQYXNzKCk7XG4gICAgfVxufVxuXG5jbGFzcyBBc3NpZ25tZW50UGF0dGVybiBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBhZGRFeHBvcnRlZFZhcmlhYmxlcyh2YXJpYWJsZXMsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSkge1xuICAgICAgICB0aGlzLmxlZnQuYWRkRXhwb3J0ZWRWYXJpYWJsZXModmFyaWFibGVzLCBleHBvcnROYW1lc0J5VmFyaWFibGUpO1xuICAgIH1cbiAgICBkZWNsYXJlKGtpbmQsIGluaXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5kZWNsYXJlKGtpbmQsIGluaXQpO1xuICAgIH1cbiAgICBkZW9wdGltaXplUGF0aChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0LmRlb3B0aW1pemVQYXRoKHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAocGF0aC5sZW5ndGggPiAwIHx8IHRoaXMubGVmdC5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChFTVBUWV9QQVRILCBpbnRlcmFjdGlvbiwgY29udGV4dCkpO1xuICAgIH1cbiAgICBtYXJrRGVjbGFyYXRpb25SZWFjaGVkKCkge1xuICAgICAgICB0aGlzLmxlZnQubWFya0RlY2xhcmF0aW9uUmVhY2hlZCgpO1xuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucywgeyBpc1Nob3J0aGFuZFByb3BlcnR5IH0gPSBCTEFOSykge1xuICAgICAgICB0aGlzLmxlZnQucmVuZGVyKGNvZGUsIG9wdGlvbnMsIHsgaXNTaG9ydGhhbmRQcm9wZXJ0eSB9KTtcbiAgICAgICAgdGhpcy5yaWdodC5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFwcGx5RGVvcHRpbWl6YXRpb25zKCkge1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sZWZ0LmRlb3B0aW1pemVQYXRoKEVNUFRZX1BBVEgpO1xuICAgICAgICB0aGlzLnJpZ2h0LmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgIHRoaXMuc2NvcGUuY29udGV4dC5yZXF1ZXN0VHJlZXNoYWtpbmdQYXNzKCk7XG4gICAgfVxufVxuXG5jbGFzcyBBd2FpdEV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgaGFzRWZmZWN0cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICBpZiAoIXRoaXMuZGVvcHRpbWl6ZWQpXG4gICAgICAgICAgICB0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCk7XG4gICAgICAgIGlmICghdGhpcy5pbmNsdWRlZCkge1xuICAgICAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgICAgICBjaGVja1RvcExldmVsQXdhaXQ6IGlmICghdGhpcy5zY29wZS5jb250ZXh0LnVzZXNUb3BMZXZlbEF3YWl0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEZ1bmN0aW9uTm9kZSB8fCBwYXJlbnQgaW5zdGFuY2VvZiBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGNoZWNrVG9wTGV2ZWxBd2FpdDtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICgocGFyZW50ID0gcGFyZW50LnBhcmVudCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NvcGUuY29udGV4dC51c2VzVG9wTGV2ZWxBd2FpdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcmd1bWVudC5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICB9XG59XG5cbmNvbnN0IGJpbmFyeU9wZXJhdG9ycyA9IHtcbiAgICAnIT0nOiAobGVmdCwgcmlnaHQpID0+IGxlZnQgIT0gcmlnaHQsXG4gICAgJyE9PSc6IChsZWZ0LCByaWdodCkgPT4gbGVmdCAhPT0gcmlnaHQsXG4gICAgJyUnOiAobGVmdCwgcmlnaHQpID0+IGxlZnQgJSByaWdodCxcbiAgICAnJic6IChsZWZ0LCByaWdodCkgPT4gbGVmdCAmIHJpZ2h0LFxuICAgICcqJzogKGxlZnQsIHJpZ2h0KSA9PiBsZWZ0ICogcmlnaHQsXG4gICAgLy8gQXQgdGhlIG1vbWVudCwgXCIqKlwiIHdpbGwgYmUgdHJhbnNwaWxlZCB0byBNYXRoLnBvd1xuICAgICcqKic6IChsZWZ0LCByaWdodCkgPT4gbGVmdCAqKiByaWdodCxcbiAgICAnKyc6IChsZWZ0LCByaWdodCkgPT4gbGVmdCArIHJpZ2h0LFxuICAgICctJzogKGxlZnQsIHJpZ2h0KSA9PiBsZWZ0IC0gcmlnaHQsXG4gICAgJy8nOiAobGVmdCwgcmlnaHQpID0+IGxlZnQgLyByaWdodCxcbiAgICAnPCc6IChsZWZ0LCByaWdodCkgPT4gbGVmdCA8IHJpZ2h0LFxuICAgICc8PCc6IChsZWZ0LCByaWdodCkgPT4gbGVmdCA8PCByaWdodCxcbiAgICAnPD0nOiAobGVmdCwgcmlnaHQpID0+IGxlZnQgPD0gcmlnaHQsXG4gICAgJz09JzogKGxlZnQsIHJpZ2h0KSA9PiBsZWZ0ID09IHJpZ2h0LFxuICAgICc9PT0nOiAobGVmdCwgcmlnaHQpID0+IGxlZnQgPT09IHJpZ2h0LFxuICAgICc+JzogKGxlZnQsIHJpZ2h0KSA9PiBsZWZ0ID4gcmlnaHQsXG4gICAgJz49JzogKGxlZnQsIHJpZ2h0KSA9PiBsZWZ0ID49IHJpZ2h0LFxuICAgICc+Pic6IChsZWZ0LCByaWdodCkgPT4gbGVmdCA+PiByaWdodCxcbiAgICAnPj4+JzogKGxlZnQsIHJpZ2h0KSA9PiBsZWZ0ID4+PiByaWdodCxcbiAgICAnXic6IChsZWZ0LCByaWdodCkgPT4gbGVmdCBeIHJpZ2h0LFxuICAgICd8JzogKGxlZnQsIHJpZ2h0KSA9PiBsZWZ0IHwgcmlnaHRcbiAgICAvLyBXZSB1c2UgdGhlIGZhbGxiYWNrIGZvciBjYXNlcyB3aGVyZSB3ZSByZXR1cm4gc29tZXRoaW5nIHVua25vd25cbiAgICAvLyBpbjogKCkgPT4gVW5rbm93blZhbHVlLFxuICAgIC8vIGluc3RhbmNlb2Y6ICgpID0+IFVua25vd25WYWx1ZSxcbn07XG5jbGFzcyBCaW5hcnlFeHByZXNzaW9uIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGRlb3B0aW1pemVDYWNoZSgpIHsgfVxuICAgIGdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duVmFsdWU7XG4gICAgICAgIGNvbnN0IGxlZnRWYWx1ZSA9IHRoaXMubGVmdC5nZXRMaXRlcmFsVmFsdWVBdFBhdGgoRU1QVFlfUEFUSCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsZWZ0VmFsdWUgPT09ICdzeW1ib2wnKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25WYWx1ZTtcbiAgICAgICAgY29uc3QgcmlnaHRWYWx1ZSA9IHRoaXMucmlnaHQuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKEVNUFRZX1BBVEgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgICAgIGlmICh0eXBlb2YgcmlnaHRWYWx1ZSA9PT0gJ3N5bWJvbCcpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blZhbHVlO1xuICAgICAgICBjb25zdCBvcGVyYXRvckZ1bmN0aW9uID0gYmluYXJ5T3BlcmF0b3JzW3RoaXMub3BlcmF0b3JdO1xuICAgICAgICBpZiAoIW9wZXJhdG9yRnVuY3Rpb24pXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blZhbHVlO1xuICAgICAgICByZXR1cm4gb3BlcmF0b3JGdW5jdGlvbihsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgLy8gc3VwcG9ydCBzb21lIGltcGxpY2l0IHR5cGUgY29lcmNpb24gcnVudGltZSBlcnJvcnNcbiAgICAgICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICcrJyAmJlxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBFeHByZXNzaW9uU3RhdGVtZW50ICYmXG4gICAgICAgICAgICB0aGlzLmxlZnQuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKEVNUFRZX1BBVEgsIFNIQVJFRF9SRUNVUlNJT05fVFJBQ0tFUiwgdGhpcykgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuaGFzRWZmZWN0cyhjb250ZXh0KTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgeyB0eXBlIH0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGUgIT09IElOVEVSQUNUSU9OX0FDQ0VTU0VEIHx8IHBhdGgubGVuZ3RoID4gMTtcbiAgICB9XG4gICAgcmVtb3ZlQW5ub3RhdGlvbnMoY29kZSkge1xuICAgICAgICB0aGlzLmxlZnQucmVtb3ZlQW5ub3RhdGlvbnMoY29kZSk7XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zLCB7IHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50IH0gPSBCTEFOSykge1xuICAgICAgICB0aGlzLmxlZnQucmVuZGVyKGNvZGUsIG9wdGlvbnMsIHsgcmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQgfSk7XG4gICAgICAgIHRoaXMucmlnaHQucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuY2xhc3MgQnJlYWtTdGF0ZW1lbnQgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuaWdub3JlLmxhYmVscy5oYXModGhpcy5sYWJlbC5uYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRleHQuaW5jbHVkZWRMYWJlbHMuYWRkKHRoaXMubGFiZWwubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuaWdub3JlLmJyZWFrcylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRleHQuaGFzQnJlYWsgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuYnJva2VuRmxvdyA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5sYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5sYWJlbC5pbmNsdWRlKCk7XG4gICAgICAgICAgICBjb250ZXh0LmluY2x1ZGVkTGFiZWxzLmFkZCh0aGlzLmxhYmVsLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5oYXNCcmVhayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNhbGxBcmd1bWVudHMoY29kZSwgb3B0aW9ucywgbm9kZSkge1xuICAgIGlmIChub2RlLmFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChub2RlLmFyZ3VtZW50c1tub2RlLmFyZ3VtZW50cy5sZW5ndGggLSAxXS5pbmNsdWRlZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhcmd1bWVudCBvZiBub2RlLmFyZ3VtZW50cykge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50LnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsYXN0SW5jbHVkZWRJbmRleCA9IG5vZGUuYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgICAgICAgICB3aGlsZSAobGFzdEluY2x1ZGVkSW5kZXggPj0gMCAmJiAhbm9kZS5hcmd1bWVudHNbbGFzdEluY2x1ZGVkSW5kZXhdLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgbGFzdEluY2x1ZGVkSW5kZXgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0SW5jbHVkZWRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8PSBsYXN0SW5jbHVkZWRJbmRleDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmFyZ3VtZW50c1tpbmRleF0ucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2RlLnJlbW92ZShmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZS5vcmlnaW5hbCwgJywnLCBub2RlLmFyZ3VtZW50c1tsYXN0SW5jbHVkZWRJbmRleF0uZW5kKSwgbm9kZS5lbmQgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGUucmVtb3ZlKGZpbmRGaXJzdE9jY3VycmVuY2VPdXRzaWRlQ29tbWVudChjb2RlLm9yaWdpbmFsLCAnKCcsIG5vZGUuY2FsbGVlLmVuZCkgKyAxLCBub2RlLmVuZCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBDYWxsRXhwcmVzc2lvbkJhc2UgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucmV0dXJuRXhwcmVzc2lvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6YWJsZURlcGVuZGVudEV4cHJlc3Npb25zID0gW107XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIGRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoLCByZWN1cnNpb25UcmFja2VyKSB7XG4gICAgICAgIGNvbnN0IHsgYXJncyB9ID0gaW50ZXJhY3Rpb247XG4gICAgICAgIGNvbnN0IFtyZXR1cm5FeHByZXNzaW9uLCBpc1B1cmVdID0gdGhpcy5nZXRSZXR1cm5FeHByZXNzaW9uKHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgICAgICBpZiAoaXNQdXJlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBkZW9wdGltaXplZEV4cHJlc3Npb25zID0gYXJncy5maWx0ZXIoZXhwcmVzc2lvbiA9PiAhIWV4cHJlc3Npb24gJiYgZXhwcmVzc2lvbiAhPT0gVU5LTk9XTl9FWFBSRVNTSU9OKTtcbiAgICAgICAgaWYgKGRlb3B0aW1pemVkRXhwcmVzc2lvbnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAocmV0dXJuRXhwcmVzc2lvbiA9PT0gVU5LTk9XTl9FWFBSRVNTSU9OKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV4cHJlc3Npb24gb2YgZGVvcHRpbWl6ZWRFeHByZXNzaW9ucykge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24uZGVvcHRpbWl6ZVBhdGgoVU5LTk9XTl9QQVRIKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlY3Vyc2lvblRyYWNrZXIud2l0aFRyYWNrZWRFbnRpdHlBdFBhdGgocGF0aCwgcmV0dXJuRXhwcmVzc2lvbiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXhwcmVzc2lvbiBvZiBkZW9wdGltaXplZEV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQuYWRkKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm5FeHByZXNzaW9uLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoLCByZWN1cnNpb25UcmFja2VyKTtcbiAgICAgICAgICAgIH0sIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlb3B0aW1pemVDYWNoZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmV0dXJuRXhwcmVzc2lvbj8uWzBdICE9PSBVTktOT1dOX0VYUFJFU1NJT04pIHtcbiAgICAgICAgICAgIHRoaXMucmV0dXJuRXhwcmVzc2lvbiA9IFVOS05PV05fUkVUVVJOX0VYUFJFU1NJT047XG4gICAgICAgICAgICBjb25zdCB7IGRlb3B0aW1pemFibGVEZXBlbmRlbnRFeHByZXNzaW9ucywgZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkID0gRU1QVFlfU0VUO1xuICAgICAgICAgICAgdGhpcy5kZW9wdGltaXphYmxlRGVwZW5kZW50RXhwcmVzc2lvbnMgPSBFTVBUWV9BUlJBWTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXhwcmVzc2lvbiBvZiBkZW9wdGltaXphYmxlRGVwZW5kZW50RXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uLmRlb3B0aW1pemVDYWNoZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIGV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkKSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5kZW9wdGltaXplUGF0aChVTktOT1dOX1BBVEgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlb3B0aW1pemVQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQuZGVvcHRpbWl6YXRpb25UcmFja2VyLnRyYWNrRW50aXR5QXRQYXRoQW5kR2V0SWZUcmFja2VkKHBhdGgsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3JldHVybkV4cHJlc3Npb25dID0gdGhpcy5nZXRSZXR1cm5FeHByZXNzaW9uKCk7XG4gICAgICAgIGlmIChyZXR1cm5FeHByZXNzaW9uICE9PSBVTktOT1dOX0VYUFJFU1NJT04pIHtcbiAgICAgICAgICAgIHJldHVybkV4cHJlc3Npb24uZGVvcHRpbWl6ZVBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgICAgICBjb25zdCBbcmV0dXJuRXhwcmVzc2lvbl0gPSB0aGlzLmdldFJldHVybkV4cHJlc3Npb24ocmVjdXJzaW9uVHJhY2tlcik7XG4gICAgICAgIGlmIChyZXR1cm5FeHByZXNzaW9uID09PSBVTktOT1dOX0VYUFJFU1NJT04pIHtcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2lvblRyYWNrZXIud2l0aFRyYWNrZWRFbnRpdHlBdFBhdGgocGF0aCwgcmV0dXJuRXhwcmVzc2lvbiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kZW9wdGltaXphYmxlRGVwZW5kZW50RXhwcmVzc2lvbnMucHVzaChvcmlnaW4pO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybkV4cHJlc3Npb24uZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgICAgIH0sIFVua25vd25WYWx1ZSk7XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgY29uc3QgcmV0dXJuRXhwcmVzc2lvbiA9IHRoaXMuZ2V0UmV0dXJuRXhwcmVzc2lvbihyZWN1cnNpb25UcmFja2VyKTtcbiAgICAgICAgaWYgKHJldHVybkV4cHJlc3Npb25bMF0gPT09IFVOS05PV05fRVhQUkVTU0lPTikge1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybkV4cHJlc3Npb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2lvblRyYWNrZXIud2l0aFRyYWNrZWRFbnRpdHlBdFBhdGgocGF0aCwgcmV0dXJuRXhwcmVzc2lvbiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kZW9wdGltaXphYmxlRGVwZW5kZW50RXhwcmVzc2lvbnMucHVzaChvcmlnaW4pO1xuICAgICAgICAgICAgY29uc3QgW2V4cHJlc3Npb24sIGlzUHVyZV0gPSByZXR1cm5FeHByZXNzaW9uWzBdLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgICAgICAgICAgcmV0dXJuIFtleHByZXNzaW9uLCBpc1B1cmUgfHwgcmV0dXJuRXhwcmVzc2lvblsxXV07XG4gICAgICAgIH0sIFVOS05PV05fUkVUVVJOX0VYUFJFU1NJT04pO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IGludGVyYWN0aW9uO1xuICAgICAgICBpZiAodHlwZSA9PT0gSU5URVJBQ1RJT05fQ0FMTEVEKSB7XG4gICAgICAgICAgICBjb25zdCB7IGFyZ3MsIHdpdGhOZXcgfSA9IGludGVyYWN0aW9uO1xuICAgICAgICAgICAgaWYgKCh3aXRoTmV3ID8gY29udGV4dC5pbnN0YW50aWF0ZWQgOiBjb250ZXh0LmNhbGxlZCkudHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQocGF0aCwgYXJncywgdGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHR5cGUgPT09IElOVEVSQUNUSU9OX0FTU0lHTkVEXG4gICAgICAgICAgICA/IGNvbnRleHQuYXNzaWduZWRcbiAgICAgICAgICAgIDogY29udGV4dC5hY2Nlc3NlZCkudHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQocGF0aCwgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbcmV0dXJuRXhwcmVzc2lvbiwgaXNQdXJlXSA9IHRoaXMuZ2V0UmV0dXJuRXhwcmVzc2lvbigpO1xuICAgICAgICByZXR1cm4gKCh0eXBlID09PSBJTlRFUkFDVElPTl9BU1NJR05FRCB8fCAhaXNQdXJlKSAmJlxuICAgICAgICAgICAgcmV0dXJuRXhwcmVzc2lvbi5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkpO1xuICAgIH1cbn1cblxuY2xhc3MgQ2FsbEV4cHJlc3Npb24gZXh0ZW5kcyBDYWxsRXhwcmVzc2lvbkJhc2Uge1xuICAgIGdldCBvcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhZ1NldCh0aGlzLmZsYWdzLCAxMjggLyogRmxhZy5vcHRpb25hbCAqLyk7XG4gICAgfVxuICAgIHNldCBvcHRpb25hbCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZsYWdzID0gc2V0RmxhZyh0aGlzLmZsYWdzLCAxMjggLyogRmxhZy5vcHRpb25hbCAqLywgdmFsdWUpO1xuICAgIH1cbiAgICBiaW5kKCkge1xuICAgICAgICBzdXBlci5iaW5kKCk7XG4gICAgICAgIGlmICh0aGlzLmNhbGxlZSBpbnN0YW5jZW9mIElkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlID0gdGhpcy5zY29wZS5maW5kVmFyaWFibGUodGhpcy5jYWxsZWUubmFtZSk7XG4gICAgICAgICAgICBpZiAodmFyaWFibGUuaXNOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQubG9nKExPR0xFVkVMX1dBUk4sIGxvZ0Nhbm5vdENhbGxOYW1lc3BhY2UodGhpcy5jYWxsZWUubmFtZSksIHRoaXMuc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGVlLm5hbWUgPT09ICdldmFsJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NvcGUuY29udGV4dC5sb2coTE9HTEVWRUxfV0FSTiwgbG9nRXZhbCh0aGlzLnNjb3BlLmNvbnRleHQubW9kdWxlLmlkKSwgdGhpcy5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbiA9IHtcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxlZSBpbnN0YW5jZW9mIE1lbWJlckV4cHJlc3Npb24gJiYgIXRoaXMuY2FsbGVlLnZhcmlhYmxlXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5jYWxsZWUub2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmFyZ3VtZW50c1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHR5cGU6IElOVEVSQUNUSU9OX0NBTExFRCxcbiAgICAgICAgICAgIHdpdGhOZXc6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldExpdGVyYWxWYWx1ZUF0UGF0aEFzQ2hhaW5FbGVtZW50KHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgICAgICByZXR1cm4gZ2V0Q2hhaW5FbGVtZW50TGl0ZXJhbFZhbHVlQXRQYXRoKHRoaXMsIHRoaXMuY2FsbGVlLCBwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICBmb3IgKGNvbnN0IGFyZ3VtZW50IG9mIHRoaXMuYXJndW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnQuaGFzRWZmZWN0cyhjb250ZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbm5vdGF0aW9uUHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5jYWxsZWUuaGFzRWZmZWN0cyhjb250ZXh0KSB8fFxuICAgICAgICAgICAgdGhpcy5jYWxsZWUuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoRU1QVFlfUEFUSCwgdGhpcy5pbnRlcmFjdGlvbiwgY29udGV4dCkpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzQXNDaGFpbkVsZW1lbnQoY29udGV4dCkge1xuICAgICAgICBjb25zdCBjYWxsZWVIYXNFZmZlY3RzID0gJ2hhc0VmZmVjdHNBc0NoYWluRWxlbWVudCcgaW4gdGhpcy5jYWxsZWVcbiAgICAgICAgICAgID8gdGhpcy5jYWxsZWUuaGFzRWZmZWN0c0FzQ2hhaW5FbGVtZW50KGNvbnRleHQpXG4gICAgICAgICAgICA6IHRoaXMuY2FsbGVlLmhhc0VmZmVjdHMoY29udGV4dCk7XG4gICAgICAgIGlmIChjYWxsZWVIYXNFZmZlY3RzID09PSBJU19TS0lQUEVEX0NIQUlOKVxuICAgICAgICAgICAgcmV0dXJuIElTX1NLSVBQRURfQ0hBSU47XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsICYmXG4gICAgICAgICAgICB0aGlzLmNhbGxlZS5nZXRMaXRlcmFsVmFsdWVBdFBhdGgoRU1QVFlfUEFUSCwgU0hBUkVEX1JFQ1VSU0lPTl9UUkFDS0VSLCB0aGlzKSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gKCF0aGlzLmFubm90YXRpb25QdXJlICYmIGNhbGxlZUhhc0VmZmVjdHMpIHx8IElTX1NLSVBQRURfQ0hBSU47XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugb25seSBhcHBseSBkZW9wdGltaXphdGlvbnMgbGF6aWx5IG9uY2Ugd2Uga25vdyB3ZSBhcmUgbm90IHNraXBwaW5nXG4gICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgZm9yIChjb25zdCBhcmd1bWVudCBvZiB0aGlzLmFyZ3VtZW50cykge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50Lmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICghdGhpcy5hbm5vdGF0aW9uUHVyZSAmJlxuICAgICAgICAgICAgKGNhbGxlZUhhc0VmZmVjdHMgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxlZS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChFTVBUWV9QQVRILCB0aGlzLmludGVyYWN0aW9uLCBjb250ZXh0KSkpO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgaWYgKGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgICAgICBzdXBlci5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSA9PT0gSU5DTFVERV9QQVJBTUVURVJTICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsZWUgaW5zdGFuY2VvZiBJZGVudGlmaWVyICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsZWUudmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxlZS52YXJpYWJsZS5tYXJrQ2FsbGVkRnJvbVRyeVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNhbGxlZS5pbmNsdWRlKGNvbnRleHQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxlZS5pbmNsdWRlQ2FsbEFyZ3VtZW50cyhjb250ZXh0LCB0aGlzLmFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGluaXRpYWxpc2UoKSB7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuYW5ub3RhdGlvbnMgJiZcbiAgICAgICAgICAgIHRoaXMuc2NvcGUuY29udGV4dC5vcHRpb25zLnRyZWVzaGFrZS5hbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9uUHVyZSA9IHRoaXMuYW5ub3RhdGlvbnMuc29tZShjb21tZW50ID0+IGNvbW1lbnQudHlwZSA9PT0gJ3B1cmUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucywgeyByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudCB9ID0gQkxBTkspIHtcbiAgICAgICAgdGhpcy5jYWxsZWUucmVuZGVyKGNvZGUsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGlzQ2FsbGVlT2ZSZW5kZXJlZFBhcmVudDogdHJ1ZSxcbiAgICAgICAgICAgIHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJDYWxsQXJndW1lbnRzKGNvZGUsIG9wdGlvbnMsIHRoaXMpO1xuICAgIH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kZW9wdGltaXplZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FsbGVlLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHRoaXMuaW50ZXJhY3Rpb24sIEVNUFRZX1BBVEgsIFNIQVJFRF9SRUNVUlNJT05fVFJBQ0tFUik7XG4gICAgICAgIHRoaXMuc2NvcGUuY29udGV4dC5yZXF1ZXN0VHJlZXNoYWtpbmdQYXNzKCk7XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb24ocmVjdXJzaW9uVHJhY2tlciA9IFNIQVJFRF9SRUNVUlNJT05fVFJBQ0tFUikge1xuICAgICAgICBpZiAodGhpcy5yZXR1cm5FeHByZXNzaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJldHVybkV4cHJlc3Npb24gPSBVTktOT1dOX1JFVFVSTl9FWFBSRVNTSU9OO1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnJldHVybkV4cHJlc3Npb24gPSB0aGlzLmNhbGxlZS5nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChFTVBUWV9QQVRILCB0aGlzLmludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmV0dXJuRXhwcmVzc2lvbjtcbiAgICB9XG59XG5cbmNsYXNzIENhdGNoQ2xhdXNlIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNyZWF0ZVNjb3BlKHBhcmVudFNjb3BlKSB7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBuZXcgUGFyYW1ldGVyU2NvcGUocGFyZW50U2NvcGUsIHRydWUpO1xuICAgIH1cbiAgICBwYXJzZU5vZGUoZXNUcmVlTm9kZSkge1xuICAgICAgICBjb25zdCB7IGJvZHksIHBhcmFtLCB0eXBlIH0gPSBlc1RyZWVOb2RlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICBpZiAocGFyYW0pIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW0gPSBuZXcgKHRoaXMuc2NvcGUuY29udGV4dC5nZXROb2RlQ29uc3RydWN0b3IocGFyYW0udHlwZSkpKHRoaXMsIHRoaXMuc2NvcGUpLnBhcnNlTm9kZShwYXJhbSk7XG4gICAgICAgICAgICB0aGlzLnBhcmFtLmRlY2xhcmUoJ3BhcmFtZXRlcicsIFVOS05PV05fRVhQUkVTU0lPTik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2R5ID0gbmV3IEJsb2NrU3RhdGVtZW50KHRoaXMsIHRoaXMuc2NvcGUuYm9keVNjb3BlKS5wYXJzZU5vZGUoYm9keSk7XG4gICAgICAgIHJldHVybiBzdXBlci5wYXJzZU5vZGUoZXNUcmVlTm9kZSk7XG4gICAgfVxufVxuQ2F0Y2hDbGF1c2UucHJvdG90eXBlLnByZXZlbnRDaGlsZEJsb2NrU2NvcGUgPSB0cnVlO1xuXG5jbGFzcyBDaGFpbkV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgLy8gZGVvcHRpbWl6YXRpb25zIGFyZSBub3QgcmVsZXZhbnQgYXMgd2UgYXJlIG5vdCBjYWNoaW5nIHZhbHVlc1xuICAgIGRlb3B0aW1pemVDYWNoZSgpIHsgfVxuICAgIGdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgY29uc3QgbGl0ZXJhbFZhbHVlID0gdGhpcy5leHByZXNzaW9uLmdldExpdGVyYWxWYWx1ZUF0UGF0aEFzQ2hhaW5FbGVtZW50KHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgICAgIHJldHVybiBsaXRlcmFsVmFsdWUgPT09IElTX1NLSVBQRURfQ0hBSU4gPyB1bmRlZmluZWQgOiBsaXRlcmFsVmFsdWU7XG4gICAgfVxuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLmhhc0VmZmVjdHNBc0NoYWluRWxlbWVudChjb250ZXh0KSA9PT0gdHJ1ZTtcbiAgICB9XG4gICAgcmVtb3ZlQW5ub3RhdGlvbnMoY29kZSkge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24ucmVtb3ZlQW5ub3RhdGlvbnMoY29kZSk7XG4gICAgfVxuICAgIGFwcGx5RGVvcHRpbWl6YXRpb25zKCkgeyB9XG59XG5cbmNsYXNzIENsYXNzQm9keVNjb3BlIGV4dGVuZHMgQ2hpbGRTY29wZSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBjbGFzc05vZGUpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZXh0IH0gPSBwYXJlbnQ7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVzLnNldCgndGhpcycsICh0aGlzLnRoaXNWYXJpYWJsZSA9IG5ldyBMb2NhbFZhcmlhYmxlKCd0aGlzJywgbnVsbCwgY2xhc3NOb2RlLCBjb250ZXh0LCAnb3RoZXInKSkpO1xuICAgICAgICB0aGlzLmluc3RhbmNlU2NvcGUgPSBuZXcgQ2hpbGRTY29wZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZVNjb3BlLnZhcmlhYmxlcy5zZXQoJ3RoaXMnLCBuZXcgVGhpc1ZhcmlhYmxlKGNvbnRleHQpKTtcbiAgICB9XG4gICAgZmluZExleGljYWxCb3VuZGFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5jbGFzcyBDbGFzc0JvZHkgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY3JlYXRlU2NvcGUocGFyZW50U2NvcGUpIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IG5ldyBDbGFzc0JvZHlTY29wZShwYXJlbnRTY29wZSwgdGhpcy5wYXJlbnQpO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQuaW5jbHVkZVZhcmlhYmxlSW5Nb2R1bGUodGhpcy5zY29wZS50aGlzVmFyaWFibGUpO1xuICAgICAgICBmb3IgKGNvbnN0IGRlZmluaXRpb24gb2YgdGhpcy5ib2R5KSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlTm9kZShlc1RyZWVOb2RlKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSAodGhpcy5ib2R5ID0gbmV3IEFycmF5KGVzVHJlZU5vZGUuYm9keS5sZW5ndGgpKTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBkZWZpbml0aW9uIG9mIGVzVHJlZU5vZGUuYm9keSkge1xuICAgICAgICAgICAgYm9keVtpbmRleCsrXSA9IG5ldyAodGhpcy5zY29wZS5jb250ZXh0LmdldE5vZGVDb25zdHJ1Y3RvcihkZWZpbml0aW9uLnR5cGUpKSh0aGlzLCBkZWZpbml0aW9uLnN0YXRpYyA/IHRoaXMuc2NvcGUgOiB0aGlzLnNjb3BlLmluc3RhbmNlU2NvcGUpLnBhcnNlTm9kZShkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIucGFyc2VOb2RlKGVzVHJlZU5vZGUpO1xuICAgIH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHsgfVxufVxuXG5jbGFzcyBDbGFzc0V4cHJlc3Npb24gZXh0ZW5kcyBDbGFzc05vZGUge1xuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zLCB7IHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50IH0gPSBCTEFOSykge1xuICAgICAgICBzdXBlci5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChyZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudCA9PT0gRXhwcmVzc2lvblN0YXRlbWVudCQxKSB7XG4gICAgICAgICAgICBjb2RlLmFwcGVuZFJpZ2h0KHRoaXMuc3RhcnQsICcoJyk7XG4gICAgICAgICAgICBjb2RlLnByZXBlbmRMZWZ0KHRoaXMuZW5kLCAnKScpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBNdWx0aUV4cHJlc3Npb24gZXh0ZW5kcyBFeHByZXNzaW9uRW50aXR5IHtcbiAgICBjb25zdHJ1Y3RvcihleHByZXNzaW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgfVxuICAgIGRlb3B0aW1pemVQYXRoKHBhdGgpIHtcbiAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIHRoaXMuZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZGVvcHRpbWl6ZVBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IE11bHRpRXhwcmVzc2lvbih0aGlzLmV4cHJlc3Npb25zLm1hcChleHByZXNzaW9uID0+IGV4cHJlc3Npb24uZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbilbMF0pKSxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgIF07XG4gICAgfVxuICAgIGhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIGZvciAoY29uc3QgZXhwcmVzc2lvbiBvZiB0aGlzLmV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuY2xhc3MgQ29uZGl0aW9uYWxFeHByZXNzaW9uIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkID0gW107XG4gICAgICAgIHRoaXMudXNlZEJyYW5jaCA9IG51bGw7XG4gICAgfVxuICAgIGdldCBpc0JyYW5jaFJlc29sdXRpb25BbmFseXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhZ1NldCh0aGlzLmZsYWdzLCA2NTUzNiAvKiBGbGFnLmlzQnJhbmNoUmVzb2x1dGlvbkFuYWx5c2VkICovKTtcbiAgICB9XG4gICAgc2V0IGlzQnJhbmNoUmVzb2x1dGlvbkFuYWx5c2VkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBzZXRGbGFnKHRoaXMuZmxhZ3MsIDY1NTM2IC8qIEZsYWcuaXNCcmFuY2hSZXNvbHV0aW9uQW5hbHlzZWQgKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIpIHtcbiAgICAgICAgdGhpcy5jb25zZXF1ZW50LmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoLCByZWN1cnNpb25UcmFja2VyKTtcbiAgICAgICAgdGhpcy5hbHRlcm5hdGUuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgIH1cbiAgICBkZW9wdGltaXplQ2FjaGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnVzZWRCcmFuY2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHVudXNlZEJyYW5jaCA9IHRoaXMudXNlZEJyYW5jaCA9PT0gdGhpcy5jb25zZXF1ZW50ID8gdGhpcy5hbHRlcm5hdGUgOiB0aGlzLmNvbnNlcXVlbnQ7XG4gICAgICAgICAgICB0aGlzLnVzZWRCcmFuY2ggPSBudWxsO1xuICAgICAgICAgICAgdW51c2VkQnJhbmNoLmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgICAgICBjb25zdCB7IGV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZCA9IEVNUFRZX0FSUkFZO1xuICAgICAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIGV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkKSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5kZW9wdGltaXplQ2FjaGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZW9wdGltaXplUGF0aChwYXRoKSB7XG4gICAgICAgIGNvbnN0IHVzZWRCcmFuY2ggPSB0aGlzLmdldFVzZWRCcmFuY2goKTtcbiAgICAgICAgaWYgKHVzZWRCcmFuY2gpIHtcbiAgICAgICAgICAgIHVzZWRCcmFuY2guZGVvcHRpbWl6ZVBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnNlcXVlbnQuZGVvcHRpbWl6ZVBhdGgocGF0aCk7XG4gICAgICAgICAgICB0aGlzLmFsdGVybmF0ZS5kZW9wdGltaXplUGF0aChwYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IHVzZWRCcmFuY2ggPSB0aGlzLmdldFVzZWRCcmFuY2goKTtcbiAgICAgICAgaWYgKCF1c2VkQnJhbmNoKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25WYWx1ZTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZC5wdXNoKG9yaWdpbik7XG4gICAgICAgIHJldHVybiB1c2VkQnJhbmNoLmdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgIH1cbiAgICBnZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IHVzZWRCcmFuY2ggPSB0aGlzLmdldFVzZWRCcmFuY2goKTtcbiAgICAgICAgaWYgKCF1c2VkQnJhbmNoKVxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBuZXcgTXVsdGlFeHByZXNzaW9uKFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zZXF1ZW50LmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pWzBdLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsdGVybmF0ZS5nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKVswXVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICBdO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkLnB1c2gob3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHVzZWRCcmFuY2guZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgfVxuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy50ZXN0Lmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgdXNlZEJyYW5jaCA9IHRoaXMuZ2V0VXNlZEJyYW5jaCgpO1xuICAgICAgICBpZiAoIXVzZWRCcmFuY2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnNlcXVlbnQuaGFzRWZmZWN0cyhjb250ZXh0KSB8fCB0aGlzLmFsdGVybmF0ZS5oYXNFZmZlY3RzKGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1c2VkQnJhbmNoLmhhc0VmZmVjdHMoY29udGV4dCk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHVzZWRCcmFuY2ggPSB0aGlzLmdldFVzZWRCcmFuY2goKTtcbiAgICAgICAgaWYgKCF1c2VkQnJhbmNoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuY29uc2VxdWVudC5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmFsdGVybmF0ZS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1c2VkQnJhbmNoLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdXNlZEJyYW5jaCA9IHRoaXMuZ2V0VXNlZEJyYW5jaCgpO1xuICAgICAgICBpZiAoaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkgfHwgdGhpcy50ZXN0LnNob3VsZEJlSW5jbHVkZWQoY29udGV4dCkgfHwgdXNlZEJyYW5jaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50ZXN0LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICAgICAgdGhpcy5jb25zZXF1ZW50LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICAgICAgdGhpcy5hbHRlcm5hdGUuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1c2VkQnJhbmNoLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluY2x1ZGVDYWxsQXJndW1lbnRzKGNvbnRleHQsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3QgdXNlZEJyYW5jaCA9IHRoaXMuZ2V0VXNlZEJyYW5jaCgpO1xuICAgICAgICBpZiAodXNlZEJyYW5jaCkge1xuICAgICAgICAgICAgdXNlZEJyYW5jaC5pbmNsdWRlQ2FsbEFyZ3VtZW50cyhjb250ZXh0LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29uc2VxdWVudC5pbmNsdWRlQ2FsbEFyZ3VtZW50cyhjb250ZXh0LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRlLmluY2x1ZGVDYWxsQXJndW1lbnRzKGNvbnRleHQsIHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUFubm90YXRpb25zKGNvZGUpIHtcbiAgICAgICAgdGhpcy50ZXN0LnJlbW92ZUFubm90YXRpb25zKGNvZGUpO1xuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucywgeyBpc0NhbGxlZU9mUmVuZGVyZWRQYXJlbnQsIHByZXZlbnRBU0ksIHJlbmRlcmVkUGFyZW50VHlwZSwgcmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQgfSA9IEJMQU5LKSB7XG4gICAgICAgIGNvbnN0IHVzZWRCcmFuY2ggPSB0aGlzLmdldFVzZWRCcmFuY2goKTtcbiAgICAgICAgaWYgKHRoaXMudGVzdC5pbmNsdWRlZCkge1xuICAgICAgICAgICAgdGhpcy50ZXN0LnJlbmRlcihjb2RlLCBvcHRpb25zLCB7IHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50IH0pO1xuICAgICAgICAgICAgdGhpcy5jb25zZXF1ZW50LnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRlLnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9uUG9zID0gZmluZEZpcnN0T2NjdXJyZW5jZU91dHNpZGVDb21tZW50KGNvZGUub3JpZ2luYWwsICc6JywgdGhpcy5jb25zZXF1ZW50LmVuZCk7XG4gICAgICAgICAgICBjb25zdCBpbmNsdXNpb25TdGFydCA9IGZpbmROb25XaGl0ZVNwYWNlKGNvZGUub3JpZ2luYWwsICh0aGlzLmNvbnNlcXVlbnQuaW5jbHVkZWRcbiAgICAgICAgICAgICAgICA/IGZpbmRGaXJzdE9jY3VycmVuY2VPdXRzaWRlQ29tbWVudChjb2RlLm9yaWdpbmFsLCAnPycsIHRoaXMudGVzdC5lbmQpXG4gICAgICAgICAgICAgICAgOiBjb2xvblBvcykgKyAxKTtcbiAgICAgICAgICAgIGlmIChwcmV2ZW50QVNJKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTGluZUJyZWFrcyhjb2RlLCBpbmNsdXNpb25TdGFydCwgdXNlZEJyYW5jaC5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlLnJlbW92ZSh0aGlzLnN0YXJ0LCBpbmNsdXNpb25TdGFydCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25zZXF1ZW50LmluY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgY29kZS5yZW1vdmUoY29sb25Qb3MsIHRoaXMuZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGVzdC5yZW1vdmVBbm5vdGF0aW9ucyhjb2RlKTtcbiAgICAgICAgICAgIHVzZWRCcmFuY2gucmVuZGVyKGNvZGUsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBpc0NhbGxlZU9mUmVuZGVyZWRQYXJlbnQsXG4gICAgICAgICAgICAgICAgcHJldmVudEFTSTogdHJ1ZSxcbiAgICAgICAgICAgICAgICByZW5kZXJlZFBhcmVudFR5cGU6IHJlbmRlcmVkUGFyZW50VHlwZSB8fCB0aGlzLnBhcmVudC50eXBlLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50OiByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudCB8fCB0aGlzLnBhcmVudC50eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRVc2VkQnJhbmNoKCkge1xuICAgICAgICBpZiAodGhpcy5pc0JyYW5jaFJlc29sdXRpb25BbmFseXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlZEJyYW5jaDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQnJhbmNoUmVzb2x1dGlvbkFuYWx5c2VkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdGVzdFZhbHVlID0gdGhpcy50ZXN0LmdldExpdGVyYWxWYWx1ZUF0UGF0aChFTVBUWV9QQVRILCBTSEFSRURfUkVDVVJTSU9OX1RSQUNLRVIsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRlc3RWYWx1ZSA9PT0gJ3N5bWJvbCdcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiAodGhpcy51c2VkQnJhbmNoID0gdGVzdFZhbHVlID8gdGhpcy5jb25zZXF1ZW50IDogdGhpcy5hbHRlcm5hdGUpO1xuICAgIH1cbn1cblxuY2xhc3MgQ29udGludWVTdGF0ZW1lbnQgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuaWdub3JlLmxhYmVscy5oYXModGhpcy5sYWJlbC5uYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRleHQuaW5jbHVkZWRMYWJlbHMuYWRkKHRoaXMubGFiZWwubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuaWdub3JlLmNvbnRpbnVlcylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRleHQuaGFzQ29udGludWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuYnJva2VuRmxvdyA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5sYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5sYWJlbC5pbmNsdWRlKCk7XG4gICAgICAgICAgICBjb250ZXh0LmluY2x1ZGVkTGFiZWxzLmFkZCh0aGlzLmxhYmVsLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5oYXNDb250aW51ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gdHJ1ZTtcbiAgICB9XG59XG5cbmNsYXNzIERlYnVnZ2VyU3RhdGVtZW50IGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGhhc0VmZmVjdHMoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuY2xhc3MgRGVjb3JhdG9yIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZXhwcmVzc2lvbi5oYXNFZmZlY3RzKGNvbnRleHQpIHx8XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoRU1QVFlfUEFUSCwgTk9ERV9JTlRFUkFDVElPTl9VTktOT1dOX0NBTEwsIGNvbnRleHQpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhhc0xvb3BCb2R5RWZmZWN0cyhjb250ZXh0LCBib2R5KSB7XG4gICAgY29uc3QgeyBicm9rZW5GbG93LCBoYXNCcmVhaywgaGFzQ29udGludWUsIGlnbm9yZSB9ID0gY29udGV4dDtcbiAgICBjb25zdCB7IGJyZWFrcywgY29udGludWVzIH0gPSBpZ25vcmU7XG4gICAgaWdub3JlLmJyZWFrcyA9IHRydWU7XG4gICAgaWdub3JlLmNvbnRpbnVlcyA9IHRydWU7XG4gICAgY29udGV4dC5oYXNCcmVhayA9IGZhbHNlO1xuICAgIGNvbnRleHQuaGFzQ29udGludWUgPSBmYWxzZTtcbiAgICBpZiAoYm9keS5oYXNFZmZlY3RzKGNvbnRleHQpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZ25vcmUuYnJlYWtzID0gYnJlYWtzO1xuICAgIGlnbm9yZS5jb250aW51ZXMgPSBjb250aW51ZXM7XG4gICAgY29udGV4dC5oYXNCcmVhayA9IGhhc0JyZWFrO1xuICAgIGNvbnRleHQuaGFzQ29udGludWUgPSBoYXNDb250aW51ZTtcbiAgICBjb250ZXh0LmJyb2tlbkZsb3cgPSBicm9rZW5GbG93O1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVMb29wQm9keShjb250ZXh0LCBib2R5LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgIGNvbnN0IHsgYnJva2VuRmxvdywgaGFzQnJlYWssIGhhc0NvbnRpbnVlIH0gPSBjb250ZXh0O1xuICAgIGNvbnRleHQuaGFzQnJlYWsgPSBmYWxzZTtcbiAgICBjb250ZXh0Lmhhc0NvbnRpbnVlID0gZmFsc2U7XG4gICAgYm9keS5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5LCB7IGFzU2luZ2xlU3RhdGVtZW50OiB0cnVlIH0pO1xuICAgIGNvbnRleHQuaGFzQnJlYWsgPSBoYXNCcmVhaztcbiAgICBjb250ZXh0Lmhhc0NvbnRpbnVlID0gaGFzQ29udGludWU7XG4gICAgY29udGV4dC5icm9rZW5GbG93ID0gYnJva2VuRmxvdztcbn1cblxuY2xhc3MgRG9XaGlsZVN0YXRlbWVudCBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMudGVzdC5oYXNFZmZlY3RzKGNvbnRleHQpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBoYXNMb29wQm9keUVmZmVjdHMoY29udGV4dCwgdGhpcy5ib2R5KTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50ZXN0LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICBpbmNsdWRlTG9vcEJvZHkoY29udGV4dCwgdGhpcy5ib2R5LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgfVxufVxuXG5jbGFzcyBFbXB0eVN0YXRlbWVudCBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBoYXNFZmZlY3RzKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5jbGFzcyBFeHBvcnRBbGxEZWNsYXJhdGlvbiBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBoYXNFZmZlY3RzKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGluaXRpYWxpc2UoKSB7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpc2UoKTtcbiAgICAgICAgdGhpcy5zY29wZS5jb250ZXh0LmFkZEV4cG9ydCh0aGlzKTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIF9vcHRpb25zLCBub2RlUmVuZGVyT3B0aW9ucykge1xuICAgICAgICBjb2RlLnJlbW92ZShub2RlUmVuZGVyT3B0aW9ucy5zdGFydCwgbm9kZVJlbmRlck9wdGlvbnMuZW5kKTtcbiAgICB9XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7IH1cbn1cbkV4cG9ydEFsbERlY2xhcmF0aW9uLnByb3RvdHlwZS5uZWVkc0JvdW5kYXJpZXMgPSB0cnVlO1xuXG5jbGFzcyBFeHBvcnROYW1lZERlY2xhcmF0aW9uIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGJpbmQoKSB7XG4gICAgICAgIC8vIERvIG5vdCBiaW5kIHNwZWNpZmllcnNcbiAgICAgICAgdGhpcy5kZWNsYXJhdGlvbj8uYmluZCgpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5kZWNsYXJhdGlvbj8uaGFzRWZmZWN0cyhjb250ZXh0KTtcbiAgICB9XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGlzZSgpO1xuICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQuYWRkRXhwb3J0KHRoaXMpO1xuICAgIH1cbiAgICByZW1vdmVBbm5vdGF0aW9ucyhjb2RlKSB7XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb24/LnJlbW92ZUFubm90YXRpb25zKGNvZGUpO1xuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucywgbm9kZVJlbmRlck9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBub2RlUmVuZGVyT3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuZGVjbGFyYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvZGUucmVtb3ZlKHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29kZS5yZW1vdmUodGhpcy5zdGFydCwgdGhpcy5kZWNsYXJhdGlvbi5zdGFydCk7XG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uLnJlbmRlcihjb2RlLCBvcHRpb25zLCB7IGVuZCwgc3RhcnQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7IH1cbn1cbkV4cG9ydE5hbWVkRGVjbGFyYXRpb24ucHJvdG90eXBlLm5lZWRzQm91bmRhcmllcyA9IHRydWU7XG5cbmNsYXNzIEV4cG9ydFNwZWNpZmllciBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHsgfVxufVxuXG5jbGFzcyBGb3JJblN0YXRlbWVudCBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjcmVhdGVTY29wZShwYXJlbnRTY29wZSkge1xuICAgICAgICB0aGlzLnNjb3BlID0gbmV3IEJsb2NrU2NvcGUocGFyZW50U2NvcGUpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgeyBib2R5LCBkZW9wdGltaXplZCwgbGVmdCwgcmlnaHQgfSA9IHRoaXM7XG4gICAgICAgIGlmICghZGVvcHRpbWl6ZWQpXG4gICAgICAgICAgICB0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCk7XG4gICAgICAgIGlmIChsZWZ0Lmhhc0VmZmVjdHNBc0Fzc2lnbm1lbnRUYXJnZXQoY29udGV4dCwgZmFsc2UpIHx8IHJpZ2h0Lmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGhhc0xvb3BCb2R5RWZmZWN0cyhjb250ZXh0LCBib2R5KTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICBjb25zdCB7IGJvZHksIGRlb3B0aW1pemVkLCBsZWZ0LCByaWdodCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFkZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIGxlZnQuaW5jbHVkZUFzQXNzaWdubWVudFRhcmdldChjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSB8fCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHJpZ2h0LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICBpbmNsdWRlTG9vcEJvZHkoY29udGV4dCwgYm9keSwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgIH1cbiAgICBpbml0aWFsaXNlKCkge1xuICAgICAgICBzdXBlci5pbml0aWFsaXNlKCk7XG4gICAgICAgIHRoaXMubGVmdC5zZXRBc3NpZ25lZFZhbHVlKFVOS05PV05fRVhQUkVTU0lPTik7XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubGVmdC5yZW5kZXIoY29kZSwgb3B0aW9ucywgTk9fU0VNSUNPTE9OKTtcbiAgICAgICAgdGhpcy5yaWdodC5yZW5kZXIoY29kZSwgb3B0aW9ucywgTk9fU0VNSUNPTE9OKTtcbiAgICAgICAgLy8gaGFuZGxlIG5vIHNwYWNlIGJldHdlZW4gXCJpblwiIGFuZCB0aGUgcmlnaHQgc2lkZVxuICAgICAgICBpZiAoY29kZS5vcmlnaW5hbC5jaGFyQ29kZUF0KHRoaXMucmlnaHQuc3RhcnQgLSAxKSA9PT0gMTEwIC8qIG4gKi8pIHtcbiAgICAgICAgICAgIGNvZGUucHJlcGVuZExlZnQodGhpcy5yaWdodC5zdGFydCwgJyAnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvZHkucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kZW9wdGltaXplZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGVmdC5kZW9wdGltaXplUGF0aChFTVBUWV9QQVRIKTtcbiAgICAgICAgdGhpcy5zY29wZS5jb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKTtcbiAgICB9XG59XG5cbmNsYXNzIEZvck9mU3RhdGVtZW50IGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGdldCBhd2FpdCgpIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhZ1NldCh0aGlzLmZsYWdzLCAxMzEwNzIgLyogRmxhZy5hd2FpdCAqLyk7XG4gICAgfVxuICAgIHNldCBhd2FpdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZsYWdzID0gc2V0RmxhZyh0aGlzLmZsYWdzLCAxMzEwNzIgLyogRmxhZy5hd2FpdCAqLywgdmFsdWUpO1xuICAgIH1cbiAgICBjcmVhdGVTY29wZShwYXJlbnRTY29wZSkge1xuICAgICAgICB0aGlzLnNjb3BlID0gbmV3IEJsb2NrU2NvcGUocGFyZW50U2NvcGUpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGVvcHRpbWl6ZWQpXG4gICAgICAgICAgICB0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCk7XG4gICAgICAgIC8vIFBsYWNlaG9sZGVyIHVudGlsIHByb3BlciBTeW1ib2wuSXRlcmF0b3Igc3VwcG9ydFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICBjb25zdCB7IGJvZHksIGRlb3B0aW1pemVkLCBsZWZ0LCByaWdodCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFkZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIGxlZnQuaW5jbHVkZUFzQXNzaWdubWVudFRhcmdldChjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSB8fCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHJpZ2h0LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICBpbmNsdWRlTG9vcEJvZHkoY29udGV4dCwgYm9keSwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgIH1cbiAgICBpbml0aWFsaXNlKCkge1xuICAgICAgICBzdXBlci5pbml0aWFsaXNlKCk7XG4gICAgICAgIHRoaXMubGVmdC5zZXRBc3NpZ25lZFZhbHVlKFVOS05PV05fRVhQUkVTU0lPTik7XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubGVmdC5yZW5kZXIoY29kZSwgb3B0aW9ucywgTk9fU0VNSUNPTE9OKTtcbiAgICAgICAgdGhpcy5yaWdodC5yZW5kZXIoY29kZSwgb3B0aW9ucywgTk9fU0VNSUNPTE9OKTtcbiAgICAgICAgLy8gaGFuZGxlIG5vIHNwYWNlIGJldHdlZW4gXCJvZlwiIGFuZCB0aGUgcmlnaHQgc2lkZVxuICAgICAgICBpZiAoY29kZS5vcmlnaW5hbC5jaGFyQ29kZUF0KHRoaXMucmlnaHQuc3RhcnQgLSAxKSA9PT0gMTAyIC8qIGYgKi8pIHtcbiAgICAgICAgICAgIGNvZGUucHJlcGVuZExlZnQodGhpcy5yaWdodC5zdGFydCwgJyAnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvZHkucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kZW9wdGltaXplZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGVmdC5kZW9wdGltaXplUGF0aChFTVBUWV9QQVRIKTtcbiAgICAgICAgdGhpcy5yaWdodC5kZW9wdGltaXplUGF0aChVTktOT1dOX1BBVEgpO1xuICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpO1xuICAgIH1cbn1cblxuY2xhc3MgRm9yU3RhdGVtZW50IGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNyZWF0ZVNjb3BlKHBhcmVudFNjb3BlKSB7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBuZXcgQmxvY2tTY29wZShwYXJlbnRTY29wZSk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5pbml0Py5oYXNFZmZlY3RzKGNvbnRleHQpIHx8XG4gICAgICAgICAgICB0aGlzLnRlc3Q/Lmhhc0VmZmVjdHMoY29udGV4dCkgfHxcbiAgICAgICAgICAgIHRoaXMudXBkYXRlPy5oYXNFZmZlY3RzKGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzTG9vcEJvZHlFZmZlY3RzKGNvbnRleHQsIHRoaXMuYm9keSk7XG4gICAgfVxuICAgIGluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpIHtcbiAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5pdD8uaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSwgeyBhc1NpbmdsZVN0YXRlbWVudDogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy50ZXN0Py5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgdGhpcy51cGRhdGU/LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICBpbmNsdWRlTG9vcEJvZHkoY29udGV4dCwgdGhpcy5ib2R5LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdD8ucmVuZGVyKGNvZGUsIG9wdGlvbnMsIE5PX1NFTUlDT0xPTik7XG4gICAgICAgIHRoaXMudGVzdD8ucmVuZGVyKGNvZGUsIG9wdGlvbnMsIE5PX1NFTUlDT0xPTik7XG4gICAgICAgIHRoaXMudXBkYXRlPy5yZW5kZXIoY29kZSwgb3B0aW9ucywgTk9fU0VNSUNPTE9OKTtcbiAgICAgICAgdGhpcy5ib2R5LnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICB9XG59XG5cbmNsYXNzIEZ1bmN0aW9uRXhwcmVzc2lvbiBleHRlbmRzIEZ1bmN0aW9uTm9kZSB7XG4gICAgY3JlYXRlU2NvcGUocGFyZW50U2NvcGUpIHtcbiAgICAgICAgc3VwZXIuY3JlYXRlU2NvcGUoKHRoaXMuaWRTY29wZSA9IG5ldyBDaGlsZFNjb3BlKHBhcmVudFNjb3BlLCBwYXJlbnRTY29wZS5jb250ZXh0KSkpO1xuICAgIH1cbiAgICBwYXJzZU5vZGUoZXNUcmVlTm9kZSkge1xuICAgICAgICBpZiAoZXNUcmVlTm9kZS5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IG5ldyBJZGVudGlmaWVyKHRoaXMsIHRoaXMuaWRTY29wZSkucGFyc2VOb2RlKGVzVHJlZU5vZGUuaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5wYXJzZU5vZGUoZXNUcmVlTm9kZSk7XG4gICAgfVxuICAgIG9ubHlGdW5jdGlvbkNhbGxVc2VkKCkge1xuICAgICAgICBjb25zdCBpc0lJRkUgPSB0aGlzLnBhcmVudC50eXBlID09PSBDYWxsRXhwcmVzc2lvbiQxICYmXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5jYWxsZWUgPT09IHRoaXMgJiZcbiAgICAgICAgICAgICh0aGlzLmlkID09PSBudWxsIHx8IHRoaXMuaWQudmFyaWFibGUuZ2V0T25seUZ1bmN0aW9uQ2FsbFVzZWQoKSk7XG4gICAgICAgIHJldHVybiBpc0lJRkUgfHwgc3VwZXIub25seUZ1bmN0aW9uQ2FsbFVzZWQoKTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMsIHsgcmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQgfSA9IEJMQU5LKSB7XG4gICAgICAgIHN1cGVyLnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50ID09PSBFeHByZXNzaW9uU3RhdGVtZW50JDEpIHtcbiAgICAgICAgICAgIGNvZGUuYXBwZW5kUmlnaHQodGhpcy5zdGFydCwgJygnKTtcbiAgICAgICAgICAgIGNvZGUucHJlcGVuZExlZnQodGhpcy5lbmQsICcpJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFRyYWNraW5nU2NvcGUgZXh0ZW5kcyBCbG9ja1Njb3BlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ob2lzdGVkRGVjbGFyYXRpb25zID0gW107XG4gICAgfVxuICAgIGFkZERlY2xhcmF0aW9uKGlkZW50aWZpZXIsIGNvbnRleHQsIGluaXQsIGtpbmQpIHtcbiAgICAgICAgdGhpcy5ob2lzdGVkRGVjbGFyYXRpb25zLnB1c2goaWRlbnRpZmllcik7XG4gICAgICAgIHJldHVybiBzdXBlci5hZGREZWNsYXJhdGlvbihpZGVudGlmaWVyLCBjb250ZXh0LCBpbml0LCBraW5kKTtcbiAgICB9XG59XG5cbmNvbnN0IHVuc2V0ID0gU3ltYm9sKCd1bnNldCcpO1xuY2xhc3MgSWZTdGF0ZW1lbnQgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudGVzdFZhbHVlID0gdW5zZXQ7XG4gICAgfVxuICAgIGRlb3B0aW1pemVDYWNoZSgpIHtcbiAgICAgICAgdGhpcy50ZXN0VmFsdWUgPSBVbmtub3duVmFsdWU7XG4gICAgfVxuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy50ZXN0Lmhhc0VmZmVjdHMoY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlc3RWYWx1ZSA9IHRoaXMuZ2V0VGVzdFZhbHVlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGVzdFZhbHVlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgY29uc3QgeyBicm9rZW5GbG93IH0gPSBjb250ZXh0O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uc2VxdWVudC5oYXNFZmZlY3RzKGNvbnRleHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY29uc3QgY29uc2VxdWVudEJyb2tlbkZsb3cgPSBjb250ZXh0LmJyb2tlbkZsb3c7XG4gICAgICAgICAgICBjb250ZXh0LmJyb2tlbkZsb3cgPSBicm9rZW5GbG93O1xuICAgICAgICAgICAgaWYgKHRoaXMuYWx0ZXJuYXRlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsdGVybmF0ZS5oYXNFZmZlY3RzKGNvbnRleHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gY29udGV4dC5icm9rZW5GbG93ICYmIGNvbnNlcXVlbnRCcm9rZW5GbG93O1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXN0VmFsdWUgPyB0aGlzLmNvbnNlcXVlbnQuaGFzRWZmZWN0cyhjb250ZXh0KSA6ICEhdGhpcy5hbHRlcm5hdGU/Lmhhc0VmZmVjdHMoY29udGV4dCk7XG4gICAgfVxuICAgIGluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpIHtcbiAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIGlmIChpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICAgICAgdGhpcy5pbmNsdWRlUmVjdXJzaXZlbHkoaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHksIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGVzdFZhbHVlID0gdGhpcy5nZXRUZXN0VmFsdWUoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGVzdFZhbHVlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jbHVkZVVua25vd25UZXN0KGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNsdWRlS25vd25UZXN0KGNvbnRleHQsIHRlc3RWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VOb2RlKGVzVHJlZU5vZGUpIHtcbiAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gbmV3ICh0aGlzLnNjb3BlLmNvbnRleHQuZ2V0Tm9kZUNvbnN0cnVjdG9yKGVzVHJlZU5vZGUuY29uc2VxdWVudC50eXBlKSkodGhpcywgKHRoaXMuY29uc2VxdWVudFNjb3BlID0gbmV3IFRyYWNraW5nU2NvcGUodGhpcy5zY29wZSkpKS5wYXJzZU5vZGUoZXNUcmVlTm9kZS5jb25zZXF1ZW50KTtcbiAgICAgICAgaWYgKGVzVHJlZU5vZGUuYWx0ZXJuYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmFsdGVybmF0ZSA9IG5ldyAodGhpcy5zY29wZS5jb250ZXh0LmdldE5vZGVDb25zdHJ1Y3Rvcihlc1RyZWVOb2RlLmFsdGVybmF0ZS50eXBlKSkodGhpcywgKHRoaXMuYWx0ZXJuYXRlU2NvcGUgPSBuZXcgVHJhY2tpbmdTY29wZSh0aGlzLnNjb3BlKSkpLnBhcnNlTm9kZShlc1RyZWVOb2RlLmFsdGVybmF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlTm9kZShlc1RyZWVOb2RlKTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBzbmlwcGV0czogeyBnZXRQcm9wZXJ0eUFjY2VzcyB9IH0gPSBvcHRpb25zO1xuICAgICAgICAvLyBOb3RlIHRoYXQgdW5rbm93biB0ZXN0IHZhbHVlcyBhcmUgYWx3YXlzIGluY2x1ZGVkXG4gICAgICAgIGNvbnN0IHRlc3RWYWx1ZSA9IHRoaXMuZ2V0VGVzdFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IGhvaXN0ZWREZWNsYXJhdGlvbnMgPSBbXTtcbiAgICAgICAgY29uc3QgaW5jbHVkZXNJZkVsc2UgPSB0aGlzLnRlc3QuaW5jbHVkZWQ7XG4gICAgICAgIGNvbnN0IG5vVHJlZXNoYWtlID0gIXRoaXMuc2NvcGUuY29udGV4dC5vcHRpb25zLnRyZWVzaGFrZTtcbiAgICAgICAgaWYgKGluY2x1ZGVzSWZFbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnRlc3QucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29kZS5yZW1vdmUodGhpcy5zdGFydCwgdGhpcy5jb25zZXF1ZW50LnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25zZXF1ZW50LmluY2x1ZGVkICYmIChub1RyZWVzaGFrZSB8fCB0eXBlb2YgdGVzdFZhbHVlID09PSAnc3ltYm9sJyB8fCB0ZXN0VmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnNlcXVlbnQucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUodGhpcy5jb25zZXF1ZW50LnN0YXJ0LCB0aGlzLmNvbnNlcXVlbnQuZW5kLCBpbmNsdWRlc0lmRWxzZSA/ICc7JyA6ICcnKTtcbiAgICAgICAgICAgIGhvaXN0ZWREZWNsYXJhdGlvbnMucHVzaCguLi50aGlzLmNvbnNlcXVlbnRTY29wZS5ob2lzdGVkRGVjbGFyYXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbHRlcm5hdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsdGVybmF0ZS5pbmNsdWRlZCAmJiAobm9UcmVlc2hha2UgfHwgdHlwZW9mIHRlc3RWYWx1ZSA9PT0gJ3N5bWJvbCcgfHwgIXRlc3RWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZXNJZkVsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUub3JpZ2luYWwuY2hhckNvZGVBdCh0aGlzLmFsdGVybmF0ZS5zdGFydCAtIDEpID09PSAxMDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUucHJlcGVuZExlZnQodGhpcy5hbHRlcm5hdGUuc3RhcnQsICcgJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUucmVtb3ZlKHRoaXMuY29uc2VxdWVudC5lbmQsIHRoaXMuYWx0ZXJuYXRlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hbHRlcm5hdGUucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVzSWZFbHNlICYmIHRoaXMuc2hvdWxkS2VlcEFsdGVybmF0ZUJyYW5jaCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMuYWx0ZXJuYXRlLnN0YXJ0LCB0aGlzLmVuZCwgJzsnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUucmVtb3ZlKHRoaXMuY29uc2VxdWVudC5lbmQsIHRoaXMuZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaG9pc3RlZERlY2xhcmF0aW9ucy5wdXNoKC4uLnRoaXMuYWx0ZXJuYXRlU2NvcGUuaG9pc3RlZERlY2xhcmF0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJIb2lzdGVkRGVjbGFyYXRpb25zKGhvaXN0ZWREZWNsYXJhdGlvbnMsIGNvZGUsIGdldFByb3BlcnR5QWNjZXNzKTtcbiAgICB9XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7IH1cbiAgICBnZXRUZXN0VmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnRlc3RWYWx1ZSA9PT0gdW5zZXQpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy50ZXN0VmFsdWUgPSB0aGlzLnRlc3QuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKEVNUFRZX1BBVEgsIFNIQVJFRF9SRUNVUlNJT05fVFJBQ0tFUiwgdGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRlc3RWYWx1ZTtcbiAgICB9XG4gICAgaW5jbHVkZUtub3duVGVzdChjb250ZXh0LCB0ZXN0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudGVzdC5zaG91bGRCZUluY2x1ZGVkKGNvbnRleHQpKSB7XG4gICAgICAgICAgICB0aGlzLnRlc3QuaW5jbHVkZShjb250ZXh0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlc3RWYWx1ZSAmJiB0aGlzLmNvbnNlcXVlbnQuc2hvdWxkQmVJbmNsdWRlZChjb250ZXh0KSkge1xuICAgICAgICAgICAgdGhpcy5jb25zZXF1ZW50LmluY2x1ZGUoY29udGV4dCwgZmFsc2UsIHsgYXNTaW5nbGVTdGF0ZW1lbnQ6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0ZXN0VmFsdWUgJiYgdGhpcy5hbHRlcm5hdGU/LnNob3VsZEJlSW5jbHVkZWQoY29udGV4dCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRlLmluY2x1ZGUoY29udGV4dCwgZmFsc2UsIHsgYXNTaW5nbGVTdGF0ZW1lbnQ6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5jbHVkZVJlY3Vyc2l2ZWx5KGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudGVzdC5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgdGhpcy5jb25zZXF1ZW50LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICB0aGlzLmFsdGVybmF0ZT8uaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgfVxuICAgIGluY2x1ZGVVbmtub3duVGVzdChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudGVzdC5pbmNsdWRlKGNvbnRleHQsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgeyBicm9rZW5GbG93IH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgY29uc2VxdWVudEJyb2tlbkZsb3cgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuY29uc2VxdWVudC5zaG91bGRCZUluY2x1ZGVkKGNvbnRleHQpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnNlcXVlbnQuaW5jbHVkZShjb250ZXh0LCBmYWxzZSwgeyBhc1NpbmdsZVN0YXRlbWVudDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnNlcXVlbnRCcm9rZW5GbG93ID0gY29udGV4dC5icm9rZW5GbG93O1xuICAgICAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gYnJva2VuRmxvdztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbHRlcm5hdGU/LnNob3VsZEJlSW5jbHVkZWQoY29udGV4dCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRlLmluY2x1ZGUoY29udGV4dCwgZmFsc2UsIHsgYXNTaW5nbGVTdGF0ZW1lbnQ6IHRydWUgfSk7XG4gICAgICAgICAgICBjb250ZXh0LmJyb2tlbkZsb3cgPSBjb250ZXh0LmJyb2tlbkZsb3cgJiYgY29uc2VxdWVudEJyb2tlbkZsb3c7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVySG9pc3RlZERlY2xhcmF0aW9ucyhob2lzdGVkRGVjbGFyYXRpb25zLCBjb2RlLCBnZXRQcm9wZXJ0eUFjY2Vzcykge1xuICAgICAgICBjb25zdCBob2lzdGVkVmFyaWFibGVzID0gW1xuICAgICAgICAgICAgLi4ubmV3IFNldChob2lzdGVkRGVjbGFyYXRpb25zLm1hcChpZGVudGlmaWVyID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YXJpYWJsZSA9IGlkZW50aWZpZXIudmFyaWFibGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlLmluY2x1ZGVkID8gdmFyaWFibGUuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2VzcykgOiAnJztcbiAgICAgICAgICAgIH0pKVxuICAgICAgICBdXG4gICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgaWYgKGhvaXN0ZWRWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFR5cGUgPSB0aGlzLnBhcmVudC50eXBlO1xuICAgICAgICAgICAgY29uc3QgbmVlZHNCcmFjZXMgPSBwYXJlbnRUeXBlICE9PSBQcm9ncmFtJDEgJiYgcGFyZW50VHlwZSAhPT0gQmxvY2tTdGF0ZW1lbnQkMTtcbiAgICAgICAgICAgIGNvZGUucHJlcGVuZFJpZ2h0KHRoaXMuc3RhcnQsIGAke25lZWRzQnJhY2VzID8gJ3sgJyA6ICcnfXZhciAke2hvaXN0ZWRWYXJpYWJsZXN9OyBgKTtcbiAgICAgICAgICAgIGlmIChuZWVkc0JyYWNlcykge1xuICAgICAgICAgICAgICAgIGNvZGUuYXBwZW5kTGVmdCh0aGlzLmVuZCwgYCB9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvdWxkS2VlcEFsdGVybmF0ZUJyYW5jaCgpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRQYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgaW5zdGFuY2VvZiBJZlN0YXRlbWVudCAmJiBjdXJyZW50UGFyZW50LmFsdGVybmF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgaW5zdGFuY2VvZiBCbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50LnBhcmVudDtcbiAgICAgICAgfSB3aGlsZSAoY3VycmVudFBhcmVudCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmNsYXNzIEltcG9ydEF0dHJpYnV0ZSBleHRlbmRzIE5vZGVCYXNlIHtcbn1cblxuY2xhc3MgSW1wb3J0RGVjbGFyYXRpb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgLy8gRG8gbm90IGJpbmQgc3BlY2lmaWVycyBvciBhdHRyaWJ1dGVzXG4gICAgYmluZCgpIHsgfVxuICAgIGhhc0VmZmVjdHMoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGlzZSgpO1xuICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQuYWRkSW1wb3J0KHRoaXMpO1xuICAgIH1cbiAgICByZW5kZXIoY29kZSwgX29wdGlvbnMsIG5vZGVSZW5kZXJPcHRpb25zKSB7XG4gICAgICAgIGNvZGUucmVtb3ZlKG5vZGVSZW5kZXJPcHRpb25zLnN0YXJ0LCBub2RlUmVuZGVyT3B0aW9ucy5lbmQpO1xuICAgIH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHsgfVxufVxuSW1wb3J0RGVjbGFyYXRpb24ucHJvdG90eXBlLm5lZWRzQm91bmRhcmllcyA9IHRydWU7XG5cbmNsYXNzIEltcG9ydERlZmF1bHRTcGVjaWZpZXIgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7IH1cbn1cblxuZnVuY3Rpb24gaXNSZWFzc2lnbmVkRXhwb3J0c01lbWJlcih2YXJpYWJsZSwgZXhwb3J0TmFtZXNCeVZhcmlhYmxlKSB7XG4gICAgcmV0dXJuICh2YXJpYWJsZS5yZW5kZXJCYXNlTmFtZSAhPT0gbnVsbCAmJiBleHBvcnROYW1lc0J5VmFyaWFibGUuaGFzKHZhcmlhYmxlKSAmJiB2YXJpYWJsZS5pc1JlYXNzaWduZWQpO1xufVxuXG5jbGFzcyBWYXJpYWJsZURlY2xhcmF0b3IgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgZGVjbGFyZURlY2xhcmF0b3Ioa2luZCwgaXNVc2luZ0RlY2xhcmF0aW9uKSB7XG4gICAgICAgIHRoaXMuaXNVc2luZ0RlY2xhcmF0aW9uID0gaXNVc2luZ0RlY2xhcmF0aW9uO1xuICAgICAgICB0aGlzLmlkLmRlY2xhcmUoa2luZCwgdGhpcy5pbml0IHx8IFVOREVGSU5FRF9FWFBSRVNTSU9OKTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZVBhdGgocGF0aCkge1xuICAgICAgICB0aGlzLmlkLmRlb3B0aW1pemVQYXRoKHBhdGgpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICBjb25zdCBpbml0RWZmZWN0ID0gdGhpcy5pbml0Py5oYXNFZmZlY3RzKGNvbnRleHQpO1xuICAgICAgICB0aGlzLmlkLm1hcmtEZWNsYXJhdGlvblJlYWNoZWQoKTtcbiAgICAgICAgcmV0dXJuIGluaXRFZmZlY3QgfHwgdGhpcy5pZC5oYXNFZmZlY3RzKGNvbnRleHQpIHx8IHRoaXMuaXNVc2luZ0RlY2xhcmF0aW9uO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIGNvbnN0IHsgZGVvcHRpbWl6ZWQsIGlkLCBpbml0IH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgaW5pdD8uaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIGlkLm1hcmtEZWNsYXJhdGlvblJlYWNoZWQoKTtcbiAgICAgICAgaWYgKGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5IHx8IGlkLnNob3VsZEJlSW5jbHVkZWQoY29udGV4dCkpIHtcbiAgICAgICAgICAgIGlkLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUFubm90YXRpb25zKGNvZGUpIHtcbiAgICAgICAgdGhpcy5pbml0Py5yZW1vdmVBbm5vdGF0aW9ucyhjb2RlKTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBleHBvcnROYW1lc0J5VmFyaWFibGUsIHNuaXBwZXRzOiB7IF8sIGdldFByb3BlcnR5QWNjZXNzIH0gfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgZW5kLCBpZCwgaW5pdCwgc3RhcnQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHJlbmRlcklkID0gaWQuaW5jbHVkZWQgfHwgdGhpcy5pc1VzaW5nRGVjbGFyYXRpb247XG4gICAgICAgIGlmIChyZW5kZXJJZCkge1xuICAgICAgICAgICAgaWQucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3JQb3MgPSBmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZS5vcmlnaW5hbCwgJz0nLCBpZC5lbmQpO1xuICAgICAgICAgICAgY29kZS5yZW1vdmUoc3RhcnQsIGZpbmROb25XaGl0ZVNwYWNlKGNvZGUub3JpZ2luYWwsIG9wZXJhdG9yUG9zICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0KSB7XG4gICAgICAgICAgICBpZiAoaWQgaW5zdGFuY2VvZiBJZGVudGlmaWVyICYmIGluaXQgaW5zdGFuY2VvZiBDbGFzc0V4cHJlc3Npb24gJiYgIWluaXQuaWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlZFZhcmlhYmxlID0gaWQudmFyaWFibGUuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2Vzcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbmRlcmVkVmFyaWFibGUgIT09IGlkLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5hcHBlbmRMZWZ0KGluaXQuc3RhcnQgKyA1LCBgICR7aWQubmFtZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbml0LnJlbmRlcihjb2RlLCBvcHRpb25zLCByZW5kZXJJZCA/IEJMQU5LIDogeyByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudDogRXhwcmVzc2lvblN0YXRlbWVudCQxIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlkIGluc3RhbmNlb2YgSWRlbnRpZmllciAmJlxuICAgICAgICAgICAgaXNSZWFzc2lnbmVkRXhwb3J0c01lbWJlcihpZC52YXJpYWJsZSwgZXhwb3J0TmFtZXNCeVZhcmlhYmxlKSkge1xuICAgICAgICAgICAgY29kZS5hcHBlbmRMZWZ0KGVuZCwgYCR7X309JHtffXZvaWQgMGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5RGVvcHRpbWl6YXRpb25zKCkge1xuICAgICAgICB0aGlzLmRlb3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBpZCwgaW5pdCB9ID0gdGhpcztcbiAgICAgICAgaWYgKGluaXQgJiYgaWQgaW5zdGFuY2VvZiBJZGVudGlmaWVyICYmIGluaXQgaW5zdGFuY2VvZiBDbGFzc0V4cHJlc3Npb24gJiYgIWluaXQuaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgdmFyaWFibGUgfSA9IGlkO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhY2Nlc3NlZFZhcmlhYmxlIG9mIGluaXQuc2NvcGUuYWNjZXNzZWRPdXRzaWRlVmFyaWFibGVzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjY2Vzc2VkVmFyaWFibGUgIT09IHZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc2VkVmFyaWFibGUuZm9yYmlkTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEltcG9ydEV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaW5saW5lTmFtZXNwYWNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZWNoYW5pc20gPSBudWxsO1xuICAgICAgICB0aGlzLm5hbWVzcGFjZUV4cG9ydE5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzb2x1dGlvblN0cmluZyA9IG51bGw7XG4gICAgfVxuICAgIC8vIERvIG5vdCBiaW5kIGF0dHJpYnV0ZXNcbiAgICBiaW5kKCkge1xuICAgICAgICB0aGlzLnNvdXJjZS5iaW5kKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBpbXBvcnRlZCB2YXJpYWJsZXMgZm9yIGRldGVybWluaXN0aWMgdXNhZ2UsIHZhbGlkIGNhc2VzIGFyZTpcbiAgICAgKlxuICAgICAqIC0gYGNvbnN0IHsgZm9vIH0gPSBhd2FpdCBpbXBvcnQoJ2JhcicpYC5cbiAgICAgKiAtIGAoYXdhaXQgaW1wb3J0KCdiYXInKSkuZm9vYFxuICAgICAqIC0gYGltcG9ydCgnYmFyJykudGhlbigoeyBmb28gfSkgPT4ge30pYFxuICAgICAqXG4gICAgICogUmV0dXJucyBlbXB0eSBhcnJheSBpZiBpdCdzIHNpZGUtZWZmZWN0IG9ubHkgaW1wb3J0LlxuICAgICAqIFJldHVybnMgdW5kZWZpbmVkIGlmIGl0J3Mgbm90IGZ1bGx5IGRldGVybWluaXN0aWMuXG4gICAgICovXG4gICAgZ2V0RGV0ZXJtaW5pc3RpY0ltcG9ydGVkTmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudDEgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgLy8gU2lkZS1lZmZlY3Qgb25seTogaW1wb3J0KCdiYXInKVxuICAgICAgICBpZiAocGFyZW50MSBpbnN0YW5jZW9mIEV4cHJlc3Npb25TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9BUlJBWTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50MSBpbnN0YW5jZW9mIEF3YWl0RXhwcmVzc2lvbikge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50MiA9IHBhcmVudDEucGFyZW50O1xuICAgICAgICAgICAgLy8gU2lkZS1lZmZlY3Qgb25seTogYXdhaXQgaW1wb3J0KCdiYXInKVxuICAgICAgICAgICAgaWYgKHBhcmVudDIgaW5zdGFuY2VvZiBFeHByZXNzaW9uU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0FSUkFZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FzZSAxOiBjb25zdCB7IGZvbyB9ID0gYXdhaXQgaW1wb3J0KCdiYXInKVxuICAgICAgICAgICAgaWYgKHBhcmVudDIgaW5zdGFuY2VvZiBWYXJpYWJsZURlY2xhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IHBhcmVudDIuaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uIGluc3RhbmNlb2YgT2JqZWN0UGF0dGVyblxuICAgICAgICAgICAgICAgICAgICA/IGdldERldGVybWluaXN0aWNPYmplY3REZXN0cnVjdHVyZShkZWNsYXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYXNlIDI6IChhd2FpdCBpbXBvcnQoJ2JhcicpKS5mb29cbiAgICAgICAgICAgIGlmIChwYXJlbnQyIGluc3RhbmNlb2YgTWVtYmVyRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gcGFyZW50Mi5wcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudDIuY29tcHV0ZWQgJiYgaWQgaW5zdGFuY2VvZiBJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbaWQubmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhc2UgMzogaW1wb3J0KCdiYXInKS50aGVuKCh7IGZvbyB9KSA9PiB7fSlcbiAgICAgICAgaWYgKHBhcmVudDEgaW5zdGFuY2VvZiBNZW1iZXJFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsRXhwcmVzc2lvbiA9IHBhcmVudDEucGFyZW50O1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBwYXJlbnQxLnByb3BlcnR5O1xuICAgICAgICAgICAgaWYgKCEoY2FsbEV4cHJlc3Npb24gaW5zdGFuY2VvZiBDYWxsRXhwcmVzc2lvbikgfHwgIShwcm9wZXJ0eSBpbnN0YW5jZW9mIElkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVtYmVyTmFtZSA9IHByb3BlcnR5Lm5hbWU7XG4gICAgICAgICAgICAvLyBzaWRlLWVmZmVjdCBvbmx5LCB3aGVuIG9ubHkgY2hhaW5pbmcgLmNhdGNoIG9yIC5maW5hbGx5XG4gICAgICAgICAgICBpZiAoY2FsbEV4cHJlc3Npb24ucGFyZW50IGluc3RhbmNlb2YgRXhwcmVzc2lvblN0YXRlbWVudCAmJlxuICAgICAgICAgICAgICAgIFsnY2F0Y2gnLCAnZmluYWxseSddLmluY2x1ZGVzKG1lbWJlck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0FSUkFZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lbWJlck5hbWUgIT09ICd0aGVuJylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBTaWRlLWVmZmVjdCBvbmx5OiBpbXBvcnQoJ2JhcicpLnRoZW4oKVxuICAgICAgICAgICAgaWYgKGNhbGxFeHByZXNzaW9uLmFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRU1QVFlfQVJSQVk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcmd1bWVudCA9IGNhbGxFeHByZXNzaW9uLmFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGlmIChjYWxsRXhwcmVzc2lvbi5hcmd1bWVudHMubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgICAgICAgICAgIShhcmd1bWVudCBpbnN0YW5jZW9mIEFycm93RnVuY3Rpb25FeHByZXNzaW9uIHx8IGFyZ3VtZW50IGluc3RhbmNlb2YgRnVuY3Rpb25FeHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNpZGUtZWZmZWN0IG9ubHk6IGltcG9ydCgnYmFyJykudGhlbigoKSA9PiB7fSlcbiAgICAgICAgICAgIGlmIChhcmd1bWVudC5wYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0FSUkFZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSBhcmd1bWVudC5wYXJhbXNbMF07XG4gICAgICAgICAgICBpZiAoYXJndW1lbnQucGFyYW1zLmxlbmd0aCA9PT0gMSAmJiBkZWNsYXJhdGlvbiBpbnN0YW5jZW9mIE9iamVjdFBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RGV0ZXJtaW5pc3RpY09iamVjdERlc3RydWN0dXJlKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNFZmZlY3RzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICBpZiAoIXRoaXMuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zY29wZS5jb250ZXh0LmluY2x1ZGVEeW5hbWljSW1wb3J0KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zY29wZS5hZGRBY2Nlc3NlZER5bmFtaWNJbXBvcnQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3VyY2UuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgfVxuICAgIGluaXRpYWxpc2UoKSB7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpc2UoKTtcbiAgICAgICAgdGhpcy5zY29wZS5jb250ZXh0LmFkZER5bmFtaWNJbXBvcnQodGhpcyk7XG4gICAgfVxuICAgIHBhcnNlTm9kZShlc1RyZWVOb2RlKSB7XG4gICAgICAgIHRoaXMuc291cmNlQXN0Tm9kZSA9IGVzVHJlZU5vZGUuc291cmNlO1xuICAgICAgICByZXR1cm4gc3VwZXIucGFyc2VOb2RlKGVzVHJlZU5vZGUpO1xuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHNuaXBwZXRzOiB7IF8sIGdldERpcmVjdFJldHVybkZ1bmN0aW9uLCBnZXRPYmplY3QsIGdldFByb3BlcnR5QWNjZXNzIH0gfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmICh0aGlzLmlubGluZU5hbWVzcGFjZSkge1xuICAgICAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGdldERpcmVjdFJldHVybkZ1bmN0aW9uKFtdLCB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25SZXR1cm46IHRydWUsXG4gICAgICAgICAgICAgICAgbGluZUJyZWFrSW5kZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUodGhpcy5zdGFydCwgdGhpcy5lbmQsIGBQcm9taXNlLnJlc29sdmUoKS50aGVuKCR7bGVmdH0ke3RoaXMuaW5saW5lTmFtZXNwYWNlLmdldE5hbWUoZ2V0UHJvcGVydHlBY2Nlc3MpfSR7cmlnaHR9KWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1lY2hhbmlzbSkge1xuICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUodGhpcy5zdGFydCwgZmluZEZpcnN0T2NjdXJyZW5jZU91dHNpZGVDb21tZW50KGNvZGUub3JpZ2luYWwsICcoJywgdGhpcy5zdGFydCArIDYpICsgMSwgdGhpcy5tZWNoYW5pc20ubGVmdCk7XG4gICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLmVuZCAtIDEsIHRoaXMuZW5kLCB0aGlzLm1lY2hhbmlzbS5yaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVzb2x1dGlvblN0cmluZykge1xuICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUodGhpcy5zb3VyY2Uuc3RhcnQsIHRoaXMuc291cmNlLmVuZCwgdGhpcy5yZXNvbHV0aW9uU3RyaW5nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWVzcGFjZUV4cG9ydE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb24oWyduJ10sIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25SZXR1cm46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVCcmVha0luZGVudDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvZGUucHJlcGVuZExlZnQodGhpcy5lbmQsIGAudGhlbigke2xlZnR9bi4ke3RoaXMubmFtZXNwYWNlRXhwb3J0TmFtZX0ke3JpZ2h0fSlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdHRyaWJ1dGVzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUodGhpcy5zb3VyY2UuZW5kLCB0aGlzLmVuZCAtIDEsICcnLCB7IGNvbnRlbnRPbmx5OiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGNvZGUuYXBwZW5kTGVmdCh0aGlzLmVuZCAtIDEsIGAsJHtffSR7Z2V0T2JqZWN0KFtbJ2Fzc2VydCcsIHRoaXMuYXR0cmlidXRlc11dLCB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVCcmVha0luZGVudDogbnVsbFxuICAgICAgICAgICAgICAgIH0pfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldEV4dGVybmFsUmVzb2x1dGlvbihleHBvcnRNb2RlLCByZXNvbHV0aW9uLCBvcHRpb25zLCBzbmlwcGV0cywgcGx1Z2luRHJpdmVyLCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlLCByZXNvbHV0aW9uU3RyaW5nLCBuYW1lc3BhY2VFeHBvcnROYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IHsgZm9ybWF0IH0gPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmlubGluZU5hbWVzcGFjZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgICAgIHRoaXMucmVzb2x1dGlvblN0cmluZyA9IHJlc29sdXRpb25TdHJpbmc7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlRXhwb3J0TmFtZSA9IG5hbWVzcGFjZUV4cG9ydE5hbWU7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIGNvbnN0IGFjY2Vzc2VkR2xvYmFscyA9IFsuLi4oYWNjZXNzZWRJbXBvcnRHbG9iYWxzW2Zvcm1hdF0gfHwgW10pXTtcbiAgICAgICAgbGV0IGhlbHBlcjtcbiAgICAgICAgKHsgaGVscGVyLCBtZWNoYW5pc206IHRoaXMubWVjaGFuaXNtIH0gPSB0aGlzLmdldER5bmFtaWNJbXBvcnRNZWNoYW5pc21BbmRIZWxwZXIocmVzb2x1dGlvbiwgZXhwb3J0TW9kZSwgb3B0aW9ucywgc25pcHBldHMsIHBsdWdpbkRyaXZlcikpO1xuICAgICAgICBpZiAoaGVscGVyKSB7XG4gICAgICAgICAgICBhY2Nlc3NlZEdsb2JhbHMucHVzaChoZWxwZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY2Nlc3NlZEdsb2JhbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zY29wZS5hZGRBY2Nlc3NlZEdsb2JhbHMoYWNjZXNzZWRHbG9iYWxzLCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRJbnRlcm5hbFJlc29sdXRpb24oaW5saW5lTmFtZXNwYWNlKSB7XG4gICAgICAgIHRoaXMuaW5saW5lTmFtZXNwYWNlID0gaW5saW5lTmFtZXNwYWNlO1xuICAgIH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHsgfVxuICAgIGdldER5bmFtaWNJbXBvcnRNZWNoYW5pc21BbmRIZWxwZXIocmVzb2x1dGlvbiwgZXhwb3J0TW9kZSwgeyBjb21wYWN0LCBkeW5hbWljSW1wb3J0SW5DanMsIGZvcm1hdCwgZ2VuZXJhdGVkQ29kZTogeyBhcnJvd0Z1bmN0aW9ucyB9LCBpbnRlcm9wIH0sIHsgXywgZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb24sIGdldERpcmVjdFJldHVybklpZmVMZWZ0IH0sIHBsdWdpbkRyaXZlcikge1xuICAgICAgICBjb25zdCBtZWNoYW5pc20gPSBwbHVnaW5Ecml2ZXIuaG9va0ZpcnN0U3luYygncmVuZGVyRHluYW1pY0ltcG9ydCcsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjdXN0b21SZXNvbHV0aW9uOiB0eXBlb2YgdGhpcy5yZXNvbHV0aW9uID09PSAnc3RyaW5nJyA/IHRoaXMucmVzb2x1dGlvbiA6IG51bGwsXG4gICAgICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICAgICAgICAgIG1vZHVsZUlkOiB0aGlzLnNjb3BlLmNvbnRleHQubW9kdWxlLmlkLFxuICAgICAgICAgICAgICAgIHRhcmdldE1vZHVsZUlkOiB0aGlzLnJlc29sdXRpb24gJiYgdHlwZW9mIHRoaXMucmVzb2x1dGlvbiAhPT0gJ3N0cmluZycgPyB0aGlzLnJlc29sdXRpb24uaWQgOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIF0pO1xuICAgICAgICBpZiAobWVjaGFuaXNtKSB7XG4gICAgICAgICAgICByZXR1cm4geyBoZWxwZXI6IG51bGwsIG1lY2hhbmlzbSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc0R5bmFtaWNUYXJnZXQgPSAhdGhpcy5yZXNvbHV0aW9uIHx8IHR5cGVvZiB0aGlzLnJlc29sdXRpb24gPT09ICdzdHJpbmcnO1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSAnY2pzJzoge1xuICAgICAgICAgICAgICAgIGlmIChkeW5hbWljSW1wb3J0SW5DanMgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFyZXNvbHV0aW9uIHx8IHR5cGVvZiByZXNvbHV0aW9uID09PSAnc3RyaW5nJyB8fCByZXNvbHV0aW9uIGluc3RhbmNlb2YgRXh0ZXJuYWxNb2R1bGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGhlbHBlcjogbnVsbCwgbWVjaGFuaXNtOiBudWxsIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGhlbHBlciA9IGdldEludGVyb3BIZWxwZXIocmVzb2x1dGlvbiwgZXhwb3J0TW9kZSwgaW50ZXJvcCk7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQgPSBgcmVxdWlyZShgO1xuICAgICAgICAgICAgICAgIGxldCByaWdodCA9IGApYDtcbiAgICAgICAgICAgICAgICBpZiAoaGVscGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBgLyojX19QVVJFX18qLyR7aGVscGVyfSgke2xlZnR9YDtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgKz0gJyknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBbZnVuY3Rpb25MZWZ0LCBmdW5jdGlvblJpZ2h0XSA9IGdldERpcmVjdFJldHVybkZ1bmN0aW9uKFtdLCB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmV0dXJuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBsaW5lQnJlYWtJbmRlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gYFByb21pc2UucmVzb2x2ZSgpLnRoZW4oJHtmdW5jdGlvbkxlZnR9JHtsZWZ0fWA7XG4gICAgICAgICAgICAgICAgcmlnaHQgKz0gYCR7ZnVuY3Rpb25SaWdodH0pYDtcbiAgICAgICAgICAgICAgICBpZiAoIWFycm93RnVuY3Rpb25zICYmIGhhc0R5bmFtaWNUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGdldERpcmVjdFJldHVybklpZmVMZWZ0KFsndCddLCBgJHtsZWZ0fXQke3JpZ2h0fWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRzQXJyb3dSZXR1cm5QYXJlbnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZHNXcmFwcGVkRnVuY3Rpb246IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gJyknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXIsXG4gICAgICAgICAgICAgICAgICAgIG1lY2hhbmlzbTogeyBsZWZ0LCByaWdodCB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2FtZCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlID0gY29tcGFjdCA/ICdjJyA6ICdyZXNvbHZlJztcbiAgICAgICAgICAgICAgICBjb25zdCByZWplY3QgPSBjb21wYWN0ID8gJ2UnIDogJ3JlamVjdCc7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVscGVyID0gZ2V0SW50ZXJvcEhlbHBlcihyZXNvbHV0aW9uLCBleHBvcnRNb2RlLCBpbnRlcm9wKTtcbiAgICAgICAgICAgICAgICBjb25zdCBbcmVzb2x2ZUxlZnQsIHJlc29sdmVSaWdodF0gPSBnZXREaXJlY3RSZXR1cm5GdW5jdGlvbihbJ20nXSwge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblJldHVybjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVCcmVha0luZGVudDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVOYW1lc3BhY2UgPSBoZWxwZXJcbiAgICAgICAgICAgICAgICAgICAgPyBgJHtyZXNvbHZlTGVmdH0ke3Jlc29sdmV9KC8qI19fUFVSRV9fKi8ke2hlbHBlcn0obSkpJHtyZXNvbHZlUmlnaHR9YFxuICAgICAgICAgICAgICAgICAgICA6IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgY29uc3QgW2hhbmRsZXJMZWZ0LCBoYW5kbGVyUmlnaHRdID0gZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb24oW3Jlc29sdmUsIHJlamVjdF0sIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25SZXR1cm46IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBsaW5lQnJlYWtJbmRlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCA9IGBuZXcgUHJvbWlzZSgke2hhbmRsZXJMZWZ0fXJlcXVpcmUoW2A7XG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0gYF0sJHtffSR7cmVzb2x2ZU5hbWVzcGFjZX0sJHtffSR7cmVqZWN0fSkke2hhbmRsZXJSaWdodH0pYDtcbiAgICAgICAgICAgICAgICBpZiAoIWFycm93RnVuY3Rpb25zICYmIGhhc0R5bmFtaWNUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGdldERpcmVjdFJldHVybklpZmVMZWZ0KFsndCddLCBgJHtsZWZ0fXQke3JpZ2h0fWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRzQXJyb3dSZXR1cm5QYXJlbnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZHNXcmFwcGVkRnVuY3Rpb246IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gJyknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXIsXG4gICAgICAgICAgICAgICAgICAgIG1lY2hhbmlzbTogeyBsZWZ0LCByaWdodCB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3N5c3RlbSc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1lY2hhbmlzbToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogJ21vZHVsZS5pbXBvcnQoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAnKSdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaGVscGVyOiBudWxsLCBtZWNoYW5pc206IG51bGwgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRJbnRlcm9wSGVscGVyKHJlc29sdXRpb24sIGV4cG9ydE1vZGUsIGludGVyb3ApIHtcbiAgICByZXR1cm4gZXhwb3J0TW9kZSA9PT0gJ2V4dGVybmFsJ1xuICAgICAgICA/IG5hbWVzcGFjZUludGVyb3BIZWxwZXJzQnlJbnRlcm9wVHlwZVtpbnRlcm9wKHJlc29sdXRpb24gaW5zdGFuY2VvZiBFeHRlcm5hbE1vZHVsZSA/IHJlc29sdXRpb24uaWQgOiBudWxsKV1cbiAgICAgICAgOiBleHBvcnRNb2RlID09PSAnZGVmYXVsdCdcbiAgICAgICAgICAgID8gSU5URVJPUF9OQU1FU1BBQ0VfREVGQVVMVF9PTkxZX1ZBUklBQkxFXG4gICAgICAgICAgICA6IG51bGw7XG59XG5jb25zdCBhY2Nlc3NlZEltcG9ydEdsb2JhbHMgPSB7XG4gICAgYW1kOiBbJ3JlcXVpcmUnXSxcbiAgICBjanM6IFsncmVxdWlyZSddLFxuICAgIHN5c3RlbTogWydtb2R1bGUnXVxufTtcbmZ1bmN0aW9uIGdldERldGVybWluaXN0aWNPYmplY3REZXN0cnVjdHVyZShvYmplY3RQYXR0ZXJuKSB7XG4gICAgY29uc3QgdmFyaWFibGVzID0gW107XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBvYmplY3RQYXR0ZXJuLnByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5LnR5cGUgPT09ICdSZXN0RWxlbWVudCcgfHwgcHJvcGVydHkuY29tcHV0ZWQgfHwgcHJvcGVydHkua2V5LnR5cGUgIT09ICdJZGVudGlmaWVyJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyaWFibGVzLnB1c2gocHJvcGVydHkua2V5Lm5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFyaWFibGVzO1xufVxuXG5jbGFzcyBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7IH1cbn1cblxuY2xhc3MgSW1wb3J0U3BlY2lmaWVyIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGFwcGx5RGVvcHRpbWl6YXRpb25zKCkgeyB9XG59XG5cbmNsYXNzIEpTWElkZW50aWZpZXIgZXh0ZW5kcyBJZGVudGlmaWVyQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaXNOYXRpdmVFbGVtZW50ID0gZmFsc2U7XG4gICAgfVxuICAgIGJpbmQoKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IDAgLyogSWRlbnRpZmllclR5cGUuUmVmZXJlbmNlICovKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlID0gdGhpcy5zY29wZS5maW5kVmFyaWFibGUodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGUuYWRkUmVmZXJlbmNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IDEgLyogSWRlbnRpZmllclR5cGUuTmF0aXZlRWxlbWVudE5hbWUgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuaXNOYXRpdmVFbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoY29kZSwgeyBzbmlwcGV0czogeyBnZXRQcm9wZXJ0eUFjY2VzcyB9LCB1c2VPcmlnaW5hbE5hbWUgfSkge1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMudmFyaWFibGUuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2VzcywgdXNlT3JpZ2luYWxOYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgbmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50T25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVOYW1lOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc05hdGl2ZUVsZW1lbnQgJiZcbiAgICAgICAgICAgIHRoaXMuc2NvcGUuY29udGV4dC5vcHRpb25zLmpzeC5tb2RlICE9PSAncHJlc2VydmUnKSB7XG4gICAgICAgICAgICBjb2RlLnVwZGF0ZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgSlNPTi5zdHJpbmdpZnkodGhpcy5uYW1lKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VHlwZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdKU1hPcGVuaW5nRWxlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdKU1hDbG9zaW5nRWxlbWVudCc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lLnN0YXJ0c1dpdGgodGhpcy5uYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgICAgICAgICA/IDAgLyogSWRlbnRpZmllclR5cGUuUmVmZXJlbmNlICovXG4gICAgICAgICAgICAgICAgICAgIDogMSAvKiBJZGVudGlmaWVyVHlwZS5OYXRpdmVFbGVtZW50TmFtZSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0pTWE1lbWJlckV4cHJlc3Npb24nOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm9iamVjdCA9PT0gdGhpc1xuICAgICAgICAgICAgICAgICAgICA/IDAgLyogSWRlbnRpZmllclR5cGUuUmVmZXJlbmNlICovXG4gICAgICAgICAgICAgICAgICAgIDogMiAvKiBJZGVudGlmaWVyVHlwZS5PdGhlciAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0pTWEF0dHJpYnV0ZSc6XG4gICAgICAgICAgICBjYXNlICdKU1hOYW1lc3BhY2VkTmFtZSc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBJZGVudGlmaWVyVHlwZS5PdGhlciAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBwYXJlbnQgbm9kZSB0eXBlIGZvciBKU1hJZGVudGlmaWVyOiAke3RoaXMucGFyZW50LnR5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEpTWEF0dHJpYnV0ZSBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucywgeyBqc3hNb2RlIH0gPSBCTEFOSykge1xuICAgICAgICBzdXBlci5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChbJ2NsYXNzaWMnLCAnYXV0b21hdGljJ10uaW5jbHVkZXMoanN4TW9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgdmFsdWUgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBuYW1lIGluc3RhbmNlb2YgSlNYSWRlbnRpZmllciA/IG5hbWUubmFtZSA6IGAke25hbWUubmFtZXNwYWNlLm5hbWV9OiR7bmFtZS5uYW1lLm5hbWV9YDtcbiAgICAgICAgICAgIGlmICghKGpzeE1vZGUgPT09ICdhdXRvbWF0aWMnICYmIGtleSA9PT0gJ2tleScpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2FmZUtleSA9IHN0cmluZ2lmeU9iamVjdEtleUlmTmVlZGVkKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gc2FmZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShuYW1lLnN0YXJ0LCBuYW1lLmVuZCwgc2FmZUtleSwgeyBjb250ZW50T25seTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKG5hbWUuZW5kLCB2YWx1ZS5zdGFydCwgJzogJywgeyBjb250ZW50T25seTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUuYXBwZW5kTGVmdChuYW1lLmVuZCwgJzogdHJ1ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgSlNYQ2xvc2luZ0Jhc2UgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBtb2RlIH0gPSB0aGlzLnNjb3BlLmNvbnRleHQub3B0aW9ucy5qc3g7XG4gICAgICAgIGlmIChtb2RlICE9PSAncHJlc2VydmUnKSB7XG4gICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgJyknLCB7IGNvbnRlbnRPbmx5OiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBKU1hDbG9zaW5nRWxlbWVudCBleHRlbmRzIEpTWENsb3NpbmdCYXNlIHtcbn1cblxuY2xhc3MgSlNYQ2xvc2luZ0ZyYWdtZW50IGV4dGVuZHMgSlNYQ2xvc2luZ0Jhc2Uge1xufVxuXG5jbGFzcyBKU1hTcHJlYWRBdHRyaWJ1dGUgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hcmd1bWVudC5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgbW9kZSB9ID0gdGhpcy5zY29wZS5jb250ZXh0Lm9wdGlvbnMuanN4O1xuICAgICAgICBpZiAobW9kZSAhPT0gJ3ByZXNlcnZlJykge1xuICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUodGhpcy5zdGFydCwgdGhpcy5hcmd1bWVudC5zdGFydCwgJycsIHsgY29udGVudE9ubHk6IHRydWUgfSk7XG4gICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLmFyZ3VtZW50LmVuZCwgdGhpcy5lbmQsICcnLCB7IGNvbnRlbnRPbmx5OiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBKU1hFbXB0eUV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG59XG5cbmNsYXNzIEpTWEV4cHJlc3Npb25Db250YWluZXIgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBtb2RlIH0gPSB0aGlzLnNjb3BlLmNvbnRleHQub3B0aW9ucy5qc3g7XG4gICAgICAgIGlmIChtb2RlICE9PSAncHJlc2VydmUnKSB7XG4gICAgICAgICAgICBjb2RlLnJlbW92ZSh0aGlzLnN0YXJ0LCB0aGlzLmV4cHJlc3Npb24uc3RhcnQpO1xuICAgICAgICAgICAgY29kZS5yZW1vdmUodGhpcy5leHByZXNzaW9uLmVuZCwgdGhpcy5lbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbi5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZW5kZXJlZEpzeENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgbGV0IHJlbmRlcmVkQ2hpbGRyZW4gPSAwO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBKU1hFeHByZXNzaW9uQ29udGFpbmVyICYmIGNoaWxkLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBKU1hFbXB0eUV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICByZW5kZXJlZENoaWxkcmVuKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlcmVkQ2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGdldEFuZEluY2x1ZGVGYWN0b3J5VmFyaWFibGUoZmFjdG9yeSwgcHJlc2VydmUsIGltcG9ydFNvdXJjZSwgbm9kZSkge1xuICAgIGNvbnN0IFtiYXNlTmFtZSwgbmVzdGVkTmFtZV0gPSBmYWN0b3J5LnNwbGl0KCcuJyk7XG4gICAgbGV0IGZhY3RvcnlWYXJpYWJsZTtcbiAgICBpZiAoaW1wb3J0U291cmNlKSB7XG4gICAgICAgIGZhY3RvcnlWYXJpYWJsZSA9IG5vZGUuc2NvcGUuY29udGV4dC5nZXRJbXBvcnRlZEpzeEZhY3RvcnlWYXJpYWJsZShuZXN0ZWROYW1lID8gJ2RlZmF1bHQnIDogYmFzZU5hbWUsIG5vZGUuc3RhcnQsIGltcG9ydFNvdXJjZSk7XG4gICAgICAgIGlmIChwcmVzZXJ2ZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBwcmV0ZW5kcyB3ZSBhcmUgYWNjZXNzaW5nIGFuIGluY2x1ZGVkIGdsb2JhbCB2YXJpYWJsZSBvZiB0aGUgc2FtZSBuYW1lXG4gICAgICAgICAgICBjb25zdCBnbG9iYWxWYXJpYWJsZSA9IG5vZGUuc2NvcGUuZmluZEdsb2JhbChiYXNlTmFtZSk7XG4gICAgICAgICAgICBnbG9iYWxWYXJpYWJsZS5pbmNsdWRlKCk7XG4gICAgICAgICAgICAvLyBUaGlzIGV4Y2x1ZGVzIHRoaXMgdmFyaWFibGUgZnJvbSByZW5hbWluZ1xuICAgICAgICAgICAgZmFjdG9yeVZhcmlhYmxlLmdsb2JhbE5hbWUgPSBiYXNlTmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmFjdG9yeVZhcmlhYmxlID0gbm9kZS5zY29wZS5maW5kR2xvYmFsKGJhc2VOYW1lKTtcbiAgICB9XG4gICAgbm9kZS5zY29wZS5jb250ZXh0LmluY2x1ZGVWYXJpYWJsZUluTW9kdWxlKGZhY3RvcnlWYXJpYWJsZSk7XG4gICAgaWYgKGZhY3RvcnlWYXJpYWJsZSBpbnN0YW5jZW9mIExvY2FsVmFyaWFibGUpIHtcbiAgICAgICAgZmFjdG9yeVZhcmlhYmxlLmNvbnNvbGlkYXRlSW5pdGlhbGl6ZXJzKCk7XG4gICAgICAgIGZhY3RvcnlWYXJpYWJsZS5hZGRVc2VkUGxhY2Uobm9kZSk7XG4gICAgICAgIG5vZGUuc2NvcGUuY29udGV4dC5yZXF1ZXN0VHJlZXNoYWtpbmdQYXNzKCk7XG4gICAgfVxuICAgIHJldHVybiBmYWN0b3J5VmFyaWFibGU7XG59XG5cbmNsYXNzIEpTWEVsZW1lbnRCYXNlIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmZhY3RvcnlWYXJpYWJsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmFjdG9yeSA9IG51bGw7XG4gICAgfVxuICAgIGluaXRpYWxpc2UoKSB7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpc2UoKTtcbiAgICAgICAgY29uc3QgeyBpbXBvcnRTb3VyY2UgfSA9ICh0aGlzLmpzeE1vZGUgPSB0aGlzLmdldFJlbmRlcmluZ01vZGUoKSk7XG4gICAgICAgIGlmIChpbXBvcnRTb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGUuY29udGV4dC5hZGRJbXBvcnRTb3VyY2UoaW1wb3J0U291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIGlmICghdGhpcy5pbmNsdWRlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBmYWN0b3J5LCBpbXBvcnRTb3VyY2UsIG1vZGUgfSA9IHRoaXMuanN4TW9kZTtcbiAgICAgICAgICAgIGlmIChmYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgICAgICAgICB0aGlzLmZhY3RvcnlWYXJpYWJsZSA9IGdldEFuZEluY2x1ZGVGYWN0b3J5VmFyaWFibGUoZmFjdG9yeSwgbW9kZSA9PT0gJ3ByZXNlcnZlJywgaW1wb3J0U291cmNlLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICB9XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7IH1cbiAgICBnZXRSZW5kZXJpbmdNb2RlKCkge1xuICAgICAgICBjb25zdCBqc3ggPSB0aGlzLnNjb3BlLmNvbnRleHQub3B0aW9ucy5qc3g7XG4gICAgICAgIGNvbnN0IHsgbW9kZSwgZmFjdG9yeSwgaW1wb3J0U291cmNlIH0gPSBqc3g7XG4gICAgICAgIGlmIChtb2RlID09PSAnYXV0b21hdGljJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5OiBnZXRSZW5kZXJlZEpzeENoaWxkcmVuKHRoaXMuY2hpbGRyZW4pID4gMSA/ICdqc3hzJyA6ICdqc3gnLFxuICAgICAgICAgICAgICAgIGltcG9ydFNvdXJjZToganN4LmpzeEltcG9ydFNvdXJjZSxcbiAgICAgICAgICAgICAgICBtb2RlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZhY3RvcnksIGltcG9ydFNvdXJjZSwgbW9kZSB9O1xuICAgIH1cbiAgICByZW5kZXJDaGlsZHJlbihjb2RlLCBvcHRpb25zLCBvcGVuaW5nRW5kKSB7XG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXM7XG4gICAgICAgIGxldCBoYXNNdWx0aXBsZUNoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgIGxldCBjaGlsZHJlbkVuZCA9IG9wZW5pbmdFbmQ7XG4gICAgICAgIGxldCBmaXJzdENoaWxkID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgSlNYRXhwcmVzc2lvbkNvbnRhaW5lciAmJlxuICAgICAgICAgICAgICAgIGNoaWxkLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBKU1hFbXB0eUV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBjb2RlLnJlbW92ZShjaGlsZHJlbkVuZCwgY2hpbGQuZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGUuYXBwZW5kTGVmdChjaGlsZHJlbkVuZCwgJywgJyk7XG4gICAgICAgICAgICAgICAgY2hpbGQucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc011bHRpcGxlQ2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RDaGlsZCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuRW5kID0gY2hpbGQuZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoaWxkcmVuRW5kLCBmaXJzdENoaWxkLCBoYXNNdWx0aXBsZUNoaWxkcmVuIH07XG4gICAgfVxufVxuXG5jbGFzcyBKU1hFbGVtZW50IGV4dGVuZHMgSlNYRWxlbWVudEJhc2Uge1xuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5qc3hNb2RlLm1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NsYXNzaWMnOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJDbGFzc2ljTW9kZShjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2F1dG9tYXRpYyc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckF1dG9tYXRpY01vZGUoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgc3VwZXIucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJlbmRlcmluZ01vZGUoKSB7XG4gICAgICAgIGNvbnN0IGpzeCA9IHRoaXMuc2NvcGUuY29udGV4dC5vcHRpb25zLmpzeDtcbiAgICAgICAgY29uc3QgeyBtb2RlLCBmYWN0b3J5LCBpbXBvcnRTb3VyY2UgfSA9IGpzeDtcbiAgICAgICAgaWYgKG1vZGUgPT09ICdhdXRvbWF0aWMnKSB7XG4gICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSB0aGVyZSBpcyBhIGtleSBhZnRlciBhIHNwcmVhZCBhdHRyaWJ1dGUsIHdlIGZhbGwgYmFjayB0b1xuICAgICAgICAgICAgLy8gY2xhc3NpYyBtb2RlLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDAzMSNpc3N1ZWNvbW1lbnQtNzEwMzQ2ODY2XG4gICAgICAgICAgICAvLyBmb3IgcmVhc29uaW5nLlxuICAgICAgICAgICAgbGV0IGhhc1NwcmVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgdGhpcy5vcGVuaW5nRWxlbWVudC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZSBpbnN0YW5jZW9mIEpTWFNwcmVhZEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNTcHJlYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNTcHJlYWQgJiYgYXR0cmlidXRlLm5hbWUubmFtZSA9PT0gJ2tleScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZmFjdG9yeSwgaW1wb3J0U291cmNlLCBtb2RlOiAnY2xhc3NpYycgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldFJlbmRlcmluZ01vZGUoKTtcbiAgICB9XG4gICAgcmVuZGVyQ2xhc3NpY01vZGUoY29kZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHNuaXBwZXRzOiB7IGdldFByb3BlcnR5QWNjZXNzIH0sIHVzZU9yaWdpbmFsTmFtZSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgeyBjbG9zaW5nRWxlbWVudCwgZW5kLCBmYWN0b3J5LCBmYWN0b3J5VmFyaWFibGUsIG9wZW5pbmdFbGVtZW50OiB7IGVuZDogb3BlbmluZ0VuZCwgc2VsZkNsb3NpbmcgfSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgWywgLi4ubmVzdGVkTmFtZV0gPSBmYWN0b3J5LnNwbGl0KCcuJyk7XG4gICAgICAgIGNvbnN0IHsgZmlyc3RBdHRyaWJ1dGUsIGhhc0F0dHJpYnV0ZXMsIGhhc1NwcmVhZCwgaW5PYmplY3QsIHByZXZpb3VzRW5kIH0gPSB0aGlzLnJlbmRlckF0dHJpYnV0ZXMoY29kZSwgb3B0aW9ucywgW2ZhY3RvcnlWYXJpYWJsZS5nZXROYW1lKGdldFByb3BlcnR5QWNjZXNzLCB1c2VPcmlnaW5hbE5hbWUpLCAuLi5uZXN0ZWROYW1lXS5qb2luKCcuJyksIGZhbHNlKTtcbiAgICAgICAgdGhpcy53cmFwQXR0cmlidXRlcyhjb2RlLCBpbk9iamVjdCwgaGFzQXR0cmlidXRlcywgaGFzU3ByZWFkLCBmaXJzdEF0dHJpYnV0ZSwgJ251bGwnLCBwcmV2aW91c0VuZCk7XG4gICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4oY29kZSwgb3B0aW9ucywgb3BlbmluZ0VuZCk7XG4gICAgICAgIGlmIChzZWxmQ2xvc2luZykge1xuICAgICAgICAgICAgY29kZS5hcHBlbmRMZWZ0KGVuZCwgJyknKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsb3NpbmdFbGVtZW50LnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJBdXRvbWF0aWNNb2RlKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBzbmlwcGV0czogeyBnZXRQcm9wZXJ0eUFjY2VzcyB9LCB1c2VPcmlnaW5hbE5hbWUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgY2xvc2luZ0VsZW1lbnQsIGVuZCwgZmFjdG9yeVZhcmlhYmxlLCBvcGVuaW5nRWxlbWVudDogeyBlbmQ6IG9wZW5pbmRFbmQsIHNlbGZDbG9zaW5nIH0gfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGZpcnN0QXR0cmlidXRlLCBoYXNBdHRyaWJ1dGVzLCBoYXNTcHJlYWQsIGluT2JqZWN0LCBrZXlBdHRyaWJ1dGUsIHByZXZpb3VzRW5kIH0gPSB0aGlzLnJlbmRlckF0dHJpYnV0ZXMoY29kZSwgb3B0aW9ucywgZmFjdG9yeVZhcmlhYmxlLmdldE5hbWUoZ2V0UHJvcGVydHlBY2Nlc3MsIHVzZU9yaWdpbmFsTmFtZSksIHRydWUpO1xuICAgICAgICBjb25zdCB7IGZpcnN0Q2hpbGQsIGhhc011bHRpcGxlQ2hpbGRyZW4sIGNoaWxkcmVuRW5kIH0gPSB0aGlzLnJlbmRlckNoaWxkcmVuKGNvZGUsIG9wdGlvbnMsIG9wZW5pbmRFbmQpO1xuICAgICAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgY29kZS5wcmVwZW5kUmlnaHQoZmlyc3RDaGlsZC5zdGFydCwgYGNoaWxkcmVuOiAke2hhc011bHRpcGxlQ2hpbGRyZW4gPyAnWycgOiAnJ31gKTtcbiAgICAgICAgICAgIGlmICghaW5PYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb2RlLnByZXBlbmRSaWdodChmaXJzdENoaWxkLnN0YXJ0LCAneyAnKTtcbiAgICAgICAgICAgICAgICBpbk9iamVjdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91c0VuZCA9IGNsb3NpbmdFbGVtZW50LnN0YXJ0O1xuICAgICAgICAgICAgaWYgKGhhc011bHRpcGxlQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBjb2RlLmFwcGVuZExlZnQocHJldmlvdXNFbmQsICddJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cmFwQXR0cmlidXRlcyhjb2RlLCBpbk9iamVjdCwgaGFzQXR0cmlidXRlcyB8fCAhIWZpcnN0Q2hpbGQsIGhhc1NwcmVhZCwgZmlyc3RBdHRyaWJ1dGUgfHwgZmlyc3RDaGlsZCwgJ3t9JywgY2hpbGRyZW5FbmQpO1xuICAgICAgICBpZiAoa2V5QXR0cmlidXRlKSB7XG4gICAgICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSBrZXlBdHRyaWJ1dGU7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgYXBwZWFyIHRvIHRoZSBsZWZ0IG9mIHRoZSBtb3ZlZCBjb2RlLi4uXG4gICAgICAgICAgICBjb2RlLmFwcGVuZExlZnQoY2hpbGRyZW5FbmQsICcsICcpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29kZS5tb3ZlKHZhbHVlLnN0YXJ0LCB2YWx1ZS5lbmQsIGNoaWxkcmVuRW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGUuYXBwZW5kTGVmdChjaGlsZHJlbkVuZCwgJ3RydWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgICAgIC8vIE1vdmluZyB0aGUga2V5IGF0dHJpYnV0ZSB3aWxsIGFsc28gbW92ZSB0aGUgcGFyZW50aGVzaXMgdG8gdGhlIHJpZ2h0IHBvc2l0aW9uXG4gICAgICAgICAgICBjb2RlLmFwcGVuZExlZnQoa2V5QXR0cmlidXRlPy52YWx1ZT8uZW5kIHx8IGVuZCwgJyknKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsb3NpbmdFbGVtZW50LnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJBdHRyaWJ1dGVzKGNvZGUsIG9wdGlvbnMsIGZhY3RvcnlOYW1lLCBleHRyYWN0S2V5QXR0cmlidXRlKSB7XG4gICAgICAgIGNvbnN0IHsganN4TW9kZTogeyBtb2RlIH0sIG9wZW5pbmdFbGVtZW50IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGF0dHJpYnV0ZXMsIGVuZDogb3BlbmluZ0VuZCwgc3RhcnQ6IG9wZW5pbmdTdGFydCwgbmFtZTogeyBzdGFydDogbmFtZVN0YXJ0LCBlbmQ6IG5hbWVFbmQgfSB9ID0gb3BlbmluZ0VsZW1lbnQ7XG4gICAgICAgIGNvZGUudXBkYXRlKG9wZW5pbmdTdGFydCwgbmFtZVN0YXJ0LCBgLyojX19QVVJFX18qLyR7ZmFjdG9yeU5hbWV9KGApO1xuICAgICAgICBvcGVuaW5nRWxlbWVudC5yZW5kZXIoY29kZSwgb3B0aW9ucywgeyBqc3hNb2RlOiBtb2RlIH0pO1xuICAgICAgICBsZXQga2V5QXR0cmlidXRlID0gbnVsbDtcbiAgICAgICAgbGV0IGhhc1NwcmVhZCA9IGZhbHNlO1xuICAgICAgICBsZXQgaW5PYmplY3QgPSBmYWxzZTtcbiAgICAgICAgbGV0IHByZXZpb3VzRW5kID0gbmFtZUVuZDtcbiAgICAgICAgbGV0IGhhc0F0dHJpYnV0ZXMgPSBmYWxzZTtcbiAgICAgICAgbGV0IGZpcnN0QXR0cmlidXRlID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZSBpbnN0YW5jZW9mIEpTWEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChleHRyYWN0S2V5QXR0cmlidXRlICYmIGF0dHJpYnV0ZS5uYW1lLm5hbWUgPT09ICdrZXknKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5yZW1vdmUocHJldmlvdXNFbmQsIGF0dHJpYnV0ZS52YWx1ZT8uc3RhcnQgfHwgYXR0cmlidXRlLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2RlLmFwcGVuZExlZnQocHJldmlvdXNFbmQsICcsJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpbk9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlLnByZXBlbmRSaWdodChhdHRyaWJ1dGUuc3RhcnQsICd7ICcpO1xuICAgICAgICAgICAgICAgICAgICBpbk9iamVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhc0F0dHJpYnV0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGluT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlLmFwcGVuZExlZnQocHJldmlvdXNFbmQsICcgJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29kZS5hcHBlbmRMZWZ0KHByZXZpb3VzRW5kLCAnfSwnKTtcbiAgICAgICAgICAgICAgICAgICAgaW5PYmplY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUuYXBwZW5kTGVmdChwcmV2aW91c0VuZCwgJywnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFzU3ByZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzRW5kID0gYXR0cmlidXRlLmVuZDtcbiAgICAgICAgICAgIGlmICghZmlyc3RBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBmaXJzdEF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2RlLnJlbW92ZShhdHRyaWJ1dGVzLmF0KC0xKT8uZW5kIHx8IHByZXZpb3VzRW5kLCBvcGVuaW5nRW5kKTtcbiAgICAgICAgcmV0dXJuIHsgZmlyc3RBdHRyaWJ1dGUsIGhhc0F0dHJpYnV0ZXMsIGhhc1NwcmVhZCwgaW5PYmplY3QsIGtleUF0dHJpYnV0ZSwgcHJldmlvdXNFbmQgfTtcbiAgICB9XG4gICAgd3JhcEF0dHJpYnV0ZXMoY29kZSwgaW5PYmplY3QsIGhhc0F0dHJpYnV0ZXMsIGhhc1NwcmVhZCwgZmlyc3RBdHRyaWJ1dGUsIG1pc3NpbmdBdHRyaWJ1dGVzRmFsbGJhY2ssIGF0dHJpYnV0ZXNFbmQpIHtcbiAgICAgICAgaWYgKGluT2JqZWN0KSB7XG4gICAgICAgICAgICBjb2RlLmFwcGVuZExlZnQoYXR0cmlidXRlc0VuZCwgJyB9Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1NwcmVhZCkge1xuICAgICAgICAgICAgaWYgKGhhc0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN0YXJ0IH0gPSBmaXJzdEF0dHJpYnV0ZTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RBdHRyaWJ1dGUgaW5zdGFuY2VvZiBKU1hTcHJlYWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5wcmVwZW5kUmlnaHQoc3RhcnQsICd7fSwgJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGUucHJlcGVuZFJpZ2h0KHN0YXJ0LCAnT2JqZWN0LmFzc2lnbignKTtcbiAgICAgICAgICAgICAgICBjb2RlLmFwcGVuZExlZnQoYXR0cmlidXRlc0VuZCwgJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaGFzQXR0cmlidXRlcykge1xuICAgICAgICAgICAgY29kZS5hcHBlbmRMZWZ0KGF0dHJpYnV0ZXNFbmQsIGAsICR7bWlzc2luZ0F0dHJpYnV0ZXNGYWxsYmFja31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgSlNYRnJhZ21lbnQgZXh0ZW5kcyBKU1hFbGVtZW50QmFzZSB7XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmpzeE1vZGUubW9kZSkge1xuICAgICAgICAgICAgY2FzZSAnY2xhc3NpYyc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckNsYXNzaWNNb2RlKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYXV0b21hdGljJzoge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQXV0b21hdGljTW9kZShjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBzdXBlci5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyQ2xhc3NpY01vZGUoY29kZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHNuaXBwZXRzOiB7IGdldFByb3BlcnR5QWNjZXNzIH0sIHVzZU9yaWdpbmFsTmFtZSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgeyBjbG9zaW5nRnJhZ21lbnQsIGZhY3RvcnksIGZhY3RvcnlWYXJpYWJsZSwgb3BlbmluZ0ZyYWdtZW50LCBzdGFydCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgWywgLi4ubmVzdGVkTmFtZV0gPSBmYWN0b3J5LnNwbGl0KCcuJyk7XG4gICAgICAgIG9wZW5pbmdGcmFnbWVudC5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgIGNvZGUucHJlcGVuZFJpZ2h0KHN0YXJ0LCBgLyojX19QVVJFX18qLyR7W1xuICAgICAgICAgICAgZmFjdG9yeVZhcmlhYmxlLmdldE5hbWUoZ2V0UHJvcGVydHlBY2Nlc3MsIHVzZU9yaWdpbmFsTmFtZSksXG4gICAgICAgICAgICAuLi5uZXN0ZWROYW1lXG4gICAgICAgIF0uam9pbignLicpfShgKTtcbiAgICAgICAgY29kZS5hcHBlbmRMZWZ0KG9wZW5pbmdGcmFnbWVudC5lbmQsICcsIG51bGwnKTtcbiAgICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbihjb2RlLCBvcHRpb25zLCBvcGVuaW5nRnJhZ21lbnQuZW5kKTtcbiAgICAgICAgY2xvc2luZ0ZyYWdtZW50LnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmVuZGVyQXV0b21hdGljTW9kZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgc25pcHBldHM6IHsgZ2V0UHJvcGVydHlBY2Nlc3MgfSwgdXNlT3JpZ2luYWxOYW1lIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCB7IGNsb3NpbmdGcmFnbWVudCwgZmFjdG9yeVZhcmlhYmxlLCBvcGVuaW5nRnJhZ21lbnQsIHN0YXJ0IH0gPSB0aGlzO1xuICAgICAgICBvcGVuaW5nRnJhZ21lbnQucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICBjb2RlLnByZXBlbmRSaWdodChzdGFydCwgYC8qI19fUFVSRV9fKi8ke2ZhY3RvcnlWYXJpYWJsZS5nZXROYW1lKGdldFByb3BlcnR5QWNjZXNzLCB1c2VPcmlnaW5hbE5hbWUpfShgKTtcbiAgICAgICAgY29uc3QgeyBmaXJzdENoaWxkLCBoYXNNdWx0aXBsZUNoaWxkcmVuLCBjaGlsZHJlbkVuZCB9ID0gdGhpcy5yZW5kZXJDaGlsZHJlbihjb2RlLCBvcHRpb25zLCBvcGVuaW5nRnJhZ21lbnQuZW5kKTtcbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGNvZGUucHJlcGVuZFJpZ2h0KGZpcnN0Q2hpbGQuc3RhcnQsIGB7IGNoaWxkcmVuOiAke2hhc011bHRpcGxlQ2hpbGRyZW4gPyAnWycgOiAnJ31gKTtcbiAgICAgICAgICAgIGlmIChoYXNNdWx0aXBsZUNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgY29kZS5hcHBlbmRMZWZ0KGNsb3NpbmdGcmFnbWVudC5zdGFydCwgJ10nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGUuYXBwZW5kTGVmdChjaGlsZHJlbkVuZCwgJyB9Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2RlLmFwcGVuZExlZnQob3BlbmluZ0ZyYWdtZW50LmVuZCwgJywge30nKTtcbiAgICAgICAgfVxuICAgICAgICBjbG9zaW5nRnJhZ21lbnQucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuY2xhc3MgSlNYTWVtYmVyRXhwcmVzc2lvbiBleHRlbmRzIE5vZGVCYXNlIHtcbn1cblxuY2xhc3MgSlNYTmFtZXNwYWNlZE5hbWUgZXh0ZW5kcyBOb2RlQmFzZSB7XG59XG5cbmNsYXNzIEpTWE9wZW5pbmdFbGVtZW50IGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zLCB7IGpzeE1vZGUgPSB0aGlzLnNjb3BlLmNvbnRleHQub3B0aW9ucy5qc3gubW9kZSB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5uYW1lLnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGUucmVuZGVyKGNvZGUsIG9wdGlvbnMsIHsganN4TW9kZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgSlNYT3BlbmluZ0ZyYWdtZW50IGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mcmFnbWVudFZhcmlhYmxlID0gbnVsbDtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICBpZiAoIXRoaXMuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGpzeCA9IHRoaXMuc2NvcGUuY29udGV4dC5vcHRpb25zLmpzeDtcbiAgICAgICAgICAgIGlmIChqc3gubW9kZSA9PT0gJ2F1dG9tYXRpYycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50ID0gJ0ZyYWdtZW50JztcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50VmFyaWFibGUgPSBnZXRBbmRJbmNsdWRlRmFjdG9yeVZhcmlhYmxlKCdGcmFnbWVudCcsIGZhbHNlLCBqc3guanN4SW1wb3J0U291cmNlLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZnJhZ21lbnQsIGltcG9ydFNvdXJjZSwgbW9kZSB9ID0ganN4O1xuICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudFZhcmlhYmxlID0gZ2V0QW5kSW5jbHVkZUZhY3RvcnlWYXJpYWJsZShmcmFnbWVudCwgbW9kZSA9PT0gJ3ByZXNlcnZlJywgaW1wb3J0U291cmNlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgbW9kZSB9ID0gdGhpcy5zY29wZS5jb250ZXh0Lm9wdGlvbnMuanN4O1xuICAgICAgICBpZiAobW9kZSAhPT0gJ3ByZXNlcnZlJykge1xuICAgICAgICAgICAgY29uc3QgeyBzbmlwcGV0czogeyBnZXRQcm9wZXJ0eUFjY2VzcyB9LCB1c2VPcmlnaW5hbE5hbWUgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBbLCAuLi5uZXN0ZWRGcmFnbWVudF0gPSB0aGlzLmZyYWdtZW50LnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IFtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50VmFyaWFibGUuZ2V0TmFtZShnZXRQcm9wZXJ0eUFjY2VzcywgdXNlT3JpZ2luYWxOYW1lKSxcbiAgICAgICAgICAgICAgICAuLi5uZXN0ZWRGcmFnbWVudFxuICAgICAgICAgICAgXS5qb2luKCcuJyk7XG4gICAgICAgICAgICBjb2RlLnVwZGF0ZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgZnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBKU1hTcHJlYWRDaGlsZCBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlci5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgbW9kZSB9ID0gdGhpcy5zY29wZS5jb250ZXh0Lm9wdGlvbnMuanN4O1xuICAgICAgICBpZiAobW9kZSAhPT0gJ3ByZXNlcnZlJykge1xuICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUodGhpcy5zdGFydCwgdGhpcy5leHByZXNzaW9uLnN0YXJ0LCAnLi4uJywgeyBjb250ZW50T25seTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMuZXhwcmVzc2lvbi5lbmQsIHRoaXMuZW5kLCAnJywgeyBjb250ZW50T25seTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgSlNYVGV4dCBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICByZW5kZXIoY29kZSkge1xuICAgICAgICBjb25zdCB7IG1vZGUgfSA9IHRoaXMuc2NvcGUuY29udGV4dC5vcHRpb25zLmpzeDtcbiAgICAgICAgaWYgKG1vZGUgIT09ICdwcmVzZXJ2ZScpIHtcbiAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCBKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlKSwge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRPbmx5OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgTGFiZWxlZFN0YXRlbWVudCBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgeyBicm9rZW5GbG93LCBpbmNsdWRlZExhYmVscyB9ID0gY29udGV4dDtcbiAgICAgICAgY29udGV4dC5pZ25vcmUubGFiZWxzLmFkZCh0aGlzLmxhYmVsLm5hbWUpO1xuICAgICAgICBjb250ZXh0LmluY2x1ZGVkTGFiZWxzID0gbmV3IFNldCgpO1xuICAgICAgICBsZXQgYm9keUhhc0VmZmVjdHMgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuYm9keS5oYXNFZmZlY3RzKGNvbnRleHQpKSB7XG4gICAgICAgICAgICBib2R5SGFzRWZmZWN0cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0Lmlnbm9yZS5sYWJlbHMuZGVsZXRlKHRoaXMubGFiZWwubmFtZSk7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5pbmNsdWRlZExhYmVscy5oYXModGhpcy5sYWJlbC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuaW5jbHVkZWRMYWJlbHMuZGVsZXRlKHRoaXMubGFiZWwubmFtZSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gYnJva2VuRmxvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmluY2x1ZGVkTGFiZWxzID0gbmV3IFNldChbLi4uaW5jbHVkZWRMYWJlbHMsIC4uLmNvbnRleHQuaW5jbHVkZWRMYWJlbHNdKTtcbiAgICAgICAgcmV0dXJuIGJvZHlIYXNFZmZlY3RzO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IGJyb2tlbkZsb3csIGluY2x1ZGVkTGFiZWxzIH0gPSBjb250ZXh0O1xuICAgICAgICBjb250ZXh0LmluY2x1ZGVkTGFiZWxzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmJvZHkuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIGlmIChpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSB8fCBjb250ZXh0LmluY2x1ZGVkTGFiZWxzLmhhcyh0aGlzLmxhYmVsLm5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsLmluY2x1ZGUoKTtcbiAgICAgICAgICAgIGNvbnRleHQuaW5jbHVkZWRMYWJlbHMuZGVsZXRlKHRoaXMubGFiZWwubmFtZSk7XG4gICAgICAgICAgICBjb250ZXh0LmJyb2tlbkZsb3cgPSBicm9rZW5GbG93O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuaW5jbHVkZWRMYWJlbHMgPSBuZXcgU2V0KFsuLi5pbmNsdWRlZExhYmVscywgLi4uY29udGV4dC5pbmNsdWRlZExhYmVsc10pO1xuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5sYWJlbC5pbmNsdWRlZCkge1xuICAgICAgICAgICAgdGhpcy5sYWJlbC5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2RlLnJlbW92ZSh0aGlzLnN0YXJ0LCBmaW5kTm9uV2hpdGVTcGFjZShjb2RlLm9yaWdpbmFsLCBmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZS5vcmlnaW5hbCwgJzonLCB0aGlzLmxhYmVsLmVuZCkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2R5LnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICB9XG59XG5cbmNsYXNzIExvZ2ljYWxFeHByZXNzaW9uIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyBXZSBjb2xsZWN0IGRlb3B0aW1pemF0aW9uIGluZm9ybWF0aW9uIGlmIHVzZWRCcmFuY2ggIT09IG51bGxcbiAgICAgICAgdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZCA9IFtdO1xuICAgICAgICB0aGlzLnVzZWRCcmFuY2ggPSBudWxsO1xuICAgIH1cbiAgICAvL3ByaXZhdGUgaXNCcmFuY2hSZXNvbHV0aW9uQW5hbHlzZWQgPSBmYWxzZTtcbiAgICBnZXQgaXNCcmFuY2hSZXNvbHV0aW9uQW5hbHlzZWQoKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYWdTZXQodGhpcy5mbGFncywgNjU1MzYgLyogRmxhZy5pc0JyYW5jaFJlc29sdXRpb25BbmFseXNlZCAqLyk7XG4gICAgfVxuICAgIHNldCBpc0JyYW5jaFJlc29sdXRpb25BbmFseXNlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZsYWdzID0gc2V0RmxhZyh0aGlzLmZsYWdzLCA2NTUzNiAvKiBGbGFnLmlzQnJhbmNoUmVzb2x1dGlvbkFuYWx5c2VkICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoLCByZWN1cnNpb25UcmFja2VyKSB7XG4gICAgICAgIHRoaXMubGVmdC5kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aChpbnRlcmFjdGlvbiwgcGF0aCwgcmVjdXJzaW9uVHJhY2tlcik7XG4gICAgICAgIHRoaXMucmlnaHQuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgIH1cbiAgICBkZW9wdGltaXplQ2FjaGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnVzZWRCcmFuY2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHVudXNlZEJyYW5jaCA9IHRoaXMudXNlZEJyYW5jaCA9PT0gdGhpcy5sZWZ0ID8gdGhpcy5yaWdodCA6IHRoaXMubGVmdDtcbiAgICAgICAgICAgIHRoaXMudXNlZEJyYW5jaCA9IG51bGw7XG4gICAgICAgICAgICB1bnVzZWRCcmFuY2guZGVvcHRpbWl6ZVBhdGgoVU5LTk9XTl9QQVRIKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2NvcGU6IHsgY29udGV4dCB9LCBleHByZXNzaW9uc1RvQmVEZW9wdGltaXplZCB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQgPSBFTVBUWV9BUlJBWTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXhwcmVzc2lvbiBvZiBleHByZXNzaW9uc1RvQmVEZW9wdGltaXplZCkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24uZGVvcHRpbWl6ZUNhY2hlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXF1ZXN0IGFub3RoZXIgcGFzcyBiZWNhdXNlIHdlIG5lZWQgdG8gZW5zdXJlIFwiaW5jbHVkZVwiIHJ1bnMgYWdhaW4gaWZcbiAgICAgICAgICAgIC8vIGl0IGlzIHJlbmRlcmVkXG4gICAgICAgICAgICBjb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZW9wdGltaXplUGF0aChwYXRoKSB7XG4gICAgICAgIGNvbnN0IHVzZWRCcmFuY2ggPSB0aGlzLmdldFVzZWRCcmFuY2goKTtcbiAgICAgICAgaWYgKHVzZWRCcmFuY2gpIHtcbiAgICAgICAgICAgIHVzZWRCcmFuY2guZGVvcHRpbWl6ZVBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxlZnQuZGVvcHRpbWl6ZVBhdGgocGF0aCk7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0LmRlb3B0aW1pemVQYXRoKHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgY29uc3QgdXNlZEJyYW5jaCA9IHRoaXMuZ2V0VXNlZEJyYW5jaCgpO1xuICAgICAgICBpZiAoIXVzZWRCcmFuY2gpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blZhbHVlO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkLnB1c2gob3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHVzZWRCcmFuY2guZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbik7XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgY29uc3QgdXNlZEJyYW5jaCA9IHRoaXMuZ2V0VXNlZEJyYW5jaCgpO1xuICAgICAgICBpZiAoIXVzZWRCcmFuY2gpXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5ldyBNdWx0aUV4cHJlc3Npb24oW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbilbMF0sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbilbMF1cbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZC5wdXNoKG9yaWdpbik7XG4gICAgICAgIHJldHVybiB1c2VkQnJhbmNoLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMubGVmdC5oYXNFZmZlY3RzKGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZXRVc2VkQnJhbmNoKCkgIT09IHRoaXMubGVmdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQuaGFzRWZmZWN0cyhjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHVzZWRCcmFuY2ggPSB0aGlzLmdldFVzZWRCcmFuY2goKTtcbiAgICAgICAgaWYgKCF1c2VkQnJhbmNoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMubGVmdC5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0Lmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVzZWRCcmFuY2guaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB1c2VkQnJhbmNoID0gdGhpcy5nZXRVc2VkQnJhbmNoKCk7XG4gICAgICAgIGlmIChpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSB8fFxuICAgICAgICAgICAgKHVzZWRCcmFuY2ggPT09IHRoaXMucmlnaHQgJiYgdGhpcy5sZWZ0LnNob3VsZEJlSW5jbHVkZWQoY29udGV4dCkpIHx8XG4gICAgICAgICAgICAhdXNlZEJyYW5jaCkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICAgICAgdGhpcy5yaWdodC5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVzZWRCcmFuY2guaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQW5ub3RhdGlvbnMoY29kZSkge1xuICAgICAgICB0aGlzLmxlZnQucmVtb3ZlQW5ub3RhdGlvbnMoY29kZSk7XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zLCB7IGlzQ2FsbGVlT2ZSZW5kZXJlZFBhcmVudCwgcHJldmVudEFTSSwgcmVuZGVyZWRQYXJlbnRUeXBlLCByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudCB9ID0gQkxBTkspIHtcbiAgICAgICAgaWYgKCF0aGlzLmxlZnQuaW5jbHVkZWQgfHwgIXRoaXMucmlnaHQuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9yUG9zID0gZmluZEZpcnN0T2NjdXJyZW5jZU91dHNpZGVDb21tZW50KGNvZGUub3JpZ2luYWwsIHRoaXMub3BlcmF0b3IsIHRoaXMubGVmdC5lbmQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdmVQb3MgPSBmaW5kTm9uV2hpdGVTcGFjZShjb2RlLm9yaWdpbmFsLCBvcGVyYXRvclBvcyArIDIpO1xuICAgICAgICAgICAgICAgIGNvZGUucmVtb3ZlKHRoaXMuc3RhcnQsIHJlbW92ZVBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZlbnRBU0kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGluZUJyZWFrcyhjb2RlLCByZW1vdmVQb3MsIHRoaXMucmlnaHQuc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQucmVtb3ZlQW5ub3RhdGlvbnMoY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlLnJlbW92ZShmaW5kTGFzdFdoaXRlU3BhY2VSZXZlcnNlKGNvZGUub3JpZ2luYWwsIHRoaXMubGVmdC5lbmQsIG9wZXJhdG9yUG9zKSwgdGhpcy5lbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nZXRVc2VkQnJhbmNoKCkucmVuZGVyKGNvZGUsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBpc0NhbGxlZU9mUmVuZGVyZWRQYXJlbnQsXG4gICAgICAgICAgICAgICAgcHJldmVudEFTSSxcbiAgICAgICAgICAgICAgICByZW5kZXJlZFBhcmVudFR5cGU6IHJlbmRlcmVkUGFyZW50VHlwZSB8fCB0aGlzLnBhcmVudC50eXBlLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50OiByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudCB8fCB0aGlzLnBhcmVudC50eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGVmdC5yZW5kZXIoY29kZSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgIHByZXZlbnRBU0ksXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yaWdodC5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VXNlZEJyYW5jaCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQnJhbmNoUmVzb2x1dGlvbkFuYWx5c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmlzQnJhbmNoUmVzb2x1dGlvbkFuYWx5c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRWYWx1ZSA9IHRoaXMubGVmdC5nZXRMaXRlcmFsVmFsdWVBdFBhdGgoRU1QVFlfUEFUSCwgU0hBUkVEX1JFQ1VSU0lPTl9UUkFDS0VSLCB0aGlzKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGVmdFZhbHVlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51c2VkQnJhbmNoID1cbiAgICAgICAgICAgICAgICAgICAgKHRoaXMub3BlcmF0b3IgPT09ICd8fCcgJiYgbGVmdFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMub3BlcmF0b3IgPT09ICcmJicgJiYgIWxlZnRWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPz8nICYmIGxlZnRWYWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmxlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy51c2VkQnJhbmNoO1xuICAgIH1cbn1cblxuY2xhc3MgTmV3RXhwcmVzc2lvbiBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICBmb3IgKGNvbnN0IGFyZ3VtZW50IG9mIHRoaXMuYXJndW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnQuaGFzRWZmZWN0cyhjb250ZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbm5vdGF0aW9uUHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5jYWxsZWUuaGFzRWZmZWN0cyhjb250ZXh0KSB8fFxuICAgICAgICAgICAgdGhpcy5jYWxsZWUuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoRU1QVFlfUEFUSCwgdGhpcy5pbnRlcmFjdGlvbiwgY29udGV4dCkpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCB7IHR5cGUgfSkge1xuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAwIHx8IHR5cGUgIT09IElOVEVSQUNUSU9OX0FDQ0VTU0VEO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgaWYgKGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgICAgICBzdXBlci5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jYWxsZWUuaW5jbHVkZShjb250ZXh0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsZWUuaW5jbHVkZUNhbGxBcmd1bWVudHMoY29udGV4dCwgdGhpcy5hcmd1bWVudHMpO1xuICAgIH1cbiAgICBpbml0aWFsaXNlKCkge1xuICAgICAgICBzdXBlci5pbml0aWFsaXNlKCk7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb24gPSB7XG4gICAgICAgICAgICBhcmdzOiBbbnVsbCwgLi4udGhpcy5hcmd1bWVudHNdLFxuICAgICAgICAgICAgdHlwZTogSU5URVJBQ1RJT05fQ0FMTEVELFxuICAgICAgICAgICAgd2l0aE5ldzogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5hbm5vdGF0aW9ucyAmJlxuICAgICAgICAgICAgdGhpcy5zY29wZS5jb250ZXh0Lm9wdGlvbnMudHJlZXNoYWtlLmFubm90YXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmFubm90YXRpb25QdXJlID0gdGhpcy5hbm5vdGF0aW9ucy5zb21lKGNvbW1lbnQgPT4gY29tbWVudC50eXBlID09PSAncHVyZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY2FsbGVlLnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgcmVuZGVyQ2FsbEFyZ3VtZW50cyhjb2RlLCBvcHRpb25zLCB0aGlzKTtcbiAgICB9XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbGxlZS5kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCh0aGlzLmludGVyYWN0aW9uLCBFTVBUWV9QQVRILCBTSEFSRURfUkVDVVJTSU9OX1RSQUNLRVIpO1xuICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpO1xuICAgIH1cbn1cblxuY2xhc3MgT2JqZWN0RXhwcmVzc2lvbiBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5vYmplY3RFbnRpdHkgPSBudWxsO1xuICAgIH1cbiAgICBkZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aChpbnRlcmFjdGlvbiwgcGF0aCwgcmVjdXJzaW9uVHJhY2tlcikge1xuICAgICAgICB0aGlzLmdldE9iamVjdEVudGl0eSgpLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoLCByZWN1cnNpb25UcmFja2VyKTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZUNhY2hlKCkge1xuICAgICAgICB0aGlzLmdldE9iamVjdEVudGl0eSgpLmRlb3B0aW1pemVBbGxQcm9wZXJ0aWVzKCk7XG4gICAgfVxuICAgIGRlb3B0aW1pemVQYXRoKHBhdGgpIHtcbiAgICAgICAgdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5kZW9wdGltaXplUGF0aChwYXRoKTtcbiAgICB9XG4gICAgZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5nZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKTtcbiAgICB9XG4gICAgZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0RW50aXR5KCkuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucywgeyByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudCB9ID0gQkxBTkspIHtcbiAgICAgICAgc3VwZXIucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAocmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQgPT09IEV4cHJlc3Npb25TdGF0ZW1lbnQkMSB8fFxuICAgICAgICAgICAgcmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQgPT09IEFycm93RnVuY3Rpb25FeHByZXNzaW9uJDEpIHtcbiAgICAgICAgICAgIGNvZGUuYXBwZW5kUmlnaHQodGhpcy5zdGFydCwgJygnKTtcbiAgICAgICAgICAgIGNvZGUucHJlcGVuZExlZnQodGhpcy5lbmQsICcpJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7IH1cbiAgICBnZXRPYmplY3RFbnRpdHkoKSB7XG4gICAgICAgIGlmICh0aGlzLm9iamVjdEVudGl0eSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0RW50aXR5O1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcm90b3R5cGUgPSBPQkpFQ1RfUFJPVE9UWVBFO1xuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgdGhpcy5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydHkgaW5zdGFuY2VvZiBTcHJlYWRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHsga2V5OiBVbmtub3duS2V5LCBraW5kOiAnaW5pdCcsIHByb3BlcnR5IH0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5jb21wdXRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleVZhbHVlID0gcHJvcGVydHkua2V5LmdldExpdGVyYWxWYWx1ZUF0UGF0aChFTVBUWV9QQVRILCBTSEFSRURfUkVDVVJTSU9OX1RSQUNLRVIsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5VmFsdWUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaCh7IGtleTogVW5rbm93bktleSwga2luZDogcHJvcGVydHkua2luZCwgcHJvcGVydHkgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gU3RyaW5nKGtleVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgPVxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS5rZXkgaW5zdGFuY2VvZiBJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHByb3BlcnR5LmtleS5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFN0cmluZyhwcm9wZXJ0eS5rZXkudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nICYmIHByb3BlcnR5LmtpbmQgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgICAgICAgICBwcm90b3R5cGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkudmFsdWUgaW5zdGFuY2VvZiBMaXRlcmFsICYmIHByb3BlcnR5LnZhbHVlLnZhbHVlID09PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBwcm9wZXJ0eS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHsga2V5LCBraW5kOiBwcm9wZXJ0eS5raW5kLCBwcm9wZXJ0eSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMub2JqZWN0RW50aXR5ID0gbmV3IE9iamVjdEVudGl0eShwcm9wZXJ0aWVzLCBwcm90b3R5cGUpKTtcbiAgICB9XG59XG5cbmNsYXNzIFBhbmljRXJyb3IgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLnNjb3BlLmNvbnRleHQubW9kdWxlLmlkO1xuICAgICAgICAvLyBUaGlzIHNpbXVsYXRlcyB0aGUgY3VycmVudCBuZXN0ZWQgZXJyb3Igc3RydWN0dXJlLiBXZSBjb3VsZCBhbHNvIGp1c3RcbiAgICAgICAgLy8gcmVwbGFjZSBpdCB3aXRoIGEgZmxhdCBlcnJvci5cbiAgICAgICAgY29uc3QgcGFyc2VFcnJvciA9IGdldFJvbGx1cEVycm9yKGxvZ1BhcnNlRXJyb3IodGhpcy5tZXNzYWdlKSk7XG4gICAgICAgIGNvbnN0IG1vZHVsZVBhcnNlRXJyb3IgPSBsb2dNb2R1bGVQYXJzZUVycm9yKHBhcnNlRXJyb3IsIGlkKTtcbiAgICAgICAgcmV0dXJuIGVycm9yKG1vZHVsZVBhcnNlRXJyb3IpO1xuICAgIH1cbn1cblxuY2xhc3MgUGFyc2VFcnJvciBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBpbml0aWFsaXNlKCkge1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMuc2NvcGUuY29udGV4dC5tb2R1bGUuaWQ7XG4gICAgICAgIC8vIFRoaXMgc2ltdWxhdGVzIHRoZSBjdXJyZW50IG5lc3RlZCBlcnJvciBzdHJ1Y3R1cmUuIFdlIGNvdWxkIGFsc28ganVzdFxuICAgICAgICAvLyByZXBsYWNlIGl0IHdpdGggYSBmbGF0IGVycm9yLlxuICAgICAgICBjb25zdCBwYXJzZUVycm9yID0gZ2V0Um9sbHVwRXJyb3IobG9nUGFyc2VFcnJvcih0aGlzLm1lc3NhZ2UsIHBvcykpO1xuICAgICAgICBjb25zdCBtb2R1bGVQYXJzZUVycm9yID0gbG9nTW9kdWxlUGFyc2VFcnJvcihwYXJzZUVycm9yLCBpZCk7XG4gICAgICAgIHRoaXMuc2NvcGUuY29udGV4dC5lcnJvcihtb2R1bGVQYXJzZUVycm9yLCBwb3MpO1xuICAgIH1cbn1cblxuY2xhc3MgUHJpdmF0ZUlkZW50aWZpZXIgZXh0ZW5kcyBOb2RlQmFzZSB7XG59XG5cbmNsYXNzIFByb2dyYW0gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaGFzQ2FjaGVkRWZmZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNMb2dnZWRFZmZlY3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaGFzQ2FjaGVkRWZmZWN0cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQ2FjaGVkRWZmZWN0ID09PSBudWxsXG4gICAgICAgICAgICA/ICh0aGlzLmhhc0NhY2hlZEVmZmVjdCA9IHRoaXMuaGFzRWZmZWN0cyhjcmVhdGVIYXNFZmZlY3RzQ29udGV4dCgpKSlcbiAgICAgICAgICAgIDogdGhpcy5oYXNDYWNoZWRFZmZlY3Q7XG4gICAgfVxuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5ib2R5KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5oYXNFZmZlY3RzKGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NvcGUuY29udGV4dC5vcHRpb25zLmV4cGVyaW1lbnRhbExvZ1NpZGVFZmZlY3RzICYmICF0aGlzLmhhc0xvZ2dlZEVmZmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc0xvZ2dlZEVmZmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY29kZSwgbG9nLCBtb2R1bGUgfSA9IHRoaXMuc2NvcGUuY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgbG9nKExPR0xFVkVMX0lORk8sIGxvZ0ZpcnN0U2lkZUVmZmVjdChjb2RlLCBtb2R1bGUuaWQsIGxvY2F0ZShjb2RlLCBub2RlLnN0YXJ0LCB7IG9mZnNldExpbmU6IDEgfSkpLCBub2RlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmhhc0NhY2hlZEVmZmVjdCA9IHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMuYm9keSkge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5IHx8IG5vZGUuc2hvdWxkQmVJbmNsdWRlZChjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIG5vZGUuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGlzZSgpO1xuICAgICAgICBpZiAodGhpcy5pbnZhbGlkQW5ub3RhdGlvbnMpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgc3RhcnQsIGVuZCwgdHlwZSB9IG9mIHRoaXMuaW52YWxpZEFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY29wZS5jb250ZXh0Lm1hZ2ljU3RyaW5nLnJlbW92ZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3B1cmUnIHx8IHR5cGUgPT09ICdub1NpZGVFZmZlY3RzJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQubG9nKExPR0xFVkVMX1dBUk4sIGxvZ0ludmFsaWRBbm5vdGF0aW9uKHRoaXMuc2NvcGUuY29udGV4dC5jb2RlLnNsaWNlKHN0YXJ0LCBlbmQpLCB0aGlzLnNjb3BlLmNvbnRleHQubW9kdWxlLmlkLCB0eXBlKSwgc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgaWYgKGNvZGUub3JpZ2luYWwuc3RhcnRzV2l0aCgnIyEnKSkge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1pbihjb2RlLm9yaWdpbmFsLmluZGV4T2YoJ1xcbicpICsgMSwgdGhpcy5lbmQpO1xuICAgICAgICAgICAgY29kZS5yZW1vdmUoMCwgc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gS2VlcCBhbGwgY29uc2VjdXRpdmUgbGluZXMgdGhhdCBzdGFydCB3aXRoIGEgY29tbWVudFxuICAgICAgICAgICAgd2hpbGUgKGNvZGUub3JpZ2luYWxbc3RhcnRdID09PSAnLycgJiYgL1sqL10vLnRlc3QoY29kZS5vcmlnaW5hbFtzdGFydCArIDFdKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0TGluZUJyZWFrID0gZmluZEZpcnN0TGluZUJyZWFrT3V0c2lkZUNvbW1lbnQoY29kZS5vcmlnaW5hbC5zbGljZShzdGFydCwgdGhpcy5ib2R5WzBdLnN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0TGluZUJyZWFrWzBdID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhcnQgKz0gZmlyc3RMaW5lQnJlYWtbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW5kZXJTdGF0ZW1lbnRMaXN0KHRoaXMuYm9keSwgY29kZSwgc3RhcnQsIHRoaXMuZW5kLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHsgfVxufVxuXG5jbGFzcyBQcm9wZXJ0eSBleHRlbmRzIE1ldGhvZEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmRlY2xhcmF0aW9uSW5pdCA9IG51bGw7XG4gICAgfVxuICAgIC8vZGVjbGFyZSBtZXRob2Q6IGJvb2xlYW47XG4gICAgZ2V0IG1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhZ1NldCh0aGlzLmZsYWdzLCAyNjIxNDQgLyogRmxhZy5tZXRob2QgKi8pO1xuICAgIH1cbiAgICBzZXQgbWV0aG9kKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBzZXRGbGFnKHRoaXMuZmxhZ3MsIDI2MjE0NCAvKiBGbGFnLm1ldGhvZCAqLywgdmFsdWUpO1xuICAgIH1cbiAgICAvL2RlY2xhcmUgc2hvcnRoYW5kOiBib29sZWFuO1xuICAgIGdldCBzaG9ydGhhbmQoKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYWdTZXQodGhpcy5mbGFncywgNTI0Mjg4IC8qIEZsYWcuc2hvcnRoYW5kICovKTtcbiAgICB9XG4gICAgc2V0IHNob3J0aGFuZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZsYWdzID0gc2V0RmxhZyh0aGlzLmZsYWdzLCA1MjQyODggLyogRmxhZy5zaG9ydGhhbmQgKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjbGFyZShraW5kLCBpbml0KSB7XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25Jbml0ID0gaW5pdDtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuZGVjbGFyZShraW5kLCBVTktOT1dOX0VYUFJFU1NJT04pO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICBjb25zdCBwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0cyA9IHRoaXMuc2NvcGUuY29udGV4dC5vcHRpb25zLnRyZWVzaGFrZS5wcm9wZXJ0eVJlYWRTaWRlRWZmZWN0cztcbiAgICAgICAgcmV0dXJuICgodGhpcy5wYXJlbnQudHlwZSA9PT0gJ09iamVjdFBhdHRlcm4nICYmIHByb3BlcnR5UmVhZFNpZGVFZmZlY3RzID09PSAnYWx3YXlzJykgfHxcbiAgICAgICAgICAgIHRoaXMua2V5Lmhhc0VmZmVjdHMoY29udGV4dCkgfHxcbiAgICAgICAgICAgIHRoaXMudmFsdWUuaGFzRWZmZWN0cyhjb250ZXh0KSk7XG4gICAgfVxuICAgIG1hcmtEZWNsYXJhdGlvblJlYWNoZWQoKSB7XG4gICAgICAgIHRoaXMudmFsdWUubWFya0RlY2xhcmF0aW9uUmVhY2hlZCgpO1xuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuc2hvcnRoYW5kKSB7XG4gICAgICAgICAgICB0aGlzLmtleS5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZS5yZW5kZXIoY29kZSwgb3B0aW9ucywgeyBpc1Nob3J0aGFuZFByb3BlcnR5OiB0aGlzLnNob3J0aGFuZCB9KTtcbiAgICB9XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5kZWNsYXJhdGlvbkluaXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25Jbml0LmRlb3B0aW1pemVQYXRoKFtVbmtub3duS2V5LCBVbmtub3duS2V5XSk7XG4gICAgICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBQcm9wZXJ0eURlZmluaXRpb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgZ2V0IGNvbXB1dGVkKCkge1xuICAgICAgICByZXR1cm4gaXNGbGFnU2V0KHRoaXMuZmxhZ3MsIDEwMjQgLyogRmxhZy5jb21wdXRlZCAqLyk7XG4gICAgfVxuICAgIHNldCBjb21wdXRlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZsYWdzID0gc2V0RmxhZyh0aGlzLmZsYWdzLCAxMDI0IC8qIEZsYWcuY29tcHV0ZWQgKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIpIHtcbiAgICAgICAgdGhpcy52YWx1ZT8uZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgIH1cbiAgICBkZW9wdGltaXplUGF0aChwYXRoKSB7XG4gICAgICAgIHRoaXMudmFsdWU/LmRlb3B0aW1pemVQYXRoKHBhdGgpO1xuICAgIH1cbiAgICBnZXRMaXRlcmFsVmFsdWVBdFBhdGgocGF0aCwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlXG4gICAgICAgICAgICA/IHRoaXMudmFsdWUuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbilcbiAgICAgICAgICAgIDogVW5rbm93blZhbHVlO1xuICAgIH1cbiAgICBnZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgcmVjdXJzaW9uVHJhY2tlciwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlXG4gICAgICAgICAgICA/IHRoaXMudmFsdWUuZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgocGF0aCwgaW50ZXJhY3Rpb24sIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbilcbiAgICAgICAgICAgIDogVU5LTk9XTl9SRVRVUk5fRVhQUkVTU0lPTjtcbiAgICB9XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5rZXkuaGFzRWZmZWN0cyhjb250ZXh0KSB8fFxuICAgICAgICAgICAgKHRoaXMuc3RhdGljICYmICEhdGhpcy52YWx1ZT8uaGFzRWZmZWN0cyhjb250ZXh0KSkgfHxcbiAgICAgICAgICAgIGNoZWNrRWZmZWN0Rm9yTm9kZXModGhpcy5kZWNvcmF0b3JzLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIGhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAhdGhpcy52YWx1ZSB8fCB0aGlzLnZhbHVlLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7IH1cbn1cblxuY2xhc3MgUmV0dXJuU3RhdGVtZW50IGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICBpZiAoIWNvbnRleHQuaWdub3JlLnJldHVybllpZWxkIHx8IHRoaXMuYXJndW1lbnQ/Lmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmFyZ3VtZW50Py5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gdHJ1ZTtcbiAgICB9XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGlzZSgpO1xuICAgICAgICB0aGlzLnNjb3BlLmFkZFJldHVybkV4cHJlc3Npb24odGhpcy5hcmd1bWVudCB8fCBVTktOT1dOX0VYUFJFU1NJT04pO1xuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5hcmd1bWVudCkge1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudC5yZW5kZXIoY29kZSwgb3B0aW9ucywgeyBwcmV2ZW50QVNJOiB0cnVlIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJndW1lbnQuc3RhcnQgPT09IHRoaXMuc3RhcnQgKyA2IC8qICdyZXR1cm4nLmxlbmd0aCAqLykge1xuICAgICAgICAgICAgICAgIGNvZGUucHJlcGVuZExlZnQodGhpcy5zdGFydCArIDYsICcgJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFNlcXVlbmNlRXhwcmVzc2lvbiBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBkZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aChpbnRlcmFjdGlvbiwgcGF0aCwgcmVjdXJzaW9uVHJhY2tlcikge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zW3RoaXMuZXhwcmVzc2lvbnMubGVuZ3RoIC0gMV0uZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgIH1cbiAgICBkZW9wdGltaXplUGF0aChwYXRoKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnNbdGhpcy5leHByZXNzaW9ucy5sZW5ndGggLSAxXS5kZW9wdGltaXplUGF0aChwYXRoKTtcbiAgICB9XG4gICAgZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIsIG9yaWdpbikge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uc1t0aGlzLmV4cHJlc3Npb25zLmxlbmd0aCAtIDFdLmdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIHRoaXMuZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uLmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uc1t0aGlzLmV4cHJlc3Npb25zLmxlbmd0aCAtIDFdLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHBhdGgsIGludGVyYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgbGFzdEV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb25zW3RoaXMuZXhwcmVzc2lvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGZvciAoY29uc3QgZXhwcmVzc2lvbiBvZiB0aGlzLmV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkgfHxcbiAgICAgICAgICAgICAgICAoZXhwcmVzc2lvbiA9PT0gbGFzdEV4cHJlc3Npb24gJiYgISh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIEV4cHJlc3Npb25TdGF0ZW1lbnQpKSB8fFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24uc2hvdWxkQmVJbmNsdWRlZChjb250ZXh0KSlcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUFubm90YXRpb25zKGNvZGUpIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uc1swXS5yZW1vdmVBbm5vdGF0aW9ucyhjb2RlKTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMsIHsgcmVuZGVyZWRQYXJlbnRUeXBlLCBpc0NhbGxlZU9mUmVuZGVyZWRQYXJlbnQsIHByZXZlbnRBU0kgfSA9IEJMQU5LKSB7XG4gICAgICAgIGxldCBpbmNsdWRlZE5vZGVzID0gMDtcbiAgICAgICAgbGV0IGxhc3RTZXBhcmF0b3JQb3MgPSBudWxsO1xuICAgICAgICBjb25zdCBsYXN0Tm9kZSA9IHRoaXMuZXhwcmVzc2lvbnNbdGhpcy5leHByZXNzaW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgZm9yIChjb25zdCB7IG5vZGUsIHNlcGFyYXRvciwgc3RhcnQsIGVuZCB9IG9mIGdldENvbW1hU2VwYXJhdGVkTm9kZXNXaXRoQm91bmRhcmllcyh0aGlzLmV4cHJlc3Npb25zLCBjb2RlLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCkpIHtcbiAgICAgICAgICAgIGlmICghbm9kZS5pbmNsdWRlZCkge1xuICAgICAgICAgICAgICAgIHRyZWVzaGFrZU5vZGUobm9kZSwgY29kZSwgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmNsdWRlZE5vZGVzKys7XG4gICAgICAgICAgICBsYXN0U2VwYXJhdG9yUG9zID0gc2VwYXJhdG9yO1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVkTm9kZXMgPT09IDEgJiYgcHJldmVudEFTSSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUxpbmVCcmVha3MoY29kZSwgc3RhcnQsIG5vZGUuc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluY2x1ZGVkTm9kZXMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRUeXBlID0gcmVuZGVyZWRQYXJlbnRUeXBlIHx8IHRoaXMucGFyZW50LnR5cGU7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW5kZXIoY29kZSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICBpc0NhbGxlZU9mUmVuZGVyZWRQYXJlbnQ6IGlzQ2FsbGVlT2ZSZW5kZXJlZFBhcmVudCAmJiBub2RlID09PSBsYXN0Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRQYXJlbnRUeXBlOiBwYXJlbnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudDogcGFyZW50VHlwZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RTZXBhcmF0b3JQb3MpIHtcbiAgICAgICAgICAgIGNvZGUucmVtb3ZlKGxhc3RTZXBhcmF0b3JQb3MsIHRoaXMuZW5kKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgU3VwZXIgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgYmluZCgpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZSA9IHRoaXMuc2NvcGUuZmluZFZhcmlhYmxlKCd0aGlzJyk7XG4gICAgfVxuICAgIGRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoLCByZWN1cnNpb25UcmFja2VyKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGUuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoaW50ZXJhY3Rpb24sIHBhdGgsIHJlY3Vyc2lvblRyYWNrZXIpO1xuICAgIH1cbiAgICBkZW9wdGltaXplUGF0aChwYXRoKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGUuZGVvcHRpbWl6ZVBhdGgocGF0aCk7XG4gICAgfVxuICAgIGluY2x1ZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbmNsdWRlZCkge1xuICAgICAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQuaW5jbHVkZVZhcmlhYmxlSW5Nb2R1bGUodGhpcy52YXJpYWJsZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFN3aXRjaENhc2UgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLnRlc3Q/Lmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMuY29uc2VxdWVudCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuYnJva2VuRmxvdylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChub2RlLmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRlc3Q/LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5jb25zZXF1ZW50KSB7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkgfHwgbm9kZS5zaG91bGRCZUluY2x1ZGVkKGNvbnRleHQpKVxuICAgICAgICAgICAgICAgIG5vZGUuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMsIG5vZGVSZW5kZXJPcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnNlcXVlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGVzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGVzdC5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZXN0RW5kID0gdGhpcy50ZXN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLnRlc3QuZW5kXG4gICAgICAgICAgICAgICAgOiBmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZS5vcmlnaW5hbCwgJ2RlZmF1bHQnLCB0aGlzLnN0YXJ0KSArIDc7XG4gICAgICAgICAgICBjb25zdCBjb25zZXF1ZW50U3RhcnQgPSBmaW5kRmlyc3RPY2N1cnJlbmNlT3V0c2lkZUNvbW1lbnQoY29kZS5vcmlnaW5hbCwgJzonLCB0ZXN0RW5kKSArIDE7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZW1lbnRMaXN0KHRoaXMuY29uc2VxdWVudCwgY29kZSwgY29uc2VxdWVudFN0YXJ0LCBub2RlUmVuZGVyT3B0aW9ucy5lbmQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufVxuU3dpdGNoQ2FzZS5wcm90b3R5cGUubmVlZHNCb3VuZGFyaWVzID0gdHJ1ZTtcblxuY2xhc3MgU3dpdGNoU3RhdGVtZW50IGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNyZWF0ZVNjb3BlKHBhcmVudFNjb3BlKSB7XG4gICAgICAgIHRoaXMucGFyZW50U2NvcGUgPSBwYXJlbnRTY29wZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IG5ldyBCbG9ja1Njb3BlKHBhcmVudFNjb3BlKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2NyaW1pbmFudC5oYXNFZmZlY3RzKGNvbnRleHQpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IHsgYnJva2VuRmxvdywgaGFzQnJlYWssIGlnbm9yZSB9ID0gY29udGV4dDtcbiAgICAgICAgY29uc3QgeyBicmVha3MgfSA9IGlnbm9yZTtcbiAgICAgICAgaWdub3JlLmJyZWFrcyA9IHRydWU7XG4gICAgICAgIGNvbnRleHQuaGFzQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgbGV0IG9ubHlIYXNCcm9rZW5GbG93ID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBzd2l0Y2hDYXNlIG9mIHRoaXMuY2FzZXMpIHtcbiAgICAgICAgICAgIGlmIChzd2l0Y2hDYXNlLmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBvbmx5SGFzQnJva2VuRmxvdyAmJj0gY29udGV4dC5icm9rZW5GbG93ICYmICFjb250ZXh0Lmhhc0JyZWFrO1xuICAgICAgICAgICAgY29udGV4dC5oYXNCcmVhayA9IGZhbHNlO1xuICAgICAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gYnJva2VuRmxvdztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWZhdWx0Q2FzZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gb25seUhhc0Jyb2tlbkZsb3c7XG4gICAgICAgIH1cbiAgICAgICAgaWdub3JlLmJyZWFrcyA9IGJyZWFrcztcbiAgICAgICAgY29udGV4dC5oYXNCcmVhayA9IGhhc0JyZWFrO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpIHtcbiAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzY3JpbWluYW50LmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICBjb25zdCB7IGJyb2tlbkZsb3csIGhhc0JyZWFrIH0gPSBjb250ZXh0O1xuICAgICAgICBjb250ZXh0Lmhhc0JyZWFrID0gZmFsc2U7XG4gICAgICAgIGxldCBvbmx5SGFzQnJva2VuRmxvdyA9IHRydWU7XG4gICAgICAgIGxldCBpc0Nhc2VJbmNsdWRlZCA9IGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5IHx8XG4gICAgICAgICAgICAodGhpcy5kZWZhdWx0Q2FzZSAhPT0gbnVsbCAmJiB0aGlzLmRlZmF1bHRDYXNlIDwgdGhpcy5jYXNlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgZm9yIChsZXQgY2FzZUluZGV4ID0gdGhpcy5jYXNlcy5sZW5ndGggLSAxOyBjYXNlSW5kZXggPj0gMDsgY2FzZUluZGV4LS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHN3aXRjaENhc2UgPSB0aGlzLmNhc2VzW2Nhc2VJbmRleF07XG4gICAgICAgICAgICBpZiAoc3dpdGNoQ2FzZS5pbmNsdWRlZCkge1xuICAgICAgICAgICAgICAgIGlzQ2FzZUluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNDYXNlSW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNFZmZlY3RzQ29udGV4dCA9IGNyZWF0ZUhhc0VmZmVjdHNDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgaGFzRWZmZWN0c0NvbnRleHQuaWdub3JlLmJyZWFrcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaXNDYXNlSW5jbHVkZWQgPSBzd2l0Y2hDYXNlLmhhc0VmZmVjdHMoaGFzRWZmZWN0c0NvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQ2FzZUluY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoQ2FzZS5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgICAgICAgICBvbmx5SGFzQnJva2VuRmxvdyAmJj0gY29udGV4dC5icm9rZW5GbG93ICYmICFjb250ZXh0Lmhhc0JyZWFrO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuaGFzQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJyb2tlbkZsb3cgPSBicm9rZW5GbG93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb25seUhhc0Jyb2tlbkZsb3cgPSBicm9rZW5GbG93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Nhc2VJbmNsdWRlZCAmJiB0aGlzLmRlZmF1bHRDYXNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250ZXh0LmJyb2tlbkZsb3cgPSBvbmx5SGFzQnJva2VuRmxvdztcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0Lmhhc0JyZWFrID0gaGFzQnJlYWs7XG4gICAgfVxuICAgIGluaXRpYWxpc2UoKSB7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpc2UoKTtcbiAgICAgICAgZm9yIChsZXQgY2FzZUluZGV4ID0gMDsgY2FzZUluZGV4IDwgdGhpcy5jYXNlcy5sZW5ndGg7IGNhc2VJbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYXNlc1tjYXNlSW5kZXhdLnRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRDYXNlID0gY2FzZUluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlZmF1bHRDYXNlID0gbnVsbDtcbiAgICB9XG4gICAgcGFyc2VOb2RlKGVzVHJlZU5vZGUpIHtcbiAgICAgICAgdGhpcy5kaXNjcmltaW5hbnQgPSBuZXcgKHRoaXMuc2NvcGUuY29udGV4dC5nZXROb2RlQ29uc3RydWN0b3IoZXNUcmVlTm9kZS5kaXNjcmltaW5hbnQudHlwZSkpKHRoaXMsIHRoaXMucGFyZW50U2NvcGUpLnBhcnNlTm9kZShlc1RyZWVOb2RlLmRpc2NyaW1pbmFudCk7XG4gICAgICAgIHJldHVybiBzdXBlci5wYXJzZU5vZGUoZXNUcmVlTm9kZSk7XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZGlzY3JpbWluYW50LnJlbmRlcihjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuY2FzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVuZGVyU3RhdGVtZW50TGlzdCh0aGlzLmNhc2VzLCBjb2RlLCB0aGlzLmNhc2VzWzBdLnN0YXJ0LCB0aGlzLmVuZCAtIDEsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gZXh0ZW5kcyBDYWxsRXhwcmVzc2lvbkJhc2Uge1xuICAgIGJpbmQoKSB7XG4gICAgICAgIHN1cGVyLmJpbmQoKTtcbiAgICAgICAgaWYgKHRoaXMudGFnLnR5cGUgPT09IElkZW50aWZpZXIkMSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMudGFnLm5hbWU7XG4gICAgICAgICAgICBjb25zdCB2YXJpYWJsZSA9IHRoaXMuc2NvcGUuZmluZFZhcmlhYmxlKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHZhcmlhYmxlLmlzTmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY29wZS5jb250ZXh0LmxvZyhMT0dMRVZFTF9XQVJOLCBsb2dDYW5ub3RDYWxsTmFtZXNwYWNlKG5hbWUpLCB0aGlzLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICBmb3IgKGNvbnN0IGFyZ3VtZW50IG9mIHRoaXMucXVhc2kuZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudC5oYXNFZmZlY3RzKGNvbnRleHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy50YWcuaGFzRWZmZWN0cyhjb250ZXh0KSB8fFxuICAgICAgICAgICAgdGhpcy50YWcuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoRU1QVFlfUEFUSCwgdGhpcy5pbnRlcmFjdGlvbiwgY29udGV4dCkpO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgaWYgKGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgICAgICBzdXBlci5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50YWcuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgICAgICB0aGlzLnF1YXNpLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFnLmluY2x1ZGVDYWxsQXJndW1lbnRzKGNvbnRleHQsIHRoaXMuYXJncyk7XG4gICAgICAgIGNvbnN0IFtyZXR1cm5FeHByZXNzaW9uXSA9IHRoaXMuZ2V0UmV0dXJuRXhwcmVzc2lvbigpO1xuICAgICAgICBpZiAoIXJldHVybkV4cHJlc3Npb24uaW5jbHVkZWQpIHtcbiAgICAgICAgICAgIHJldHVybkV4cHJlc3Npb24uaW5jbHVkZShjb250ZXh0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGlzZSgpO1xuICAgICAgICB0aGlzLmFyZ3MgPSBbVU5LTk9XTl9FWFBSRVNTSU9OLCAuLi50aGlzLnF1YXNpLmV4cHJlc3Npb25zXTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbiA9IHtcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB0aGlzLnRhZyBpbnN0YW5jZW9mIE1lbWJlckV4cHJlc3Npb24gJiYgIXRoaXMudGFnLnZhcmlhYmxlID8gdGhpcy50YWcub2JqZWN0IDogbnVsbCxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmFyZ3NcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB0eXBlOiBJTlRFUkFDVElPTl9DQUxMRUQsXG4gICAgICAgICAgICB3aXRoTmV3OiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnRhZy5yZW5kZXIoY29kZSwgb3B0aW9ucywgeyBpc0NhbGxlZU9mUmVuZGVyZWRQYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIHRoaXMucXVhc2kucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kZW9wdGltaXplZCA9IHRydWU7XG4gICAgICAgIHRoaXMudGFnLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHRoaXMuaW50ZXJhY3Rpb24sIEVNUFRZX1BBVEgsIFNIQVJFRF9SRUNVUlNJT05fVFJBQ0tFUik7XG4gICAgICAgIHRoaXMuc2NvcGUuY29udGV4dC5yZXF1ZXN0VHJlZXNoYWtpbmdQYXNzKCk7XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb24ocmVjdXJzaW9uVHJhY2tlciA9IFNIQVJFRF9SRUNVUlNJT05fVFJBQ0tFUikge1xuICAgICAgICBpZiAodGhpcy5yZXR1cm5FeHByZXNzaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJldHVybkV4cHJlc3Npb24gPSBVTktOT1dOX1JFVFVSTl9FWFBSRVNTSU9OO1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnJldHVybkV4cHJlc3Npb24gPSB0aGlzLnRhZy5nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChFTVBUWV9QQVRILCB0aGlzLmludGVyYWN0aW9uLCByZWN1cnNpb25UcmFja2VyLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmV0dXJuRXhwcmVzc2lvbjtcbiAgICB9XG59XG5cbmNsYXNzIFRlbXBsYXRlRWxlbWVudCBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBnZXQgdGFpbCgpIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhZ1NldCh0aGlzLmZsYWdzLCAxMDQ4NTc2IC8qIEZsYWcudGFpbCAqLyk7XG4gICAgfVxuICAgIHNldCB0YWlsKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBzZXRGbGFnKHRoaXMuZmxhZ3MsIDEwNDg1NzYgLyogRmxhZy50YWlsICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIERvIG5vdCB0cnkgdG8gYmluZCB2YWx1ZVxuICAgIGJpbmQoKSB7IH1cbiAgICBoYXNFZmZlY3RzKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGluY2x1ZGUoKSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgIH1cbiAgICBwYXJzZU5vZGUoZXNUcmVlTm9kZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gZXNUcmVlTm9kZS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlTm9kZShlc1RyZWVOb2RlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkgeyB9XG59XG5cbmNsYXNzIFRlbXBsYXRlTGl0ZXJhbCBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBkZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCgpIHsgfVxuICAgIGdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IDAgfHwgdGhpcy5xdWFzaXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1YXNpc1swXS52YWx1ZS5jb29rZWQ7XG4gICAgfVxuICAgIGdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gVU5LTk9XTl9SRVRVUk5fRVhQUkVTU0lPTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0TWVtYmVyUmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWQobGl0ZXJhbFN0cmluZ01lbWJlcnMsIHBhdGhbMF0pO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICBpZiAoaW50ZXJhY3Rpb24udHlwZSA9PT0gSU5URVJBQ1RJT05fQUNDRVNTRUQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVyYWN0aW9uLnR5cGUgPT09IElOVEVSQUNUSU9OX0NBTExFRCAmJiBwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhc01lbWJlckVmZmVjdFdoZW5DYWxsZWQobGl0ZXJhbFN0cmluZ01lbWJlcnMsIHBhdGhbMF0sIGludGVyYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29kZS5pbmRlbnRFeGNsdXNpb25SYW5nZXMucHVzaChbdGhpcy5zdGFydCwgdGhpcy5lbmRdKTtcbiAgICAgICAgc3VwZXIucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuY2xhc3MgTW9kdWxlU2NvcGUgZXh0ZW5kcyBDaGlsZFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMuc2V0KCd0aGlzJywgbmV3IExvY2FsVmFyaWFibGUoJ3RoaXMnLCBudWxsLCBVTkRFRklORURfRVhQUkVTU0lPTiwgY29udGV4dCwgJ290aGVyJykpO1xuICAgIH1cbiAgICBhZGREZWNsYXJhdGlvbihpZGVudGlmaWVyLCBjb250ZXh0LCBpbml0LCBraW5kKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQubW9kdWxlLmltcG9ydERlc2NyaXB0aW9ucy5oYXMoaWRlbnRpZmllci5uYW1lKSkge1xuICAgICAgICAgICAgY29udGV4dC5lcnJvcihsb2dSZWRlY2xhcmF0aW9uRXJyb3IoaWRlbnRpZmllci5uYW1lKSwgaWRlbnRpZmllci5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmFkZERlY2xhcmF0aW9uKGlkZW50aWZpZXIsIGNvbnRleHQsIGluaXQsIGtpbmQpO1xuICAgIH1cbiAgICBhZGRFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24obmFtZSwgZXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlID0gbmV3IEV4cG9ydERlZmF1bHRWYXJpYWJsZShuYW1lLCBleHBvcnREZWZhdWx0RGVjbGFyYXRpb24sIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcy5zZXQoJ2RlZmF1bHQnLCB2YXJpYWJsZSk7XG4gICAgICAgIHJldHVybiB2YXJpYWJsZTtcbiAgICB9XG4gICAgYWRkTmFtZXNwYWNlTWVtYmVyQWNjZXNzKCkgeyB9XG4gICAgZGVjb25mbGljdChmb3JtYXQsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSwgYWNjZXNzZWRHbG9iYWxzQnlTY29wZSkge1xuICAgICAgICAvLyBhbGwgbW9kdWxlIGxldmVsIHZhcmlhYmxlcyBhcmUgYWxyZWFkeSBkZWNvbmZsaWN0ZWQgd2hlbiBkZWNvbmZsaWN0aW5nIHRoZSBjaHVua1xuICAgICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICBzY29wZS5kZWNvbmZsaWN0KGZvcm1hdCwgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlKTtcbiAgICB9XG4gICAgZmluZExleGljYWxCb3VuZGFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmRWYXJpYWJsZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IGtub3duVmFyaWFibGUgPSB0aGlzLnZhcmlhYmxlcy5nZXQobmFtZSkgfHwgdGhpcy5hY2Nlc3NlZE91dHNpZGVWYXJpYWJsZXMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoa25vd25WYXJpYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtub3duVmFyaWFibGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFyaWFibGUgPSB0aGlzLmNvbnRleHQudHJhY2VWYXJpYWJsZShuYW1lKSB8fCB0aGlzLnBhcmVudC5maW5kVmFyaWFibGUobmFtZSk7XG4gICAgICAgIGlmICh2YXJpYWJsZSBpbnN0YW5jZW9mIEdsb2JhbFZhcmlhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmFjY2Vzc2VkT3V0c2lkZVZhcmlhYmxlcy5zZXQobmFtZSwgdmFyaWFibGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YXJpYWJsZTtcbiAgICB9XG59XG5cbmNsYXNzIFRoaXNFeHByZXNzaW9uIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGJpbmQoKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGUgPSB0aGlzLnNjb3BlLmZpbmRWYXJpYWJsZSgndGhpcycpO1xuICAgIH1cbiAgICBkZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aChpbnRlcmFjdGlvbiwgcGF0aCwgcmVjdXJzaW9uVHJhY2tlcikge1xuICAgICAgICB0aGlzLnZhcmlhYmxlLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGludGVyYWN0aW9uLCBwYXRoLCByZWN1cnNpb25UcmFja2VyKTtcbiAgICB9XG4gICAgZGVvcHRpbWl6ZVBhdGgocGF0aCkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlLmRlb3B0aW1pemVQYXRoKHBhdGgpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcmFjdGlvbi50eXBlICE9PSBJTlRFUkFDVElPTl9BQ0NFU1NFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YXJpYWJsZS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCBpbnRlcmFjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGluY2x1ZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbmNsdWRlZCkge1xuICAgICAgICAgICAgdGhpcy5pbmNsdWRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNjb3BlLmNvbnRleHQuaW5jbHVkZVZhcmlhYmxlSW5Nb2R1bGUodGhpcy52YXJpYWJsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGlzZSgpO1xuICAgICAgICB0aGlzLmFsaWFzID1cbiAgICAgICAgICAgIHRoaXMuc2NvcGUuZmluZExleGljYWxCb3VuZGFyeSgpIGluc3RhbmNlb2YgTW9kdWxlU2NvcGVcbiAgICAgICAgICAgICAgICA/IHRoaXMuc2NvcGUuY29udGV4dC5tb2R1bGVDb250ZXh0XG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5hbGlhcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGUuY29udGV4dC5sb2coTE9HTEVWRUxfV0FSTiwgbG9nVGhpc0lzVW5kZWZpbmVkKCksIHRoaXMuc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcihjb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmFsaWFzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgdGhpcy5hbGlhcywge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRPbmx5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzdG9yZU5hbWU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBUaHJvd1N0YXRlbWVudCBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBoYXNFZmZlY3RzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hcmd1bWVudC5pbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVuZGVyKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hcmd1bWVudC5yZW5kZXIoY29kZSwgb3B0aW9ucywgeyBwcmV2ZW50QVNJOiB0cnVlIH0pO1xuICAgICAgICBpZiAodGhpcy5hcmd1bWVudC5zdGFydCA9PT0gdGhpcy5zdGFydCArIDUgLyogJ3Rocm93Jy5sZW5ndGggKi8pIHtcbiAgICAgICAgICAgIGNvZGUucHJlcGVuZExlZnQodGhpcy5zdGFydCArIDUsICcgJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFRyeVN0YXRlbWVudCBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5kaXJlY3RseUluY2x1ZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5jbHVkZWRMYWJlbHNBZnRlckJsb2NrID0gbnVsbDtcbiAgICB9XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMuc2NvcGUuY29udGV4dC5vcHRpb25zLnRyZWVzaGFrZS50cnlDYXRjaERlb3B0aW1pemF0aW9uXG4gICAgICAgICAgICA/IHRoaXMuYmxvY2suYm9keS5sZW5ndGggPiAwXG4gICAgICAgICAgICA6IHRoaXMuYmxvY2suaGFzRWZmZWN0cyhjb250ZXh0KSkgfHwgISF0aGlzLmZpbmFsaXplcj8uaGFzRWZmZWN0cyhjb250ZXh0KSk7XG4gICAgfVxuICAgIGluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpIHtcbiAgICAgICAgY29uc3QgdHJ5Q2F0Y2hEZW9wdGltaXphdGlvbiA9IHRoaXMuc2NvcGUuY29udGV4dC5vcHRpb25zLnRyZWVzaGFrZT8udHJ5Q2F0Y2hEZW9wdGltaXphdGlvbjtcbiAgICAgICAgY29uc3QgeyBicm9rZW5GbG93LCBpbmNsdWRlZExhYmVscyB9ID0gY29udGV4dDtcbiAgICAgICAgaWYgKCF0aGlzLmRpcmVjdGx5SW5jbHVkZWQgfHwgIXRyeUNhdGNoRGVvcHRpbWl6YXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RseUluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYmxvY2suaW5jbHVkZShjb250ZXh0LCB0cnlDYXRjaERlb3B0aW1pemF0aW9uID8gSU5DTFVERV9QQVJBTUVURVJTIDogaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVkTGFiZWxzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNsdWRlZExhYmVsc0FmdGVyQmxvY2sgPSBbLi4uaW5jbHVkZWRMYWJlbHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gYnJva2VuRmxvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmluY2x1ZGVkTGFiZWxzQWZ0ZXJCbG9jaykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBsYWJlbCBvZiB0aGlzLmluY2x1ZGVkTGFiZWxzQWZ0ZXJCbG9jaykge1xuICAgICAgICAgICAgICAgIGluY2x1ZGVkTGFiZWxzLmFkZChsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLmluY2x1ZGUoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkpO1xuICAgICAgICAgICAgY29udGV4dC5icm9rZW5GbG93ID0gYnJva2VuRmxvdztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmFsaXplcj8uaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgfVxufVxuXG5jb25zdCB1bmFyeU9wZXJhdG9ycyA9IHtcbiAgICAnISc6IHZhbHVlID0+ICF2YWx1ZSxcbiAgICAnKyc6IHZhbHVlID0+ICt2YWx1ZSxcbiAgICAnLSc6IHZhbHVlID0+IC12YWx1ZSxcbiAgICBkZWxldGU6ICgpID0+IFVua25vd25WYWx1ZSxcbiAgICB0eXBlb2Y6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSxcbiAgICB2b2lkOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgJ34nOiB2YWx1ZSA9PiB+dmFsdWVcbn07XG5jbGFzcyBVbmFyeUV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgZ2V0IHByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhZ1NldCh0aGlzLmZsYWdzLCAyMDk3MTUyIC8qIEZsYWcucHJlZml4ICovKTtcbiAgICB9XG4gICAgc2V0IHByZWZpeCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZsYWdzID0gc2V0RmxhZyh0aGlzLmZsYWdzLCAyMDk3MTUyIC8qIEZsYWcucHJlZml4ICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldExpdGVyYWxWYWx1ZUF0UGF0aChwYXRoLCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duVmFsdWU7XG4gICAgICAgIGNvbnN0IGFyZ3VtZW50VmFsdWUgPSB0aGlzLmFyZ3VtZW50LmdldExpdGVyYWxWYWx1ZUF0UGF0aChFTVBUWV9QQVRILCByZWN1cnNpb25UcmFja2VyLCBvcmlnaW4pO1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50VmFsdWUgPT09ICdzeW1ib2wnKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25WYWx1ZTtcbiAgICAgICAgcmV0dXJuIHVuYXJ5T3BlcmF0b3JzW3RoaXMub3BlcmF0b3JdKGFyZ3VtZW50VmFsdWUpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJ3R5cGVvZicgJiYgdGhpcy5hcmd1bWVudCBpbnN0YW5jZW9mIElkZW50aWZpZXIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiAodGhpcy5hcmd1bWVudC5oYXNFZmZlY3RzKGNvbnRleHQpIHx8XG4gICAgICAgICAgICAodGhpcy5vcGVyYXRvciA9PT0gJ2RlbGV0ZScgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3VtZW50Lmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKEVNUFRZX1BBVEgsIE5PREVfSU5URVJBQ1RJT05fVU5LTk9XTl9BU1NJR05NRU5ULCBjb250ZXh0KSkpO1xuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChwYXRoLCB7IHR5cGUgfSkge1xuICAgICAgICByZXR1cm4gdHlwZSAhPT0gSU5URVJBQ1RJT05fQUNDRVNTRUQgfHwgcGF0aC5sZW5ndGggPiAodGhpcy5vcGVyYXRvciA9PT0gJ3ZvaWQnID8gMCA6IDEpO1xuICAgIH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHtcbiAgICAgICAgdGhpcy5kZW9wdGltaXplZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgdGhpcy5hcmd1bWVudC5kZW9wdGltaXplUGF0aChFTVBUWV9QQVRIKTtcbiAgICAgICAgICAgIHRoaXMuc2NvcGUuY29udGV4dC5yZXF1ZXN0VHJlZXNoYWtpbmdQYXNzKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFVwZGF0ZUV4cHJlc3Npb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgaGFzRWZmZWN0cyhjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5kZW9wdGltaXplZClcbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJndW1lbnQuaGFzRWZmZWN0c0FzQXNzaWdubWVudFRhcmdldChjb250ZXh0LCB0cnVlKTtcbiAgICB9XG4gICAgaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocGF0aCwgeyB0eXBlIH0pIHtcbiAgICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMSB8fCB0eXBlICE9PSBJTlRFUkFDVElPTl9BQ0NFU1NFRDtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSkge1xuICAgICAgICBpZiAoIXRoaXMuZGVvcHRpbWl6ZWQpXG4gICAgICAgICAgICB0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCk7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmFyZ3VtZW50LmluY2x1ZGVBc0Fzc2lnbm1lbnRUYXJnZXQoY29udGV4dCwgaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHksIHRydWUpO1xuICAgIH1cbiAgICBpbml0aWFsaXNlKCkge1xuICAgICAgICBzdXBlci5pbml0aWFsaXNlKCk7XG4gICAgICAgIHRoaXMuYXJndW1lbnQuc2V0QXNzaWduZWRWYWx1ZShVTktOT1dOX0VYUFJFU1NJT04pO1xuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGV4cG9ydE5hbWVzQnlWYXJpYWJsZSwgZm9ybWF0LCBzbmlwcGV0czogeyBfIH0gfSA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYXJndW1lbnQucmVuZGVyKGNvZGUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnc3lzdGVtJykge1xuICAgICAgICAgICAgY29uc3QgdmFyaWFibGUgPSB0aGlzLmFyZ3VtZW50LnZhcmlhYmxlO1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0TmFtZXMgPSBleHBvcnROYW1lc0J5VmFyaWFibGUuZ2V0KHZhcmlhYmxlKTtcbiAgICAgICAgICAgIGlmIChleHBvcnROYW1lcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb3J0TmFtZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTeXN0ZW1FeHBvcnRFeHByZXNzaW9uKHZhcmlhYmxlLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTeXN0ZW1FeHBvcnRTZXF1ZW5jZUFmdGVyRXhwcmVzc2lvbih2YXJpYWJsZSwgdGhpcy5zdGFydCwgdGhpcy5lbmQsIHRoaXMucGFyZW50LnR5cGUgIT09IEV4cHJlc3Npb25TdGF0ZW1lbnQkMSwgY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9yID0gdGhpcy5vcGVyYXRvclswXTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3lzdGVtRXhwb3J0U2VxdWVuY2VCZWZvcmVFeHByZXNzaW9uKHZhcmlhYmxlLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgdGhpcy5wYXJlbnQudHlwZSAhPT0gRXhwcmVzc2lvblN0YXRlbWVudCQxLCBjb2RlLCBvcHRpb25zLCBgJHtffSR7b3BlcmF0b3J9JHtffTFgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlEZW9wdGltaXphdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZGVvcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmFyZ3VtZW50LmRlb3B0aW1pemVQYXRoKEVNUFRZX1BBVEgpO1xuICAgICAgICBpZiAodGhpcy5hcmd1bWVudCBpbnN0YW5jZW9mIElkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlID0gdGhpcy5zY29wZS5maW5kVmFyaWFibGUodGhpcy5hcmd1bWVudC5uYW1lKTtcbiAgICAgICAgICAgIHZhcmlhYmxlLm1hcmtSZWFzc2lnbmVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY29wZS5jb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFyZUFsbERlY2xhcmF0aW9uc0luY2x1ZGVkQW5kTm90RXhwb3J0ZWQoZGVjbGFyYXRpb25zLCBleHBvcnROYW1lc0J5VmFyaWFibGUpIHtcbiAgICBmb3IgKGNvbnN0IGRlY2xhcmF0b3Igb2YgZGVjbGFyYXRpb25zKSB7XG4gICAgICAgIGlmICghZGVjbGFyYXRvci5pZC5pbmNsdWRlZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRlY2xhcmF0b3IuaWQudHlwZSA9PT0gSWRlbnRpZmllciQxKSB7XG4gICAgICAgICAgICBpZiAoZXhwb3J0TmFtZXNCeVZhcmlhYmxlLmhhcyhkZWNsYXJhdG9yLmlkLnZhcmlhYmxlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBleHBvcnRlZFZhcmlhYmxlcyA9IFtdO1xuICAgICAgICAgICAgZGVjbGFyYXRvci5pZC5hZGRFeHBvcnRlZFZhcmlhYmxlcyhleHBvcnRlZFZhcmlhYmxlcywgZXhwb3J0TmFtZXNCeVZhcmlhYmxlKTtcbiAgICAgICAgICAgIGlmIChleHBvcnRlZFZhcmlhYmxlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIFZhcmlhYmxlRGVjbGFyYXRpb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgZGVvcHRpbWl6ZVBhdGgoKSB7XG4gICAgICAgIGZvciAoY29uc3QgZGVjbGFyYXRvciBvZiB0aGlzLmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgZGVjbGFyYXRvci5kZW9wdGltaXplUGF0aChFTVBUWV9QQVRIKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5LCB7IGFzU2luZ2xlU3RhdGVtZW50IH0gPSBCTEFOSykge1xuICAgICAgICB0aGlzLmluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBkZWNsYXJhdG9yIG9mIHRoaXMuZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZUNoaWxkcmVuUmVjdXJzaXZlbHkgfHwgZGVjbGFyYXRvci5zaG91bGRCZUluY2x1ZGVkKGNvbnRleHQpKVxuICAgICAgICAgICAgICAgIGRlY2xhcmF0b3IuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgICAgICBjb25zdCB7IGlkLCBpbml0IH0gPSBkZWNsYXJhdG9yO1xuICAgICAgICAgICAgaWYgKGFzU2luZ2xlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWQuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5pdCAmJlxuICAgICAgICAgICAgICAgIGlkLmluY2x1ZGVkICYmXG4gICAgICAgICAgICAgICAgIWluaXQuaW5jbHVkZWQgJiZcbiAgICAgICAgICAgICAgICAoaWQgaW5zdGFuY2VvZiBPYmplY3RQYXR0ZXJuIHx8IGlkIGluc3RhbmNlb2YgQXJyYXlQYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIGluaXQuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdGlhbGlzZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGlzZSgpO1xuICAgICAgICB0aGlzLmlzVXNpbmdEZWNsYXJhdGlvbiA9IHRoaXMua2luZCA9PT0gJ2F3YWl0IHVzaW5nJyB8fCB0aGlzLmtpbmQgPT09ICd1c2luZyc7XG4gICAgICAgIGZvciAoY29uc3QgZGVjbGFyYXRvciBvZiB0aGlzLmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgZGVjbGFyYXRvci5kZWNsYXJlRGVjbGFyYXRvcih0aGlzLmtpbmQsIHRoaXMuaXNVc2luZ0RlY2xhcmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVBbm5vdGF0aW9ucyhjb2RlKSB7XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25zWzBdLnJlbW92ZUFubm90YXRpb25zKGNvZGUpO1xuICAgIH1cbiAgICByZW5kZXIoY29kZSwgb3B0aW9ucywgbm9kZVJlbmRlck9wdGlvbnMgPSBCTEFOSykge1xuICAgICAgICBpZiAodGhpcy5pc1VzaW5nRGVjbGFyYXRpb24gfHxcbiAgICAgICAgICAgIGFyZUFsbERlY2xhcmF0aW9uc0luY2x1ZGVkQW5kTm90RXhwb3J0ZWQodGhpcy5kZWNsYXJhdGlvbnMsIG9wdGlvbnMuZXhwb3J0TmFtZXNCeVZhcmlhYmxlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkZWNsYXJhdG9yIG9mIHRoaXMuZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRvci5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5vZGVSZW5kZXJPcHRpb25zLmlzTm9TdGF0ZW1lbnQgJiZcbiAgICAgICAgICAgICAgICBjb2RlLm9yaWdpbmFsLmNoYXJDb2RlQXQodGhpcy5lbmQgLSAxKSAhPT0gNTkgLypcIjtcIiovKSB7XG4gICAgICAgICAgICAgICAgY29kZS5hcHBlbmRMZWZ0KHRoaXMuZW5kLCAnOycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJSZXBsYWNlZERlY2xhcmF0aW9ucyhjb2RlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBseURlb3B0aW1pemF0aW9ucygpIHsgfVxuICAgIHJlbmRlckRlY2xhcmF0aW9uRW5kKGNvZGUsIHNlcGFyYXRvclN0cmluZywgbGFzdFNlcGFyYXRvclBvcywgYWN0dWFsQ29udGVudEVuZCwgcmVuZGVyZWRDb250ZW50RW5kLCBzeXN0ZW1QYXR0ZXJuRXhwb3J0cywgb3B0aW9ucykge1xuICAgICAgICBpZiAoY29kZS5vcmlnaW5hbC5jaGFyQ29kZUF0KHRoaXMuZW5kIC0gMSkgPT09IDU5IC8qXCI7XCIqLykge1xuICAgICAgICAgICAgY29kZS5yZW1vdmUodGhpcy5lbmQgLSAxLCB0aGlzLmVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VwYXJhdG9yU3RyaW5nICs9ICc7JztcbiAgICAgICAgaWYgKGxhc3RTZXBhcmF0b3JQb3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvZGUuYXBwZW5kTGVmdChyZW5kZXJlZENvbnRlbnRFbmQsIHNlcGFyYXRvclN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29kZS5vcmlnaW5hbC5jaGFyQ29kZUF0KGFjdHVhbENvbnRlbnRFbmQgLSAxKSA9PT0gMTAgLypcIlxcblwiKi8gJiZcbiAgICAgICAgICAgICAgICAoY29kZS5vcmlnaW5hbC5jaGFyQ29kZUF0KHRoaXMuZW5kKSA9PT0gMTAgLypcIlxcblwiKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgY29kZS5vcmlnaW5hbC5jaGFyQ29kZUF0KHRoaXMuZW5kKSA9PT0gMTMpIC8qXCJcXHJcIiovKSB7XG4gICAgICAgICAgICAgICAgYWN0dWFsQ29udGVudEVuZC0tO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlLm9yaWdpbmFsLmNoYXJDb2RlQXQoYWN0dWFsQ29udGVudEVuZCkgPT09IDEzIC8qXCJcXHJcIiovKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbENvbnRlbnRFbmQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWN0dWFsQ29udGVudEVuZCA9PT0gbGFzdFNlcGFyYXRvclBvcyArIDEpIHtcbiAgICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShsYXN0U2VwYXJhdG9yUG9zLCByZW5kZXJlZENvbnRlbnRFbmQsIHNlcGFyYXRvclN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShsYXN0U2VwYXJhdG9yUG9zLCBsYXN0U2VwYXJhdG9yUG9zICsgMSwgc2VwYXJhdG9yU3RyaW5nKTtcbiAgICAgICAgICAgICAgICBjb2RlLnJlbW92ZShhY3R1YWxDb250ZW50RW5kLCByZW5kZXJlZENvbnRlbnRFbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzeXN0ZW1QYXR0ZXJuRXhwb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb2RlLmFwcGVuZExlZnQocmVuZGVyZWRDb250ZW50RW5kLCBgICR7Z2V0U3lzdGVtRXhwb3J0U3RhdGVtZW50KHN5c3RlbVBhdHRlcm5FeHBvcnRzLCBvcHRpb25zKX07YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyUmVwbGFjZWREZWNsYXJhdGlvbnMoY29kZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzZXBhcmF0ZWROb2RlcyA9IGdldENvbW1hU2VwYXJhdGVkTm9kZXNXaXRoQm91bmRhcmllcyh0aGlzLmRlY2xhcmF0aW9ucywgY29kZSwgdGhpcy5zdGFydCArIHRoaXMua2luZC5sZW5ndGgsIHRoaXMuZW5kIC0gKGNvZGUub3JpZ2luYWwuY2hhckNvZGVBdCh0aGlzLmVuZCAtIDEpID09PSA1OSAvKlwiO1wiKi8gPyAxIDogMCkpO1xuICAgICAgICBsZXQgYWN0dWFsQ29udGVudEVuZCwgcmVuZGVyZWRDb250ZW50RW5kO1xuICAgICAgICByZW5kZXJlZENvbnRlbnRFbmQgPSBmaW5kTm9uV2hpdGVTcGFjZShjb2RlLm9yaWdpbmFsLCB0aGlzLnN0YXJ0ICsgdGhpcy5raW5kLmxlbmd0aCk7XG4gICAgICAgIGxldCBsYXN0U2VwYXJhdG9yUG9zID0gcmVuZGVyZWRDb250ZW50RW5kIC0gMTtcbiAgICAgICAgY29kZS5yZW1vdmUodGhpcy5zdGFydCwgbGFzdFNlcGFyYXRvclBvcyk7XG4gICAgICAgIGxldCBpc0luRGVjbGFyYXRpb24gPSBmYWxzZTtcbiAgICAgICAgbGV0IGhhc1JlbmRlcmVkQ29udGVudCA9IGZhbHNlO1xuICAgICAgICBsZXQgc2VwYXJhdG9yU3RyaW5nID0gJycsIGxlYWRpbmdTdHJpbmcsIG5leHRTZXBhcmF0b3JTdHJpbmc7XG4gICAgICAgIGNvbnN0IGFnZ3JlZ2F0ZWRTeXN0ZW1FeHBvcnRzID0gW107XG4gICAgICAgIGNvbnN0IHNpbmdsZVN5c3RlbUV4cG9ydCA9IGdhdGhlclN5c3RlbUV4cG9ydHNBbmRHZXRTaW5nbGVFeHBvcnQoc2VwYXJhdGVkTm9kZXMsIG9wdGlvbnMsIGFnZ3JlZ2F0ZWRTeXN0ZW1FeHBvcnRzKTtcbiAgICAgICAgZm9yIChjb25zdCB7IG5vZGUsIHN0YXJ0LCBzZXBhcmF0b3IsIGNvbnRlbnRFbmQsIGVuZCB9IG9mIHNlcGFyYXRlZE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICBjb2RlLnJlbW92ZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUFubm90YXRpb25zKGNvZGUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5yZW5kZXIoY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBsZWFkaW5nU3RyaW5nID0gJyc7XG4gICAgICAgICAgICBuZXh0U2VwYXJhdG9yU3RyaW5nID0gJyc7XG4gICAgICAgICAgICBpZiAoIW5vZGUuaWQuaW5jbHVkZWQgfHxcbiAgICAgICAgICAgICAgICAobm9kZS5pZCBpbnN0YW5jZW9mIElkZW50aWZpZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNSZWFzc2lnbmVkRXhwb3J0c01lbWJlcihub2RlLmlkLnZhcmlhYmxlLCBvcHRpb25zLmV4cG9ydE5hbWVzQnlWYXJpYWJsZSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1JlbmRlcmVkQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3JTdHJpbmcgKz0gJzsnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpc0luRGVjbGFyYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVTeXN0ZW1FeHBvcnQgJiYgc2luZ2xlU3lzdGVtRXhwb3J0ID09PSBub2RlLmlkLnZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9yUG9zID0gZmluZEZpcnN0T2NjdXJyZW5jZU91dHNpZGVDb21tZW50KGNvZGUub3JpZ2luYWwsICc9Jywgbm9kZS5pZC5lbmQpO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJTeXN0ZW1FeHBvcnRFeHByZXNzaW9uKHNpbmdsZVN5c3RlbUV4cG9ydCwgZmluZE5vbldoaXRlU3BhY2UoY29kZS5vcmlnaW5hbCwgb3BlcmF0b3JQb3MgKyAxKSwgc2VwYXJhdG9yID09PSBudWxsID8gY29udGVudEVuZCA6IHNlcGFyYXRvciwgY29kZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0luRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yU3RyaW5nICs9ICcsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNSZW5kZXJlZENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvclN0cmluZyArPSAnOyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGVhZGluZ1N0cmluZyArPSBgJHt0aGlzLmtpbmR9IGA7XG4gICAgICAgICAgICAgICAgICAgIGlzSW5EZWNsYXJhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbmRlcmVkQ29udGVudEVuZCA9PT0gbGFzdFNlcGFyYXRvclBvcyArIDEpIHtcbiAgICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShsYXN0U2VwYXJhdG9yUG9zLCByZW5kZXJlZENvbnRlbnRFbmQsIHNlcGFyYXRvclN0cmluZyArIGxlYWRpbmdTdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUobGFzdFNlcGFyYXRvclBvcywgbGFzdFNlcGFyYXRvclBvcyArIDEsIHNlcGFyYXRvclN0cmluZyk7XG4gICAgICAgICAgICAgICAgY29kZS5hcHBlbmRMZWZ0KHJlbmRlcmVkQ29udGVudEVuZCwgbGVhZGluZ1N0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3R1YWxDb250ZW50RW5kID0gY29udGVudEVuZDtcbiAgICAgICAgICAgIHJlbmRlcmVkQ29udGVudEVuZCA9IGVuZDtcbiAgICAgICAgICAgIGhhc1JlbmRlcmVkQ29udGVudCA9IHRydWU7XG4gICAgICAgICAgICBsYXN0U2VwYXJhdG9yUG9zID0gc2VwYXJhdG9yO1xuICAgICAgICAgICAgc2VwYXJhdG9yU3RyaW5nID0gbmV4dFNlcGFyYXRvclN0cmluZztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlckRlY2xhcmF0aW9uRW5kKGNvZGUsIHNlcGFyYXRvclN0cmluZywgbGFzdFNlcGFyYXRvclBvcywgYWN0dWFsQ29udGVudEVuZCwgcmVuZGVyZWRDb250ZW50RW5kLCBhZ2dyZWdhdGVkU3lzdGVtRXhwb3J0cywgb3B0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2F0aGVyU3lzdGVtRXhwb3J0c0FuZEdldFNpbmdsZUV4cG9ydChzZXBhcmF0ZWROb2Rlcywgb3B0aW9ucywgYWdncmVnYXRlZFN5c3RlbUV4cG9ydHMpIHtcbiAgICBsZXQgc2luZ2xlU3lzdGVtRXhwb3J0ID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdzeXN0ZW0nKSB7XG4gICAgICAgIGZvciAoY29uc3QgeyBub2RlIH0gb2Ygc2VwYXJhdGVkTm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlkIGluc3RhbmNlb2YgSWRlbnRpZmllciAmJlxuICAgICAgICAgICAgICAgIG5vZGUuaW5pdCAmJlxuICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZWRTeXN0ZW1FeHBvcnRzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZXhwb3J0TmFtZXNCeVZhcmlhYmxlLmdldChub2RlLmlkLnZhcmlhYmxlKT8ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2luZ2xlU3lzdGVtRXhwb3J0ID0gbm9kZS5pZC52YXJpYWJsZTtcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGVkU3lzdGVtRXhwb3J0cy5wdXNoKHNpbmdsZVN5c3RlbUV4cG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLmlkLmFkZEV4cG9ydGVkVmFyaWFibGVzKGFnZ3JlZ2F0ZWRTeXN0ZW1FeHBvcnRzLCBvcHRpb25zLmV4cG9ydE5hbWVzQnlWYXJpYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFnZ3JlZ2F0ZWRTeXN0ZW1FeHBvcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHNpbmdsZVN5c3RlbUV4cG9ydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2luZ2xlU3lzdGVtRXhwb3J0KSB7XG4gICAgICAgICAgICBhZ2dyZWdhdGVkU3lzdGVtRXhwb3J0cy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaW5nbGVTeXN0ZW1FeHBvcnQ7XG59XG5cbmNsYXNzIFdoaWxlU3RhdGVtZW50IGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGhhc0VmZmVjdHMoY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy50ZXN0Lmhhc0VmZmVjdHMoY29udGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGhhc0xvb3BCb2R5RWZmZWN0cyhjb250ZXh0LCB0aGlzLmJvZHkpO1xuICAgIH1cbiAgICBpbmNsdWRlKGNvbnRleHQsIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRlc3QuaW5jbHVkZShjb250ZXh0LCBpbmNsdWRlQ2hpbGRyZW5SZWN1cnNpdmVseSk7XG4gICAgICAgIGluY2x1ZGVMb29wQm9keShjb250ZXh0LCB0aGlzLmJvZHksIGluY2x1ZGVDaGlsZHJlblJlY3Vyc2l2ZWx5KTtcbiAgICB9XG59XG5cbmNsYXNzIFlpZWxkRXhwcmVzc2lvbiBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBoYXNFZmZlY3RzKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlb3B0aW1pemVkKVxuICAgICAgICAgICAgdGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO1xuICAgICAgICByZXR1cm4gIShjb250ZXh0Lmlnbm9yZS5yZXR1cm5ZaWVsZCAmJiAhdGhpcy5hcmd1bWVudD8uaGFzRWZmZWN0cyhjb250ZXh0KSk7XG4gICAgfVxuICAgIHJlbmRlcihjb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmFyZ3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmFyZ3VtZW50LnJlbmRlcihjb2RlLCBvcHRpb25zLCB7IHByZXZlbnRBU0k6IHRydWUgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5hcmd1bWVudC5zdGFydCA9PT0gdGhpcy5zdGFydCArIDUgLyogJ3lpZWxkJy5sZW5ndGggKi8pIHtcbiAgICAgICAgICAgICAgICBjb2RlLnByZXBlbmRMZWZ0KHRoaXMuc3RhcnQgKyA1LCAnICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHNjcmlwdHMvZ2VuZXJhdGUtYnVmZmVyLXBhcnNlcnMuanMuXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgZGlyZWN0bHkuXG5mdW5jdGlvbiBjb252ZXJ0UHJvZ3JhbShidWZmZXIsIHBhcmVudCwgcGFyZW50U2NvcGUpIHtcbiAgICByZXR1cm4gY29udmVydE5vZGUocGFyZW50LCBwYXJlbnRTY29wZSwgMCwgZ2V0QXN0QnVmZmVyKGJ1ZmZlcikpO1xufVxuY29uc3Qgbm9kZVR5cGVTdHJpbmdzID0gW1xuICAgICdQYW5pY0Vycm9yJyxcbiAgICAnUGFyc2VFcnJvcicsXG4gICAgJ0FycmF5RXhwcmVzc2lvbicsXG4gICAgJ0FycmF5UGF0dGVybicsXG4gICAgJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyxcbiAgICAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxuICAgICdBc3NpZ25tZW50UGF0dGVybicsXG4gICAgJ0F3YWl0RXhwcmVzc2lvbicsXG4gICAgJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgICdCbG9ja1N0YXRlbWVudCcsXG4gICAgJ0JyZWFrU3RhdGVtZW50JyxcbiAgICAnQ2FsbEV4cHJlc3Npb24nLFxuICAgICdDYXRjaENsYXVzZScsXG4gICAgJ0NoYWluRXhwcmVzc2lvbicsXG4gICAgJ0NsYXNzQm9keScsXG4gICAgJ0NsYXNzRGVjbGFyYXRpb24nLFxuICAgICdDbGFzc0V4cHJlc3Npb24nLFxuICAgICdDb25kaXRpb25hbEV4cHJlc3Npb24nLFxuICAgICdDb250aW51ZVN0YXRlbWVudCcsXG4gICAgJ0RlYnVnZ2VyU3RhdGVtZW50JyxcbiAgICAnRGVjb3JhdG9yJyxcbiAgICAnRXhwcmVzc2lvblN0YXRlbWVudCcsXG4gICAgJ0RvV2hpbGVTdGF0ZW1lbnQnLFxuICAgICdFbXB0eVN0YXRlbWVudCcsXG4gICAgJ0V4cG9ydEFsbERlY2xhcmF0aW9uJyxcbiAgICAnRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uJyxcbiAgICAnRXhwb3J0TmFtZWREZWNsYXJhdGlvbicsXG4gICAgJ0V4cG9ydFNwZWNpZmllcicsXG4gICAgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnLFxuICAgICdGb3JJblN0YXRlbWVudCcsXG4gICAgJ0Zvck9mU3RhdGVtZW50JyxcbiAgICAnRm9yU3RhdGVtZW50JyxcbiAgICAnRnVuY3Rpb25EZWNsYXJhdGlvbicsXG4gICAgJ0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgJ0lkZW50aWZpZXInLFxuICAgICdJZlN0YXRlbWVudCcsXG4gICAgJ0ltcG9ydEF0dHJpYnV0ZScsXG4gICAgJ0ltcG9ydERlY2xhcmF0aW9uJyxcbiAgICAnSW1wb3J0RGVmYXVsdFNwZWNpZmllcicsXG4gICAgJ0ltcG9ydEV4cHJlc3Npb24nLFxuICAgICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInLFxuICAgICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICdKU1hBdHRyaWJ1dGUnLFxuICAgICdKU1hDbG9zaW5nRWxlbWVudCcsXG4gICAgJ0pTWENsb3NpbmdGcmFnbWVudCcsXG4gICAgJ0pTWEVsZW1lbnQnLFxuICAgICdKU1hFbXB0eUV4cHJlc3Npb24nLFxuICAgICdKU1hFeHByZXNzaW9uQ29udGFpbmVyJyxcbiAgICAnSlNYRnJhZ21lbnQnLFxuICAgICdKU1hJZGVudGlmaWVyJyxcbiAgICAnSlNYTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgJ0pTWE5hbWVzcGFjZWROYW1lJyxcbiAgICAnSlNYT3BlbmluZ0VsZW1lbnQnLFxuICAgICdKU1hPcGVuaW5nRnJhZ21lbnQnLFxuICAgICdKU1hTcHJlYWRBdHRyaWJ1dGUnLFxuICAgICdKU1hTcHJlYWRDaGlsZCcsXG4gICAgJ0pTWFRleHQnLFxuICAgICdMYWJlbGVkU3RhdGVtZW50JyxcbiAgICAnTGl0ZXJhbCcsXG4gICAgJ0xpdGVyYWwnLFxuICAgICdMaXRlcmFsJyxcbiAgICAnTGl0ZXJhbCcsXG4gICAgJ0xpdGVyYWwnLFxuICAgICdMaXRlcmFsJyxcbiAgICAnTG9naWNhbEV4cHJlc3Npb24nLFxuICAgICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAnTWV0YVByb3BlcnR5JyxcbiAgICAnTWV0aG9kRGVmaW5pdGlvbicsXG4gICAgJ05ld0V4cHJlc3Npb24nLFxuICAgICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAnT2JqZWN0UGF0dGVybicsXG4gICAgJ1ByaXZhdGVJZGVudGlmaWVyJyxcbiAgICAnUHJvZ3JhbScsXG4gICAgJ1Byb3BlcnR5JyxcbiAgICAnUHJvcGVydHlEZWZpbml0aW9uJyxcbiAgICAnUmVzdEVsZW1lbnQnLFxuICAgICdSZXR1cm5TdGF0ZW1lbnQnLFxuICAgICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxuICAgICdTcHJlYWRFbGVtZW50JyxcbiAgICAnU3RhdGljQmxvY2snLFxuICAgICdTdXBlcicsXG4gICAgJ1N3aXRjaENhc2UnLFxuICAgICdTd2l0Y2hTdGF0ZW1lbnQnLFxuICAgICdUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24nLFxuICAgICdUZW1wbGF0ZUVsZW1lbnQnLFxuICAgICdUZW1wbGF0ZUxpdGVyYWwnLFxuICAgICdUaGlzRXhwcmVzc2lvbicsXG4gICAgJ1Rocm93U3RhdGVtZW50JyxcbiAgICAnVHJ5U3RhdGVtZW50JyxcbiAgICAnVW5hcnlFeHByZXNzaW9uJyxcbiAgICAnVXBkYXRlRXhwcmVzc2lvbicsXG4gICAgJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxuICAgICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICdXaGlsZVN0YXRlbWVudCcsXG4gICAgJ1lpZWxkRXhwcmVzc2lvbidcbl07XG5jb25zdCBub2RlQ29uc3RydWN0b3JzJDEgPSBbXG4gICAgUGFuaWNFcnJvcixcbiAgICBQYXJzZUVycm9yLFxuICAgIEFycmF5RXhwcmVzc2lvbixcbiAgICBBcnJheVBhdHRlcm4sXG4gICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgQXNzaWdubWVudEV4cHJlc3Npb24sXG4gICAgQXNzaWdubWVudFBhdHRlcm4sXG4gICAgQXdhaXRFeHByZXNzaW9uLFxuICAgIEJpbmFyeUV4cHJlc3Npb24sXG4gICAgQmxvY2tTdGF0ZW1lbnQsXG4gICAgQnJlYWtTdGF0ZW1lbnQsXG4gICAgQ2FsbEV4cHJlc3Npb24sXG4gICAgQ2F0Y2hDbGF1c2UsXG4gICAgQ2hhaW5FeHByZXNzaW9uLFxuICAgIENsYXNzQm9keSxcbiAgICBDbGFzc0RlY2xhcmF0aW9uLFxuICAgIENsYXNzRXhwcmVzc2lvbixcbiAgICBDb25kaXRpb25hbEV4cHJlc3Npb24sXG4gICAgQ29udGludWVTdGF0ZW1lbnQsXG4gICAgRGVidWdnZXJTdGF0ZW1lbnQsXG4gICAgRGVjb3JhdG9yLFxuICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQsXG4gICAgRG9XaGlsZVN0YXRlbWVudCxcbiAgICBFbXB0eVN0YXRlbWVudCxcbiAgICBFeHBvcnRBbGxEZWNsYXJhdGlvbixcbiAgICBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24sXG4gICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbixcbiAgICBFeHBvcnRTcGVjaWZpZXIsXG4gICAgRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgICBGb3JJblN0YXRlbWVudCxcbiAgICBGb3JPZlN0YXRlbWVudCxcbiAgICBGb3JTdGF0ZW1lbnQsXG4gICAgRnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgICBGdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgSWRlbnRpZmllcixcbiAgICBJZlN0YXRlbWVudCxcbiAgICBJbXBvcnRBdHRyaWJ1dGUsXG4gICAgSW1wb3J0RGVjbGFyYXRpb24sXG4gICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcixcbiAgICBJbXBvcnRFeHByZXNzaW9uLFxuICAgIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcixcbiAgICBJbXBvcnRTcGVjaWZpZXIsXG4gICAgSlNYQXR0cmlidXRlLFxuICAgIEpTWENsb3NpbmdFbGVtZW50LFxuICAgIEpTWENsb3NpbmdGcmFnbWVudCxcbiAgICBKU1hFbGVtZW50LFxuICAgIEpTWEVtcHR5RXhwcmVzc2lvbixcbiAgICBKU1hFeHByZXNzaW9uQ29udGFpbmVyLFxuICAgIEpTWEZyYWdtZW50LFxuICAgIEpTWElkZW50aWZpZXIsXG4gICAgSlNYTWVtYmVyRXhwcmVzc2lvbixcbiAgICBKU1hOYW1lc3BhY2VkTmFtZSxcbiAgICBKU1hPcGVuaW5nRWxlbWVudCxcbiAgICBKU1hPcGVuaW5nRnJhZ21lbnQsXG4gICAgSlNYU3ByZWFkQXR0cmlidXRlLFxuICAgIEpTWFNwcmVhZENoaWxkLFxuICAgIEpTWFRleHQsXG4gICAgTGFiZWxlZFN0YXRlbWVudCxcbiAgICBMaXRlcmFsLFxuICAgIExpdGVyYWwsXG4gICAgTGl0ZXJhbCxcbiAgICBMaXRlcmFsLFxuICAgIExpdGVyYWwsXG4gICAgTGl0ZXJhbCxcbiAgICBMb2dpY2FsRXhwcmVzc2lvbixcbiAgICBNZW1iZXJFeHByZXNzaW9uLFxuICAgIE1ldGFQcm9wZXJ0eSxcbiAgICBNZXRob2REZWZpbml0aW9uLFxuICAgIE5ld0V4cHJlc3Npb24sXG4gICAgT2JqZWN0RXhwcmVzc2lvbixcbiAgICBPYmplY3RQYXR0ZXJuLFxuICAgIFByaXZhdGVJZGVudGlmaWVyLFxuICAgIFByb2dyYW0sXG4gICAgUHJvcGVydHksXG4gICAgUHJvcGVydHlEZWZpbml0aW9uLFxuICAgIFJlc3RFbGVtZW50LFxuICAgIFJldHVyblN0YXRlbWVudCxcbiAgICBTZXF1ZW5jZUV4cHJlc3Npb24sXG4gICAgU3ByZWFkRWxlbWVudCxcbiAgICBTdGF0aWNCbG9jayxcbiAgICBTdXBlcixcbiAgICBTd2l0Y2hDYXNlLFxuICAgIFN3aXRjaFN0YXRlbWVudCxcbiAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24sXG4gICAgVGVtcGxhdGVFbGVtZW50LFxuICAgIFRlbXBsYXRlTGl0ZXJhbCxcbiAgICBUaGlzRXhwcmVzc2lvbixcbiAgICBUaHJvd1N0YXRlbWVudCxcbiAgICBUcnlTdGF0ZW1lbnQsXG4gICAgVW5hcnlFeHByZXNzaW9uLFxuICAgIFVwZGF0ZUV4cHJlc3Npb24sXG4gICAgVmFyaWFibGVEZWNsYXJhdGlvbixcbiAgICBWYXJpYWJsZURlY2xhcmF0b3IsXG4gICAgV2hpbGVTdGF0ZW1lbnQsXG4gICAgWWllbGRFeHByZXNzaW9uXG5dO1xuY29uc3QgYnVmZmVyUGFyc2VycyA9IFtcbiAgICBmdW5jdGlvbiBwYW5pY0Vycm9yKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgbm9kZS5tZXNzYWdlID0gYnVmZmVyLmNvbnZlcnRTdHJpbmcoYnVmZmVyW3Bvc2l0aW9uXSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBwYXJzZUVycm9yKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgbm9kZS5tZXNzYWdlID0gYnVmZmVyLmNvbnZlcnRTdHJpbmcoYnVmZmVyW3Bvc2l0aW9uXSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBhcnJheUV4cHJlc3Npb24obm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLmVsZW1lbnRzID0gY29udmVydE5vZGVMaXN0KG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb25dLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gYXJyYXlQYXR0ZXJuKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS5lbGVtZW50cyA9IGNvbnZlcnROb2RlTGlzdChub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGFycm93RnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBidWZmZXJbcG9zaXRpb25dO1xuICAgICAgICBub2RlLmFzeW5jID0gKGZsYWdzICYgMSkgPT09IDE7XG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IChmbGFncyAmIDIpID09PSAyO1xuICAgICAgICBub2RlLmdlbmVyYXRvciA9IChmbGFncyAmIDQpID09PSA0O1xuICAgICAgICBjb25zdCBhbm5vdGF0aW9ucyA9IChub2RlLmFubm90YXRpb25zID0gY29udmVydEFubm90YXRpb25zKGJ1ZmZlcltwb3NpdGlvbiArIDFdLCBidWZmZXIpKTtcbiAgICAgICAgbm9kZS5hbm5vdGF0aW9uTm9TaWRlRWZmZWN0cyA9IGFubm90YXRpb25zLnNvbWUoY29tbWVudCA9PiBjb21tZW50LnR5cGUgPT09ICdub1NpZGVFZmZlY3RzJyk7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSAobm9kZS5wYXJhbXMgPSBjb252ZXJ0Tm9kZUxpc3Qobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbiArIDJdLCBidWZmZXIpKTtcbiAgICAgICAgc2NvcGUuYWRkUGFyYW1ldGVyVmFyaWFibGVzKHBhcmFtZXRlcnMubWFwKHBhcmFtZXRlciA9PiBwYXJhbWV0ZXIuZGVjbGFyZSgncGFyYW1ldGVyJywgVU5LTk9XTl9FWFBSRVNTSU9OKSksIHBhcmFtZXRlcnNbcGFyYW1ldGVycy5sZW5ndGggLSAxXSBpbnN0YW5jZW9mIFJlc3RFbGVtZW50KTtcbiAgICAgICAgbm9kZS5ib2R5ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUuYm9keVNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAzXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGFzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS5vcGVyYXRvciA9IEZJWEVEX1NUUklOR1NbYnVmZmVyW3Bvc2l0aW9uXV07XG4gICAgICAgIG5vZGUubGVmdCA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAxXSwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5yaWdodCA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAyXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGFzc2lnbm1lbnRQYXR0ZXJuKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS5sZWZ0ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUucmlnaHQgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMV0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBhd2FpdEV4cHJlc3Npb24obm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLmFyZ3VtZW50ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBiaW5hcnlFeHByZXNzaW9uKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS5vcGVyYXRvciA9IEZJWEVEX1NUUklOR1NbYnVmZmVyW3Bvc2l0aW9uXV07XG4gICAgICAgIG5vZGUubGVmdCA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAxXSwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5yaWdodCA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAyXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGJsb2NrU3RhdGVtZW50KG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS5ib2R5ID0gY29udmVydE5vZGVMaXN0KG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb25dLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gYnJlYWtTdGF0ZW1lbnQobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBjb25zdCBsYWJlbFBvc2l0aW9uID0gYnVmZmVyW3Bvc2l0aW9uXTtcbiAgICAgICAgbm9kZS5sYWJlbCA9IGxhYmVsUG9zaXRpb24gPT09IDAgPyBudWxsIDogY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGxhYmVsUG9zaXRpb24sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBjYWxsRXhwcmVzc2lvbihub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2NvcGUgfSA9IG5vZGU7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gYnVmZmVyW3Bvc2l0aW9uXTtcbiAgICAgICAgbm9kZS5vcHRpb25hbCA9IChmbGFncyAmIDEpID09PSAxO1xuICAgICAgICBub2RlLmFubm90YXRpb25zID0gY29udmVydEFubm90YXRpb25zKGJ1ZmZlcltwb3NpdGlvbiArIDFdLCBidWZmZXIpO1xuICAgICAgICBub2RlLmNhbGxlZSA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAyXSwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5hcmd1bWVudHMgPSBjb252ZXJ0Tm9kZUxpc3Qobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbiArIDNdLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gY2F0Y2hDbGF1c2Uobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJQb3NpdGlvbiA9IGJ1ZmZlcltwb3NpdGlvbl07XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlciA9IChub2RlLnBhcmFtID1cbiAgICAgICAgICAgIHBhcmFtZXRlclBvc2l0aW9uID09PSAwID8gbnVsbCA6IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBwYXJhbWV0ZXJQb3NpdGlvbiwgYnVmZmVyKSk7XG4gICAgICAgIHBhcmFtZXRlcj8uZGVjbGFyZSgncGFyYW1ldGVyJywgVU5LTk9XTl9FWFBSRVNTSU9OKTtcbiAgICAgICAgbm9kZS5ib2R5ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUuYm9keVNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAxXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGNoYWluRXhwcmVzc2lvbihub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2NvcGUgfSA9IG5vZGU7XG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb25dLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gY2xhc3NCb2R5KG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgYm9keVBvc2l0aW9uID0gYnVmZmVyW3Bvc2l0aW9uXTtcbiAgICAgICAgaWYgKGJvZHlQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gYnVmZmVyW2JvZHlQb3NpdGlvbl07XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gKG5vZGUuYm9keSA9IG5ldyBBcnJheShsZW5ndGgpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlUG9zaXRpb24gPSBidWZmZXJbYm9keVBvc2l0aW9uICsgMSArIGluZGV4XTtcbiAgICAgICAgICAgICAgICBib2R5W2luZGV4XSA9IGNvbnZlcnROb2RlKG5vZGUsIChidWZmZXJbbm9kZVBvc2l0aW9uICsgM10gJiAxKSA9PT0gMCA/IHNjb3BlLmluc3RhbmNlU2NvcGUgOiBzY29wZSwgbm9kZVBvc2l0aW9uLCBidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5ib2R5ID0gW107XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGZ1bmN0aW9uIGNsYXNzRGVjbGFyYXRpb24obm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLmRlY29yYXRvcnMgPSBjb252ZXJ0Tm9kZUxpc3Qobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGlkUG9zaXRpb24gPSBidWZmZXJbcG9zaXRpb24gKyAxXTtcbiAgICAgICAgbm9kZS5pZCA9XG4gICAgICAgICAgICBpZFBvc2l0aW9uID09PSAwID8gbnVsbCA6IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLnBhcmVudCwgaWRQb3NpdGlvbiwgYnVmZmVyKTtcbiAgICAgICAgY29uc3Qgc3VwZXJDbGFzc1Bvc2l0aW9uID0gYnVmZmVyW3Bvc2l0aW9uICsgMl07XG4gICAgICAgIG5vZGUuc3VwZXJDbGFzcyA9XG4gICAgICAgICAgICBzdXBlckNsYXNzUG9zaXRpb24gPT09IDAgPyBudWxsIDogY29udmVydE5vZGUobm9kZSwgc2NvcGUsIHN1cGVyQ2xhc3NQb3NpdGlvbiwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5ib2R5ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbiArIDNdLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gY2xhc3NFeHByZXNzaW9uKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS5kZWNvcmF0b3JzID0gY29udmVydE5vZGVMaXN0KG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb25dLCBidWZmZXIpO1xuICAgICAgICBjb25zdCBpZFBvc2l0aW9uID0gYnVmZmVyW3Bvc2l0aW9uICsgMV07XG4gICAgICAgIG5vZGUuaWQgPSBpZFBvc2l0aW9uID09PSAwID8gbnVsbCA6IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBpZFBvc2l0aW9uLCBidWZmZXIpO1xuICAgICAgICBjb25zdCBzdXBlckNsYXNzUG9zaXRpb24gPSBidWZmZXJbcG9zaXRpb24gKyAyXTtcbiAgICAgICAgbm9kZS5zdXBlckNsYXNzID1cbiAgICAgICAgICAgIHN1cGVyQ2xhc3NQb3NpdGlvbiA9PT0gMCA/IG51bGwgOiBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgc3VwZXJDbGFzc1Bvc2l0aW9uLCBidWZmZXIpO1xuICAgICAgICBub2RlLmJvZHkgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgM10sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBjb25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLnRlc3QgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uXSwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5jb25zZXF1ZW50ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbiArIDFdLCBidWZmZXIpO1xuICAgICAgICBub2RlLmFsdGVybmF0ZSA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAyXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGNvbnRpbnVlU3RhdGVtZW50KG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgbGFiZWxQb3NpdGlvbiA9IGJ1ZmZlcltwb3NpdGlvbl07XG4gICAgICAgIG5vZGUubGFiZWwgPSBsYWJlbFBvc2l0aW9uID09PSAwID8gbnVsbCA6IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBsYWJlbFBvc2l0aW9uLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gZGVidWdnZXJTdGF0ZW1lbnQoKSB7IH0sXG4gICAgZnVuY3Rpb24gZGVjb3JhdG9yKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS5leHByZXNzaW9uID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBkaXJlY3RpdmUobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLmRpcmVjdGl2ZSA9IGJ1ZmZlci5jb252ZXJ0U3RyaW5nKGJ1ZmZlcltwb3NpdGlvbl0pO1xuICAgICAgICBub2RlLmV4cHJlc3Npb24gPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMV0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBkb1doaWxlU3RhdGVtZW50KG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS5ib2R5ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUudGVzdCA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAxXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGVtcHR5U3RhdGVtZW50KCkgeyB9LFxuICAgIGZ1bmN0aW9uIGV4cG9ydEFsbERlY2xhcmF0aW9uKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgZXhwb3J0ZWRQb3NpdGlvbiA9IGJ1ZmZlcltwb3NpdGlvbl07XG4gICAgICAgIG5vZGUuZXhwb3J0ZWQgPVxuICAgICAgICAgICAgZXhwb3J0ZWRQb3NpdGlvbiA9PT0gMCA/IG51bGwgOiBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgZXhwb3J0ZWRQb3NpdGlvbiwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5zb3VyY2UgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMV0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUuYXR0cmlidXRlcyA9IGNvbnZlcnROb2RlTGlzdChub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMl0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBleHBvcnREZWZhdWx0RGVjbGFyYXRpb24obm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLmRlY2xhcmF0aW9uID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBleHBvcnROYW1lZERlY2xhcmF0aW9uKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS5zcGVjaWZpZXJzID0gY29udmVydE5vZGVMaXN0KG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb25dLCBidWZmZXIpO1xuICAgICAgICBjb25zdCBzb3VyY2VQb3NpdGlvbiA9IGJ1ZmZlcltwb3NpdGlvbiArIDFdO1xuICAgICAgICBub2RlLnNvdXJjZSA9IHNvdXJjZVBvc2l0aW9uID09PSAwID8gbnVsbCA6IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBzb3VyY2VQb3NpdGlvbiwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5hdHRyaWJ1dGVzID0gY29udmVydE5vZGVMaXN0KG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAyXSwgYnVmZmVyKTtcbiAgICAgICAgY29uc3QgZGVjbGFyYXRpb25Qb3NpdGlvbiA9IGJ1ZmZlcltwb3NpdGlvbiArIDNdO1xuICAgICAgICBub2RlLmRlY2xhcmF0aW9uID1cbiAgICAgICAgICAgIGRlY2xhcmF0aW9uUG9zaXRpb24gPT09IDAgPyBudWxsIDogY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGRlY2xhcmF0aW9uUG9zaXRpb24sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBleHBvcnRTcGVjaWZpZXIobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLmxvY2FsID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGV4cG9ydGVkUG9zaXRpb24gPSBidWZmZXJbcG9zaXRpb24gKyAxXTtcbiAgICAgICAgbm9kZS5leHBvcnRlZCA9XG4gICAgICAgICAgICBleHBvcnRlZFBvc2l0aW9uID09PSAwID8gbm9kZS5sb2NhbCA6IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBleHBvcnRlZFBvc2l0aW9uLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gZXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2NvcGUgfSA9IG5vZGU7XG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb25dLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gZm9ySW5TdGF0ZW1lbnQobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLmxlZnQgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uXSwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5yaWdodCA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAxXSwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5ib2R5ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbiArIDJdLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gZm9yT2ZTdGF0ZW1lbnQobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBjb25zdCBmbGFncyA9IGJ1ZmZlcltwb3NpdGlvbl07XG4gICAgICAgIG5vZGUuYXdhaXQgPSAoZmxhZ3MgJiAxKSA9PT0gMTtcbiAgICAgICAgbm9kZS5sZWZ0ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbiArIDFdLCBidWZmZXIpO1xuICAgICAgICBub2RlLnJpZ2h0ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbiArIDJdLCBidWZmZXIpO1xuICAgICAgICBub2RlLmJvZHkgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgM10sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBmb3JTdGF0ZW1lbnQobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBjb25zdCBpbml0UG9zaXRpb24gPSBidWZmZXJbcG9zaXRpb25dO1xuICAgICAgICBub2RlLmluaXQgPSBpbml0UG9zaXRpb24gPT09IDAgPyBudWxsIDogY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGluaXRQb3NpdGlvbiwgYnVmZmVyKTtcbiAgICAgICAgY29uc3QgdGVzdFBvc2l0aW9uID0gYnVmZmVyW3Bvc2l0aW9uICsgMV07XG4gICAgICAgIG5vZGUudGVzdCA9IHRlc3RQb3NpdGlvbiA9PT0gMCA/IG51bGwgOiBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgdGVzdFBvc2l0aW9uLCBidWZmZXIpO1xuICAgICAgICBjb25zdCB1cGRhdGVQb3NpdGlvbiA9IGJ1ZmZlcltwb3NpdGlvbiArIDJdO1xuICAgICAgICBub2RlLnVwZGF0ZSA9IHVwZGF0ZVBvc2l0aW9uID09PSAwID8gbnVsbCA6IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCB1cGRhdGVQb3NpdGlvbiwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5ib2R5ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbiArIDNdLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvbihub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2NvcGUgfSA9IG5vZGU7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gYnVmZmVyW3Bvc2l0aW9uXTtcbiAgICAgICAgbm9kZS5hc3luYyA9IChmbGFncyAmIDEpID09PSAxO1xuICAgICAgICBub2RlLmdlbmVyYXRvciA9IChmbGFncyAmIDIpID09PSAyO1xuICAgICAgICBjb25zdCBhbm5vdGF0aW9ucyA9IChub2RlLmFubm90YXRpb25zID0gY29udmVydEFubm90YXRpb25zKGJ1ZmZlcltwb3NpdGlvbiArIDFdLCBidWZmZXIpKTtcbiAgICAgICAgbm9kZS5hbm5vdGF0aW9uTm9TaWRlRWZmZWN0cyA9IGFubm90YXRpb25zLnNvbWUoY29tbWVudCA9PiBjb21tZW50LnR5cGUgPT09ICdub1NpZGVFZmZlY3RzJyk7XG4gICAgICAgIGNvbnN0IGlkUG9zaXRpb24gPSBidWZmZXJbcG9zaXRpb24gKyAyXTtcbiAgICAgICAgbm9kZS5pZCA9XG4gICAgICAgICAgICBpZFBvc2l0aW9uID09PSAwID8gbnVsbCA6IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLnBhcmVudCwgaWRQb3NpdGlvbiwgYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IChub2RlLnBhcmFtcyA9IGNvbnZlcnROb2RlTGlzdChub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgM10sIGJ1ZmZlcikpO1xuICAgICAgICBzY29wZS5hZGRQYXJhbWV0ZXJWYXJpYWJsZXMocGFyYW1ldGVycy5tYXAocGFyYW1ldGVyID0+IHBhcmFtZXRlci5kZWNsYXJlKCdwYXJhbWV0ZXInLCBVTktOT1dOX0VYUFJFU1NJT04pKSwgcGFyYW1ldGVyc1twYXJhbWV0ZXJzLmxlbmd0aCAtIDFdIGluc3RhbmNlb2YgUmVzdEVsZW1lbnQpO1xuICAgICAgICBub2RlLmJvZHkgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZS5ib2R5U2NvcGUsIGJ1ZmZlcltwb3NpdGlvbiArIDRdLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBidWZmZXJbcG9zaXRpb25dO1xuICAgICAgICBub2RlLmFzeW5jID0gKGZsYWdzICYgMSkgPT09IDE7XG4gICAgICAgIG5vZGUuZ2VuZXJhdG9yID0gKGZsYWdzICYgMikgPT09IDI7XG4gICAgICAgIGNvbnN0IGFubm90YXRpb25zID0gKG5vZGUuYW5ub3RhdGlvbnMgPSBjb252ZXJ0QW5ub3RhdGlvbnMoYnVmZmVyW3Bvc2l0aW9uICsgMV0sIGJ1ZmZlcikpO1xuICAgICAgICBub2RlLmFubm90YXRpb25Ob1NpZGVFZmZlY3RzID0gYW5ub3RhdGlvbnMuc29tZShjb21tZW50ID0+IGNvbW1lbnQudHlwZSA9PT0gJ25vU2lkZUVmZmVjdHMnKTtcbiAgICAgICAgY29uc3QgaWRQb3NpdGlvbiA9IGJ1ZmZlcltwb3NpdGlvbiArIDJdO1xuICAgICAgICBub2RlLmlkID0gaWRQb3NpdGlvbiA9PT0gMCA/IG51bGwgOiBjb252ZXJ0Tm9kZShub2RlLCBub2RlLmlkU2NvcGUsIGlkUG9zaXRpb24sIGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSAobm9kZS5wYXJhbXMgPSBjb252ZXJ0Tm9kZUxpc3Qobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbiArIDNdLCBidWZmZXIpKTtcbiAgICAgICAgc2NvcGUuYWRkUGFyYW1ldGVyVmFyaWFibGVzKHBhcmFtZXRlcnMubWFwKHBhcmFtZXRlciA9PiBwYXJhbWV0ZXIuZGVjbGFyZSgncGFyYW1ldGVyJywgVU5LTk9XTl9FWFBSRVNTSU9OKSksIHBhcmFtZXRlcnNbcGFyYW1ldGVycy5sZW5ndGggLSAxXSBpbnN0YW5jZW9mIFJlc3RFbGVtZW50KTtcbiAgICAgICAgbm9kZS5ib2R5ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUuYm9keVNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyA0XSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGlkZW50aWZpZXIobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBub2RlLm5hbWUgPSBidWZmZXIuY29udmVydFN0cmluZyhidWZmZXJbcG9zaXRpb25dKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGlmU3RhdGVtZW50KG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS50ZXN0ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUuY29uc2VxdWVudCA9IGNvbnZlcnROb2RlKG5vZGUsIChub2RlLmNvbnNlcXVlbnRTY29wZSA9IG5ldyBUcmFja2luZ1Njb3BlKHNjb3BlKSksIGJ1ZmZlcltwb3NpdGlvbiArIDFdLCBidWZmZXIpO1xuICAgICAgICBjb25zdCBhbHRlcm5hdGVQb3NpdGlvbiA9IGJ1ZmZlcltwb3NpdGlvbiArIDJdO1xuICAgICAgICBub2RlLmFsdGVybmF0ZSA9XG4gICAgICAgICAgICBhbHRlcm5hdGVQb3NpdGlvbiA9PT0gMFxuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogY29udmVydE5vZGUobm9kZSwgKG5vZGUuYWx0ZXJuYXRlU2NvcGUgPSBuZXcgVHJhY2tpbmdTY29wZShzY29wZSkpLCBhbHRlcm5hdGVQb3NpdGlvbiwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGltcG9ydEF0dHJpYnV0ZShub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2NvcGUgfSA9IG5vZGU7XG4gICAgICAgIG5vZGUua2V5ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUudmFsdWUgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMV0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBpbXBvcnREZWNsYXJhdGlvbihub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2NvcGUgfSA9IG5vZGU7XG4gICAgICAgIG5vZGUuc3BlY2lmaWVycyA9IGNvbnZlcnROb2RlTGlzdChub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uXSwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5zb3VyY2UgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMV0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUuYXR0cmlidXRlcyA9IGNvbnZlcnROb2RlTGlzdChub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMl0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBpbXBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS5sb2NhbCA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb25dLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gaW1wb3J0RXhwcmVzc2lvbihub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2NvcGUgfSA9IG5vZGU7XG4gICAgICAgIG5vZGUuc291cmNlID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUuc291cmNlQXN0Tm9kZSA9IGNvbnZlcnROb2RlJDEoYnVmZmVyW3Bvc2l0aW9uXSwgYnVmZmVyKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uc1Bvc2l0aW9uID0gYnVmZmVyW3Bvc2l0aW9uICsgMV07XG4gICAgICAgIG5vZGUub3B0aW9ucyA9IG9wdGlvbnNQb3NpdGlvbiA9PT0gMCA/IG51bGwgOiBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgb3B0aW9uc1Bvc2l0aW9uLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gaW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS5sb2NhbCA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb25dLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gaW1wb3J0U3BlY2lmaWVyKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgaW1wb3J0ZWRQb3NpdGlvbiA9IGJ1ZmZlcltwb3NpdGlvbl07XG4gICAgICAgIG5vZGUubG9jYWwgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMV0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUuaW1wb3J0ZWQgPVxuICAgICAgICAgICAgaW1wb3J0ZWRQb3NpdGlvbiA9PT0gMCA/IG5vZGUubG9jYWwgOiBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgaW1wb3J0ZWRQb3NpdGlvbiwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGpzeEF0dHJpYnV0ZShub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2NvcGUgfSA9IG5vZGU7XG4gICAgICAgIG5vZGUubmFtZSA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb25dLCBidWZmZXIpO1xuICAgICAgICBjb25zdCB2YWx1ZVBvc2l0aW9uID0gYnVmZmVyW3Bvc2l0aW9uICsgMV07XG4gICAgICAgIG5vZGUudmFsdWUgPSB2YWx1ZVBvc2l0aW9uID09PSAwID8gbnVsbCA6IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCB2YWx1ZVBvc2l0aW9uLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24ganN4Q2xvc2luZ0VsZW1lbnQobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLm5hbWUgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGpzeENsb3NpbmdGcmFnbWVudCgpIHsgfSxcbiAgICBmdW5jdGlvbiBqc3hFbGVtZW50KG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS5vcGVuaW5nRWxlbWVudCA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb25dLCBidWZmZXIpO1xuICAgICAgICBub2RlLmNoaWxkcmVuID0gY29udmVydE5vZGVMaXN0KG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAxXSwgYnVmZmVyKTtcbiAgICAgICAgY29uc3QgY2xvc2luZ0VsZW1lbnRQb3NpdGlvbiA9IGJ1ZmZlcltwb3NpdGlvbiArIDJdO1xuICAgICAgICBub2RlLmNsb3NpbmdFbGVtZW50ID1cbiAgICAgICAgICAgIGNsb3NpbmdFbGVtZW50UG9zaXRpb24gPT09IDBcbiAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICA6IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBjbG9zaW5nRWxlbWVudFBvc2l0aW9uLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24ganN4RW1wdHlFeHByZXNzaW9uKCkgeyB9LFxuICAgIGZ1bmN0aW9uIGpzeEV4cHJlc3Npb25Db250YWluZXIobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLmV4cHJlc3Npb24gPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGpzeEZyYWdtZW50KG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS5vcGVuaW5nRnJhZ21lbnQgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uXSwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5jaGlsZHJlbiA9IGNvbnZlcnROb2RlTGlzdChub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMV0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUuY2xvc2luZ0ZyYWdtZW50ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbiArIDJdLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24ganN4SWRlbnRpZmllcihub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIG5vZGUubmFtZSA9IGJ1ZmZlci5jb252ZXJ0U3RyaW5nKGJ1ZmZlcltwb3NpdGlvbl0pO1xuICAgIH0sXG4gICAgZnVuY3Rpb24ganN4TWVtYmVyRXhwcmVzc2lvbihub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2NvcGUgfSA9IG5vZGU7XG4gICAgICAgIG5vZGUub2JqZWN0ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUucHJvcGVydHkgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMV0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBqc3hOYW1lc3BhY2VkTmFtZShub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2NvcGUgfSA9IG5vZGU7XG4gICAgICAgIG5vZGUubmFtZXNwYWNlID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUubmFtZSA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAxXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGpzeE9wZW5pbmdFbGVtZW50KG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBidWZmZXJbcG9zaXRpb25dO1xuICAgICAgICBub2RlLnNlbGZDbG9zaW5nID0gKGZsYWdzICYgMSkgPT09IDE7XG4gICAgICAgIG5vZGUubmFtZSA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAxXSwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5hdHRyaWJ1dGVzID0gY29udmVydE5vZGVMaXN0KG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAyXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGpzeE9wZW5pbmdGcmFnbWVudChub2RlKSB7XG4gICAgICAgIG5vZGUuYXR0cmlidXRlcyA9IFtdO1xuICAgICAgICBub2RlLnNlbGZDbG9zaW5nID0gZmFsc2U7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBqc3hTcHJlYWRBdHRyaWJ1dGUobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLmFyZ3VtZW50ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBqc3hTcHJlYWRDaGlsZChub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2NvcGUgfSA9IG5vZGU7XG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb25dLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24ganN4VGV4dChub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSBidWZmZXIuY29udmVydFN0cmluZyhidWZmZXJbcG9zaXRpb25dKTtcbiAgICAgICAgbm9kZS5yYXcgPSBidWZmZXIuY29udmVydFN0cmluZyhidWZmZXJbcG9zaXRpb24gKyAxXSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBsYWJlbGVkU3RhdGVtZW50KG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS5sYWJlbCA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb25dLCBidWZmZXIpO1xuICAgICAgICBub2RlLmJvZHkgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMV0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBsaXRlcmFsQmlnSW50KG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgYmlnaW50ID0gKG5vZGUuYmlnaW50ID0gYnVmZmVyLmNvbnZlcnRTdHJpbmcoYnVmZmVyW3Bvc2l0aW9uXSkpO1xuICAgICAgICBub2RlLnJhdyA9IGJ1ZmZlci5jb252ZXJ0U3RyaW5nKGJ1ZmZlcltwb3NpdGlvbiArIDFdKTtcbiAgICAgICAgbm9kZS52YWx1ZSA9IEJpZ0ludChiaWdpbnQpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gbGl0ZXJhbEJvb2xlYW4obm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBmbGFncyA9IGJ1ZmZlcltwb3NpdGlvbl07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gKG5vZGUudmFsdWUgPSAoZmxhZ3MgJiAxKSA9PT0gMSk7XG4gICAgICAgIG5vZGUucmF3ID0gdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gbGl0ZXJhbE51bGwobm9kZSkge1xuICAgICAgICBub2RlLnZhbHVlID0gbnVsbDtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGxpdGVyYWxOdW1iZXIobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCByYXdQb3NpdGlvbiA9IGJ1ZmZlcltwb3NpdGlvbl07XG4gICAgICAgIG5vZGUucmF3ID0gcmF3UG9zaXRpb24gPT09IDAgPyB1bmRlZmluZWQgOiBidWZmZXIuY29udmVydFN0cmluZyhyYXdQb3NpdGlvbik7XG4gICAgICAgIG5vZGUudmFsdWUgPSBuZXcgRGF0YVZpZXcoYnVmZmVyLmJ1ZmZlcikuZ2V0RmxvYXQ2NCgocG9zaXRpb24gKyAxKSA8PCAyLCB0cnVlKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGxpdGVyYWxSZWdFeHAobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBmbGFncyA9IGJ1ZmZlci5jb252ZXJ0U3RyaW5nKGJ1ZmZlcltwb3NpdGlvbl0pO1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gYnVmZmVyLmNvbnZlcnRTdHJpbmcoYnVmZmVyW3Bvc2l0aW9uICsgMV0pO1xuICAgICAgICBub2RlLnJhdyA9IGAvJHtwYXR0ZXJufS8ke2ZsYWdzfWA7XG4gICAgICAgIG5vZGUucmVnZXggPSB7IGZsYWdzLCBwYXR0ZXJuIH07XG4gICAgICAgIG5vZGUudmFsdWUgPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIGxpdGVyYWxTdHJpbmcobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBub2RlLnZhbHVlID0gYnVmZmVyLmNvbnZlcnRTdHJpbmcoYnVmZmVyW3Bvc2l0aW9uXSk7XG4gICAgICAgIGNvbnN0IHJhd1Bvc2l0aW9uID0gYnVmZmVyW3Bvc2l0aW9uICsgMV07XG4gICAgICAgIG5vZGUucmF3ID0gcmF3UG9zaXRpb24gPT09IDAgPyB1bmRlZmluZWQgOiBidWZmZXIuY29udmVydFN0cmluZyhyYXdQb3NpdGlvbik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBsb2dpY2FsRXhwcmVzc2lvbihub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2NvcGUgfSA9IG5vZGU7XG4gICAgICAgIG5vZGUub3BlcmF0b3IgPSBGSVhFRF9TVFJJTkdTW2J1ZmZlcltwb3NpdGlvbl1dO1xuICAgICAgICBub2RlLmxlZnQgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMV0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUucmlnaHQgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMl0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBtZW1iZXJFeHByZXNzaW9uKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBidWZmZXJbcG9zaXRpb25dO1xuICAgICAgICBub2RlLmNvbXB1dGVkID0gKGZsYWdzICYgMSkgPT09IDE7XG4gICAgICAgIG5vZGUub3B0aW9uYWwgPSAoZmxhZ3MgJiAyKSA9PT0gMjtcbiAgICAgICAgbm9kZS5vYmplY3QgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMV0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUucHJvcGVydHkgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMl0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBtZXRhUHJvcGVydHkobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLm1ldGEgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uXSwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5wcm9wZXJ0eSA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAxXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIG1ldGhvZERlZmluaXRpb24obm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBjb25zdCBmbGFncyA9IGJ1ZmZlcltwb3NpdGlvbl07XG4gICAgICAgIG5vZGUuc3RhdGljID0gKGZsYWdzICYgMSkgPT09IDE7XG4gICAgICAgIG5vZGUuY29tcHV0ZWQgPSAoZmxhZ3MgJiAyKSA9PT0gMjtcbiAgICAgICAgbm9kZS5kZWNvcmF0b3JzID0gY29udmVydE5vZGVMaXN0KG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAxXSwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5rZXkgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMl0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUudmFsdWUgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgM10sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUua2luZCA9IEZJWEVEX1NUUklOR1NbYnVmZmVyW3Bvc2l0aW9uICsgNF1dO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gbmV3RXhwcmVzc2lvbihub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2NvcGUgfSA9IG5vZGU7XG4gICAgICAgIG5vZGUuYW5ub3RhdGlvbnMgPSBjb252ZXJ0QW5ub3RhdGlvbnMoYnVmZmVyW3Bvc2l0aW9uXSwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5jYWxsZWUgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMV0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUuYXJndW1lbnRzID0gY29udmVydE5vZGVMaXN0KG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAyXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIG9iamVjdEV4cHJlc3Npb24obm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLnByb3BlcnRpZXMgPSBjb252ZXJ0Tm9kZUxpc3Qobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBvYmplY3RQYXR0ZXJuKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS5wcm9wZXJ0aWVzID0gY29udmVydE5vZGVMaXN0KG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb25dLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gcHJpdmF0ZUlkZW50aWZpZXIobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBub2RlLm5hbWUgPSBidWZmZXIuY29udmVydFN0cmluZyhidWZmZXJbcG9zaXRpb25dKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHByb2dyYW0obm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLmJvZHkgPSBjb252ZXJ0Tm9kZUxpc3Qobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUuaW52YWxpZEFubm90YXRpb25zID0gY29udmVydEFubm90YXRpb25zKGJ1ZmZlcltwb3NpdGlvbiArIDFdLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gcHJvcGVydHkobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBjb25zdCBmbGFncyA9IGJ1ZmZlcltwb3NpdGlvbl07XG4gICAgICAgIG5vZGUubWV0aG9kID0gKGZsYWdzICYgMSkgPT09IDE7XG4gICAgICAgIG5vZGUuc2hvcnRoYW5kID0gKGZsYWdzICYgMikgPT09IDI7XG4gICAgICAgIG5vZGUuY29tcHV0ZWQgPSAoZmxhZ3MgJiA0KSA9PT0gNDtcbiAgICAgICAgY29uc3Qga2V5UG9zaXRpb24gPSBidWZmZXJbcG9zaXRpb24gKyAxXTtcbiAgICAgICAgbm9kZS52YWx1ZSA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAyXSwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5raW5kID0gRklYRURfU1RSSU5HU1tidWZmZXJbcG9zaXRpb24gKyAzXV07XG4gICAgICAgIG5vZGUua2V5ID0ga2V5UG9zaXRpb24gPT09IDAgPyBub2RlLnZhbHVlIDogY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGtleVBvc2l0aW9uLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gcHJvcGVydHlEZWZpbml0aW9uKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBidWZmZXJbcG9zaXRpb25dO1xuICAgICAgICBub2RlLnN0YXRpYyA9IChmbGFncyAmIDEpID09PSAxO1xuICAgICAgICBub2RlLmNvbXB1dGVkID0gKGZsYWdzICYgMikgPT09IDI7XG4gICAgICAgIG5vZGUuZGVjb3JhdG9ycyA9IGNvbnZlcnROb2RlTGlzdChub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMV0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUua2V5ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbiArIDJdLCBidWZmZXIpO1xuICAgICAgICBjb25zdCB2YWx1ZVBvc2l0aW9uID0gYnVmZmVyW3Bvc2l0aW9uICsgM107XG4gICAgICAgIG5vZGUudmFsdWUgPSB2YWx1ZVBvc2l0aW9uID09PSAwID8gbnVsbCA6IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCB2YWx1ZVBvc2l0aW9uLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gcmVzdEVsZW1lbnQobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLmFyZ3VtZW50ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiByZXR1cm5TdGF0ZW1lbnQobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBjb25zdCBhcmd1bWVudFBvc2l0aW9uID0gYnVmZmVyW3Bvc2l0aW9uXTtcbiAgICAgICAgbm9kZS5hcmd1bWVudCA9XG4gICAgICAgICAgICBhcmd1bWVudFBvc2l0aW9uID09PSAwID8gbnVsbCA6IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBhcmd1bWVudFBvc2l0aW9uLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gc2VxdWVuY2VFeHByZXNzaW9uKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS5leHByZXNzaW9ucyA9IGNvbnZlcnROb2RlTGlzdChub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHNwcmVhZEVsZW1lbnQobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLmFyZ3VtZW50ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBzdGF0aWNCbG9jayhub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2NvcGUgfSA9IG5vZGU7XG4gICAgICAgIG5vZGUuYm9keSA9IGNvbnZlcnROb2RlTGlzdChub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHN1cGVyRWxlbWVudCgpIHsgfSxcbiAgICBmdW5jdGlvbiBzd2l0Y2hDYXNlKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgdGVzdFBvc2l0aW9uID0gYnVmZmVyW3Bvc2l0aW9uXTtcbiAgICAgICAgbm9kZS50ZXN0ID0gdGVzdFBvc2l0aW9uID09PSAwID8gbnVsbCA6IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCB0ZXN0UG9zaXRpb24sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUuY29uc2VxdWVudCA9IGNvbnZlcnROb2RlTGlzdChub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMV0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBzd2l0Y2hTdGF0ZW1lbnQobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLmRpc2NyaW1pbmFudCA9IGNvbnZlcnROb2RlKG5vZGUsIG5vZGUucGFyZW50U2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUuY2FzZXMgPSBjb252ZXJ0Tm9kZUxpc3Qobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbiArIDFdLCBidWZmZXIpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gdGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS50YWcgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uXSwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5xdWFzaSA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAxXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHRlbXBsYXRlRWxlbWVudChub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gYnVmZmVyW3Bvc2l0aW9uXTtcbiAgICAgICAgbm9kZS50YWlsID0gKGZsYWdzICYgMSkgPT09IDE7XG4gICAgICAgIGNvbnN0IGNvb2tlZFBvc2l0aW9uID0gYnVmZmVyW3Bvc2l0aW9uICsgMV07XG4gICAgICAgIGNvbnN0IGNvb2tlZCA9IGNvb2tlZFBvc2l0aW9uID09PSAwID8gdW5kZWZpbmVkIDogYnVmZmVyLmNvbnZlcnRTdHJpbmcoY29va2VkUG9zaXRpb24pO1xuICAgICAgICBjb25zdCByYXcgPSBidWZmZXIuY29udmVydFN0cmluZyhidWZmZXJbcG9zaXRpb24gKyAyXSk7XG4gICAgICAgIG5vZGUudmFsdWUgPSB7IGNvb2tlZCwgcmF3IH07XG4gICAgfSxcbiAgICBmdW5jdGlvbiB0ZW1wbGF0ZUxpdGVyYWwobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLnF1YXNpcyA9IGNvbnZlcnROb2RlTGlzdChub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uXSwgYnVmZmVyKTtcbiAgICAgICAgbm9kZS5leHByZXNzaW9ucyA9IGNvbnZlcnROb2RlTGlzdChub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMV0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiB0aGlzRXhwcmVzc2lvbigpIHsgfSxcbiAgICBmdW5jdGlvbiB0aHJvd1N0YXRlbWVudChub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2NvcGUgfSA9IG5vZGU7XG4gICAgICAgIG5vZGUuYXJndW1lbnQgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHRyeVN0YXRlbWVudChub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2NvcGUgfSA9IG5vZGU7XG4gICAgICAgIG5vZGUuYmxvY2sgPSBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uXSwgYnVmZmVyKTtcbiAgICAgICAgY29uc3QgaGFuZGxlclBvc2l0aW9uID0gYnVmZmVyW3Bvc2l0aW9uICsgMV07XG4gICAgICAgIG5vZGUuaGFuZGxlciA9IGhhbmRsZXJQb3NpdGlvbiA9PT0gMCA/IG51bGwgOiBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgaGFuZGxlclBvc2l0aW9uLCBidWZmZXIpO1xuICAgICAgICBjb25zdCBmaW5hbGl6ZXJQb3NpdGlvbiA9IGJ1ZmZlcltwb3NpdGlvbiArIDJdO1xuICAgICAgICBub2RlLmZpbmFsaXplciA9XG4gICAgICAgICAgICBmaW5hbGl6ZXJQb3NpdGlvbiA9PT0gMCA/IG51bGwgOiBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgZmluYWxpemVyUG9zaXRpb24sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiB1bmFyeUV4cHJlc3Npb24obm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLm9wZXJhdG9yID0gRklYRURfU1RSSU5HU1tidWZmZXJbcG9zaXRpb25dXTtcbiAgICAgICAgbm9kZS5hcmd1bWVudCA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAxXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHVwZGF0ZUV4cHJlc3Npb24obm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBjb25zdCBmbGFncyA9IGJ1ZmZlcltwb3NpdGlvbl07XG4gICAgICAgIG5vZGUucHJlZml4ID0gKGZsYWdzICYgMSkgPT09IDE7XG4gICAgICAgIG5vZGUub3BlcmF0b3IgPSBGSVhFRF9TVFJJTkdTW2J1ZmZlcltwb3NpdGlvbiArIDFdXTtcbiAgICAgICAgbm9kZS5hcmd1bWVudCA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAyXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHZhcmlhYmxlRGVjbGFyYXRpb24obm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLmtpbmQgPSBGSVhFRF9TVFJJTkdTW2J1ZmZlcltwb3NpdGlvbl1dO1xuICAgICAgICBub2RlLmRlY2xhcmF0aW9ucyA9IGNvbnZlcnROb2RlTGlzdChub2RlLCBzY29wZSwgYnVmZmVyW3Bvc2l0aW9uICsgMV0sIGJ1ZmZlcik7XG4gICAgfSxcbiAgICBmdW5jdGlvbiB2YXJpYWJsZURlY2xhcmF0b3Iobm9kZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB7IHNjb3BlIH0gPSBub2RlO1xuICAgICAgICBub2RlLmlkID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGluaXRQb3NpdGlvbiA9IGJ1ZmZlcltwb3NpdGlvbiArIDFdO1xuICAgICAgICBub2RlLmluaXQgPSBpbml0UG9zaXRpb24gPT09IDAgPyBudWxsIDogY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGluaXRQb3NpdGlvbiwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHdoaWxlU3RhdGVtZW50KG5vZGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzY29wZSB9ID0gbm9kZTtcbiAgICAgICAgbm9kZS50ZXN0ID0gY29udmVydE5vZGUobm9kZSwgc2NvcGUsIGJ1ZmZlcltwb3NpdGlvbl0sIGJ1ZmZlcik7XG4gICAgICAgIG5vZGUuYm9keSA9IGNvbnZlcnROb2RlKG5vZGUsIHNjb3BlLCBidWZmZXJbcG9zaXRpb24gKyAxXSwgYnVmZmVyKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIHlpZWxkRXhwcmVzc2lvbihub2RlLCBwb3NpdGlvbiwgYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHsgc2NvcGUgfSA9IG5vZGU7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gYnVmZmVyW3Bvc2l0aW9uXTtcbiAgICAgICAgbm9kZS5kZWxlZ2F0ZSA9IChmbGFncyAmIDEpID09PSAxO1xuICAgICAgICBjb25zdCBhcmd1bWVudFBvc2l0aW9uID0gYnVmZmVyW3Bvc2l0aW9uICsgMV07XG4gICAgICAgIG5vZGUuYXJndW1lbnQgPVxuICAgICAgICAgICAgYXJndW1lbnRQb3NpdGlvbiA9PT0gMCA/IG51bGwgOiBjb252ZXJ0Tm9kZShub2RlLCBzY29wZSwgYXJndW1lbnRQb3NpdGlvbiwgYnVmZmVyKTtcbiAgICB9XG5dO1xuZnVuY3Rpb24gY29udmVydE5vZGUocGFyZW50LCBwYXJlbnRTY29wZSwgcG9zaXRpb24sIGJ1ZmZlcikge1xuICAgIGNvbnN0IG5vZGVUeXBlID0gYnVmZmVyW3Bvc2l0aW9uXTtcbiAgICBjb25zdCBOb2RlQ29uc3RydWN0b3IgPSBub2RlQ29uc3RydWN0b3JzJDFbbm9kZVR5cGVdO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogVGhpcyBzaG91bGQgbmV2ZXIgYmUgZXhlY3V0ZWQgYnV0IGlzIGEgc2FmZWd1YXJkIGFnYWluc3QgZmF1bHR5IGJ1ZmZlcnMgKi9cbiAgICBpZiAoIU5vZGVDb25zdHJ1Y3Rvcikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBub2RlIHR5cGU6ICR7bm9kZVR5cGV9YCk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBuZXcgTm9kZUNvbnN0cnVjdG9yKHBhcmVudCwgcGFyZW50U2NvcGUpO1xuICAgIG5vZGUudHlwZSA9IG5vZGVUeXBlU3RyaW5nc1tub2RlVHlwZV07XG4gICAgbm9kZS5zdGFydCA9IGJ1ZmZlcltwb3NpdGlvbiArIDFdO1xuICAgIG5vZGUuZW5kID0gYnVmZmVyW3Bvc2l0aW9uICsgMl07XG4gICAgYnVmZmVyUGFyc2Vyc1tub2RlVHlwZV0obm9kZSwgcG9zaXRpb24gKyAzLCBidWZmZXIpO1xuICAgIG5vZGUuaW5pdGlhbGlzZSgpO1xuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY29udmVydE5vZGVMaXN0KHBhcmVudCwgcGFyZW50U2NvcGUsIHBvc2l0aW9uLCBidWZmZXIpIHtcbiAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgIHJldHVybiBFTVBUWV9BUlJBWTtcbiAgICBjb25zdCBsZW5ndGggPSBidWZmZXJbcG9zaXRpb24rK107XG4gICAgY29uc3QgbGlzdCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29uc3Qgbm9kZVBvc2l0aW9uID0gYnVmZmVyW3Bvc2l0aW9uKytdO1xuICAgICAgICBsaXN0W2luZGV4XSA9IG5vZGVQb3NpdGlvbiA/IGNvbnZlcnROb2RlKHBhcmVudCwgcGFyZW50U2NvcGUsIG5vZGVQb3NpdGlvbiwgYnVmZmVyKSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufVxuXG5jbGFzcyBVbmtub3duTm9kZSBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBoYXNFZmZlY3RzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5jbHVkZShjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyLmluY2x1ZGUoY29udGV4dCwgdHJ1ZSk7XG4gICAgfVxufVxuXG4vLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHNjcmlwdHMvZ2VuZXJhdGUtbm9kZS1pbmRleC5qcy5cbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBkaXJlY3RseS5cbmNvbnN0IG5vZGVDb25zdHJ1Y3RvcnMgPSB7XG4gICAgQXJyYXlFeHByZXNzaW9uLFxuICAgIEFycmF5UGF0dGVybixcbiAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbixcbiAgICBBc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgICBBc3NpZ25tZW50UGF0dGVybixcbiAgICBBd2FpdEV4cHJlc3Npb24sXG4gICAgQmluYXJ5RXhwcmVzc2lvbixcbiAgICBCbG9ja1N0YXRlbWVudCxcbiAgICBCcmVha1N0YXRlbWVudCxcbiAgICBDYWxsRXhwcmVzc2lvbixcbiAgICBDYXRjaENsYXVzZSxcbiAgICBDaGFpbkV4cHJlc3Npb24sXG4gICAgQ2xhc3NCb2R5LFxuICAgIENsYXNzRGVjbGFyYXRpb24sXG4gICAgQ2xhc3NFeHByZXNzaW9uLFxuICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbixcbiAgICBDb250aW51ZVN0YXRlbWVudCxcbiAgICBEZWJ1Z2dlclN0YXRlbWVudCxcbiAgICBEZWNvcmF0b3IsXG4gICAgRG9XaGlsZVN0YXRlbWVudCxcbiAgICBFbXB0eVN0YXRlbWVudCxcbiAgICBFeHBvcnRBbGxEZWNsYXJhdGlvbixcbiAgICBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24sXG4gICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbixcbiAgICBFeHBvcnRTcGVjaWZpZXIsXG4gICAgRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgICBGb3JJblN0YXRlbWVudCxcbiAgICBGb3JPZlN0YXRlbWVudCxcbiAgICBGb3JTdGF0ZW1lbnQsXG4gICAgRnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgICBGdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgSWRlbnRpZmllcixcbiAgICBJZlN0YXRlbWVudCxcbiAgICBJbXBvcnRBdHRyaWJ1dGUsXG4gICAgSW1wb3J0RGVjbGFyYXRpb24sXG4gICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcixcbiAgICBJbXBvcnRFeHByZXNzaW9uLFxuICAgIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcixcbiAgICBJbXBvcnRTcGVjaWZpZXIsXG4gICAgSlNYQXR0cmlidXRlLFxuICAgIEpTWENsb3NpbmdFbGVtZW50LFxuICAgIEpTWENsb3NpbmdGcmFnbWVudCxcbiAgICBKU1hFbGVtZW50LFxuICAgIEpTWEVtcHR5RXhwcmVzc2lvbixcbiAgICBKU1hFeHByZXNzaW9uQ29udGFpbmVyLFxuICAgIEpTWEZyYWdtZW50LFxuICAgIEpTWElkZW50aWZpZXIsXG4gICAgSlNYTWVtYmVyRXhwcmVzc2lvbixcbiAgICBKU1hOYW1lc3BhY2VkTmFtZSxcbiAgICBKU1hPcGVuaW5nRWxlbWVudCxcbiAgICBKU1hPcGVuaW5nRnJhZ21lbnQsXG4gICAgSlNYU3ByZWFkQXR0cmlidXRlLFxuICAgIEpTWFNwcmVhZENoaWxkLFxuICAgIEpTWFRleHQsXG4gICAgTGFiZWxlZFN0YXRlbWVudCxcbiAgICBMaXRlcmFsLFxuICAgIExvZ2ljYWxFeHByZXNzaW9uLFxuICAgIE1lbWJlckV4cHJlc3Npb24sXG4gICAgTWV0YVByb3BlcnR5LFxuICAgIE1ldGhvZERlZmluaXRpb24sXG4gICAgTmV3RXhwcmVzc2lvbixcbiAgICBPYmplY3RFeHByZXNzaW9uLFxuICAgIE9iamVjdFBhdHRlcm4sXG4gICAgUGFuaWNFcnJvcixcbiAgICBQYXJzZUVycm9yLFxuICAgIFByaXZhdGVJZGVudGlmaWVyLFxuICAgIFByb2dyYW0sXG4gICAgUHJvcGVydHksXG4gICAgUHJvcGVydHlEZWZpbml0aW9uLFxuICAgIFJlc3RFbGVtZW50LFxuICAgIFJldHVyblN0YXRlbWVudCxcbiAgICBTZXF1ZW5jZUV4cHJlc3Npb24sXG4gICAgU3ByZWFkRWxlbWVudCxcbiAgICBTdGF0aWNCbG9jayxcbiAgICBTdXBlcixcbiAgICBTd2l0Y2hDYXNlLFxuICAgIFN3aXRjaFN0YXRlbWVudCxcbiAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24sXG4gICAgVGVtcGxhdGVFbGVtZW50LFxuICAgIFRlbXBsYXRlTGl0ZXJhbCxcbiAgICBUaGlzRXhwcmVzc2lvbixcbiAgICBUaHJvd1N0YXRlbWVudCxcbiAgICBUcnlTdGF0ZW1lbnQsXG4gICAgVW5hcnlFeHByZXNzaW9uLFxuICAgIFVua25vd25Ob2RlLFxuICAgIFVwZGF0ZUV4cHJlc3Npb24sXG4gICAgVmFyaWFibGVEZWNsYXJhdGlvbixcbiAgICBWYXJpYWJsZURlY2xhcmF0b3IsXG4gICAgV2hpbGVTdGF0ZW1lbnQsXG4gICAgWWllbGRFeHByZXNzaW9uXG59O1xuXG5jbGFzcyBFeHBvcnRTaGltVmFyaWFibGUgZXh0ZW5kcyBWYXJpYWJsZSB7XG4gICAgY29uc3RydWN0b3IobW9kdWxlKSB7XG4gICAgICAgIHN1cGVyKE1JU1NJTkdfRVhQT1JUX1NISU1fVkFSSUFCTEUpO1xuICAgICAgICB0aGlzLm1vZHVsZSA9IG1vZHVsZTtcbiAgICB9XG4gICAgaW5jbHVkZSgpIHtcbiAgICAgICAgc3VwZXIuaW5jbHVkZSgpO1xuICAgICAgICB0aGlzLm1vZHVsZS5uZWVkc0V4cG9ydFNoaW0gPSB0cnVlO1xuICAgIH1cbn1cblxudmFyIEJ1aWxkUGhhc2U7XG4oZnVuY3Rpb24gKEJ1aWxkUGhhc2UpIHtcbiAgICBCdWlsZFBoYXNlW0J1aWxkUGhhc2VbXCJMT0FEX0FORF9QQVJTRVwiXSA9IDBdID0gXCJMT0FEX0FORF9QQVJTRVwiO1xuICAgIEJ1aWxkUGhhc2VbQnVpbGRQaGFzZVtcIkFOQUxZU0VcIl0gPSAxXSA9IFwiQU5BTFlTRVwiO1xuICAgIEJ1aWxkUGhhc2VbQnVpbGRQaGFzZVtcIkdFTkVSQVRFXCJdID0gMl0gPSBcIkdFTkVSQVRFXCI7XG59KShCdWlsZFBoYXNlIHx8IChCdWlsZFBoYXNlID0ge30pKTtcblxuY29uc3Qgc291cmNlTWFwQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBUaGlzIGNsZWFycyB0aGUgZGVjb2RlZCBhcnJheSBhbmQgZmFsbHMgYmFjayB0byB0aGUgZW5jb2RlZCBzdHJpbmcgZm9ybS5cbiAqIFNvdXJjZW1hcCBtYXBwaW5ncyBhcnJheXMgY2FuIGJlIHZlcnkgbGFyZ2UgYW5kIGhvbGRpbmcgb24gdG8gdGhlbSBmb3IgbG9uZ2VyXG4gKiB0aGFuIGlzIG5lY2Vzc2FyeSBsZWFkcyB0byBwb29yIGhlYXAgdXRpbGl6YXRpb24uXG4gKi9cbmZ1bmN0aW9uIHJlc2V0Q2FjaGVUb0VuY29kZWQoY2FjaGUpIHtcbiAgICBpZiAoY2FjaGUuZW5jb2RlZE1hcHBpbmdzID09PSB1bmRlZmluZWQgJiYgY2FjaGUuZGVjb2RlZE1hcHBpbmdzKSB7XG4gICAgICAgIGNhY2hlLmVuY29kZWRNYXBwaW5ncyA9IGVuY29kZShjYWNoZS5kZWNvZGVkTWFwcGluZ3MpO1xuICAgIH1cbiAgICBjYWNoZS5kZWNvZGVkTWFwcGluZ3MgPSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiByZXNldFNvdXJjZW1hcENhY2hlKG1hcCwgc291cmNlbWFwQ2hhaW4pIHtcbiAgICBpZiAobWFwKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gc291cmNlTWFwQ2FjaGUuZ2V0KG1hcCk7XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgICAgcmVzZXRDYWNoZVRvRW5jb2RlZChjYWNoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzb3VyY2VtYXBDaGFpbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgbWFwIG9mIHNvdXJjZW1hcENoYWluKSB7XG4gICAgICAgIGlmIChtYXAubWlzc2luZylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICByZXNldFNvdXJjZW1hcENhY2hlKG1hcCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVjb2RlZFNvdXJjZW1hcChtYXApIHtcbiAgICBpZiAoIW1hcClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKHR5cGVvZiBtYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcCA9IEpTT04ucGFyc2UobWFwKTtcbiAgICB9XG4gICAgaWYgKCFtYXAubWFwcGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hcHBpbmdzOiBbXSxcbiAgICAgICAgICAgIG5hbWVzOiBbXSxcbiAgICAgICAgICAgIHNvdXJjZXM6IFtdLFxuICAgICAgICAgICAgdmVyc2lvbjogM1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBvcmlnaW5hbE1hcHBpbmdzID0gbWFwLm1hcHBpbmdzO1xuICAgIGNvbnN0IGlzQWxyZWFkeURlY29kZWQgPSBBcnJheS5pc0FycmF5KG9yaWdpbmFsTWFwcGluZ3MpO1xuICAgIGNvbnN0IGNhY2hlID0ge1xuICAgICAgICBkZWNvZGVkTWFwcGluZ3M6IGlzQWxyZWFkeURlY29kZWQgPyBvcmlnaW5hbE1hcHBpbmdzIDogdW5kZWZpbmVkLFxuICAgICAgICBlbmNvZGVkTWFwcGluZ3M6IGlzQWxyZWFkeURlY29kZWQgPyB1bmRlZmluZWQgOiBvcmlnaW5hbE1hcHBpbmdzXG4gICAgfTtcbiAgICBjb25zdCBkZWNvZGVkTWFwID0ge1xuICAgICAgICAuLi5tYXAsXG4gICAgICAgIC8vIEJ5IG1vdmluZyBtYXBwaW5ncyBiZWhpbmQgYW4gYWNjZXNzb3IsIHdlIGNhbiBhdm9pZCB1bm5lZWRlZCBjb21wdXRhdGlvbiBmb3IgY2FzZXNcbiAgICAgICAgLy8gd2hlcmUgdGhlIG1hcHBpbmdzIGZpZWxkIGlzIG5ldmVyIGFjdHVhbGx5IGFjY2Vzc2VkLiBUaGlzIGFwcGVhcnMgdG8gZ3JlYXRseSByZWR1Y2VcbiAgICAgICAgLy8gdGhlIG92ZXJoZWFkIG9mIHNvdXJjZW1hcCBkZWNvZGluZyBpbiB0ZXJtcyBvZiBib3RoIGNvbXB1dGUgdGltZSBhbmQgbWVtb3J5IHVzYWdlLlxuICAgICAgICBnZXQgbWFwcGluZ3MoKSB7XG4gICAgICAgICAgICBpZiAoY2FjaGUuZGVjb2RlZE1hcHBpbmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmRlY29kZWRNYXBwaW5ncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGRlY29kZWRNYXBwaW5ncyBkb2Vzbid0IGV4aXN0IHRoZW4gZW5jb2RlZE1hcHBpbmdzIHNob3VsZC5cbiAgICAgICAgICAgIC8vIFRoZSBvbmx5IHNjZW5hcmlvIHdoZXJlIGNhY2hlLmVuY29kZWRNYXBwaW5ncyBzaG91bGQgYmUgdW5kZWZpbmVkIGlzIGlmIHRoZSBtYXBcbiAgICAgICAgICAgIC8vIHRoaXMgd2FzIGNvbnN0cnVjdGVkIGZyb20gd2FzIGFscmVhZHkgZGVjb2RlZCwgb3IgaWYgbWFwcGluZ3Mgd2FzIHNldCB0byBhIG5ld1xuICAgICAgICAgICAgLy8gZGVjb2RlZCBzdHJpbmcuIEluIGVpdGhlciBjYXNlLCB0aGlzIGxpbmUgc2hvdWxkbid0IGdldCBoaXQuXG4gICAgICAgICAgICBjYWNoZS5kZWNvZGVkTWFwcGluZ3MgPSBjYWNoZS5lbmNvZGVkTWFwcGluZ3MgPyBkZWNvZGUoY2FjaGUuZW5jb2RlZE1hcHBpbmdzKSA6IFtdO1xuICAgICAgICAgICAgY2FjaGUuZW5jb2RlZE1hcHBpbmdzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmRlY29kZWRNYXBwaW5ncztcbiAgICAgICAgfVxuICAgIH07XG4gICAgc291cmNlTWFwQ2FjaGUuc2V0KGRlY29kZWRNYXAsIGNhY2hlKTtcbiAgICByZXR1cm4gZGVjb2RlZE1hcDtcbn1cblxuZnVuY3Rpb24gZ2V0SWQobSkge1xuICAgIHJldHVybiBtLmlkO1xufVxuXG5mdW5jdGlvbiBnZXRPcmlnaW5hbExvY2F0aW9uKHNvdXJjZW1hcENoYWluLCBsb2NhdGlvbikge1xuICAgIGNvbnN0IGZpbHRlcmVkU291cmNlbWFwQ2hhaW4gPSBzb3VyY2VtYXBDaGFpbi5maWx0ZXIoKHNvdXJjZW1hcCkgPT4gIXNvdXJjZW1hcC5taXNzaW5nKTtcbiAgICB0cmFjZVNvdXJjZW1hcDogd2hpbGUgKGZpbHRlcmVkU291cmNlbWFwQ2hhaW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBzb3VyY2VtYXAgPSBmaWx0ZXJlZFNvdXJjZW1hcENoYWluLnBvcCgpO1xuICAgICAgICBjb25zdCBsaW5lID0gc291cmNlbWFwLm1hcHBpbmdzW2xvY2F0aW9uLmxpbmUgLSAxXTtcbiAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkTGluZSA9IGxpbmUuZmlsdGVyKChzZWdtZW50KSA9PiBzZWdtZW50Lmxlbmd0aCA+IDEpO1xuICAgICAgICAgICAgY29uc3QgbGFzdFNlZ21lbnQgPSBmaWx0ZXJlZExpbmVbZmlsdGVyZWRMaW5lLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzZWdtZW50IG9mIGZpbHRlcmVkTGluZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50WzBdID49IGxvY2F0aW9uLmNvbHVtbiB8fCBzZWdtZW50ID09PSBsYXN0U2VnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogc2VnbWVudFszXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHNlZ21lbnRbMl0gKyAxXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRyYWNlU291cmNlbWFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCByZXNvbHZlIG9yaWdpbmFsIGxvY2F0aW9uIG9mIGVycm9yLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2F0aW9uO1xufVxuXG5jb25zdCBBVFRSSUJVVEVfS0VZV09SRFMgPSBuZXcgU2V0KFsnYXNzZXJ0JywgJ3dpdGgnXSk7XG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVzRnJvbUltcG9ydEV4cHJlc3Npb24obm9kZSkge1xuICAgIGNvbnN0IHsgc2NvcGU6IHsgY29udGV4dCB9LCBvcHRpb25zLCBzdGFydCB9ID0gbm9kZTtcbiAgICBpZiAoIShvcHRpb25zIGluc3RhbmNlb2YgT2JqZWN0RXhwcmVzc2lvbikpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnRleHQubW9kdWxlLmxvZyhMT0dMRVZFTF9XQVJOLCBsb2dJbXBvcnRBdHRyaWJ1dGVJc0ludmFsaWQoY29udGV4dC5tb2R1bGUuaWQpLCBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEVNUFRZX09CSkVDVDtcbiAgICB9XG4gICAgY29uc3QgYXNzZXJ0UHJvcGVydHkgPSBvcHRpb25zLnByb3BlcnRpZXMuZmluZCgocHJvcGVydHkpID0+IEFUVFJJQlVURV9LRVlXT1JEUy5oYXMoZ2V0UHJvcGVydHlLZXkocHJvcGVydHkpKSk/LnZhbHVlO1xuICAgIGlmICghYXNzZXJ0UHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIEVNUFRZX09CSkVDVDtcbiAgICB9XG4gICAgaWYgKCEoYXNzZXJ0UHJvcGVydHkgaW5zdGFuY2VvZiBPYmplY3RFeHByZXNzaW9uKSkge1xuICAgICAgICBjb250ZXh0Lm1vZHVsZS5sb2coTE9HTEVWRUxfV0FSTiwgbG9nSW1wb3J0T3B0aW9uc0FyZUludmFsaWQoY29udGV4dC5tb2R1bGUuaWQpLCBzdGFydCk7XG4gICAgICAgIHJldHVybiBFTVBUWV9PQkpFQ1Q7XG4gICAgfVxuICAgIGNvbnN0IGFzc2VydEZpZWxkcyA9IGFzc2VydFByb3BlcnR5LnByb3BlcnRpZXNcbiAgICAgICAgLm1hcChwcm9wZXJ0eSA9PiB7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldFByb3BlcnR5S2V5KHByb3BlcnR5KTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICB0eXBlb2YgcHJvcGVydHkudmFsdWUudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gW2tleSwgcHJvcGVydHkudmFsdWUudmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQubW9kdWxlLmxvZyhMT0dMRVZFTF9XQVJOLCBsb2dJbXBvcnRBdHRyaWJ1dGVJc0ludmFsaWQoY29udGV4dC5tb2R1bGUuaWQpLCBwcm9wZXJ0eS5zdGFydCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0pXG4gICAgICAgIC5maWx0ZXIoKHByb3BlcnR5KSA9PiAhIXByb3BlcnR5KTtcbiAgICBpZiAoYXNzZXJ0RmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhhc3NlcnRGaWVsZHMpO1xuICAgIH1cbiAgICByZXR1cm4gRU1QVFlfT0JKRUNUO1xufVxuY29uc3QgZ2V0UHJvcGVydHlLZXkgPSAocHJvcGVydHkpID0+IHtcbiAgICBjb25zdCBrZXkgPSBwcm9wZXJ0eS5rZXk7XG4gICAgcmV0dXJuIChrZXkgJiZcbiAgICAgICAgIXByb3BlcnR5LmNvbXB1dGVkICYmXG4gICAgICAgIChrZXkubmFtZSB8fCBrZXkudmFsdWUpKTtcbn07XG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVzRnJvbUltcG9ydEV4cG9ydERlY2xhcmF0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gYXR0cmlidXRlcz8ubGVuZ3RoXG4gICAgICAgID8gT2JqZWN0LmZyb21FbnRyaWVzKGF0dHJpYnV0ZXMubWFwKGFzc2VydGlvbiA9PiBbZ2V0UHJvcGVydHlLZXkoYXNzZXJ0aW9uKSwgYXNzZXJ0aW9uLnZhbHVlLnZhbHVlXSkpXG4gICAgICAgIDogRU1QVFlfT0JKRUNUO1xufVxuZnVuY3Rpb24gZG9BdHRyaWJ1dGVzRGlmZmVyKGFzc2VydGlvbkEsIGFzc2VydGlvbkIpIHtcbiAgICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKGFzc2VydGlvbkEpO1xuICAgIHJldHVybiAoa2V5c0EubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhhc3NlcnRpb25CKS5sZW5ndGggfHxcbiAgICAgICAga2V5c0Euc29tZShrZXkgPT4gYXNzZXJ0aW9uQVtrZXldICE9PSBhc3NlcnRpb25CW2tleV0pKTtcbn1cblxubGV0IHRpbWVycyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldFBlcnNpc3RlZExhYmVsKGxhYmVsLCBsZXZlbCkge1xuICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICByZXR1cm4gYCMgJHtsYWJlbH1gO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgcmV0dXJuIGAjIyAke2xhYmVsfWA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgcmV0dXJuIGAtICR7bGFiZWx9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRpbWVTdGFydEltcGwobGFiZWwsIGxldmVsID0gMykge1xuICAgIGxhYmVsID0gZ2V0UGVyc2lzdGVkTGFiZWwobGFiZWwsIGxldmVsKTtcbiAgICBjb25zdCBzdGFydE1lbW9yeSA9IHByb2Nlc3MkMS5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IHRpbWVyID0gdGltZXJzLmdldChsYWJlbCk7XG4gICAgaWYgKHRpbWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGltZXJzLnNldChsYWJlbCwge1xuICAgICAgICAgICAgbWVtb3J5OiAwLFxuICAgICAgICAgICAgc3RhcnRNZW1vcnksXG4gICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICB0aW1lOiAwLFxuICAgICAgICAgICAgdG90YWxNZW1vcnk6IDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aW1lci5zdGFydE1lbW9yeSA9IHN0YXJ0TWVtb3J5O1xuICAgICAgICB0aW1lci5zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgfVxufVxuZnVuY3Rpb24gdGltZUVuZEltcGwobGFiZWwsIGxldmVsID0gMykge1xuICAgIGxhYmVsID0gZ2V0UGVyc2lzdGVkTGFiZWwobGFiZWwsIGxldmVsKTtcbiAgICBjb25zdCB0aW1lciA9IHRpbWVycy5nZXQobGFiZWwpO1xuICAgIGlmICh0aW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRNZW1vcnkgPSBwcm9jZXNzJDEubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcbiAgICAgICAgdGltZXIubWVtb3J5ICs9IGN1cnJlbnRNZW1vcnkgLSB0aW1lci5zdGFydE1lbW9yeTtcbiAgICAgICAgdGltZXIudGltZSArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHRpbWVyLnN0YXJ0VGltZTtcbiAgICAgICAgdGltZXIudG90YWxNZW1vcnkgPSBNYXRoLm1heCh0aW1lci50b3RhbE1lbW9yeSwgY3VycmVudE1lbW9yeSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VGltaW5ncygpIHtcbiAgICBjb25zdCBuZXdUaW1pbmdzID0ge307XG4gICAgZm9yIChjb25zdCBbbGFiZWwsIHsgbWVtb3J5LCB0aW1lLCB0b3RhbE1lbW9yeSB9XSBvZiB0aW1lcnMpIHtcbiAgICAgICAgbmV3VGltaW5nc1tsYWJlbF0gPSBbdGltZSwgbWVtb3J5LCB0b3RhbE1lbW9yeV07XG4gICAgfVxuICAgIHJldHVybiBuZXdUaW1pbmdzO1xufVxubGV0IHRpbWVTdGFydCA9IGRvTm90aGluZztcbmxldCB0aW1lRW5kID0gZG9Ob3RoaW5nO1xuY29uc3QgVElNRURfUExVR0lOX0hPT0tTID0gW1xuICAgICdhdWdtZW50Q2h1bmtIYXNoJyxcbiAgICAnYnVpbGRFbmQnLFxuICAgICdidWlsZFN0YXJ0JyxcbiAgICAnZ2VuZXJhdGVCdW5kbGUnLFxuICAgICdsb2FkJyxcbiAgICAnbW9kdWxlUGFyc2VkJyxcbiAgICAnb3B0aW9ucycsXG4gICAgJ291dHB1dE9wdGlvbnMnLFxuICAgICdyZW5kZXJDaHVuaycsXG4gICAgJ3JlbmRlckR5bmFtaWNJbXBvcnQnLFxuICAgICdyZW5kZXJTdGFydCcsXG4gICAgJ3Jlc29sdmVEeW5hbWljSW1wb3J0JyxcbiAgICAncmVzb2x2ZUZpbGVVcmwnLFxuICAgICdyZXNvbHZlSWQnLFxuICAgICdyZXNvbHZlSW1wb3J0TWV0YScsXG4gICAgJ3Nob3VsZFRyYW5zZm9ybUNhY2hlZE1vZHVsZScsXG4gICAgJ3RyYW5zZm9ybScsXG4gICAgJ3dyaXRlQnVuZGxlJ1xuXTtcbmZ1bmN0aW9uIGdldFBsdWdpbldpdGhUaW1lcnMocGx1Z2luLCBpbmRleCkge1xuICAgIGlmIChwbHVnaW4uX2hhc1RpbWVyKVxuICAgICAgICByZXR1cm4gcGx1Z2luO1xuICAgIHBsdWdpbi5faGFzVGltZXIgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgaG9vayBvZiBUSU1FRF9QTFVHSU5fSE9PS1MpIHtcbiAgICAgICAgaWYgKGhvb2sgaW4gcGx1Z2luKSB7XG4gICAgICAgICAgICBsZXQgdGltZXJMYWJlbCA9IGBwbHVnaW4gJHtpbmRleH1gO1xuICAgICAgICAgICAgaWYgKHBsdWdpbi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgdGltZXJMYWJlbCArPSBgICgke3BsdWdpbi5uYW1lfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZXJMYWJlbCArPSBgIC0gJHtob29rfWA7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gZnVuY3Rpb24gKC4uLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICB0aW1lU3RhcnQodGltZXJMYWJlbCwgNCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaG9va0Z1bmN0aW9uLmFwcGx5KHRoaXMsIHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgIHRpbWVFbmQodGltZXJMYWJlbCwgNCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgaG9va0Z1bmN0aW9uO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbHVnaW5baG9va10uaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGhvb2tGdW5jdGlvbiA9IHBsdWdpbltob29rXS5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIHBsdWdpbltob29rXS5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhvb2tGdW5jdGlvbiA9IHBsdWdpbltob29rXTtcbiAgICAgICAgICAgICAgICBwbHVnaW5baG9va10gPSBoYW5kbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwbHVnaW47XG59XG5mdW5jdGlvbiBpbml0aWFsaXNlVGltZXJzKGlucHV0T3B0aW9ucykge1xuICAgIGlmIChpbnB1dE9wdGlvbnMucGVyZikge1xuICAgICAgICB0aW1lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRpbWVTdGFydCA9IHRpbWVTdGFydEltcGw7XG4gICAgICAgIHRpbWVFbmQgPSB0aW1lRW5kSW1wbDtcbiAgICAgICAgaW5wdXRPcHRpb25zLnBsdWdpbnMgPSBpbnB1dE9wdGlvbnMucGx1Z2lucy5tYXAoZ2V0UGx1Z2luV2l0aFRpbWVycyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aW1lU3RhcnQgPSBkb05vdGhpbmc7XG4gICAgICAgIHRpbWVFbmQgPSBkb05vdGhpbmc7XG4gICAgfVxufVxuXG5jb25zdCBNSVNTSU5HX0VYUE9SVF9TSElNX0RFU0NSSVBUSU9OID0ge1xuICAgIGlkZW50aWZpZXI6IG51bGwsXG4gICAgbG9jYWxOYW1lOiBNSVNTSU5HX0VYUE9SVF9TSElNX1ZBUklBQkxFXG59O1xuZnVuY3Rpb24gZ2V0VmFyaWFibGVGb3JFeHBvcnROYW1lUmVjdXJzaXZlKHRhcmdldCwgbmFtZSwgaW1wb3J0ZXJGb3JTaWRlRWZmZWN0cywgaXNFeHBvcnRBbGxTZWFyY2gsIHNlYXJjaGVkTmFtZXNBbmRNb2R1bGVzID0gbmV3IE1hcCgpKSB7XG4gICAgY29uc3Qgc2VhcmNoZWRNb2R1bGVzID0gc2VhcmNoZWROYW1lc0FuZE1vZHVsZXMuZ2V0KG5hbWUpO1xuICAgIGlmIChzZWFyY2hlZE1vZHVsZXMpIHtcbiAgICAgICAgaWYgKHNlYXJjaGVkTW9kdWxlcy5oYXModGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRXhwb3J0QWxsU2VhcmNoID8gW251bGxdIDogZXJyb3IobG9nQ2lyY3VsYXJSZWV4cG9ydChuYW1lLCB0YXJnZXQuaWQpKTtcbiAgICAgICAgfVxuICAgICAgICBzZWFyY2hlZE1vZHVsZXMuYWRkKHRhcmdldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZWFyY2hlZE5hbWVzQW5kTW9kdWxlcy5zZXQobmFtZSwgbmV3IFNldChbdGFyZ2V0XSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0LmdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZShuYW1lLCB7XG4gICAgICAgIGltcG9ydGVyRm9yU2lkZUVmZmVjdHMsXG4gICAgICAgIGlzRXhwb3J0QWxsU2VhcmNoLFxuICAgICAgICBzZWFyY2hlZE5hbWVzQW5kTW9kdWxlc1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0QW5kRXh0ZW5kU2lkZUVmZmVjdE1vZHVsZXModmFyaWFibGUsIG1vZHVsZSkge1xuICAgIGNvbnN0IHNpZGVFZmZlY3RNb2R1bGVzID0gZ2V0T3JDcmVhdGUobW9kdWxlLnNpZGVFZmZlY3REZXBlbmRlbmNpZXNCeVZhcmlhYmxlLCB2YXJpYWJsZSwgKGdldE5ld1NldCkpO1xuICAgIGxldCBjdXJyZW50VmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgICBjb25zdCByZWZlcmVuY2VkVmFyaWFibGVzID0gbmV3IFNldChbY3VycmVudFZhcmlhYmxlXSk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgaW1wb3J0aW5nTW9kdWxlID0gY3VycmVudFZhcmlhYmxlLm1vZHVsZTtcbiAgICAgICAgY3VycmVudFZhcmlhYmxlID1cbiAgICAgICAgICAgIGN1cnJlbnRWYXJpYWJsZSBpbnN0YW5jZW9mIEV4cG9ydERlZmF1bHRWYXJpYWJsZVxuICAgICAgICAgICAgICAgID8gY3VycmVudFZhcmlhYmxlLmdldERpcmVjdE9yaWdpbmFsVmFyaWFibGUoKVxuICAgICAgICAgICAgICAgIDogY3VycmVudFZhcmlhYmxlIGluc3RhbmNlb2YgU3ludGhldGljTmFtZWRFeHBvcnRWYXJpYWJsZVxuICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnRWYXJpYWJsZS5zeW50aGV0aWNOYW1lc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAoIWN1cnJlbnRWYXJpYWJsZSB8fCByZWZlcmVuY2VkVmFyaWFibGVzLmhhcyhjdXJyZW50VmFyaWFibGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZWZlcmVuY2VkVmFyaWFibGVzLmFkZChjdXJyZW50VmFyaWFibGUpO1xuICAgICAgICBzaWRlRWZmZWN0TW9kdWxlcy5hZGQoaW1wb3J0aW5nTW9kdWxlKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTaWRlRWZmZWN0cyA9IGltcG9ydGluZ01vZHVsZS5zaWRlRWZmZWN0RGVwZW5kZW5jaWVzQnlWYXJpYWJsZS5nZXQoY3VycmVudFZhcmlhYmxlKTtcbiAgICAgICAgaWYgKG9yaWdpbmFsU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG9yaWdpbmFsU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBzaWRlRWZmZWN0TW9kdWxlcy5hZGQobW9kdWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2lkZUVmZmVjdE1vZHVsZXM7XG59XG5jbGFzcyBNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGdyYXBoLCBpZCwgb3B0aW9ucywgaXNFbnRyeSwgbW9kdWxlU2lkZUVmZmVjdHMsIHN5bnRoZXRpY05hbWVkRXhwb3J0cywgbWV0YSwgYXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5hbHRlcm5hdGl2ZVJlZXhwb3J0TW9kdWxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jaHVua0ZpbGVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5jaHVua05hbWVzID0gW107XG4gICAgICAgIHRoaXMuY3ljbGVzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5keW5hbWljRGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmR5bmFtaWNJbXBvcnRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5keW5hbWljSW1wb3J0cyA9IFtdO1xuICAgICAgICB0aGlzLmV4ZWNJbmRleCA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLmhhc1RyZWVTaGFraW5nUGFzc1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbXBsaWNpdGx5TG9hZGVkQWZ0ZXIgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuaW1wbGljaXRseUxvYWRlZEJlZm9yZSA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5pbXBvcnREZXNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaW1wb3J0TWV0YXMgPSBbXTtcbiAgICAgICAgdGhpcy5pbXBvcnRlZEZyb21Ob3RUcmVlc2hha2VuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW1wb3J0ZXJzID0gW107XG4gICAgICAgIHRoaXMuaW5jbHVkZWREeW5hbWljSW1wb3J0ZXJzID0gW107XG4gICAgICAgIHRoaXMuaW5jbHVkZWRJbXBvcnRzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmlzRXhlY3V0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1VzZXJEZWZpbmVkRW50cnlQb2ludCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5lZWRzRXhwb3J0U2hpbSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNpZGVFZmZlY3REZXBlbmRlbmNpZXNCeVZhcmlhYmxlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNvdXJjZXNXaXRoQXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hbGxFeHBvcnROYW1lcyA9IG51bGw7XG4gICAgICAgIHRoaXMuYXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5leHBvcnRBbGxNb2R1bGVzID0gW107XG4gICAgICAgIHRoaXMuZXhwb3J0QWxsU291cmNlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5leHBvcnROYW1lc0J5VmFyaWFibGUgPSBudWxsO1xuICAgICAgICB0aGlzLmV4cG9ydFNoaW1WYXJpYWJsZSA9IG5ldyBFeHBvcnRTaGltVmFyaWFibGUodGhpcyk7XG4gICAgICAgIHRoaXMuZXhwb3J0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2VSZWV4cG9ydHNCeU5hbWUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucmVleHBvcnREZXNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucmVsZXZhbnREZXBlbmRlbmNpZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnN5bnRoZXRpY0V4cG9ydHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc3ludGhldGljTmFtZXNwYWNlID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1EZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgICAgdGhpcy50cmFuc2l0aXZlUmVleHBvcnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5leGNsdWRlRnJvbVNvdXJjZW1hcCA9IC9cXDAvLnRlc3QoaWQpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBvcHRpb25zLm1vZHVsZUNvbnRleHQoaWQpO1xuICAgICAgICB0aGlzLnByZXNlcnZlU2lnbmF0dXJlID0gdGhpcy5vcHRpb25zLnByZXNlcnZlRW50cnlTaWduYXR1cmVzO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgY29uc3QgbW9kdWxlID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBkeW5hbWljSW1wb3J0cywgZHluYW1pY0ltcG9ydGVycywgZXhwb3J0QWxsU291cmNlcywgZXhwb3J0cywgaW1wbGljaXRseUxvYWRlZEFmdGVyLCBpbXBsaWNpdGx5TG9hZGVkQmVmb3JlLCBpbXBvcnRlcnMsIHJlZXhwb3J0RGVzY3JpcHRpb25zLCBzb3VyY2VzV2l0aEF0dHJpYnV0ZXMgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuaW5mbyA9IHtcbiAgICAgICAgICAgIGFzdDogbnVsbCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBjb2RlOiBudWxsLFxuICAgICAgICAgICAgZ2V0IGR5bmFtaWNhbGx5SW1wb3J0ZWRJZFJlc29sdXRpb25zKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkeW5hbWljSW1wb3J0c1xuICAgICAgICAgICAgICAgICAgICAubWFwKCh7IGFyZ3VtZW50IH0pID0+IHR5cGVvZiBhcmd1bWVudCA9PT0gJ3N0cmluZycgJiYgbW9kdWxlLnJlc29sdmVkSWRzW2FyZ3VtZW50XSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgZHluYW1pY2FsbHlJbXBvcnRlZElkcygpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIHRoaXMuZHluYW1pY0RlcGVuZGVuY2llcyBiZWNhdXNlIHRoaXMgaXMgbmVlZGVkIGJlZm9yZVxuICAgICAgICAgICAgICAgIC8vIGR5bmFtaWNEZXBlbmRlbmNpZXMgYXJlIHBvcHVsYXRlZFxuICAgICAgICAgICAgICAgIHJldHVybiBkeW5hbWljSW1wb3J0cy5tYXAoKHsgaWQgfSkgPT4gaWQpLmZpbHRlcigoaWQpID0+IGlkICE9IG51bGwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBkeW5hbWljSW1wb3J0ZXJzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkeW5hbWljSW1wb3J0ZXJzLnNvcnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgZXhwb3J0ZWRCaW5kaW5ncygpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBvcnRCaW5kaW5ncyA9IHsgJy4nOiBbLi4uZXhwb3J0cy5rZXlzKCldIH07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgeyBzb3VyY2UgfV0gb2YgcmVleHBvcnREZXNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgKGV4cG9ydEJpbmRpbmdzW3NvdXJjZV0gPz89IFtdKS5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBleHBvcnRBbGxTb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIChleHBvcnRCaW5kaW5nc1tzb3VyY2VdID8/PSBbXSkucHVzaCgnKicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0QmluZGluZ3M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGV4cG9ydHMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgLi4uZXhwb3J0cy5rZXlzKCksXG4gICAgICAgICAgICAgICAgICAgIC4uLnJlZXhwb3J0RGVzY3JpcHRpb25zLmtleXMoKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uWy4uLmV4cG9ydEFsbFNvdXJjZXNdLm1hcCgoKSA9PiAnKicpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgaGFzRGVmYXVsdEV4cG9ydCgpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGluZm9ybWF0aW9uIGlzIG9ubHkgdmFsaWQgYWZ0ZXIgcGFyc2luZ1xuICAgICAgICAgICAgICAgIGlmICghbW9kdWxlLmFzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzLmhhcygnZGVmYXVsdCcpIHx8IHJlZXhwb3J0RGVzY3JpcHRpb25zLmhhcygnZGVmYXVsdCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgZ2V0IGltcGxpY2l0bHlMb2FkZWRBZnRlck9uZU9mKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKGltcGxpY2l0bHlMb2FkZWRBZnRlciwgZ2V0SWQpLnNvcnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgaW1wbGljaXRseUxvYWRlZEJlZm9yZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShpbXBsaWNpdGx5TG9hZGVkQmVmb3JlLCBnZXRJZCkuc29ydCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBpbXBvcnRlZElkUmVzb2x1dGlvbnMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oc291cmNlc1dpdGhBdHRyaWJ1dGVzLmtleXMoKSwgc291cmNlID0+IG1vZHVsZS5yZXNvbHZlZElkc1tzb3VyY2VdKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGltcG9ydGVkSWRzKCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgdGhpcy5kZXBlbmRlbmNpZXMgYmVjYXVzZSB0aGlzIGlzIG5lZWRlZCBiZWZvcmVcbiAgICAgICAgICAgICAgICAvLyBkZXBlbmRlbmNpZXMgYXJlIHBvcHVsYXRlZFxuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHNvdXJjZXNXaXRoQXR0cmlidXRlcy5rZXlzKCksIHNvdXJjZSA9PiBtb2R1bGUucmVzb2x2ZWRJZHNbc291cmNlXT8uaWQpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgaW1wb3J0ZXJzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnRlcnMuc29ydCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzRW50cnksXG4gICAgICAgICAgICBpc0V4dGVybmFsOiBmYWxzZSxcbiAgICAgICAgICAgIGdldCBpc0luY2x1ZGVkKCkge1xuICAgICAgICAgICAgICAgIGlmIChncmFwaC5waGFzZSAhPT0gQnVpbGRQaGFzZS5HRU5FUkFURSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZS5pc0luY2x1ZGVkKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWV0YTogeyAuLi5tZXRhIH0sXG4gICAgICAgICAgICBtb2R1bGVTaWRlRWZmZWN0cyxcbiAgICAgICAgICAgIHN5bnRoZXRpY05hbWVkRXhwb3J0c1xuICAgICAgICB9O1xuICAgIH1cbiAgICBiYXNlbmFtZSgpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IGJhc2VuYW1lKHRoaXMuaWQpO1xuICAgICAgICBjb25zdCBleHRlbnNpb24gPSBleHRuYW1lKHRoaXMuaWQpO1xuICAgICAgICByZXR1cm4gbWFrZUxlZ2FsKGV4dGVuc2lvbiA/IGJhc2Uuc2xpY2UoMCwgLWV4dGVuc2lvbi5sZW5ndGgpIDogYmFzZSk7XG4gICAgfVxuICAgIGJpbmRSZWZlcmVuY2VzKCkge1xuICAgICAgICB0aGlzLmFzdC5iaW5kKCk7XG4gICAgfVxuICAgIGNhY2hlSW5mb0dldHRlcnMoKSB7XG4gICAgICAgIGNhY2hlT2JqZWN0R2V0dGVycyh0aGlzLmluZm8sIFtcbiAgICAgICAgICAgICdkeW5hbWljYWxseUltcG9ydGVkSWRSZXNvbHV0aW9ucycsXG4gICAgICAgICAgICAnZHluYW1pY2FsbHlJbXBvcnRlZElkcycsXG4gICAgICAgICAgICAnZHluYW1pY0ltcG9ydGVycycsXG4gICAgICAgICAgICAnZXhwb3J0ZWRCaW5kaW5ncycsXG4gICAgICAgICAgICAnZXhwb3J0cycsXG4gICAgICAgICAgICAnaGFzRGVmYXVsdEV4cG9ydCcsXG4gICAgICAgICAgICAnaW1wbGljaXRseUxvYWRlZEFmdGVyT25lT2YnLFxuICAgICAgICAgICAgJ2ltcGxpY2l0bHlMb2FkZWRCZWZvcmUnLFxuICAgICAgICAgICAgJ2ltcG9ydGVkSWRSZXNvbHV0aW9ucycsXG4gICAgICAgICAgICAnaW1wb3J0ZWRJZHMnLFxuICAgICAgICAgICAgJ2ltcG9ydGVycydcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGVycm9yKHByb3BlcnRpZXMsIHBvcykge1xuICAgICAgICBpZiAocG9zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTG9jYXRpb25Ub0xvZ1Byb3BzKHByb3BlcnRpZXMsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yKHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICAvLyBzdW0gdXAgdGhlIGxlbmd0aCBvZiBhbGwgYXN0IG5vZGVzIHRoYXQgYXJlIGluY2x1ZGVkXG4gICAgZXN0aW1hdGVTaXplKCkge1xuICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLmFzdC5ib2R5KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5pbmNsdWRlZCkge1xuICAgICAgICAgICAgICAgIHNpemUgKz0gbm9kZS5lbmQgLSBub2RlLnN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICBnZXRBbGxFeHBvcnROYW1lcygpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxsRXhwb3J0TmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsbEV4cG9ydE5hbWVzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsRXhwb3J0TmFtZXMgPSBuZXcgU2V0KFsuLi50aGlzLmV4cG9ydHMua2V5cygpLCAuLi50aGlzLnJlZXhwb3J0RGVzY3JpcHRpb25zLmtleXMoKV0pO1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiB0aGlzLmV4cG9ydEFsbE1vZHVsZXMpIHtcbiAgICAgICAgICAgIGlmIChtb2R1bGUgaW5zdGFuY2VvZiBFeHRlcm5hbE1vZHVsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsRXhwb3J0TmFtZXMuYWRkKGAqJHttb2R1bGUuaWR9YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbW9kdWxlLmdldEFsbEV4cG9ydE5hbWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAhPT0gJ2RlZmF1bHQnKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsbEV4cG9ydE5hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBkbyBub3QgY291bnQgdGhlIHN5bnRoZXRpYyBuYW1lc3BhY2UgYXMgYSByZWd1bGFyIGV4cG9ydCB0byBoaWRlIGl0XG4gICAgICAgIC8vIGZyb20gZW50cnkgc2lnbmF0dXJlcyBhbmQgbmFtZXNwYWNlIG9iamVjdHNcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmluZm8uc3ludGhldGljTmFtZWRFeHBvcnRzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5hbGxFeHBvcnROYW1lcy5kZWxldGUodGhpcy5pbmZvLnN5bnRoZXRpY05hbWVkRXhwb3J0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsRXhwb3J0TmFtZXM7XG4gICAgfVxuICAgIGdldERlcGVuZGVuY2llc1RvQmVJbmNsdWRlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVsZXZhbnREZXBlbmRlbmNpZXMpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxldmFudERlcGVuZGVuY2llcztcbiAgICAgICAgdGhpcy5yZWxldmFudERlcGVuZGVuY2llcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgbmVjZXNzYXJ5RGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBhbHdheXNDaGVja2VkRGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBkZXBlbmRlbmN5VmFyaWFibGVzID0gbmV3IFNldCh0aGlzLmluY2x1ZGVkSW1wb3J0cyk7XG4gICAgICAgIGlmICh0aGlzLmluZm8uaXNFbnRyeSB8fFxuICAgICAgICAgICAgdGhpcy5pbmNsdWRlZER5bmFtaWNJbXBvcnRlcnMubGVuZ3RoID4gMCB8fFxuICAgICAgICAgICAgdGhpcy5uYW1lc3BhY2UuaW5jbHVkZWQgfHxcbiAgICAgICAgICAgIHRoaXMuaW1wbGljaXRseUxvYWRlZEFmdGVyLnNpemUgPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV4cG9ydE5hbWUgb2YgWy4uLnRoaXMuZ2V0UmVleHBvcnRzKCksIC4uLnRoaXMuZ2V0RXhwb3J0cygpXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtleHBvcnRlZFZhcmlhYmxlXSA9IHRoaXMuZ2V0VmFyaWFibGVGb3JFeHBvcnROYW1lKGV4cG9ydE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChleHBvcnRlZFZhcmlhYmxlPy5pbmNsdWRlZCkge1xuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5VmFyaWFibGVzLmFkZChleHBvcnRlZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdmFyaWFibGUgb2YgZGVwZW5kZW5jeVZhcmlhYmxlcykge1xuICAgICAgICAgICAgY29uc3Qgc2lkZUVmZmVjdERlcGVuZGVuY2llcyA9IHRoaXMuc2lkZUVmZmVjdERlcGVuZGVuY2llc0J5VmFyaWFibGUuZ2V0KHZhcmlhYmxlKTtcbiAgICAgICAgICAgIGlmIChzaWRlRWZmZWN0RGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2Ygc2lkZUVmZmVjdERlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgICAgICBhbHdheXNDaGVja2VkRGVwZW5kZW5jaWVzLmFkZChtb2R1bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YXJpYWJsZSBpbnN0YW5jZW9mIFN5bnRoZXRpY05hbWVkRXhwb3J0VmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlLmdldEJhc2VWYXJpYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFyaWFibGUgaW5zdGFuY2VvZiBFeHBvcnREZWZhdWx0VmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlLmdldE9yaWdpbmFsVmFyaWFibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5lY2Vzc2FyeURlcGVuZGVuY2llcy5hZGQodmFyaWFibGUubW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy50cmVlc2hha2UgfHwgdGhpcy5pbmZvLm1vZHVsZVNpZGVFZmZlY3RzID09PSAnbm8tdHJlZXNoYWtlJykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIHRoaXMuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxldmFudERlcGVuZGVuY2llcy5hZGQoZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZFJlbGV2YW50U2lkZUVmZmVjdERlcGVuZGVuY2llcyh0aGlzLnJlbGV2YW50RGVwZW5kZW5jaWVzLCBuZWNlc3NhcnlEZXBlbmRlbmNpZXMsIGFsd2F5c0NoZWNrZWREZXBlbmRlbmNpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZGVwZW5kZW5jeSBvZiBuZWNlc3NhcnlEZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIHRoaXMucmVsZXZhbnREZXBlbmRlbmNpZXMuYWRkKGRlcGVuZGVuY3kpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlbGV2YW50RGVwZW5kZW5jaWVzO1xuICAgIH1cbiAgICBnZXRFeHBvcnROYW1lc0J5VmFyaWFibGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmV4cG9ydE5hbWVzQnlWYXJpYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwb3J0TmFtZXNCeVZhcmlhYmxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cG9ydE5hbWVzQnlWYXJpYWJsZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBleHBvcnROYW1lIG9mIHRoaXMuZ2V0QWxsRXhwb3J0TmFtZXMoKSkge1xuICAgICAgICAgICAgbGV0IFt0cmFjZWRWYXJpYWJsZV0gPSB0aGlzLmdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZShleHBvcnROYW1lKTtcbiAgICAgICAgICAgIGlmICh0cmFjZWRWYXJpYWJsZSBpbnN0YW5jZW9mIEV4cG9ydERlZmF1bHRWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgIHRyYWNlZFZhcmlhYmxlID0gdHJhY2VkVmFyaWFibGUuZ2V0T3JpZ2luYWxWYXJpYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0cmFjZWRWYXJpYWJsZSB8fFxuICAgICAgICAgICAgICAgICEodHJhY2VkVmFyaWFibGUuaW5jbHVkZWQgfHwgdHJhY2VkVmFyaWFibGUgaW5zdGFuY2VvZiBFeHRlcm5hbFZhcmlhYmxlKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdFeHBvcnROYW1lcyA9IGV4cG9ydE5hbWVzQnlWYXJpYWJsZS5nZXQodHJhY2VkVmFyaWFibGUpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRXhwb3J0TmFtZXMpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ0V4cG9ydE5hbWVzLnB1c2goZXhwb3J0TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHBvcnROYW1lc0J5VmFyaWFibGUuc2V0KHRyYWNlZFZhcmlhYmxlLCBbZXhwb3J0TmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5leHBvcnROYW1lc0J5VmFyaWFibGUgPSBleHBvcnROYW1lc0J5VmFyaWFibGUpO1xuICAgIH1cbiAgICBnZXRFeHBvcnRzKCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXMuZXhwb3J0cy5rZXlzKCldO1xuICAgIH1cbiAgICBnZXRSZWV4cG9ydHMoKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zaXRpdmVSZWV4cG9ydHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpdmVSZWV4cG9ydHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG8gYXZvaWQgaW5maW5pdGUgcmVjdXJzaW9uIHdoZW4gdXNpbmcgY2lyY3VsYXIgYGV4cG9ydCAqIGZyb20gWGBcbiAgICAgICAgdGhpcy50cmFuc2l0aXZlUmVleHBvcnRzID0gW107XG4gICAgICAgIGNvbnN0IHJlZXhwb3J0cyA9IG5ldyBTZXQodGhpcy5yZWV4cG9ydERlc2NyaXB0aW9ucy5rZXlzKCkpO1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiB0aGlzLmV4cG9ydEFsbE1vZHVsZXMpIHtcbiAgICAgICAgICAgIGlmIChtb2R1bGUgaW5zdGFuY2VvZiBFeHRlcm5hbE1vZHVsZSkge1xuICAgICAgICAgICAgICAgIHJlZXhwb3J0cy5hZGQoYCoke21vZHVsZS5pZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBbLi4ubW9kdWxlLmdldFJlZXhwb3J0cygpLCAuLi5tb2R1bGUuZ2V0RXhwb3J0cygpXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSAhPT0gJ2RlZmF1bHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVleHBvcnRzLmFkZChuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLnRyYW5zaXRpdmVSZWV4cG9ydHMgPSBbLi4ucmVleHBvcnRzXSk7XG4gICAgfVxuICAgIGdldFJlbmRlcmVkRXhwb3J0cygpIHtcbiAgICAgICAgLy8gb25seSBkaXJlY3QgZXhwb3J0cyBhcmUgY291bnRlZCBoZXJlLCBub3QgcmVleHBvcnRzIGF0IGFsbFxuICAgICAgICBjb25zdCByZW5kZXJlZEV4cG9ydHMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVtb3ZlZEV4cG9ydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBleHBvcnROYW1lIG9mIHRoaXMuZXhwb3J0cy5rZXlzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IFt2YXJpYWJsZV0gPSB0aGlzLmdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZShleHBvcnROYW1lKTtcbiAgICAgICAgICAgICh2YXJpYWJsZT8uaW5jbHVkZWQgPyByZW5kZXJlZEV4cG9ydHMgOiByZW1vdmVkRXhwb3J0cykucHVzaChleHBvcnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByZW1vdmVkRXhwb3J0cywgcmVuZGVyZWRFeHBvcnRzIH07XG4gICAgfVxuICAgIGdldFN5bnRoZXRpY05hbWVzcGFjZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3ludGhldGljTmFtZXNwYWNlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN5bnRoZXRpY05hbWVzcGFjZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIFt0aGlzLnN5bnRoZXRpY05hbWVzcGFjZV0gPSB0aGlzLmdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZSh0eXBlb2YgdGhpcy5pbmZvLnN5bnRoZXRpY05hbWVkRXhwb3J0cyA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IHRoaXMuaW5mby5zeW50aGV0aWNOYW1lZEV4cG9ydHNcbiAgICAgICAgICAgICAgICA6ICdkZWZhdWx0JywgeyBvbmx5RXhwbGljaXQ6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnN5bnRoZXRpY05hbWVzcGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKGxvZ1N5bnRoZXRpY05hbWVkRXhwb3J0c05lZWROYW1lc3BhY2VFeHBvcnQodGhpcy5pZCwgdGhpcy5pbmZvLnN5bnRoZXRpY05hbWVkRXhwb3J0cykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN5bnRoZXRpY05hbWVzcGFjZTtcbiAgICB9XG4gICAgZ2V0VmFyaWFibGVGb3JFeHBvcnROYW1lKG5hbWUsIHsgaW1wb3J0ZXJGb3JTaWRlRWZmZWN0cywgaXNFeHBvcnRBbGxTZWFyY2gsIG9ubHlFeHBsaWNpdCwgc2VhcmNoZWROYW1lc0FuZE1vZHVsZXMgfSA9IEVNUFRZX09CSkVDVCkge1xuICAgICAgICBpZiAobmFtZVswXSA9PT0gJyonKSB7XG4gICAgICAgICAgICBpZiAobmFtZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBleHBvcnQgKiBmcm9tICcuL290aGVyJ1xuICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy5uYW1lc3BhY2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXhwb3J0ICogZnJvbSAnZXh0ZXJuYWwnXG4gICAgICAgICAgICBjb25zdCBtb2R1bGUgPSB0aGlzLmdyYXBoLm1vZHVsZXNCeUlkLmdldChuYW1lLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGUuZ2V0VmFyaWFibGVGb3JFeHBvcnROYW1lKCcqJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXhwb3J0IHsgZm9vIH0gZnJvbSAnLi9vdGhlcidcbiAgICAgICAgY29uc3QgcmVleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMucmVleHBvcnREZXNjcmlwdGlvbnMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAocmVleHBvcnREZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgW3ZhcmlhYmxlXSA9IGdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZVJlY3Vyc2l2ZShyZWV4cG9ydERlY2xhcmF0aW9uLm1vZHVsZSwgcmVleHBvcnREZWNsYXJhdGlvbi5sb2NhbE5hbWUsIGltcG9ydGVyRm9yU2lkZUVmZmVjdHMsIGZhbHNlLCBzZWFyY2hlZE5hbWVzQW5kTW9kdWxlcyk7XG4gICAgICAgICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IobG9nTWlzc2luZ0V4cG9ydChyZWV4cG9ydERlY2xhcmF0aW9uLmxvY2FsTmFtZSwgdGhpcy5pZCwgcmVleHBvcnREZWNsYXJhdGlvbi5tb2R1bGUuaWQpLCByZWV4cG9ydERlY2xhcmF0aW9uLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbXBvcnRlckZvclNpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgc2V0QWx0ZXJuYXRpdmVFeHBvcnRlcklmQ3ljbGljKHZhcmlhYmxlLCBpbXBvcnRlckZvclNpZGVFZmZlY3RzLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmZvLm1vZHVsZVNpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldE9yQ3JlYXRlKGltcG9ydGVyRm9yU2lkZUVmZmVjdHMuc2lkZUVmZmVjdERlcGVuZGVuY2llc0J5VmFyaWFibGUsIHZhcmlhYmxlLCAoZ2V0TmV3U2V0KSkuYWRkKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbdmFyaWFibGVdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5leHBvcnRzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKGV4cG9ydERlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZXhwb3J0RGVjbGFyYXRpb24gPT09IE1JU1NJTkdfRVhQT1JUX1NISU1fREVTQ1JJUFRJT04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RoaXMuZXhwb3J0U2hpbVZhcmlhYmxlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBleHBvcnREZWNsYXJhdGlvbi5sb2NhbE5hbWU7XG4gICAgICAgICAgICBjb25zdCB2YXJpYWJsZSA9IHRoaXMudHJhY2VWYXJpYWJsZShuYW1lLCB7XG4gICAgICAgICAgICAgICAgaW1wb3J0ZXJGb3JTaWRlRWZmZWN0cyxcbiAgICAgICAgICAgICAgICBzZWFyY2hlZE5hbWVzQW5kTW9kdWxlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW1wb3J0ZXJGb3JTaWRlRWZmZWN0cykge1xuICAgICAgICAgICAgICAgIHNldEFsdGVybmF0aXZlRXhwb3J0ZXJJZkN5Y2xpYyh2YXJpYWJsZSwgaW1wb3J0ZXJGb3JTaWRlRWZmZWN0cywgdGhpcyk7XG4gICAgICAgICAgICAgICAgZ2V0T3JDcmVhdGUoaW1wb3J0ZXJGb3JTaWRlRWZmZWN0cy5zaWRlRWZmZWN0RGVwZW5kZW5jaWVzQnlWYXJpYWJsZSwgdmFyaWFibGUsIChnZXROZXdTZXQpKS5hZGQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3ZhcmlhYmxlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25seUV4cGxpY2l0KSB7XG4gICAgICAgICAgICByZXR1cm4gW251bGxdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvdW5kTmFtZXNwYWNlUmVleHBvcnQgPSB0aGlzLm5hbWVzcGFjZVJlZXhwb3J0c0J5TmFtZS5nZXQobmFtZSkgPz9cbiAgICAgICAgICAgICAgICB0aGlzLmdldFZhcmlhYmxlRnJvbU5hbWVzcGFjZVJlZXhwb3J0cyhuYW1lLCBpbXBvcnRlckZvclNpZGVFZmZlY3RzLCBzZWFyY2hlZE5hbWVzQW5kTW9kdWxlcyk7XG4gICAgICAgICAgICB0aGlzLm5hbWVzcGFjZVJlZXhwb3J0c0J5TmFtZS5zZXQobmFtZSwgZm91bmROYW1lc3BhY2VSZWV4cG9ydCk7XG4gICAgICAgICAgICBpZiAoZm91bmROYW1lc3BhY2VSZWV4cG9ydFswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZE5hbWVzcGFjZVJlZXhwb3J0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluZm8uc3ludGhldGljTmFtZWRFeHBvcnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGdldE9yQ3JlYXRlKHRoaXMuc3ludGhldGljRXhwb3J0cywgbmFtZSwgKCkgPT4gbmV3IFN5bnRoZXRpY05hbWVkRXhwb3J0VmFyaWFibGUodGhpcy5hc3RDb250ZXh0LCBuYW1lLCB0aGlzLmdldFN5bnRoZXRpY05hbWVzcGFjZSgpKSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBjcmVhdGUgc2hpbXMgd2hlbiB3ZSBhcmUganVzdFxuICAgICAgICAvLyBwcm9iaW5nIGV4cG9ydCAqIG1vZHVsZXMgZm9yIGV4cG9ydHNcbiAgICAgICAgaWYgKCFpc0V4cG9ydEFsbFNlYXJjaCAmJiB0aGlzLm9wdGlvbnMuc2hpbU1pc3NpbmdFeHBvcnRzKSB7XG4gICAgICAgICAgICB0aGlzLnNoaW1NaXNzaW5nRXhwb3J0KG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLmV4cG9ydFNoaW1WYXJpYWJsZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtudWxsXTtcbiAgICB9XG4gICAgaGFzRWZmZWN0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5tb2R1bGVTaWRlRWZmZWN0cyA9PT0gJ25vLXRyZWVzaGFrZScgfHwgdGhpcy5hc3QuaGFzQ2FjaGVkRWZmZWN0cygpO1xuICAgIH1cbiAgICBpbmNsdWRlKCkge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlSW5jbHVzaW9uQ29udGV4dCgpO1xuICAgICAgICBpZiAodGhpcy5hc3Quc2hvdWxkQmVJbmNsdWRlZChjb250ZXh0KSlcbiAgICAgICAgICAgIHRoaXMuYXN0LmluY2x1ZGUoY29udGV4dCwgZmFsc2UpO1xuICAgIH1cbiAgICBpbmNsdWRlQWxsRXhwb3J0cyhpbmNsdWRlTmFtZXNwYWNlTWVtYmVycykge1xuICAgICAgICBpZiAoIXRoaXMuaXNFeGVjdXRlZCkge1xuICAgICAgICAgICAgbWFya01vZHVsZUFuZEltcHVyZURlcGVuZGVuY2llc0FzRXhlY3V0ZWQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmdyYXBoLm5lZWRzVHJlZXNoYWtpbmdQYXNzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGV4cG9ydE5hbWUgb2YgdGhpcy5leHBvcnRzLmtleXMoKSkge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVOYW1lc3BhY2VNZW1iZXJzIHx8IGV4cG9ydE5hbWUgIT09IHRoaXMuaW5mby5zeW50aGV0aWNOYW1lZEV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YXJpYWJsZSA9IHRoaXMuZ2V0VmFyaWFibGVGb3JFeHBvcnROYW1lKGV4cG9ydE5hbWUpWzBdO1xuICAgICAgICAgICAgICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGxvZ01pc3NpbmdFbnRyeUV4cG9ydChleHBvcnROYW1lLCB0aGlzLmlkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhcmlhYmxlLmRlb3B0aW1pemVQYXRoKFVOS05PV05fUEFUSCk7XG4gICAgICAgICAgICAgICAgaWYgKCF2YXJpYWJsZS5pbmNsdWRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluY2x1ZGVWYXJpYWJsZSh2YXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmdldFJlZXhwb3J0cygpKSB7XG4gICAgICAgICAgICBjb25zdCBbdmFyaWFibGVdID0gdGhpcy5nZXRWYXJpYWJsZUZvckV4cG9ydE5hbWUobmFtZSk7XG4gICAgICAgICAgICBpZiAodmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZS5kZW9wdGltaXplUGF0aChVTktOT1dOX1BBVEgpO1xuICAgICAgICAgICAgICAgIGlmICghdmFyaWFibGUuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmNsdWRlVmFyaWFibGUodmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFyaWFibGUgaW5zdGFuY2VvZiBFeHRlcm5hbFZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlLm1vZHVsZS5yZWV4cG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGVOYW1lc3BhY2VNZW1iZXJzKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWVzcGFjZS5zZXRNZXJnZWROYW1lc3BhY2VzKHRoaXMuaW5jbHVkZUFuZEdldEFkZGl0aW9uYWxNZXJnZWROYW1lc3BhY2VzKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluY2x1ZGVBbGxJbkJ1bmRsZSgpIHtcbiAgICAgICAgdGhpcy5hc3QuaW5jbHVkZShjcmVhdGVJbmNsdXNpb25Db250ZXh0KCksIHRydWUpO1xuICAgICAgICB0aGlzLmluY2x1ZGVBbGxFeHBvcnRzKGZhbHNlKTtcbiAgICB9XG4gICAgaW5jbHVkZUV4cG9ydHNCeU5hbWVzKG5hbWVzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0V4ZWN1dGVkKSB7XG4gICAgICAgICAgICBtYXJrTW9kdWxlQW5kSW1wdXJlRGVwZW5kZW5jaWVzQXNFeGVjdXRlZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGgubmVlZHNUcmVlc2hha2luZ1Bhc3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbmNsdWRlTmFtZXNwYWNlTWVtYmVycyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlID0gdGhpcy5nZXRWYXJpYWJsZUZvckV4cG9ydE5hbWUobmFtZSlbMF07XG4gICAgICAgICAgICBpZiAodmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZS5kZW9wdGltaXplUGF0aChVTktOT1dOX1BBVEgpO1xuICAgICAgICAgICAgICAgIGlmICghdmFyaWFibGUuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmNsdWRlVmFyaWFibGUodmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5leHBvcnRzLmhhcyhuYW1lKSAmJiAhdGhpcy5yZWV4cG9ydERlc2NyaXB0aW9ucy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlTmFtZXNwYWNlTWVtYmVycyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGVOYW1lc3BhY2VNZW1iZXJzKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWVzcGFjZS5zZXRNZXJnZWROYW1lc3BhY2VzKHRoaXMuaW5jbHVkZUFuZEdldEFkZGl0aW9uYWxNZXJnZWROYW1lc3BhY2VzKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzSW5jbHVkZWQoKSB7XG4gICAgICAgIC8vIE1vZHVsZXMgd2hlcmUgdGhpcy5hc3QgaXMgbWlzc2luZyBoYXZlIGJlZW4gbG9hZGVkIHZpYSB0aGlzLmxvYWQgYW5kIGFyZVxuICAgICAgICAvLyBub3QgeWV0IGZ1bGx5IHByb2Nlc3NlZCwgaGVuY2UgdGhleSBjYW5ub3QgYmUgaW5jbHVkZWQuXG4gICAgICAgIHJldHVybiAodGhpcy5hc3QgJiZcbiAgICAgICAgICAgICh0aGlzLmFzdC5pbmNsdWRlZCB8fFxuICAgICAgICAgICAgICAgIHRoaXMubmFtZXNwYWNlLmluY2x1ZGVkIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRlZEZyb21Ob3RUcmVlc2hha2VuIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5leHBvcnRTaGltVmFyaWFibGUuaW5jbHVkZWQpKTtcbiAgICB9XG4gICAgbGlua0ltcG9ydHMoKSB7XG4gICAgICAgIHRoaXMuYWRkTW9kdWxlc1RvSW1wb3J0RGVzY3JpcHRpb25zKHRoaXMuaW1wb3J0RGVzY3JpcHRpb25zKTtcbiAgICAgICAgdGhpcy5hZGRNb2R1bGVzVG9JbXBvcnREZXNjcmlwdGlvbnModGhpcy5yZWV4cG9ydERlc2NyaXB0aW9ucyk7XG4gICAgICAgIGNvbnN0IGV4dGVybmFsRXhwb3J0QWxsTW9kdWxlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiB0aGlzLmV4cG9ydEFsbFNvdXJjZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IHRoaXMuZ3JhcGgubW9kdWxlc0J5SWQuZ2V0KHRoaXMucmVzb2x2ZWRJZHNbc291cmNlXS5pZCk7XG4gICAgICAgICAgICBpZiAobW9kdWxlIGluc3RhbmNlb2YgRXh0ZXJuYWxNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbEV4cG9ydEFsbE1vZHVsZXMucHVzaChtb2R1bGUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5leHBvcnRBbGxNb2R1bGVzLnB1c2gobW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cG9ydEFsbE1vZHVsZXMucHVzaCguLi5leHRlcm5hbEV4cG9ydEFsbE1vZHVsZXMpO1xuICAgIH1cbiAgICBsb2cobGV2ZWwsIHByb3BlcnRpZXMsIHBvcykge1xuICAgICAgICB0aGlzLmFkZExvY2F0aW9uVG9Mb2dQcm9wcyhwcm9wZXJ0aWVzLCBwb3MpO1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Mb2cobGV2ZWwsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICByZW5kZXIob3B0aW9ucykge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLm1hZ2ljU3RyaW5nLmNsb25lKCk7XG4gICAgICAgIHRoaXMuYXN0LnJlbmRlcihzb3VyY2UsIG9wdGlvbnMpO1xuICAgICAgICBzb3VyY2UudHJpbSgpO1xuICAgICAgICBjb25zdCB7IHVzZXNUb3BMZXZlbEF3YWl0IH0gPSB0aGlzLmFzdENvbnRleHQ7XG4gICAgICAgIGlmICh1c2VzVG9wTGV2ZWxBd2FpdCAmJiBvcHRpb25zLmZvcm1hdCAhPT0gJ2VzJyAmJiBvcHRpb25zLmZvcm1hdCAhPT0gJ3N5c3RlbScpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihsb2dJbnZhbGlkRm9ybWF0Rm9yVG9wTGV2ZWxBd2FpdCh0aGlzLmlkLCBvcHRpb25zLmZvcm1hdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNvdXJjZSwgdXNlc1RvcExldmVsQXdhaXQgfTtcbiAgICB9XG4gICAgYXN5bmMgc2V0U291cmNlKHsgYXN0LCBjb2RlLCBjdXN0b21UcmFuc2Zvcm1DYWNoZSwgb3JpZ2luYWxDb2RlLCBvcmlnaW5hbFNvdXJjZW1hcCwgcmVzb2x2ZWRJZHMsIHNvdXJjZW1hcENoYWluLCB0cmFuc2Zvcm1EZXBlbmRlbmNpZXMsIHRyYW5zZm9ybUZpbGVzLCAuLi5tb2R1bGVPcHRpb25zIH0pIHtcbiAgICAgICAgdGltZVN0YXJ0KCdnZW5lcmF0ZSBhc3QnLCAzKTtcbiAgICAgICAgaWYgKGNvZGUuc3RhcnRzV2l0aCgnIyEnKSkge1xuICAgICAgICAgICAgY29uc3Qgc2hlYmFuZ0VuZFBvc2l0aW9uID0gY29kZS5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgICAgIHRoaXMuc2hlYmFuZyA9IGNvZGUuc2xpY2UoMiwgc2hlYmFuZ0VuZFBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZm8uY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMub3JpZ2luYWxDb2RlID0gb3JpZ2luYWxDb2RlO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGNhbGwgZGVjb2RlZFNvdXJjZW1hcCBvbiB0aGUgaW5wdXQgaW4gY2FzZSB0aGV5IHdlcmUgaHlkcmF0ZWQgZnJvbSBqc29uIGluIHRoZSBjYWNoZSBhbmQgZG9uJ3RcbiAgICAgICAgLy8gaGF2ZSB0aGUgbGF6eSBldmFsdWF0aW9uIGNhY2hlIGNvbmZpZ3VyZWQuIFJpZ2h0IG5vdyB0aGlzIGlzbid0IGVuZm9yY2VkIGJ5IHRoZSB0eXBlIHN5c3RlbSBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBSb2xsdXBDYWNoZSBzdG9yZXMgYEV4aXN0aW5nRGVjb2RlZFNvdXJjZW1hcGAgaW5zdGVhZCBvZiBgRXhpc3RpbmdSYXdTb3VyY2VtYXBgXG4gICAgICAgIHRoaXMub3JpZ2luYWxTb3VyY2VtYXAgPSBkZWNvZGVkU291cmNlbWFwKG9yaWdpbmFsU291cmNlbWFwKTtcbiAgICAgICAgdGhpcy5zb3VyY2VtYXBDaGFpbiA9IHNvdXJjZW1hcENoYWluLm1hcChtYXBPck1pc3NpbmcgPT4gbWFwT3JNaXNzaW5nLm1pc3NpbmcgPyBtYXBPck1pc3NpbmcgOiBkZWNvZGVkU291cmNlbWFwKG1hcE9yTWlzc2luZykpO1xuICAgICAgICAvLyBJZiBjb21pbmcgZnJvbSBjYWNoZSBhbmQgdGhpcyB2YWx1ZSBpcyBhbHJlYWR5IGZ1bGx5IGRlY29kZWQsIHdlIHdhbnQgdG8gcmUtZW5jb2RlIGhlcmUgdG8gc2F2ZSBtZW1vcnkuXG4gICAgICAgIHJlc2V0U291cmNlbWFwQ2FjaGUodGhpcy5vcmlnaW5hbFNvdXJjZW1hcCwgdGhpcy5zb3VyY2VtYXBDaGFpbik7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1GaWxlcykge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1GaWxlcyA9IHRyYW5zZm9ybUZpbGVzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmb3JtRGVwZW5kZW5jaWVzID0gdHJhbnNmb3JtRGVwZW5kZW5jaWVzO1xuICAgICAgICB0aGlzLmN1c3RvbVRyYW5zZm9ybUNhY2hlID0gY3VzdG9tVHJhbnNmb3JtQ2FjaGU7XG4gICAgICAgIHRoaXMudXBkYXRlT3B0aW9ucyhtb2R1bGVPcHRpb25zKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZElkcyA9IHJlc29sdmVkSWRzID8/IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIGBpZGAgaXMgdGhlIGZpbGUgbmFtZS4gQ3VzdG9tIHJlc29sdmVycyBhbmQgbG9hZGVyc1xuICAgICAgICAvLyBjYW4gY2hhbmdlIHRoYXQsIGJ1dCBpdCBtYWtlcyBzZW5zZSB0byB1c2UgaXQgZm9yIHRoZSBzb3VyY2UgZmlsZSBuYW1lXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gdGhpcy5pZDtcbiAgICAgICAgdGhpcy5tYWdpY1N0cmluZyA9IG5ldyBNYWdpY1N0cmluZyhjb2RlLCB7XG4gICAgICAgICAgICBmaWxlbmFtZTogKHRoaXMuZXhjbHVkZUZyb21Tb3VyY2VtYXAgPyBudWxsIDogZmlsZU5hbWUpLCAvLyBkb24ndCBpbmNsdWRlIHBsdWdpbiBoZWxwZXJzIGluIHNvdXJjZW1hcFxuICAgICAgICAgICAgaW5kZW50RXhjbHVzaW9uUmFuZ2VzOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hc3RDb250ZXh0ID0ge1xuICAgICAgICAgICAgYWRkRHluYW1pY0ltcG9ydDogdGhpcy5hZGREeW5hbWljSW1wb3J0LmJpbmQodGhpcyksXG4gICAgICAgICAgICBhZGRFeHBvcnQ6IHRoaXMuYWRkRXhwb3J0LmJpbmQodGhpcyksXG4gICAgICAgICAgICBhZGRJbXBvcnQ6IHRoaXMuYWRkSW1wb3J0LmJpbmQodGhpcyksXG4gICAgICAgICAgICBhZGRJbXBvcnRNZXRhOiB0aGlzLmFkZEltcG9ydE1ldGEuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGFkZEltcG9ydFNvdXJjZTogdGhpcy5hZGRJbXBvcnRTb3VyY2UuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNvZGUsIC8vIE9ubHkgbmVlZGVkIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgICAgIGRlb3B0aW1pemF0aW9uVHJhY2tlcjogdGhpcy5ncmFwaC5kZW9wdGltaXphdGlvblRyYWNrZXIsXG4gICAgICAgICAgICBlcnJvcjogdGhpcy5lcnJvci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZmlsZU5hbWUsIC8vIE5lZWRlZCBmb3Igd2FybmluZ3NcbiAgICAgICAgICAgIGdldEV4cG9ydHM6IHRoaXMuZ2V0RXhwb3J0cy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0SW1wb3J0ZWRKc3hGYWN0b3J5VmFyaWFibGU6IHRoaXMuZ2V0SW1wb3J0ZWRKc3hGYWN0b3J5VmFyaWFibGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldE1vZHVsZUV4ZWNJbmRleDogKCkgPT4gdGhpcy5leGVjSW5kZXgsXG4gICAgICAgICAgICBnZXRNb2R1bGVOYW1lOiB0aGlzLmJhc2VuYW1lLmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXROb2RlQ29uc3RydWN0b3I6IChuYW1lKSA9PiBub2RlQ29uc3RydWN0b3JzW25hbWVdIHx8IG5vZGVDb25zdHJ1Y3RvcnMuVW5rbm93bk5vZGUsXG4gICAgICAgICAgICBnZXRSZWV4cG9ydHM6IHRoaXMuZ2V0UmVleHBvcnRzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBpbXBvcnREZXNjcmlwdGlvbnM6IHRoaXMuaW1wb3J0RGVzY3JpcHRpb25zLFxuICAgICAgICAgICAgaW5jbHVkZUFsbEV4cG9ydHM6ICgpID0+IHRoaXMuaW5jbHVkZUFsbEV4cG9ydHModHJ1ZSksXG4gICAgICAgICAgICBpbmNsdWRlRHluYW1pY0ltcG9ydDogdGhpcy5pbmNsdWRlRHluYW1pY0ltcG9ydC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgaW5jbHVkZVZhcmlhYmxlSW5Nb2R1bGU6IHRoaXMuaW5jbHVkZVZhcmlhYmxlSW5Nb2R1bGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGxvZzogdGhpcy5sb2cuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG1hZ2ljU3RyaW5nOiB0aGlzLm1hZ2ljU3RyaW5nLFxuICAgICAgICAgICAgbWFudWFsUHVyZUZ1bmN0aW9uczogdGhpcy5ncmFwaC5wdXJlRnVuY3Rpb25zLFxuICAgICAgICAgICAgbW9kdWxlOiB0aGlzLFxuICAgICAgICAgICAgbW9kdWxlQ29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgcmVxdWVzdFRyZWVzaGFraW5nUGFzczogKCkgPT4gKHRoaXMuZ3JhcGgubmVlZHNUcmVlc2hha2luZ1Bhc3MgPSB0cnVlKSxcbiAgICAgICAgICAgIHRyYWNlRXhwb3J0OiAobmFtZSkgPT4gdGhpcy5nZXRWYXJpYWJsZUZvckV4cG9ydE5hbWUobmFtZSlbMF0sXG4gICAgICAgICAgICB0cmFjZVZhcmlhYmxlOiB0aGlzLnRyYWNlVmFyaWFibGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHVzZXNUb3BMZXZlbEF3YWl0OiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNjb3BlID0gbmV3IE1vZHVsZVNjb3BlKHRoaXMuZ3JhcGguc2NvcGUsIHRoaXMuYXN0Q29udGV4dCk7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlID0gbmV3IE5hbWVzcGFjZVZhcmlhYmxlKHRoaXMuYXN0Q29udGV4dCk7XG4gICAgICAgIGNvbnN0IHByb2dyYW1QYXJlbnQgPSB7IGNvbnRleHQ6IHRoaXMuYXN0Q29udGV4dCwgdHlwZTogJ01vZHVsZScgfTtcbiAgICAgICAgaWYgKGFzdCkge1xuICAgICAgICAgICAgdGhpcy5hc3QgPSBuZXcgbm9kZUNvbnN0cnVjdG9yc1thc3QudHlwZV0ocHJvZ3JhbVBhcmVudCwgdGhpcy5zY29wZSkucGFyc2VOb2RlKGFzdCk7XG4gICAgICAgICAgICB0aGlzLmluZm8uYXN0ID0gYXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTWVhc3VyaW5nIGFzeW5jaHJvbm91cyBjb2RlIGRvZXMgbm90IHByb3ZpZGUgcmVhc29uYWJsZSByZXN1bHRzXG4gICAgICAgICAgICB0aW1lRW5kKCdnZW5lcmF0ZSBhc3QnLCAzKTtcbiAgICAgICAgICAgIGNvbnN0IGFzdEJ1ZmZlciA9IGF3YWl0IHBhcnNlQXN5bmMoY29kZSwgZmFsc2UsIHRoaXMub3B0aW9ucy5qc3ggIT09IGZhbHNlKTtcbiAgICAgICAgICAgIHRpbWVTdGFydCgnZ2VuZXJhdGUgYXN0JywgMyk7XG4gICAgICAgICAgICB0aGlzLmFzdCA9IGNvbnZlcnRQcm9ncmFtKGFzdEJ1ZmZlciwgcHJvZ3JhbVBhcmVudCwgdGhpcy5zY29wZSk7XG4gICAgICAgICAgICAvLyBNYWtlIGxhenkgYW5kIGFwcGx5IExSVSBjYWNoZSB0byBub3QgaG9nIHRoZSBtZW1vcnlcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmluZm8sICdhc3QnLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdyYXBoLmFzdExydS5oYXMoZmlsZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ncmFwaC5hc3RMcnUuZ2V0KGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzdCA9IHRoaXMudHJ5UGFyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjYWNoZSBpcyBub3QgZGlzYWJsZWQsIHdlIG5lZWQgdG8ga2VlcCB0aGUgQVNUIGluIG1lbW9yeVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW50aWwgdGhlIGVuZCB3aGVuIHRoZSBjYWNoZSBpcyBnZW5lcmF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2FjaGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuaW5mbywgJ2FzdCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlZEFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRBc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGtlZXAgaXQgaW4gYSBzbWFsbCBMUlUgY2FjaGUgdG8gbm90IGhvZyB0b28gbXVjaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVtb3J5IGJ1dCBhbGxvdyB0aGUgc2FtZSBBU1QgdG8gYmUgcmVxdWVzdGVkIHNldmVyYWwgdGltZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLmFzdExydS5zZXQoZmlsZU5hbWUsIHBhcnNlZEFzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkQXN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGltZUVuZCgnZ2VuZXJhdGUgYXN0JywgMyk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFzdDogdGhpcy5pbmZvLmFzdCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuaW5mby5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgY29kZTogdGhpcy5pbmZvLmNvZGUsXG4gICAgICAgICAgICBjdXN0b21UcmFuc2Zvcm1DYWNoZTogdGhpcy5jdXN0b21UcmFuc2Zvcm1DYWNoZSxcbiAgICAgICAgICAgIGRlcGVuZGVuY2llczogQXJyYXkuZnJvbSh0aGlzLmRlcGVuZGVuY2llcywgZ2V0SWQpLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBtZXRhOiB0aGlzLmluZm8ubWV0YSxcbiAgICAgICAgICAgIG1vZHVsZVNpZGVFZmZlY3RzOiB0aGlzLmluZm8ubW9kdWxlU2lkZUVmZmVjdHMsXG4gICAgICAgICAgICBvcmlnaW5hbENvZGU6IHRoaXMub3JpZ2luYWxDb2RlLFxuICAgICAgICAgICAgb3JpZ2luYWxTb3VyY2VtYXA6IHRoaXMub3JpZ2luYWxTb3VyY2VtYXAsXG4gICAgICAgICAgICByZXNvbHZlZElkczogdGhpcy5yZXNvbHZlZElkcyxcbiAgICAgICAgICAgIHNvdXJjZW1hcENoYWluOiB0aGlzLnNvdXJjZW1hcENoYWluLFxuICAgICAgICAgICAgc3ludGhldGljTmFtZWRFeHBvcnRzOiB0aGlzLmluZm8uc3ludGhldGljTmFtZWRFeHBvcnRzLFxuICAgICAgICAgICAgdHJhbnNmb3JtRGVwZW5kZW5jaWVzOiB0aGlzLnRyYW5zZm9ybURlcGVuZGVuY2llcyxcbiAgICAgICAgICAgIHRyYW5zZm9ybUZpbGVzOiB0aGlzLnRyYW5zZm9ybUZpbGVzXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRyYWNlVmFyaWFibGUobmFtZSwgeyBpbXBvcnRlckZvclNpZGVFZmZlY3RzLCBpc0V4cG9ydEFsbFNlYXJjaCwgc2VhcmNoZWROYW1lc0FuZE1vZHVsZXMgfSA9IEVNUFRZX09CSkVDVCkge1xuICAgICAgICBjb25zdCBsb2NhbFZhcmlhYmxlID0gdGhpcy5zY29wZS52YXJpYWJsZXMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAobG9jYWxWYXJpYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyaWFibGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW1wb3J0RGVzY3JpcHRpb24gPSB0aGlzLmltcG9ydERlc2NyaXB0aW9ucy5nZXQobmFtZSk7XG4gICAgICAgIGlmIChpbXBvcnREZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJNb2R1bGUgPSBpbXBvcnREZXNjcmlwdGlvbi5tb2R1bGU7XG4gICAgICAgICAgICBpZiAob3RoZXJNb2R1bGUgaW5zdGFuY2VvZiBNb2R1bGUgJiYgaW1wb3J0RGVzY3JpcHRpb24ubmFtZSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyTW9kdWxlLm5hbWVzcGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFtkZWNsYXJhdGlvbl0gPSBnZXRWYXJpYWJsZUZvckV4cG9ydE5hbWVSZWN1cnNpdmUob3RoZXJNb2R1bGUsIGltcG9ydERlc2NyaXB0aW9uLm5hbWUsIGltcG9ydGVyRm9yU2lkZUVmZmVjdHMgfHwgdGhpcywgaXNFeHBvcnRBbGxTZWFyY2gsIHNlYXJjaGVkTmFtZXNBbmRNb2R1bGVzKTtcbiAgICAgICAgICAgIGlmICghZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihsb2dNaXNzaW5nRXhwb3J0KGltcG9ydERlc2NyaXB0aW9uLm5hbWUsIHRoaXMuaWQsIG90aGVyTW9kdWxlLmlkKSwgaW1wb3J0RGVzY3JpcHRpb24uc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB1cGRhdGVPcHRpb25zKHsgbWV0YSwgbW9kdWxlU2lkZUVmZmVjdHMsIHN5bnRoZXRpY05hbWVkRXhwb3J0cyB9KSB7XG4gICAgICAgIGlmIChtb2R1bGVTaWRlRWZmZWN0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluZm8ubW9kdWxlU2lkZUVmZmVjdHMgPSBtb2R1bGVTaWRlRWZmZWN0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ludGhldGljTmFtZWRFeHBvcnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaW5mby5zeW50aGV0aWNOYW1lZEV4cG9ydHMgPSBzeW50aGV0aWNOYW1lZEV4cG9ydHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmluZm8ubWV0YSwgbWV0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRHluYW1pY0ltcG9ydChub2RlKSB7XG4gICAgICAgIGxldCBhcmd1bWVudCA9IG5vZGUuc291cmNlQXN0Tm9kZTtcbiAgICAgICAgaWYgKGFyZ3VtZW50LnR5cGUgPT09IFRlbXBsYXRlTGl0ZXJhbCQxKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnQucXVhc2lzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBhcmd1bWVudC5xdWFzaXNbMF0udmFsdWUuY29va2VkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gYXJndW1lbnQucXVhc2lzWzBdLnZhbHVlLmNvb2tlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudC50eXBlID09PSBMaXRlcmFsJDEgJiZcbiAgICAgICAgICAgIHR5cGVvZiBhcmd1bWVudC52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGFyZ3VtZW50ID0gYXJndW1lbnQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5keW5hbWljSW1wb3J0cy5wdXNoKHsgYXJndW1lbnQsIGlkOiBudWxsLCBub2RlLCByZXNvbHV0aW9uOiBudWxsIH0pO1xuICAgIH1cbiAgICBhc3NlcnRVbmlxdWVFeHBvcnROYW1lKG5hbWUsIG5vZGVTdGFydCkge1xuICAgICAgICBpZiAodGhpcy5leHBvcnRzLmhhcyhuYW1lKSB8fCB0aGlzLnJlZXhwb3J0RGVzY3JpcHRpb25zLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihsb2dEdXBsaWNhdGVFeHBvcnRFcnJvcihuYW1lKSwgbm9kZVN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRFeHBvcnQobm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgZm9vO1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRVbmlxdWVFeHBvcnROYW1lKCdkZWZhdWx0Jywgbm9kZS5zdGFydCk7XG4gICAgICAgICAgICB0aGlzLmV4cG9ydHMuc2V0KCdkZWZhdWx0Jywge1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IG5vZGUudmFyaWFibGUuZ2V0QXNzaWduZWRWYXJpYWJsZU5hbWUoKSxcbiAgICAgICAgICAgICAgICBsb2NhbE5hbWU6ICdkZWZhdWx0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEV4cG9ydEFsbERlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBub2RlLnNvdXJjZS52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuYWRkU291cmNlKHNvdXJjZSwgbm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5leHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIC8vIGV4cG9ydCAqIGFzIG5hbWUgZnJvbSAnLi9vdGhlcidcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gbm9kZS5leHBvcnRlZCBpbnN0YW5jZW9mIExpdGVyYWwgPyBub2RlLmV4cG9ydGVkLnZhbHVlIDogbm9kZS5leHBvcnRlZC5uYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0VW5pcXVlRXhwb3J0TmFtZShuYW1lLCBub2RlLmV4cG9ydGVkLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZXhwb3J0RGVzY3JpcHRpb25zLnNldChuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsTmFtZTogJyonLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IG51bGwsIC8vIGZpbGxlZCBpbiBsYXRlcixcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogbm9kZS5zdGFydFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZXhwb3J0ICogZnJvbSAnLi9vdGhlcidcbiAgICAgICAgICAgICAgICB0aGlzLmV4cG9ydEFsbFNvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5zb3VyY2UgaW5zdGFuY2VvZiBMaXRlcmFsKSB7XG4gICAgICAgICAgICAvLyBleHBvcnQgeyBuYW1lIH0gZnJvbSAnLi9vdGhlcidcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IG5vZGUuc291cmNlLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5hZGRTb3VyY2Uoc291cmNlLCBub2RlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBleHBvcnRlZCwgbG9jYWwsIHN0YXJ0IH0gb2Ygbm9kZS5zcGVjaWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGV4cG9ydGVkIGluc3RhbmNlb2YgTGl0ZXJhbCA/IGV4cG9ydGVkLnZhbHVlIDogZXhwb3J0ZWQubmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2VydFVuaXF1ZUV4cG9ydE5hbWUobmFtZSwgc3RhcnQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVleHBvcnREZXNjcmlwdGlvbnMuc2V0KG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxOYW1lOiBsb2NhbCBpbnN0YW5jZW9mIExpdGVyYWwgPyBsb2NhbC52YWx1ZSA6IGxvY2FsLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZTogbnVsbCwgLy8gZmlsbGVkIGluIGxhdGVyLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5kZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSBub2RlLmRlY2xhcmF0aW9uO1xuICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9uIGluc3RhbmNlb2YgVmFyaWFibGVEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIGV4cG9ydCB2YXIgeyBmb28sIGJhciB9ID0gLi4uXG4gICAgICAgICAgICAgICAgLy8gZXhwb3J0IHZhciBmb28gPSAxLCBiYXIgPSAyO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVjbGFyYXRvciBvZiBkZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBsb2NhbE5hbWUgb2YgZXh0cmFjdEFzc2lnbmVkTmFtZXMoZGVjbGFyYXRvci5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0VW5pcXVlRXhwb3J0TmFtZShsb2NhbE5hbWUsIGRlY2xhcmF0b3IuaWQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBvcnRzLnNldChsb2NhbE5hbWUsIHsgaWRlbnRpZmllcjogbnVsbCwgbG9jYWxOYW1lIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZXhwb3J0IGZ1bmN0aW9uIGZvbyAoKSB7fVxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IGRlY2xhcmF0aW9uLmlkLm5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5hc3NlcnRVbmlxdWVFeHBvcnROYW1lKGxvY2FsTmFtZSwgZGVjbGFyYXRpb24uaWQuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwb3J0cy5zZXQobG9jYWxOYW1lLCB7IGlkZW50aWZpZXI6IG51bGwsIGxvY2FsTmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGV4cG9ydCB7IGZvbywgYmFyLCBiYXogfVxuICAgICAgICAgICAgZm9yIChjb25zdCB7IGxvY2FsLCBleHBvcnRlZCB9IG9mIG5vZGUuc3BlY2lmaWVycykge1xuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdCBmb3IgcmVleHBvcnRzLCBsb2NhbCBtdXN0IGJlIGFuIElkZW50aWZpZXJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbE5hbWUgPSBsb2NhbC5uYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cG9ydGVkTmFtZSA9IGV4cG9ydGVkIGluc3RhbmNlb2YgSWRlbnRpZmllciA/IGV4cG9ydGVkLm5hbWUgOiBleHBvcnRlZC52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2VydFVuaXF1ZUV4cG9ydE5hbWUoZXhwb3J0ZWROYW1lLCBleHBvcnRlZC5zdGFydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBvcnRzLnNldChleHBvcnRlZE5hbWUsIHsgaWRlbnRpZmllcjogbnVsbCwgbG9jYWxOYW1lIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEltcG9ydChub2RlKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG5vZGUuc291cmNlLnZhbHVlO1xuICAgICAgICB0aGlzLmFkZFNvdXJjZShzb3VyY2UsIG5vZGUpO1xuICAgICAgICBmb3IgKGNvbnN0IHNwZWNpZmllciBvZiBub2RlLnNwZWNpZmllcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IHNwZWNpZmllci5sb2NhbC5uYW1lO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NvcGUudmFyaWFibGVzLmhhcyhsb2NhbE5hbWUpIHx8IHRoaXMuaW1wb3J0RGVzY3JpcHRpb25zLmhhcyhsb2NhbE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihsb2dSZWRlY2xhcmF0aW9uRXJyb3IobG9jYWxOYW1lKSwgc3BlY2lmaWVyLmxvY2FsLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBzcGVjaWZpZXIgaW5zdGFuY2VvZiBJbXBvcnREZWZhdWx0U3BlY2lmaWVyXG4gICAgICAgICAgICAgICAgPyAnZGVmYXVsdCdcbiAgICAgICAgICAgICAgICA6IHNwZWNpZmllciBpbnN0YW5jZW9mIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllclxuICAgICAgICAgICAgICAgICAgICA/ICcqJ1xuICAgICAgICAgICAgICAgICAgICA6IHNwZWNpZmllci5pbXBvcnRlZCBpbnN0YW5jZW9mIElkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3BlY2lmaWVyLmltcG9ydGVkLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc3BlY2lmaWVyLmltcG9ydGVkLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5pbXBvcnREZXNjcmlwdGlvbnMuc2V0KGxvY2FsTmFtZSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogbnVsbCwgLy8gZmlsbGVkIGluIGxhdGVyXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHNwZWNpZmllci5zdGFydFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkSW1wb3J0U291cmNlKGltcG9ydFNvdXJjZSkge1xuICAgICAgICBpZiAoaW1wb3J0U291cmNlICYmICF0aGlzLnNvdXJjZXNXaXRoQXR0cmlidXRlcy5oYXMoaW1wb3J0U291cmNlKSkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VzV2l0aEF0dHJpYnV0ZXMuc2V0KGltcG9ydFNvdXJjZSwgRU1QVFlfT0JKRUNUKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRJbXBvcnRNZXRhKG5vZGUpIHtcbiAgICAgICAgdGhpcy5pbXBvcnRNZXRhcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICBhZGRMb2NhdGlvblRvTG9nUHJvcHMocHJvcGVydGllcywgcG9zKSB7XG4gICAgICAgIHByb3BlcnRpZXMuaWQgPSB0aGlzLmlkO1xuICAgICAgICBwcm9wZXJ0aWVzLnBvcyA9IHBvcztcbiAgICAgICAgbGV0IGNvZGUgPSB0aGlzLmluZm8uY29kZTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBsb2NhdGUoY29kZSwgcG9zLCB7IG9mZnNldExpbmU6IDEgfSk7XG4gICAgICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgICAgICAgbGV0IHsgY29sdW1uLCBsaW5lIH0gPSBsb2NhdGlvbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgKHsgY29sdW1uLCBsaW5lIH0gPSBnZXRPcmlnaW5hbExvY2F0aW9uKHRoaXMuc291cmNlbWFwQ2hhaW4sIHsgY29sdW1uLCBsaW5lIH0pKTtcbiAgICAgICAgICAgICAgICBjb2RlID0gdGhpcy5vcmlnaW5hbENvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3JfKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uTG9nKExPR0xFVkVMX1dBUk4sIGxvZ0ludmFsaWRTb3VyY2VtYXBGb3JFcnJvcihlcnJvcl8sIHRoaXMuaWQsIGNvbHVtbiwgbGluZSwgcG9zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdWdtZW50Q29kZUxvY2F0aW9uKHByb3BlcnRpZXMsIHsgY29sdW1uLCBsaW5lIH0sIGNvZGUsIHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZE1vZHVsZXNUb0ltcG9ydERlc2NyaXB0aW9ucyhpbXBvcnREZXNjcmlwdGlvbikge1xuICAgICAgICBmb3IgKGNvbnN0IHNwZWNpZmllciBvZiBpbXBvcnREZXNjcmlwdGlvbi52YWx1ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgeyBpZCB9ID0gdGhpcy5yZXNvbHZlZElkc1tzcGVjaWZpZXIuc291cmNlXTtcbiAgICAgICAgICAgIHNwZWNpZmllci5tb2R1bGUgPSB0aGlzLmdyYXBoLm1vZHVsZXNCeUlkLmdldChpZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkUmVsZXZhbnRTaWRlRWZmZWN0RGVwZW5kZW5jaWVzKHJlbGV2YW50RGVwZW5kZW5jaWVzLCBuZWNlc3NhcnlEZXBlbmRlbmNpZXMsIGFsd2F5c0NoZWNrZWREZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlZERlcGVuZGVuY2llcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgYWRkU2lkZUVmZmVjdERlcGVuZGVuY2llcyA9IChwb3NzaWJsZURlcGVuZGVuY2llcykgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIHBvc3NpYmxlRGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZWREZXBlbmRlbmNpZXMuaGFzKGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYW5kbGVkRGVwZW5kZW5jaWVzLmFkZChkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgICAgICBpZiAobmVjZXNzYXJ5RGVwZW5kZW5jaWVzLmhhcyhkZXBlbmRlbmN5KSkge1xuICAgICAgICAgICAgICAgICAgICByZWxldmFudERlcGVuZGVuY2llcy5hZGQoZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShkZXBlbmRlbmN5LmluZm8ubW9kdWxlU2lkZUVmZmVjdHMgfHwgYWx3YXlzQ2hlY2tlZERlcGVuZGVuY2llcy5oYXMoZGVwZW5kZW5jeSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVwZW5kZW5jeSBpbnN0YW5jZW9mIEV4dGVybmFsTW9kdWxlIHx8IGRlcGVuZGVuY3kuaGFzRWZmZWN0cygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGV2YW50RGVwZW5kZW5jaWVzLmFkZChkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFNpZGVFZmZlY3REZXBlbmRlbmNpZXMoZGVwZW5kZW5jeS5kZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhZGRTaWRlRWZmZWN0RGVwZW5kZW5jaWVzKHRoaXMuZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgYWRkU2lkZUVmZmVjdERlcGVuZGVuY2llcyhhbHdheXNDaGVja2VkRGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgYWRkU291cmNlKHNvdXJjZSwgZGVjbGFyYXRpb24pIHtcbiAgICAgICAgY29uc3QgcGFyc2VkQXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXNGcm9tSW1wb3J0RXhwb3J0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24uYXR0cmlidXRlcyk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQXR0cmlidXRlcyA9IHRoaXMuc291cmNlc1dpdGhBdHRyaWJ1dGVzLmdldChzb3VyY2UpO1xuICAgICAgICBpZiAoZXhpc3RpbmdBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoZG9BdHRyaWJ1dGVzRGlmZmVyKGV4aXN0aW5nQXR0cmlidXRlcywgcGFyc2VkQXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZyhMT0dMRVZFTF9XQVJOLCBsb2dJbmNvbnNpc3RlbnRJbXBvcnRBdHRyaWJ1dGVzKGV4aXN0aW5nQXR0cmlidXRlcywgcGFyc2VkQXR0cmlidXRlcywgc291cmNlLCB0aGlzLmlkKSwgZGVjbGFyYXRpb24uc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VzV2l0aEF0dHJpYnV0ZXMuc2V0KHNvdXJjZSwgcGFyc2VkQXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0SW1wb3J0ZWRKc3hGYWN0b3J5VmFyaWFibGUoYmFzZU5hbWUsIG5vZGVTdGFydCwgaW1wb3J0U291cmNlKSB7XG4gICAgICAgIGNvbnN0IHsgaWQgfSA9IHRoaXMucmVzb2x2ZWRJZHNbaW1wb3J0U291cmNlXTtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gdGhpcy5ncmFwaC5tb2R1bGVzQnlJZC5nZXQoaWQpO1xuICAgICAgICBjb25zdCBbdmFyaWFibGVdID0gbW9kdWxlLmdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZShiYXNlTmFtZSk7XG4gICAgICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKGxvZ01pc3NpbmdKc3hFeHBvcnQoYmFzZU5hbWUsIGlkLCB0aGlzLmlkKSwgbm9kZVN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFyaWFibGU7XG4gICAgfVxuICAgIGdldFZhcmlhYmxlRnJvbU5hbWVzcGFjZVJlZXhwb3J0cyhuYW1lLCBpbXBvcnRlckZvclNpZGVFZmZlY3RzLCBzZWFyY2hlZE5hbWVzQW5kTW9kdWxlcykge1xuICAgICAgICBsZXQgZm91bmRTeW50aGV0aWNEZWNsYXJhdGlvbiA9IG51bGw7XG4gICAgICAgIGNvbnN0IGZvdW5kSW50ZXJuYWxEZWNsYXJhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGZvdW5kRXh0ZXJuYWxEZWNsYXJhdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIHRoaXMuZXhwb3J0QWxsTW9kdWxlcykge1xuICAgICAgICAgICAgLy8gU3ludGhldGljIG5hbWVzcGFjZXMgc2hvdWxkIG5vdCBoaWRlIFwicmVndWxhclwiIGV4cG9ydHMgb2YgdGhlIHNhbWUgbmFtZVxuICAgICAgICAgICAgaWYgKG1vZHVsZS5pbmZvLnN5bnRoZXRpY05hbWVkRXhwb3J0cyA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW3ZhcmlhYmxlLCBpbmRpcmVjdEV4dGVybmFsXSA9IGdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZVJlY3Vyc2l2ZShtb2R1bGUsIG5hbWUsIGltcG9ydGVyRm9yU2lkZUVmZmVjdHMsIHRydWUsIFxuICAgICAgICAgICAgLy8gV2UgYXJlIGNyZWF0aW5nIGEgY29weSB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIHNhbWUgYmluZGluZyBpc1xuICAgICAgICAgICAgLy8gaW1wb3J0ZWQgdGhyb3VnaCBkaWZmZXJlbnQgbmFtZXNwYWNlIHJlZXhwb3J0cyBncmFjZWZ1bGx5XG4gICAgICAgICAgICBjb3B5TmFtZVRvTW9kdWxlc01hcChzZWFyY2hlZE5hbWVzQW5kTW9kdWxlcykpO1xuICAgICAgICAgICAgaWYgKG1vZHVsZSBpbnN0YW5jZW9mIEV4dGVybmFsTW9kdWxlIHx8IGluZGlyZWN0RXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICBmb3VuZEV4dGVybmFsRGVjbGFyYXRpb25zLmFkZCh2YXJpYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YXJpYWJsZSBpbnN0YW5jZW9mIFN5bnRoZXRpY05hbWVkRXhwb3J0VmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kU3ludGhldGljRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRTeW50aGV0aWNEZWNsYXJhdGlvbiA9IHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgZm91bmRJbnRlcm5hbERlY2xhcmF0aW9ucy5zZXQodmFyaWFibGUsIG1vZHVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kSW50ZXJuYWxEZWNsYXJhdGlvbnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZvdW5kRGVjbGFyYXRpb25MaXN0ID0gWy4uLmZvdW5kSW50ZXJuYWxEZWNsYXJhdGlvbnNdO1xuICAgICAgICAgICAgY29uc3QgdXNlZERlY2xhcmF0aW9uID0gZm91bmREZWNsYXJhdGlvbkxpc3RbMF1bMF07XG4gICAgICAgICAgICBpZiAoZm91bmREZWNsYXJhdGlvbkxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt1c2VkRGVjbGFyYXRpb25dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uTG9nKExPR0xFVkVMX1dBUk4sIGxvZ05hbWVzcGFjZUNvbmZsaWN0KG5hbWUsIHRoaXMuaWQsIGZvdW5kRGVjbGFyYXRpb25MaXN0Lm1hcCgoWywgbW9kdWxlXSkgPT4gbW9kdWxlLmlkKSkpO1xuICAgICAgICAgICAgLy8gVE9ETyB3ZSBhcmUgcHJldGVuZGluZyBpdCB3YXMgbm90IGZvdW5kIHdoaWxlIGl0IHNob3VsZCBiZWhhdmUgbGlrZSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICByZXR1cm4gW251bGxdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZEV4dGVybmFsRGVjbGFyYXRpb25zLnNpemUgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBmb3VuZERlY2xhcmF0aW9uTGlzdCA9IFsuLi5mb3VuZEV4dGVybmFsRGVjbGFyYXRpb25zXTtcbiAgICAgICAgICAgIGNvbnN0IHVzZWREZWNsYXJhdGlvbiA9IGZvdW5kRGVjbGFyYXRpb25MaXN0WzBdO1xuICAgICAgICAgICAgaWYgKGZvdW5kRGVjbGFyYXRpb25MaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25Mb2coTE9HTEVWRUxfV0FSTiwgbG9nQW1iaWd1b3VzRXh0ZXJuYWxOYW1lc3BhY2VzKG5hbWUsIHRoaXMuaWQsIHVzZWREZWNsYXJhdGlvbi5tb2R1bGUuaWQsIGZvdW5kRGVjbGFyYXRpb25MaXN0Lm1hcChkZWNsYXJhdGlvbiA9PiBkZWNsYXJhdGlvbi5tb2R1bGUuaWQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3VzZWREZWNsYXJhdGlvbiwgdHJ1ZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kU3ludGhldGljRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBbZm91bmRTeW50aGV0aWNEZWNsYXJhdGlvbl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtudWxsXTtcbiAgICB9XG4gICAgaW5jbHVkZUFuZEdldEFkZGl0aW9uYWxNZXJnZWROYW1lc3BhY2VzKCkge1xuICAgICAgICBjb25zdCBleHRlcm5hbE5hbWVzcGFjZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IHN5bnRoZXRpY05hbWVzcGFjZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIFt0aGlzLCAuLi50aGlzLmV4cG9ydEFsbE1vZHVsZXNdKSB7XG4gICAgICAgICAgICBpZiAobW9kdWxlIGluc3RhbmNlb2YgRXh0ZXJuYWxNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbZXh0ZXJuYWxWYXJpYWJsZV0gPSBtb2R1bGUuZ2V0VmFyaWFibGVGb3JFeHBvcnROYW1lKCcqJyk7XG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxWYXJpYWJsZS5pbmNsdWRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNsdWRlZEltcG9ydHMuYWRkKGV4dGVybmFsVmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIGV4dGVybmFsTmFtZXNwYWNlcy5hZGQoZXh0ZXJuYWxWYXJpYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2R1bGUuaW5mby5zeW50aGV0aWNOYW1lZEV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW50aGV0aWNOYW1lc3BhY2UgPSBtb2R1bGUuZ2V0U3ludGhldGljTmFtZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgc3ludGhldGljTmFtZXNwYWNlLmluY2x1ZGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluY2x1ZGVkSW1wb3J0cy5hZGQoc3ludGhldGljTmFtZXNwYWNlKTtcbiAgICAgICAgICAgICAgICBzeW50aGV0aWNOYW1lc3BhY2VzLmFkZChzeW50aGV0aWNOYW1lc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4uc3ludGhldGljTmFtZXNwYWNlcywgLi4uZXh0ZXJuYWxOYW1lc3BhY2VzXTtcbiAgICB9XG4gICAgaW5jbHVkZUR5bmFtaWNJbXBvcnQobm9kZSkge1xuICAgICAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5keW5hbWljSW1wb3J0cy5maW5kKGR5bmFtaWNJbXBvcnQgPT4gZHluYW1pY0ltcG9ydC5ub2RlID09PSBub2RlKS5yZXNvbHV0aW9uO1xuICAgICAgICBpZiAocmVzb2x1dGlvbiBpbnN0YW5jZW9mIE1vZHVsZSkge1xuICAgICAgICAgICAgcmVzb2x1dGlvbi5pbmNsdWRlZER5bmFtaWNJbXBvcnRlcnMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydGVkTmFtZXMgPSB0aGlzLm9wdGlvbnMudHJlZXNoYWtlXG4gICAgICAgICAgICAgICAgPyBub2RlLmdldERldGVybWluaXN0aWNJbXBvcnRlZE5hbWVzKClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChpbXBvcnRlZE5hbWVzKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvbi5pbmNsdWRlRXhwb3J0c0J5TmFtZXMoaW1wb3J0ZWROYW1lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHV0aW9uLmluY2x1ZGVBbGxFeHBvcnRzKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGluY2x1ZGVWYXJpYWJsZSh2YXJpYWJsZSkge1xuICAgICAgICBjb25zdCB2YXJpYWJsZU1vZHVsZSA9IHZhcmlhYmxlLm1vZHVsZTtcbiAgICAgICAgaWYgKHZhcmlhYmxlLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICBpZiAodmFyaWFibGVNb2R1bGUgaW5zdGFuY2VvZiBNb2R1bGUgJiYgdmFyaWFibGVNb2R1bGUgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBnZXRBbmRFeHRlbmRTaWRlRWZmZWN0TW9kdWxlcyh2YXJpYWJsZSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXJpYWJsZS5pbmNsdWRlKCk7XG4gICAgICAgICAgICB0aGlzLmdyYXBoLm5lZWRzVHJlZXNoYWtpbmdQYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZU1vZHVsZSBpbnN0YW5jZW9mIE1vZHVsZSkge1xuICAgICAgICAgICAgICAgIGlmICghdmFyaWFibGVNb2R1bGUuaXNFeGVjdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBtYXJrTW9kdWxlQW5kSW1wdXJlRGVwZW5kZW5jaWVzQXNFeGVjdXRlZCh2YXJpYWJsZU1vZHVsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZU1vZHVsZSAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWRlRWZmZWN0TW9kdWxlcyA9IGdldEFuZEV4dGVuZFNpZGVFZmZlY3RNb2R1bGVzKHZhcmlhYmxlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2Ygc2lkZUVmZmVjdE1vZHVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbW9kdWxlLmlzRXhlY3V0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrTW9kdWxlQW5kSW1wdXJlRGVwZW5kZW5jaWVzQXNFeGVjdXRlZChtb2R1bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGluY2x1ZGVWYXJpYWJsZUluTW9kdWxlKHZhcmlhYmxlKSB7XG4gICAgICAgIHRoaXMuaW5jbHVkZVZhcmlhYmxlKHZhcmlhYmxlKTtcbiAgICAgICAgY29uc3QgdmFyaWFibGVNb2R1bGUgPSB2YXJpYWJsZS5tb2R1bGU7XG4gICAgICAgIGlmICh2YXJpYWJsZU1vZHVsZSAmJiB2YXJpYWJsZU1vZHVsZSAhPT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5pbmNsdWRlZEltcG9ydHMuYWRkKHZhcmlhYmxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaGltTWlzc2luZ0V4cG9ydChuYW1lKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkxvZyhMT0dMRVZFTF9XQVJOLCBsb2dTaGltbWVkRXhwb3J0KHRoaXMuaWQsIG5hbWUpKTtcbiAgICAgICAgdGhpcy5leHBvcnRzLnNldChuYW1lLCBNSVNTSU5HX0VYUE9SVF9TSElNX0RFU0NSSVBUSU9OKTtcbiAgICB9XG4gICAgdHJ5UGFyc2UoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VBc3QodGhpcy5pbmZvLmNvZGUsIHsganN4OiB0aGlzLm9wdGlvbnMuanN4ICE9PSBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3JfKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihsb2dNb2R1bGVQYXJzZUVycm9yKGVycm9yXywgdGhpcy5pZCksIGVycm9yXy5wb3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gaWYgdGhlcmUgaXMgYSBjeWNsaWMgaW1wb3J0IGluIHRoZSByZWV4cG9ydCBjaGFpbiwgd2Ugc2hvdWxkIG5vdFxuLy8gaW1wb3J0IGZyb20gdGhlIG9yaWdpbmFsIG1vZHVsZSBidXQgZnJvbSB0aGUgY3ljbGljIG1vZHVsZSB0byBub3Rcbi8vIG1lc3MgdXAgZXhlY3V0aW9uIG9yZGVyLlxuZnVuY3Rpb24gc2V0QWx0ZXJuYXRpdmVFeHBvcnRlcklmQ3ljbGljKHZhcmlhYmxlLCBpbXBvcnRlciwgcmVleHBvcnRlcikge1xuICAgIGlmICh2YXJpYWJsZS5tb2R1bGUgaW5zdGFuY2VvZiBNb2R1bGUgJiYgdmFyaWFibGUubW9kdWxlICE9PSByZWV4cG9ydGVyKSB7XG4gICAgICAgIGNvbnN0IGV4cG9ydGVyQ3ljbGVzID0gdmFyaWFibGUubW9kdWxlLmN5Y2xlcztcbiAgICAgICAgaWYgKGV4cG9ydGVyQ3ljbGVzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpbXBvcnRlckN5Y2xlcyA9IHJlZXhwb3J0ZXIuY3ljbGVzO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjeWNsZVN5bWJvbCBvZiBpbXBvcnRlckN5Y2xlcykge1xuICAgICAgICAgICAgICAgIGlmIChleHBvcnRlckN5Y2xlcy5oYXMoY3ljbGVTeW1ib2wpKSB7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGVyLmFsdGVybmF0aXZlUmVleHBvcnRNb2R1bGVzLnNldCh2YXJpYWJsZSwgcmVleHBvcnRlcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGNvcHlOYW1lVG9Nb2R1bGVzTWFwID0gKHNlYXJjaGVkTmFtZXNBbmRNb2R1bGVzKSA9PiBzZWFyY2hlZE5hbWVzQW5kTW9kdWxlcyAmJlxuICAgIG5ldyBNYXAoQXJyYXkuZnJvbShzZWFyY2hlZE5hbWVzQW5kTW9kdWxlcywgKFtuYW1lLCBtb2R1bGVzXSkgPT4gW25hbWUsIG5ldyBTZXQobW9kdWxlcyldKSk7XG5cbmNvbnN0IGNvbmNhdFNlcGFyYXRvciA9IChvdXQsIG5leHQpID0+IChuZXh0ID8gYCR7b3V0fVxcbiR7bmV4dH1gIDogb3V0KTtcbmNvbnN0IGNvbmNhdERibFNlcGFyYXRvciA9IChvdXQsIG5leHQpID0+IChuZXh0ID8gYCR7b3V0fVxcblxcbiR7bmV4dH1gIDogb3V0KTtcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUFkZG9ucyhvcHRpb25zLCBvdXRwdXRQbHVnaW5Ecml2ZXIsIGNodW5rKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IFtiYW5uZXIsIGZvb3RlciwgaW50cm8sIG91dHJvXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIG91dHB1dFBsdWdpbkRyaXZlci5ob29rUmVkdWNlVmFsdWUoJ2Jhbm5lcicsIG9wdGlvbnMuYmFubmVyKGNodW5rKSwgW2NodW5rXSwgY29uY2F0U2VwYXJhdG9yKSxcbiAgICAgICAgICAgIG91dHB1dFBsdWdpbkRyaXZlci5ob29rUmVkdWNlVmFsdWUoJ2Zvb3RlcicsIG9wdGlvbnMuZm9vdGVyKGNodW5rKSwgW2NodW5rXSwgY29uY2F0U2VwYXJhdG9yKSxcbiAgICAgICAgICAgIG91dHB1dFBsdWdpbkRyaXZlci5ob29rUmVkdWNlVmFsdWUoJ2ludHJvJywgb3B0aW9ucy5pbnRybyhjaHVuayksIFtjaHVua10sIGNvbmNhdERibFNlcGFyYXRvciksXG4gICAgICAgICAgICBvdXRwdXRQbHVnaW5Ecml2ZXIuaG9va1JlZHVjZVZhbHVlKCdvdXRybycsIG9wdGlvbnMub3V0cm8oY2h1bmspLCBbY2h1bmtdLCBjb25jYXREYmxTZXBhcmF0b3IpXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoaW50cm8pXG4gICAgICAgICAgICBpbnRybyArPSAnXFxuXFxuJztcbiAgICAgICAgaWYgKG91dHJvKVxuICAgICAgICAgICAgb3V0cm8gPSBgXFxuXFxuJHtvdXRyb31gO1xuICAgICAgICBpZiAoYmFubmVyKVxuICAgICAgICAgICAgYmFubmVyICs9ICdcXG4nO1xuICAgICAgICBpZiAoZm9vdGVyKVxuICAgICAgICAgICAgZm9vdGVyID0gJ1xcbicgKyBmb290ZXI7XG4gICAgICAgIHJldHVybiB7IGJhbm5lciwgZm9vdGVyLCBpbnRybywgb3V0cm8gfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yXykge1xuICAgICAgICByZXR1cm4gZXJyb3IobG9nQWRkb25Ob3RHZW5lcmF0ZWQoZXJyb3JfLm1lc3NhZ2UsIGVycm9yXy5ob29rLCBlcnJvcl8ucGx1Z2luKSk7XG4gICAgfVxufVxuXG5jb25zdCBERUNPTkZMSUNUX0lNUE9SVEVEX1ZBUklBQkxFU19CWV9GT1JNQVQgPSB7XG4gICAgYW1kOiBkZWNvbmZsaWN0SW1wb3J0c090aGVyLFxuICAgIGNqczogZGVjb25mbGljdEltcG9ydHNPdGhlcixcbiAgICBlczogZGVjb25mbGljdEltcG9ydHNFc21PclN5c3RlbSxcbiAgICBpaWZlOiBkZWNvbmZsaWN0SW1wb3J0c090aGVyLFxuICAgIHN5c3RlbTogZGVjb25mbGljdEltcG9ydHNFc21PclN5c3RlbSxcbiAgICB1bWQ6IGRlY29uZmxpY3RJbXBvcnRzT3RoZXJcbn07XG5mdW5jdGlvbiBkZWNvbmZsaWN0Q2h1bmsobW9kdWxlcywgZGVwZW5kZW5jaWVzVG9CZURlY29uZmxpY3RlZCwgaW1wb3J0cywgdXNlZE5hbWVzLCBmb3JtYXQsIGludGVyb3AsIHByZXNlcnZlTW9kdWxlcywgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGNodW5rQnlNb2R1bGUsIGV4dGVybmFsQ2h1bmtCeU1vZHVsZSwgc3ludGhldGljRXhwb3J0cywgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlLCBpbmNsdWRlZE5hbWVzcGFjZXMpIHtcbiAgICBjb25zdCByZXZlcnNlZE1vZHVsZXMgPSBbLi4ubW9kdWxlc10ucmV2ZXJzZSgpO1xuICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIHJldmVyc2VkTW9kdWxlcykge1xuICAgICAgICBtb2R1bGUuc2NvcGUuYWRkVXNlZE91dHNpZGVOYW1lcyh1c2VkTmFtZXMsIGZvcm1hdCwgZXhwb3J0TmFtZXNCeVZhcmlhYmxlLCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlKTtcbiAgICB9XG4gICAgZGVjb25mbGljdFRvcExldmVsVmFyaWFibGVzKHVzZWROYW1lcywgcmV2ZXJzZWRNb2R1bGVzLCBpbmNsdWRlZE5hbWVzcGFjZXMpO1xuICAgIERFQ09ORkxJQ1RfSU1QT1JURURfVkFSSUFCTEVTX0JZX0ZPUk1BVFtmb3JtYXRdKHVzZWROYW1lcywgaW1wb3J0cywgZGVwZW5kZW5jaWVzVG9CZURlY29uZmxpY3RlZCwgaW50ZXJvcCwgcHJlc2VydmVNb2R1bGVzLCBleHRlcm5hbExpdmVCaW5kaW5ncywgY2h1bmtCeU1vZHVsZSwgZXh0ZXJuYWxDaHVua0J5TW9kdWxlLCBzeW50aGV0aWNFeHBvcnRzKTtcbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiByZXZlcnNlZE1vZHVsZXMpIHtcbiAgICAgICAgbW9kdWxlLnNjb3BlLmRlY29uZmxpY3QoZm9ybWF0LCBleHBvcnROYW1lc0J5VmFyaWFibGUsIGFjY2Vzc2VkR2xvYmFsc0J5U2NvcGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlY29uZmxpY3RJbXBvcnRzRXNtT3JTeXN0ZW0odXNlZE5hbWVzLCBpbXBvcnRzLCBkZXBlbmRlbmNpZXNUb0JlRGVjb25mbGljdGVkLCBfaW50ZXJvcCwgcHJlc2VydmVNb2R1bGVzLCBfZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGNodW5rQnlNb2R1bGUsIGV4dGVybmFsQ2h1bmtCeU1vZHVsZSwgc3ludGhldGljRXhwb3J0cykge1xuICAgIC8vIFRoaXMgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2UgcmVleHBvcnRzXG4gICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIGRlcGVuZGVuY2llc1RvQmVEZWNvbmZsaWN0ZWQuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGlmIChwcmVzZXJ2ZU1vZHVsZXMgfHwgZGVwZW5kZW5jeSBpbnN0YW5jZW9mIEV4dGVybmFsQ2h1bmspIHtcbiAgICAgICAgICAgIGRlcGVuZGVuY3kudmFyaWFibGVOYW1lID0gZ2V0U2FmZU5hbWUoZGVwZW5kZW5jeS5zdWdnZXN0ZWRWYXJpYWJsZU5hbWUsIHVzZWROYW1lcywgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB2YXJpYWJsZSBvZiBpbXBvcnRzKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IHZhcmlhYmxlLm1vZHVsZTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHZhcmlhYmxlLm5hbWU7XG4gICAgICAgIGlmICh2YXJpYWJsZS5pc05hbWVzcGFjZSAmJiAocHJlc2VydmVNb2R1bGVzIHx8IG1vZHVsZSBpbnN0YW5jZW9mIEV4dGVybmFsTW9kdWxlKSkge1xuICAgICAgICAgICAgdmFyaWFibGUuc2V0UmVuZGVyTmFtZXMobnVsbCwgKG1vZHVsZSBpbnN0YW5jZW9mIEV4dGVybmFsTW9kdWxlXG4gICAgICAgICAgICAgICAgPyBleHRlcm5hbENodW5rQnlNb2R1bGUuZ2V0KG1vZHVsZSlcbiAgICAgICAgICAgICAgICA6IGNodW5rQnlNb2R1bGUuZ2V0KG1vZHVsZSkpLnZhcmlhYmxlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobW9kdWxlIGluc3RhbmNlb2YgRXh0ZXJuYWxNb2R1bGUgJiYgbmFtZSA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICB2YXJpYWJsZS5zZXRSZW5kZXJOYW1lcyhudWxsLCBnZXRTYWZlTmFtZShbLi4ubW9kdWxlLmV4cG9ydGVkVmFyaWFibGVzXS5zb21lKChbZXhwb3J0ZWRWYXJpYWJsZSwgZXhwb3J0ZWROYW1lXSkgPT4gZXhwb3J0ZWROYW1lID09PSAnKicgJiYgZXhwb3J0ZWRWYXJpYWJsZS5pbmNsdWRlZClcbiAgICAgICAgICAgICAgICA/IG1vZHVsZS5zdWdnZXN0ZWRWYXJpYWJsZU5hbWUgKyAnX19kZWZhdWx0J1xuICAgICAgICAgICAgICAgIDogbW9kdWxlLnN1Z2dlc3RlZFZhcmlhYmxlTmFtZSwgdXNlZE5hbWVzLCB2YXJpYWJsZS5mb3JiaWRkZW5OYW1lcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyaWFibGUuc2V0UmVuZGVyTmFtZXMobnVsbCwgZ2V0U2FmZU5hbWUobWFrZUxlZ2FsKG5hbWUpLCB1c2VkTmFtZXMsIHZhcmlhYmxlLmZvcmJpZGRlbk5hbWVzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB2YXJpYWJsZSBvZiBzeW50aGV0aWNFeHBvcnRzKSB7XG4gICAgICAgIHZhcmlhYmxlLnNldFJlbmRlck5hbWVzKG51bGwsIGdldFNhZmVOYW1lKHZhcmlhYmxlLm5hbWUsIHVzZWROYW1lcywgdmFyaWFibGUuZm9yYmlkZGVuTmFtZXMpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZWNvbmZsaWN0SW1wb3J0c090aGVyKHVzZWROYW1lcywgaW1wb3J0cywgeyBkZWNvbmZsaWN0ZWREZWZhdWx0LCBkZWNvbmZsaWN0ZWROYW1lc3BhY2UsIGRlcGVuZGVuY2llcyB9LCBpbnRlcm9wLCBwcmVzZXJ2ZU1vZHVsZXMsIGV4dGVybmFsTGl2ZUJpbmRpbmdzLCBjaHVua0J5TW9kdWxlLCBleHRlcm5hbENodW5rQnlNb2R1bGUpIHtcbiAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGRlcGVuZGVuY2llcykge1xuICAgICAgICBjaHVuay52YXJpYWJsZU5hbWUgPSBnZXRTYWZlTmFtZShjaHVuay5zdWdnZXN0ZWRWYXJpYWJsZU5hbWUsIHVzZWROYW1lcywgbnVsbCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgZGVjb25mbGljdGVkTmFtZXNwYWNlKSB7XG4gICAgICAgIGNodW5rLm5hbWVzcGFjZVZhcmlhYmxlTmFtZSA9IGdldFNhZmVOYW1lKGAke2NodW5rLnN1Z2dlc3RlZFZhcmlhYmxlTmFtZX1fX25hbWVzcGFjZWAsIHVzZWROYW1lcywgbnVsbCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXh0ZXJuYWxNb2R1bGUgb2YgZGVjb25mbGljdGVkRGVmYXVsdCkge1xuICAgICAgICBleHRlcm5hbE1vZHVsZS5kZWZhdWx0VmFyaWFibGVOYW1lID1cbiAgICAgICAgICAgIGRlY29uZmxpY3RlZE5hbWVzcGFjZS5oYXMoZXh0ZXJuYWxNb2R1bGUpICYmXG4gICAgICAgICAgICAgICAgY2FuRGVmYXVsdEJlVGFrZW5Gcm9tTmFtZXNwYWNlKGludGVyb3AoZXh0ZXJuYWxNb2R1bGUuaWQpLCBleHRlcm5hbExpdmVCaW5kaW5ncylcbiAgICAgICAgICAgICAgICA/IGV4dGVybmFsTW9kdWxlLm5hbWVzcGFjZVZhcmlhYmxlTmFtZVxuICAgICAgICAgICAgICAgIDogZ2V0U2FmZU5hbWUoYCR7ZXh0ZXJuYWxNb2R1bGUuc3VnZ2VzdGVkVmFyaWFibGVOYW1lfV9fZGVmYXVsdGAsIHVzZWROYW1lcywgbnVsbCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgaW1wb3J0cykge1xuICAgICAgICBjb25zdCBtb2R1bGUgPSB2YXJpYWJsZS5tb2R1bGU7XG4gICAgICAgIGlmIChtb2R1bGUgaW5zdGFuY2VvZiBFeHRlcm5hbE1vZHVsZSkge1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBleHRlcm5hbENodW5rQnlNb2R1bGUuZ2V0KG1vZHVsZSk7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdmFyaWFibGUubmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2R1bGVJbnRlcm9wID0gaW50ZXJvcChtb2R1bGUuaWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IGRlZmF1bHRJbnRlcm9wSGVscGVyc0J5SW50ZXJvcFR5cGVbbW9kdWxlSW50ZXJvcF1cbiAgICAgICAgICAgICAgICAgICAgPyBjaHVuay5kZWZhdWx0VmFyaWFibGVOYW1lXG4gICAgICAgICAgICAgICAgICAgIDogY2h1bmsudmFyaWFibGVOYW1lO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZmF1bHRBUHJvcGVydHkobW9kdWxlSW50ZXJvcCwgZXh0ZXJuYWxMaXZlQmluZGluZ3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlLnNldFJlbmRlck5hbWVzKHZhcmlhYmxlTmFtZSwgJ2RlZmF1bHQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlLnNldFJlbmRlck5hbWVzKG51bGwsIHZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGUuc2V0UmVuZGVyTmFtZXMobnVsbCwgbmFtZXNwYWNlSW50ZXJvcEhlbHBlcnNCeUludGVyb3BUeXBlW2ludGVyb3AobW9kdWxlLmlkKV1cbiAgICAgICAgICAgICAgICAgICAgPyBjaHVuay5uYW1lc3BhY2VWYXJpYWJsZU5hbWVcbiAgICAgICAgICAgICAgICAgICAgOiBjaHVuay52YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgYG51bGxgLCBpdCB1c2VzIGl0cyBcIm5hbWVcIiBmb3IgdGhlIHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgICAgICB2YXJpYWJsZS5zZXRSZW5kZXJOYW1lcyhjaHVuay52YXJpYWJsZU5hbWUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBjaHVua0J5TW9kdWxlLmdldChtb2R1bGUpO1xuICAgICAgICAgICAgaWYgKHByZXNlcnZlTW9kdWxlcyAmJiB2YXJpYWJsZS5pc05hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlLnNldFJlbmRlck5hbWVzKG51bGwsIGNodW5rLmV4cG9ydE1vZGUgPT09ICdkZWZhdWx0JyA/IGNodW5rLm5hbWVzcGFjZVZhcmlhYmxlTmFtZSA6IGNodW5rLnZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaHVuay5leHBvcnRNb2RlID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZS5zZXRSZW5kZXJOYW1lcyhudWxsLCBjaHVuay52YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGUuc2V0UmVuZGVyTmFtZXMoY2h1bmsudmFyaWFibGVOYW1lLCBjaHVuay5nZXRWYXJpYWJsZUV4cG9ydE5hbWUodmFyaWFibGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGRlY29uZmxpY3RUb3BMZXZlbFZhcmlhYmxlcyh1c2VkTmFtZXMsIG1vZHVsZXMsIGluY2x1ZGVkTmFtZXNwYWNlcykge1xuICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCB2YXJpYWJsZSBvZiBtb2R1bGUuc2NvcGUudmFyaWFibGVzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAodmFyaWFibGUuaW5jbHVkZWQgJiZcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgb25seSBoYXBwZW4gZm9yIGV4cG9ydHMgaW4gc29tZSBmb3JtYXRzXG4gICAgICAgICAgICAgICAgISh2YXJpYWJsZS5yZW5kZXJCYXNlTmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAodmFyaWFibGUgaW5zdGFuY2VvZiBFeHBvcnREZWZhdWx0VmFyaWFibGUgJiYgdmFyaWFibGUuZ2V0T3JpZ2luYWxWYXJpYWJsZSgpICE9PSB2YXJpYWJsZSkpKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGUuc2V0UmVuZGVyTmFtZXMobnVsbCwgZ2V0U2FmZU5hbWUodmFyaWFibGUubmFtZSwgdXNlZE5hbWVzLCB2YXJpYWJsZS5mb3JiaWRkZW5OYW1lcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmNsdWRlZE5hbWVzcGFjZXMuaGFzKG1vZHVsZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IG1vZHVsZS5uYW1lc3BhY2U7XG4gICAgICAgICAgICBuYW1lc3BhY2Uuc2V0UmVuZGVyTmFtZXMobnVsbCwgZ2V0U2FmZU5hbWUobmFtZXNwYWNlLm5hbWUsIHVzZWROYW1lcywgbmFtZXNwYWNlLmZvcmJpZGRlbk5hbWVzKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkV4cG9ydHNUb01hbmdsZWROYW1lcyhleHBvcnRzLCBleHBvcnRzQnlOYW1lLCBleHBvcnROYW1lc0J5VmFyaWFibGUpIHtcbiAgICBsZXQgbmFtZUluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IHZhcmlhYmxlIG9mIGV4cG9ydHMpIHtcbiAgICAgICAgbGV0IFtleHBvcnROYW1lXSA9IHZhcmlhYmxlLm5hbWU7XG4gICAgICAgIGlmIChleHBvcnRzQnlOYW1lLmhhcyhleHBvcnROYW1lKSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGV4cG9ydE5hbWUgPSB0b0Jhc2U2NCgrK25hbWVJbmRleCk7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBwYXN0IGxlYWRpbmcgbnVtYmVyIGlkZW50aWZpZXJzXG4gICAgICAgICAgICAgICAgaWYgKGV4cG9ydE5hbWUuY2hhckNvZGVBdCgwKSA9PT0gNDkgLyogJzEnICovKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVJbmRleCArPSA5ICogNjQgKiogKGV4cG9ydE5hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydE5hbWUgPSB0b0Jhc2U2NChuYW1lSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKFJFU0VSVkVEX05BTUVTLmhhcyhleHBvcnROYW1lKSB8fCBleHBvcnRzQnlOYW1lLmhhcyhleHBvcnROYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0c0J5TmFtZS5zZXQoZXhwb3J0TmFtZSwgdmFyaWFibGUpO1xuICAgICAgICBleHBvcnROYW1lc0J5VmFyaWFibGUuc2V0KHZhcmlhYmxlLCBbZXhwb3J0TmFtZV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2lnbkV4cG9ydHNUb05hbWVzKGV4cG9ydHMsIGV4cG9ydHNCeU5hbWUsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSkge1xuICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgZXhwb3J0cykge1xuICAgICAgICBsZXQgbmFtZUluZGV4ID0gMDtcbiAgICAgICAgbGV0IGV4cG9ydE5hbWUgPSB2YXJpYWJsZS5uYW1lO1xuICAgICAgICB3aGlsZSAoZXhwb3J0c0J5TmFtZS5oYXMoZXhwb3J0TmFtZSkpIHtcbiAgICAgICAgICAgIGV4cG9ydE5hbWUgPSB2YXJpYWJsZS5uYW1lICsgJyQnICsgKytuYW1lSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0c0J5TmFtZS5zZXQoZXhwb3J0TmFtZSwgdmFyaWFibGUpO1xuICAgICAgICBleHBvcnROYW1lc0J5VmFyaWFibGUuc2V0KHZhcmlhYmxlLCBbZXhwb3J0TmFtZV0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RXhwb3J0TW9kZShjaHVuaywgeyBleHBvcnRzOiBleHBvcnRNb2RlLCBuYW1lLCBmb3JtYXQgfSwgZmFjYWRlTW9kdWxlSWQsIGxvZykge1xuICAgIGNvbnN0IGV4cG9ydEtleXMgPSBjaHVuay5nZXRFeHBvcnROYW1lcygpO1xuICAgIGlmIChleHBvcnRNb2RlID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgaWYgKGV4cG9ydEtleXMubGVuZ3RoICE9PSAxIHx8IGV4cG9ydEtleXNbMF0gIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKGxvZ0luY29tcGF0aWJsZUV4cG9ydE9wdGlvblZhbHVlKCdkZWZhdWx0JywgZXhwb3J0S2V5cywgZmFjYWRlTW9kdWxlSWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChleHBvcnRNb2RlID09PSAnbm9uZScgJiYgZXhwb3J0S2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihsb2dJbmNvbXBhdGlibGVFeHBvcnRPcHRpb25WYWx1ZSgnbm9uZScsIGV4cG9ydEtleXMsIGZhY2FkZU1vZHVsZUlkKSk7XG4gICAgfVxuICAgIGlmIChleHBvcnRNb2RlID09PSAnYXV0bycpIHtcbiAgICAgICAgaWYgKGV4cG9ydEtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBleHBvcnRNb2RlID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cG9ydEtleXMubGVuZ3RoID09PSAxICYmIGV4cG9ydEtleXNbMF0gPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgZXhwb3J0TW9kZSA9ICdkZWZhdWx0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgIT09ICdlcycgJiYgZm9ybWF0ICE9PSAnc3lzdGVtJyAmJiBleHBvcnRLZXlzLmluY2x1ZGVzKCdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgICAgICBsb2coTE9HTEVWRUxfV0FSTiwgbG9nTWl4ZWRFeHBvcnQoZmFjYWRlTW9kdWxlSWQsIG5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cG9ydE1vZGUgPSAnbmFtZWQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHBvcnRNb2RlO1xufVxuXG5mdW5jdGlvbiBndWVzc0luZGVudFN0cmluZyhjb2RlKSB7XG4gICAgY29uc3QgbGluZXMgPSBjb2RlLnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCB0YWJiZWQgPSBsaW5lcy5maWx0ZXIobGluZSA9PiAvXlxcdCsvLnRlc3QobGluZSkpO1xuICAgIGNvbnN0IHNwYWNlZCA9IGxpbmVzLmZpbHRlcihsaW5lID0+IC9eIHsyLH0vLnRlc3QobGluZSkpO1xuICAgIGlmICh0YWJiZWQubGVuZ3RoID09PSAwICYmIHNwYWNlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIE1vcmUgbGluZXMgdGFiYmVkIHRoYW4gc3BhY2VkPyBBc3N1bWUgdGFicywgYW5kXG4gICAgLy8gZGVmYXVsdCB0byB0YWJzIGluIHRoZSBjYXNlIG9mIGEgdGllIChvciBub3RoaW5nXG4gICAgLy8gdG8gZ28gb24pXG4gICAgaWYgKHRhYmJlZC5sZW5ndGggPj0gc3BhY2VkLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJ1xcdCc7XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgd2UgbmVlZCB0byBndWVzcyB0aGUgbXVsdGlwbGVcbiAgICBjb25zdCBtaW4gPSBzcGFjZWQucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICAgICAgICBjb25zdCBudW1iZXJTcGFjZXMgPSAvXiArLy5leGVjKGN1cnJlbnQpWzBdLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKG51bWJlclNwYWNlcywgcHJldmlvdXMpO1xuICAgIH0sIEluZmluaXR5KTtcbiAgICByZXR1cm4gJyAnLnJlcGVhdChtaW4pO1xufVxuZnVuY3Rpb24gZ2V0SW5kZW50U3RyaW5nKG1vZHVsZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5pbmRlbnQgIT09IHRydWUpXG4gICAgICAgIHJldHVybiBvcHRpb25zLmluZGVudDtcbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVzKSB7XG4gICAgICAgIGNvbnN0IGluZGVudCA9IGd1ZXNzSW5kZW50U3RyaW5nKG1vZHVsZS5vcmlnaW5hbENvZGUpO1xuICAgICAgICBpZiAoaW5kZW50ICE9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGluZGVudDtcbiAgICB9XG4gICAgcmV0dXJuICdcXHQnO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0aWNEZXBlbmRlbmNpZXMoY2h1bmssIG9yZGVyZWRNb2R1bGVzLCBjaHVua0J5TW9kdWxlLCBleHRlcm5hbENodW5rQnlNb2R1bGUpIHtcbiAgICBjb25zdCBzdGF0aWNEZXBlbmRlbmN5QmxvY2tzID0gW107XG4gICAgY29uc3QgaGFuZGxlZERlcGVuZGVuY2llcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBtb2R1bGVQb3MgPSBvcmRlcmVkTW9kdWxlcy5sZW5ndGggLSAxOyBtb2R1bGVQb3MgPj0gMDsgbW9kdWxlUG9zLS0pIHtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gb3JkZXJlZE1vZHVsZXNbbW9kdWxlUG9zXTtcbiAgICAgICAgaWYgKCFoYW5kbGVkRGVwZW5kZW5jaWVzLmhhcyhtb2R1bGUpKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0aWNEZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgICAgICAgIGFkZFN0YXRpY0RlcGVuZGVuY2llcyhtb2R1bGUsIHN0YXRpY0RlcGVuZGVuY2llcywgaGFuZGxlZERlcGVuZGVuY2llcywgY2h1bmssIGNodW5rQnlNb2R1bGUsIGV4dGVybmFsQ2h1bmtCeU1vZHVsZSk7XG4gICAgICAgICAgICBzdGF0aWNEZXBlbmRlbmN5QmxvY2tzLnVuc2hpZnQoc3RhdGljRGVwZW5kZW5jaWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBibG9jayBvZiBzdGF0aWNEZXBlbmRlbmN5QmxvY2tzKSB7XG4gICAgICAgIGZvciAoY29uc3QgZGVwZW5kZW5jeSBvZiBibG9jaykge1xuICAgICAgICAgICAgZGVwZW5kZW5jaWVzLmFkZChkZXBlbmRlbmN5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xufVxuZnVuY3Rpb24gYWRkU3RhdGljRGVwZW5kZW5jaWVzKG1vZHVsZSwgc3RhdGljRGVwZW5kZW5jaWVzLCBoYW5kbGVkTW9kdWxlcywgY2h1bmssIGNodW5rQnlNb2R1bGUsIGV4dGVybmFsQ2h1bmtCeU1vZHVsZSkge1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IG1vZHVsZS5nZXREZXBlbmRlbmNpZXNUb0JlSW5jbHVkZWQoKTtcbiAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGlmIChkZXBlbmRlbmN5IGluc3RhbmNlb2YgRXh0ZXJuYWxNb2R1bGUpIHtcbiAgICAgICAgICAgIHN0YXRpY0RlcGVuZGVuY2llcy5wdXNoKGV4dGVybmFsQ2h1bmtCeU1vZHVsZS5nZXQoZGVwZW5kZW5jeSkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVwZW5kZW5jeUNodW5rID0gY2h1bmtCeU1vZHVsZS5nZXQoZGVwZW5kZW5jeSk7XG4gICAgICAgIGlmIChkZXBlbmRlbmN5Q2h1bmsgIT09IGNodW5rKSB7XG4gICAgICAgICAgICBzdGF0aWNEZXBlbmRlbmNpZXMucHVzaChkZXBlbmRlbmN5Q2h1bmspO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYW5kbGVkTW9kdWxlcy5oYXMoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICAgIGhhbmRsZWRNb2R1bGVzLmFkZChkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgIGFkZFN0YXRpY0RlcGVuZGVuY2llcyhkZXBlbmRlbmN5LCBzdGF0aWNEZXBlbmRlbmNpZXMsIGhhbmRsZWRNb2R1bGVzLCBjaHVuaywgY2h1bmtCeU1vZHVsZSwgZXh0ZXJuYWxDaHVua0J5TW9kdWxlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gRm91ciByYW5kb20gY2hhcmFjdGVycyBmcm9tIHRoZSBwcml2YXRlIHVzZSBhcmVhIHRvIG1pbmltaXplIHJpc2sgb2Zcbi8vIGNvbmZsaWN0c1xuY29uc3QgaGFzaFBsYWNlaG9sZGVyTGVmdCA9ICchfnsnO1xuY29uc3QgaGFzaFBsYWNlaG9sZGVyUmlnaHQgPSAnfX4nO1xuY29uc3QgaGFzaFBsYWNlaG9sZGVyT3ZlcmhlYWQgPSBoYXNoUGxhY2Vob2xkZXJMZWZ0Lmxlbmd0aCArIGhhc2hQbGFjZWhvbGRlclJpZ2h0Lmxlbmd0aDtcbi8vIFRoaXMgaXMgdGhlIHNpemUgb2YgYSAxMjgtYml0cyB4eGhhc2ggd2l0aCBiYXNlNjR1cmwgZW5jb2RpbmdcbmNvbnN0IE1BWF9IQVNIX1NJWkUgPSAyMjtcbmNvbnN0IERFRkFVTFRfSEFTSF9TSVpFID0gODtcbmNvbnN0IGdldEhhc2hQbGFjZWhvbGRlckdlbmVyYXRvciA9ICgpID0+IHtcbiAgICBsZXQgbmV4dEluZGV4ID0gMDtcbiAgICByZXR1cm4gKG9wdGlvbk5hbWUsIGhhc2hTaXplKSA9PiB7XG4gICAgICAgIGlmIChoYXNoU2l6ZSA+IE1BWF9IQVNIX1NJWkUpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihsb2dGYWlsZWRWYWxpZGF0aW9uKGBIYXNoZXMgY2Fubm90IGJlIGxvbmdlciB0aGFuICR7TUFYX0hBU0hfU0laRX0gY2hhcmFjdGVycywgcmVjZWl2ZWQgJHtoYXNoU2l6ZX0uIENoZWNrIHRoZSBcIiR7b3B0aW9uTmFtZX1cIiBvcHRpb24uYCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gYCR7aGFzaFBsYWNlaG9sZGVyTGVmdH0ke3RvQmFzZTY0KCsrbmV4dEluZGV4KS5wYWRTdGFydChoYXNoU2l6ZSAtIGhhc2hQbGFjZWhvbGRlck92ZXJoZWFkLCAnMCcpfSR7aGFzaFBsYWNlaG9sZGVyUmlnaHR9YDtcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyLmxlbmd0aCA+IGhhc2hTaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IobG9nRmFpbGVkVmFsaWRhdGlvbihgVG8gZ2VuZXJhdGUgaGFzaGVzIGZvciB0aGlzIG51bWJlciBvZiBjaHVua3MgKGN1cnJlbnRseSAke25leHRJbmRleH0pLCB5b3UgbmVlZCBhIG1pbmltdW0gaGFzaCBzaXplIG9mICR7cGxhY2Vob2xkZXIubGVuZ3RofSwgcmVjZWl2ZWQgJHtoYXNoU2l6ZX0uIENoZWNrIHRoZSBcIiR7b3B0aW9uTmFtZX1cIiBvcHRpb24uYCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgICB9O1xufTtcbmNvbnN0IFJFUExBQ0VSX1JFR0VYID0gbmV3IFJlZ0V4cChgJHtoYXNoUGxhY2Vob2xkZXJMZWZ0fVswLTlhLXpBLVpfJF17MSwke01BWF9IQVNIX1NJWkUgLSBoYXNoUGxhY2Vob2xkZXJPdmVyaGVhZH19JHtoYXNoUGxhY2Vob2xkZXJSaWdodH1gLCAnZycpO1xuY29uc3QgcmVwbGFjZVBsYWNlaG9sZGVycyA9IChjb2RlLCBoYXNoZXNCeVBsYWNlaG9sZGVyKSA9PiBjb2RlLnJlcGxhY2UoUkVQTEFDRVJfUkVHRVgsIHBsYWNlaG9sZGVyID0+IGhhc2hlc0J5UGxhY2Vob2xkZXIuZ2V0KHBsYWNlaG9sZGVyKSB8fCBwbGFjZWhvbGRlcik7XG5jb25zdCByZXBsYWNlU2luZ2xlUGxhY2Vob2xkZXIgPSAoY29kZSwgcGxhY2Vob2xkZXIsIHZhbHVlKSA9PiBjb2RlLnJlcGxhY2UoUkVQTEFDRVJfUkVHRVgsIG1hdGNoID0+IChtYXRjaCA9PT0gcGxhY2Vob2xkZXIgPyB2YWx1ZSA6IG1hdGNoKSk7XG5jb25zdCByZXBsYWNlUGxhY2Vob2xkZXJzV2l0aERlZmF1bHRBbmRHZXRDb250YWluZWRQbGFjZWhvbGRlcnMgPSAoY29kZSwgcGxhY2Vob2xkZXJzKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVkUGxhY2Vob2xkZXJzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkQ29kZSA9IGNvZGUucmVwbGFjZShSRVBMQUNFUl9SRUdFWCwgcGxhY2Vob2xkZXIgPT4ge1xuICAgICAgICBpZiAocGxhY2Vob2xkZXJzLmhhcyhwbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lZFBsYWNlaG9sZGVycy5hZGQocGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGAke2hhc2hQbGFjZWhvbGRlckxlZnR9JHsnMCcucmVwZWF0KHBsYWNlaG9sZGVyLmxlbmd0aCAtIGhhc2hQbGFjZWhvbGRlck92ZXJoZWFkKX0ke2hhc2hQbGFjZWhvbGRlclJpZ2h0fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgIH0pO1xuICAgIHJldHVybiB7IGNvbnRhaW5lZFBsYWNlaG9sZGVycywgdHJhbnNmb3JtZWRDb2RlIH07XG59O1xuXG5jb25zdCBsb3dlcmNhc2VCdW5kbGVLZXlzID0gU3ltYm9sKCdidW5kbGVLZXlzJyk7XG5jb25zdCBGSUxFX1BMQUNFSE9MREVSID0ge1xuICAgIHR5cGU6ICdwbGFjZWhvbGRlcidcbn07XG5jb25zdCBnZXRPdXRwdXRCdW5kbGUgPSAob3V0cHV0QnVuZGxlQmFzZSkgPT4ge1xuICAgIGNvbnN0IHJlc2VydmVkTG93ZXJjYXNlQnVuZGxlS2V5cyA9IG5ldyBTZXQoKTtcbiAgICByZXR1cm4gbmV3IFByb3h5KG91dHB1dEJ1bmRsZUJhc2UsIHtcbiAgICAgICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlc2VydmVkTG93ZXJjYXNlQnVuZGxlS2V5cy5kZWxldGUoa2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IGxvd2VyY2FzZUJ1bmRsZUtleXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzZXJ2ZWRMb3dlcmNhc2VCdW5kbGVLZXlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmVzZXJ2ZWRMb3dlcmNhc2VCdW5kbGVLZXlzLmFkZChrZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmNvbnN0IHJlbW92ZVVucmVmZXJlbmNlZEFzc2V0cyA9IChvdXRwdXRCdW5kbGUpID0+IHtcbiAgICBjb25zdCB1bnJlZmVyZW5jZWRBc3NldHMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgYnVuZGxlRW50cmllcyA9IE9iamVjdC52YWx1ZXMob3V0cHV0QnVuZGxlKTtcbiAgICBmb3IgKGNvbnN0IGFzc2V0IG9mIGJ1bmRsZUVudHJpZXMpIHtcbiAgICAgICAgaWYgKGFzc2V0LnR5cGUgPT09ICdhc3NldCcgJiYgYXNzZXQubmVlZHNDb2RlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICB1bnJlZmVyZW5jZWRBc3NldHMuYWRkKGFzc2V0LmZpbGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGJ1bmRsZUVudHJpZXMpIHtcbiAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09ICdjaHVuaycpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVmZXJlbmNlZEZpbGUgb2YgY2h1bmsucmVmZXJlbmNlZEZpbGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVucmVmZXJlbmNlZEFzc2V0cy5oYXMocmVmZXJlbmNlZEZpbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVucmVmZXJlbmNlZEFzc2V0cy5kZWxldGUocmVmZXJlbmNlZEZpbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgdW5yZWZlcmVuY2VkQXNzZXRzKSB7XG4gICAgICAgIGRlbGV0ZSBvdXRwdXRCdW5kbGVbZmlsZV07XG4gICAgfVxufTtcblxuZnVuY3Rpb24gcmVuZGVyTmFtZVBhdHRlcm4ocGF0dGVybiwgcGF0dGVybk5hbWUsIHJlcGxhY2VtZW50cykge1xuICAgIGlmIChpc1BhdGhGcmFnbWVudChwYXR0ZXJuKSlcbiAgICAgICAgcmV0dXJuIGVycm9yKGxvZ0ZhaWxlZFZhbGlkYXRpb24oYEludmFsaWQgcGF0dGVybiBcIiR7cGF0dGVybn1cIiBmb3IgXCIke3BhdHRlcm5OYW1lfVwiLCBwYXR0ZXJucyBjYW4gYmUgbmVpdGhlciBhYnNvbHV0ZSBub3IgcmVsYXRpdmUgcGF0aHMuIElmIHlvdSB3YW50IHlvdXIgZmlsZXMgdG8gYmUgc3RvcmVkIGluIGEgc3ViZGlyZWN0b3J5LCB3cml0ZSBpdHMgbmFtZSB3aXRob3V0IGEgbGVhZGluZyBzbGFzaCBsaWtlIHRoaXM6IHN1YmRpcmVjdG9yeS9wYXR0ZXJuLmApKTtcbiAgICByZXR1cm4gcGF0dGVybi5yZXBsYWNlKC9cXFsoXFx3KykoOlxcZCspP10vZywgKF9tYXRjaCwgdHlwZSwgc2l6ZSkgPT4ge1xuICAgICAgICBpZiAoIXJlcGxhY2VtZW50cy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSB8fCAoc2l6ZSAmJiB0eXBlICE9PSAnaGFzaCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IobG9nRmFpbGVkVmFsaWRhdGlvbihgXCJbJHt0eXBlfSR7c2l6ZSB8fCAnJ31dXCIgaXMgbm90IGEgdmFsaWQgcGxhY2Vob2xkZXIgaW4gdGhlIFwiJHtwYXR0ZXJuTmFtZX1cIiBwYXR0ZXJuLmApKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50c1t0eXBlXShzaXplICYmIE51bWJlci5wYXJzZUludChzaXplLnNsaWNlKDEpKSk7XG4gICAgICAgIGlmIChpc1BhdGhGcmFnbWVudChyZXBsYWNlbWVudCkpXG4gICAgICAgICAgICByZXR1cm4gZXJyb3IobG9nRmFpbGVkVmFsaWRhdGlvbihgSW52YWxpZCBzdWJzdGl0dXRpb24gXCIke3JlcGxhY2VtZW50fVwiIGZvciBwbGFjZWhvbGRlciBcIlske3R5cGV9XVwiIGluIFwiJHtwYXR0ZXJuTmFtZX1cIiBwYXR0ZXJuLCBjYW4gYmUgbmVpdGhlciBhYnNvbHV0ZSBub3IgcmVsYXRpdmUgcGF0aC5gKSk7XG4gICAgICAgIHJldHVybiByZXBsYWNlbWVudDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG1ha2VVbmlxdWUobmFtZSwgeyBbbG93ZXJjYXNlQnVuZGxlS2V5c106IHJlc2VydmVkTG93ZXJjYXNlQnVuZGxlS2V5cyB9KSB7XG4gICAgaWYgKCFyZXNlcnZlZExvd2VyY2FzZUJ1bmRsZUtleXMuaGFzKG5hbWUudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IGV4dG5hbWUobmFtZSk7XG4gICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgTWF0aC5tYXgoMCwgbmFtZS5sZW5ndGggLSBleHRlbnNpb24ubGVuZ3RoKSk7XG4gICAgbGV0IHVuaXF1ZU5hbWUsIHVuaXF1ZUluZGV4ID0gMTtcbiAgICB3aGlsZSAocmVzZXJ2ZWRMb3dlcmNhc2VCdW5kbGVLZXlzLmhhcygodW5pcXVlTmFtZSA9IG5hbWUgKyArK3VuaXF1ZUluZGV4ICsgZXh0ZW5zaW9uKS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgO1xuICAgIHJldHVybiB1bmlxdWVOYW1lO1xufVxuXG5jb25zdCBOT05fQVNTRVRfRVhURU5TSU9OUyA9IG5ldyBTZXQoW1xuICAgICcuanMnLFxuICAgICcuanN4JyxcbiAgICAnLnRzJyxcbiAgICAnLnRzeCcsXG4gICAgJy5tanMnLFxuICAgICcubXRzJyxcbiAgICAnLmNqcycsXG4gICAgJy5jdHMnXG5dKTtcbmZ1bmN0aW9uIGdldEdsb2JhbE5hbWUoY2h1bmssIGdsb2JhbHMsIGhhc0V4cG9ydHMsIGxvZykge1xuICAgIGNvbnN0IGdsb2JhbE5hbWUgPSB0eXBlb2YgZ2xvYmFscyA9PT0gJ2Z1bmN0aW9uJyA/IGdsb2JhbHMoY2h1bmsuaWQpIDogZ2xvYmFsc1tjaHVuay5pZF07XG4gICAgaWYgKGdsb2JhbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbE5hbWU7XG4gICAgfVxuICAgIGlmIChoYXNFeHBvcnRzKSB7XG4gICAgICAgIGxvZyhMT0dMRVZFTF9XQVJOLCBsb2dNaXNzaW5nR2xvYmFsTmFtZShjaHVuay5pZCwgY2h1bmsudmFyaWFibGVOYW1lKSk7XG4gICAgICAgIHJldHVybiBjaHVuay52YXJpYWJsZU5hbWU7XG4gICAgfVxufVxuY2xhc3MgQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKG9yZGVyZWRNb2R1bGVzLCBpbnB1dE9wdGlvbnMsIG91dHB1dE9wdGlvbnMsIHVuc2V0T3B0aW9ucywgcGx1Z2luRHJpdmVyLCBtb2R1bGVzQnlJZCwgY2h1bmtCeU1vZHVsZSwgZXh0ZXJuYWxDaHVua0J5TW9kdWxlLCBmYWNhZGVDaHVua0J5TW9kdWxlLCBpbmNsdWRlZE5hbWVzcGFjZXMsIG1hbnVhbENodW5rQWxpYXMsIGdldFBsYWNlaG9sZGVyLCBidW5kbGUsIGlucHV0QmFzZSwgc25pcHBldHMpIHtcbiAgICAgICAgdGhpcy5vcmRlcmVkTW9kdWxlcyA9IG9yZGVyZWRNb2R1bGVzO1xuICAgICAgICB0aGlzLmlucHV0T3B0aW9ucyA9IGlucHV0T3B0aW9ucztcbiAgICAgICAgdGhpcy5vdXRwdXRPcHRpb25zID0gb3V0cHV0T3B0aW9ucztcbiAgICAgICAgdGhpcy51bnNldE9wdGlvbnMgPSB1bnNldE9wdGlvbnM7XG4gICAgICAgIHRoaXMucGx1Z2luRHJpdmVyID0gcGx1Z2luRHJpdmVyO1xuICAgICAgICB0aGlzLm1vZHVsZXNCeUlkID0gbW9kdWxlc0J5SWQ7XG4gICAgICAgIHRoaXMuY2h1bmtCeU1vZHVsZSA9IGNodW5rQnlNb2R1bGU7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxDaHVua0J5TW9kdWxlID0gZXh0ZXJuYWxDaHVua0J5TW9kdWxlO1xuICAgICAgICB0aGlzLmZhY2FkZUNodW5rQnlNb2R1bGUgPSBmYWNhZGVDaHVua0J5TW9kdWxlO1xuICAgICAgICB0aGlzLmluY2x1ZGVkTmFtZXNwYWNlcyA9IGluY2x1ZGVkTmFtZXNwYWNlcztcbiAgICAgICAgdGhpcy5tYW51YWxDaHVua0FsaWFzID0gbWFudWFsQ2h1bmtBbGlhcztcbiAgICAgICAgdGhpcy5nZXRQbGFjZWhvbGRlciA9IGdldFBsYWNlaG9sZGVyO1xuICAgICAgICB0aGlzLmJ1bmRsZSA9IGJ1bmRsZTtcbiAgICAgICAgdGhpcy5pbnB1dEJhc2UgPSBpbnB1dEJhc2U7XG4gICAgICAgIHRoaXMuc25pcHBldHMgPSBzbmlwcGV0cztcbiAgICAgICAgdGhpcy5lbnRyeU1vZHVsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5leHBvcnRNb2RlID0gJ25hbWVkJztcbiAgICAgICAgdGhpcy5mYWNhZGVNb2R1bGUgPSBudWxsO1xuICAgICAgICB0aGlzLm5hbWVzcGFjZVZhcmlhYmxlTmFtZSA9ICcnO1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZSA9ICcnO1xuICAgICAgICB0aGlzLmFjY2Vzc2VkR2xvYmFsc0J5U2NvcGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmR5bmFtaWNFbnRyeU1vZHVsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5keW5hbWljTmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZXhwb3J0TmFtZXNCeVZhcmlhYmxlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmV4cG9ydHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZXhwb3J0c0J5TmFtZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaW1wbGljaXRFbnRyeU1vZHVsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pbXBsaWNpdGx5TG9hZGVkQmVmb3JlID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmltcG9ydHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuaW5jbHVkZWREeW5hbWljSW1wb3J0cyA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5jbHVkZWRSZWV4cG9ydHNCeU1vZHVsZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gVGhpcyBtYXkgYmUgdXBkYXRlZCBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgdGhpcy5pc0VtcHR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZWVkc0V4cG9ydHNTaGltID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJlUmVuZGVyZWRDaHVua0luZm8gPSBudWxsO1xuICAgICAgICB0aGlzLnByZWxpbWluYXJ5RmlsZU5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnByZWxpbWluYXJ5U291cmNlbWFwRmlsZU5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlcmVkQ2h1bmtJbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJlZERlcGVuZGVuY2llcyA9IG51bGw7XG4gICAgICAgIHRoaXMucmVuZGVyZWRNb2R1bGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5zb3J0ZWRFeHBvcnROYW1lcyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RyaWN0RmFjYWRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXhlY0luZGV4ID0gb3JkZXJlZE1vZHVsZXMubGVuZ3RoID4gMCA/IG9yZGVyZWRNb2R1bGVzWzBdLmV4ZWNJbmRleCA6IEluZmluaXR5O1xuICAgICAgICBjb25zdCBjaHVua01vZHVsZXMgPSBuZXcgU2V0KG9yZGVyZWRNb2R1bGVzKTtcbiAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2Ygb3JkZXJlZE1vZHVsZXMpIHtcbiAgICAgICAgICAgIGNodW5rQnlNb2R1bGUuc2V0KG1vZHVsZSwgdGhpcyk7XG4gICAgICAgICAgICBpZiAobW9kdWxlLm5hbWVzcGFjZS5pbmNsdWRlZCAmJiAhb3V0cHV0T3B0aW9ucy5wcmVzZXJ2ZU1vZHVsZXMpIHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlZE5hbWVzcGFjZXMuYWRkKG1vZHVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc0VtcHR5ICYmIG1vZHVsZS5pc0luY2x1ZGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2R1bGUuaW5mby5pc0VudHJ5IHx8IG91dHB1dE9wdGlvbnMucHJlc2VydmVNb2R1bGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRyeU1vZHVsZXMucHVzaChtb2R1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBpbXBvcnRlciBvZiBtb2R1bGUuaW5jbHVkZWREeW5hbWljSW1wb3J0ZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaHVua01vZHVsZXMuaGFzKGltcG9ydGVyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmR5bmFtaWNFbnRyeU1vZHVsZXMucHVzaChtb2R1bGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBNb2R1bGVzIHdpdGggc3ludGhldGljIGV4cG9ydHMgbmVlZCBhbiBhcnRpZmljaWFsIG5hbWVzcGFjZSBmb3IgZHluYW1pYyBpbXBvcnRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2R1bGUuaW5mby5zeW50aGV0aWNOYW1lZEV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVkTmFtZXNwYWNlcy5hZGQobW9kdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwb3J0cy5hZGQobW9kdWxlLm5hbWVzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kdWxlLmltcGxpY2l0bHlMb2FkZWRBZnRlci5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW1wbGljaXRFbnRyeU1vZHVsZXMucHVzaChtb2R1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3VnZ2VzdGVkVmFyaWFibGVOYW1lID0gbWFrZUxlZ2FsKHRoaXMuZ2VuZXJhdGVWYXJpYWJsZU5hbWUoKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZW5lcmF0ZUZhY2FkZShpbnB1dE9wdGlvbnMsIG91dHB1dE9wdGlvbnMsIHVuc2V0T3B0aW9ucywgcGx1Z2luRHJpdmVyLCBtb2R1bGVzQnlJZCwgY2h1bmtCeU1vZHVsZSwgZXh0ZXJuYWxDaHVua0J5TW9kdWxlLCBmYWNhZGVDaHVua0J5TW9kdWxlLCBpbmNsdWRlZE5hbWVzcGFjZXMsIGZhY2FkZWRNb2R1bGUsIGZhY2FkZU5hbWUsIGdldFBsYWNlaG9sZGVyLCBidW5kbGUsIGlucHV0QmFzZSwgc25pcHBldHMpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBuZXcgQ2h1bmsoW10sIGlucHV0T3B0aW9ucywgb3V0cHV0T3B0aW9ucywgdW5zZXRPcHRpb25zLCBwbHVnaW5Ecml2ZXIsIG1vZHVsZXNCeUlkLCBjaHVua0J5TW9kdWxlLCBleHRlcm5hbENodW5rQnlNb2R1bGUsIGZhY2FkZUNodW5rQnlNb2R1bGUsIGluY2x1ZGVkTmFtZXNwYWNlcywgbnVsbCwgZ2V0UGxhY2Vob2xkZXIsIGJ1bmRsZSwgaW5wdXRCYXNlLCBzbmlwcGV0cyk7XG4gICAgICAgIGNodW5rLmFzc2lnbkZhY2FkZU5hbWUoZmFjYWRlTmFtZSwgZmFjYWRlZE1vZHVsZSk7XG4gICAgICAgIGlmICghZmFjYWRlQ2h1bmtCeU1vZHVsZS5oYXMoZmFjYWRlZE1vZHVsZSkpIHtcbiAgICAgICAgICAgIGZhY2FkZUNodW5rQnlNb2R1bGUuc2V0KGZhY2FkZWRNb2R1bGUsIGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgZmFjYWRlZE1vZHVsZS5nZXREZXBlbmRlbmNpZXNUb0JlSW5jbHVkZWQoKSkge1xuICAgICAgICAgICAgY2h1bmsuZGVwZW5kZW5jaWVzLmFkZChkZXBlbmRlbmN5IGluc3RhbmNlb2YgTW9kdWxlXG4gICAgICAgICAgICAgICAgPyBjaHVua0J5TW9kdWxlLmdldChkZXBlbmRlbmN5KVxuICAgICAgICAgICAgICAgIDogZXh0ZXJuYWxDaHVua0J5TW9kdWxlLmdldChkZXBlbmRlbmN5KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaHVuay5kZXBlbmRlbmNpZXMuaGFzKGNodW5rQnlNb2R1bGUuZ2V0KGZhY2FkZWRNb2R1bGUpKSAmJlxuICAgICAgICAgICAgZmFjYWRlZE1vZHVsZS5pbmZvLm1vZHVsZVNpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICBmYWNhZGVkTW9kdWxlLmhhc0VmZmVjdHMoKSkge1xuICAgICAgICAgICAgY2h1bmsuZGVwZW5kZW5jaWVzLmFkZChjaHVua0J5TW9kdWxlLmdldChmYWNhZGVkTW9kdWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmsuZW5zdXJlUmVleHBvcnRzQXJlQXZhaWxhYmxlRm9yTW9kdWxlKGZhY2FkZWRNb2R1bGUpO1xuICAgICAgICBjaHVuay5mYWNhZGVNb2R1bGUgPSBmYWNhZGVkTW9kdWxlO1xuICAgICAgICBjaHVuay5zdHJpY3RGYWNhZGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICAgIGNhbk1vZHVsZUJlRmFjYWRlKG1vZHVsZSwgZXhwb3NlZFZhcmlhYmxlcykge1xuICAgICAgICBjb25zdCBtb2R1bGVFeHBvcnROYW1lc0J5VmFyaWFibGUgPSBtb2R1bGUuZ2V0RXhwb3J0TmFtZXNCeVZhcmlhYmxlKCk7XG4gICAgICAgIC8vIEFsbCBleHBvcnRzIG9mIHRoaXMgY2h1bmsgbmVlZCB0byBiZSBleHBvc2VkIGJ5IHRoZSBjYW5kaWRhdGUgbW9kdWxlXG4gICAgICAgIGZvciAoY29uc3QgZXhwb3NlZFZhcmlhYmxlIG9mIHRoaXMuZXhwb3J0cykge1xuICAgICAgICAgICAgaWYgKCFtb2R1bGVFeHBvcnROYW1lc0J5VmFyaWFibGUuaGFzKGV4cG9zZWRWYXJpYWJsZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkaXRpb25hbGx5LCB3ZSBuZWVkIHRvIGV4cG9zZSBuYW1lc3BhY2VzIG9mIGR5bmFtaWMgZW50cmllcyB0aGF0IGFyZSBub3QgdGhlIGZhY2FkZSBtb2R1bGUgYW5kIGV4cG9ydHMgZnJvbSBvdGhlciBlbnRyeSBtb2R1bGVzXG4gICAgICAgIGZvciAoY29uc3QgZXhwb3NlZFZhcmlhYmxlIG9mIGV4cG9zZWRWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgIGlmICghKGV4cG9zZWRWYXJpYWJsZS5tb2R1bGUgPT09IG1vZHVsZSB8fFxuICAgICAgICAgICAgICAgIG1vZHVsZUV4cG9ydE5hbWVzQnlWYXJpYWJsZS5oYXMoZXhwb3NlZFZhcmlhYmxlKSB8fFxuICAgICAgICAgICAgICAgIChleHBvc2VkVmFyaWFibGUgaW5zdGFuY2VvZiBTeW50aGV0aWNOYW1lZEV4cG9ydFZhcmlhYmxlICYmXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUV4cG9ydE5hbWVzQnlWYXJpYWJsZS5oYXMoZXhwb3NlZFZhcmlhYmxlLmdldEJhc2VWYXJpYWJsZSgpKSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmaW5hbGl6ZUNodW5rKGNvZGUsIG1hcCwgc291cmNlbWFwRmlsZU5hbWUsIGhhc2hlc0J5UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyZWRDaHVua0luZm8gPSB0aGlzLmdldFJlbmRlcmVkQ2h1bmtJbmZvKCk7XG4gICAgICAgIGNvbnN0IGZpbmFsaXplID0gKGNvZGUpID0+IHJlcGxhY2VQbGFjZWhvbGRlcnMoY29kZSwgaGFzaGVzQnlQbGFjZWhvbGRlcik7XG4gICAgICAgIGNvbnN0IHByZWxpbWluYXJ5RmlsZU5hbWUgPSByZW5kZXJlZENodW5rSW5mby5maWxlTmFtZTtcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSAodGhpcy5maWxlTmFtZSA9IGZpbmFsaXplKHByZWxpbWluYXJ5RmlsZU5hbWUpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnJlbmRlcmVkQ2h1bmtJbmZvLFxuICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgIGR5bmFtaWNJbXBvcnRzOiByZW5kZXJlZENodW5rSW5mby5keW5hbWljSW1wb3J0cy5tYXAoZmluYWxpemUpLFxuICAgICAgICAgICAgZmlsZU5hbWUsXG4gICAgICAgICAgICBpbXBsaWNpdGx5TG9hZGVkQmVmb3JlOiByZW5kZXJlZENodW5rSW5mby5pbXBsaWNpdGx5TG9hZGVkQmVmb3JlLm1hcChmaW5hbGl6ZSksXG4gICAgICAgICAgICBpbXBvcnRlZEJpbmRpbmdzOiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocmVuZGVyZWRDaHVua0luZm8uaW1wb3J0ZWRCaW5kaW5ncykubWFwKChbZmlsZU5hbWUsIGJpbmRpbmdzXSkgPT4gW1xuICAgICAgICAgICAgICAgIGZpbmFsaXplKGZpbGVOYW1lKSxcbiAgICAgICAgICAgICAgICBiaW5kaW5nc1xuICAgICAgICAgICAgXSkpLFxuICAgICAgICAgICAgaW1wb3J0czogcmVuZGVyZWRDaHVua0luZm8uaW1wb3J0cy5tYXAoZmluYWxpemUpLFxuICAgICAgICAgICAgbWFwLFxuICAgICAgICAgICAgcHJlbGltaW5hcnlGaWxlTmFtZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZWRGaWxlczogcmVuZGVyZWRDaHVua0luZm8ucmVmZXJlbmNlZEZpbGVzLm1hcChmaW5hbGl6ZSksXG4gICAgICAgICAgICBzb3VyY2VtYXBGaWxlTmFtZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZW5lcmF0ZUV4cG9ydHMoKSB7XG4gICAgICAgIHRoaXMuc29ydGVkRXhwb3J0TmFtZXMgPSBudWxsO1xuICAgICAgICBjb25zdCByZW1haW5pbmdFeHBvcnRzID0gbmV3IFNldCh0aGlzLmV4cG9ydHMpO1xuICAgICAgICBpZiAodGhpcy5mYWNhZGVNb2R1bGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICh0aGlzLmZhY2FkZU1vZHVsZS5wcmVzZXJ2ZVNpZ25hdHVyZSAhPT0gZmFsc2UgfHwgdGhpcy5zdHJpY3RGYWNhZGUpKSB7XG4gICAgICAgICAgICBjb25zdCBleHBvcnROYW1lc0J5VmFyaWFibGUgPSB0aGlzLmZhY2FkZU1vZHVsZS5nZXRFeHBvcnROYW1lc0J5VmFyaWFibGUoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3ZhcmlhYmxlLCBleHBvcnROYW1lc10gb2YgZXhwb3J0TmFtZXNCeVZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBvcnROYW1lc0J5VmFyaWFibGUuc2V0KHZhcmlhYmxlLCBbLi4uZXhwb3J0TmFtZXNdKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV4cG9ydE5hbWUgb2YgZXhwb3J0TmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBvcnRzQnlOYW1lLnNldChleHBvcnROYW1lLCB2YXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbWFpbmluZ0V4cG9ydHMuZGVsZXRlKHZhcmlhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vdXRwdXRPcHRpb25zLm1pbmlmeUludGVybmFsRXhwb3J0cykge1xuICAgICAgICAgICAgYXNzaWduRXhwb3J0c1RvTWFuZ2xlZE5hbWVzKHJlbWFpbmluZ0V4cG9ydHMsIHRoaXMuZXhwb3J0c0J5TmFtZSwgdGhpcy5leHBvcnROYW1lc0J5VmFyaWFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzaWduRXhwb3J0c1RvTmFtZXMocmVtYWluaW5nRXhwb3J0cywgdGhpcy5leHBvcnRzQnlOYW1lLCB0aGlzLmV4cG9ydE5hbWVzQnlWYXJpYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3V0cHV0T3B0aW9ucy5wcmVzZXJ2ZU1vZHVsZXMgfHwgKHRoaXMuZmFjYWRlTW9kdWxlICYmIHRoaXMuZmFjYWRlTW9kdWxlLmluZm8uaXNFbnRyeSkpXG4gICAgICAgICAgICB0aGlzLmV4cG9ydE1vZGUgPSBnZXRFeHBvcnRNb2RlKHRoaXMsIHRoaXMub3V0cHV0T3B0aW9ucywgdGhpcy5mYWNhZGVNb2R1bGUuaWQsIHRoaXMuaW5wdXRPcHRpb25zLm9uTG9nKTtcbiAgICB9XG4gICAgZ2VuZXJhdGVGYWNhZGVzKCkge1xuICAgICAgICBjb25zdCBmYWNhZGVzID0gW107XG4gICAgICAgIGNvbnN0IGVudHJ5TW9kdWxlcyA9IG5ldyBTZXQoWy4uLnRoaXMuZW50cnlNb2R1bGVzLCAuLi50aGlzLmltcGxpY2l0RW50cnlNb2R1bGVzXSk7XG4gICAgICAgIGNvbnN0IGV4cG9zZWRWYXJpYWJsZXMgPSBuZXcgU2V0KHRoaXMuZHluYW1pY0VudHJ5TW9kdWxlcy5tYXAoKHsgbmFtZXNwYWNlIH0pID0+IG5hbWVzcGFjZSkpO1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBlbnRyeU1vZHVsZXMpIHtcbiAgICAgICAgICAgIGlmIChtb2R1bGUucHJlc2VydmVTaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV4cG9ydGVkVmFyaWFibGUgb2YgbW9kdWxlLmdldEV4cG9ydE5hbWVzQnlWYXJpYWJsZSgpLmtleXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGV4cG9zZSBhbGwgZW50cnkgZXhwb3J0cyBmcm9tIHRoaXMgY2h1bmtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2h1bmtCeU1vZHVsZS5nZXQoZXhwb3J0ZWRWYXJpYWJsZS5tb2R1bGUpID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvc2VkVmFyaWFibGVzLmFkZChleHBvcnRlZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBlbnRyeU1vZHVsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkRmFjYWRlcyA9IEFycmF5LmZyb20obmV3IFNldChtb2R1bGUuY2h1bmtOYW1lcy5maWx0ZXIoKHsgaXNVc2VyRGVmaW5lZCB9KSA9PiBpc1VzZXJEZWZpbmVkKS5tYXAoKHsgbmFtZSB9KSA9PiBuYW1lKSksIFxuICAgICAgICAgICAgLy8gbWFwcGluZyBtdXN0IHJ1biBhZnRlciBTZXQgJ25hbWUnIGRlZHVwZVxuICAgICAgICAgICAgbmFtZSA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlZEZhY2FkZXMubGVuZ3RoID09PSAwICYmIG1vZHVsZS5pc1VzZXJEZWZpbmVkRW50cnlQb2ludCkge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkRmFjYWRlcy5wdXNoKHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVpcmVkRmFjYWRlcy5wdXNoKC4uLkFycmF5LmZyb20obW9kdWxlLmNodW5rRmlsZU5hbWVzLCBmaWxlTmFtZSA9PiAoeyBmaWxlTmFtZSB9KSkpO1xuICAgICAgICAgICAgaWYgKHJlcXVpcmVkRmFjYWRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZEZhY2FkZXMucHVzaCh7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmFjYWRlTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmVlZHNTdHJpY3RGYWNhZGUgPSAhdGhpcy5vdXRwdXRPcHRpb25zLnByZXNlcnZlTW9kdWxlcyAmJlxuICAgICAgICAgICAgICAgICAgICAobW9kdWxlLnByZXNlcnZlU2lnbmF0dXJlID09PSAnc3RyaWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKG1vZHVsZS5wcmVzZXJ2ZVNpZ25hdHVyZSA9PT0gJ2V4cG9ydHMtb25seScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUuZ2V0RXhwb3J0TmFtZXNCeVZhcmlhYmxlKCkuc2l6ZSA+IDApKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5lZWRzU3RyaWN0RmFjYWRlIHx8IHRoaXMuY2FuTW9kdWxlQmVGYWNhZGUobW9kdWxlLCBleHBvc2VkVmFyaWFibGVzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhY2FkZU1vZHVsZSA9IG1vZHVsZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWNhZGVDaHVua0J5TW9kdWxlLnNldChtb2R1bGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kdWxlLnByZXNlcnZlU2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmljdEZhY2FkZSA9IG5lZWRzU3RyaWN0RmFjYWRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzaWduRmFjYWRlTmFtZShyZXF1aXJlZEZhY2FkZXMuc2hpZnQoKSwgbW9kdWxlLCB0aGlzLm91dHB1dE9wdGlvbnMucHJlc2VydmVNb2R1bGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZhY2FkZU5hbWUgb2YgcmVxdWlyZWRGYWNhZGVzKSB7XG4gICAgICAgICAgICAgICAgZmFjYWRlcy5wdXNoKENodW5rLmdlbmVyYXRlRmFjYWRlKHRoaXMuaW5wdXRPcHRpb25zLCB0aGlzLm91dHB1dE9wdGlvbnMsIHRoaXMudW5zZXRPcHRpb25zLCB0aGlzLnBsdWdpbkRyaXZlciwgdGhpcy5tb2R1bGVzQnlJZCwgdGhpcy5jaHVua0J5TW9kdWxlLCB0aGlzLmV4dGVybmFsQ2h1bmtCeU1vZHVsZSwgdGhpcy5mYWNhZGVDaHVua0J5TW9kdWxlLCB0aGlzLmluY2x1ZGVkTmFtZXNwYWNlcywgbW9kdWxlLCBmYWNhZGVOYW1lLCB0aGlzLmdldFBsYWNlaG9sZGVyLCB0aGlzLmJ1bmRsZSwgdGhpcy5pbnB1dEJhc2UsIHRoaXMuc25pcHBldHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiB0aGlzLmR5bmFtaWNFbnRyeU1vZHVsZXMpIHtcbiAgICAgICAgICAgIGlmIChtb2R1bGUuaW5mby5zeW50aGV0aWNOYW1lZEV4cG9ydHMpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmFjYWRlTW9kdWxlICYmIHRoaXMuY2FuTW9kdWxlQmVGYWNhZGUobW9kdWxlLCBleHBvc2VkVmFyaWFibGVzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmFjYWRlTW9kdWxlID0gbW9kdWxlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmFjYWRlQ2h1bmtCeU1vZHVsZS5zZXQobW9kdWxlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmljdEZhY2FkZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5keW5hbWljTmFtZSA9IGdldENodW5rTmFtZUZyb21Nb2R1bGUobW9kdWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZmFjYWRlTW9kdWxlID09PSBtb2R1bGUgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5zdHJpY3RGYWNhZGUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmNhbk1vZHVsZUJlRmFjYWRlKG1vZHVsZSwgZXhwb3NlZFZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmljdEZhY2FkZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5mYWNhZGVDaHVua0J5TW9kdWxlLmdldChtb2R1bGUpPy5zdHJpY3RGYWNhZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluY2x1ZGVkTmFtZXNwYWNlcy5hZGQobW9kdWxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cG9ydHMuYWRkKG1vZHVsZS5uYW1lc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRPcHRpb25zLnByZXNlcnZlTW9kdWxlcykge1xuICAgICAgICAgICAgdGhpcy5hZGROZWNlc3NhcnlJbXBvcnRzRm9yRmFjYWRlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWNhZGVzO1xuICAgIH1cbiAgICBnZXRDaHVua05hbWUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5uYW1lID8/PSB0aGlzLm91dHB1dE9wdGlvbnMuc2FuaXRpemVGaWxlTmFtZSh0aGlzLmdldEZhbGxiYWNrQ2h1bmtOYW1lKCkpKTtcbiAgICB9XG4gICAgZ2V0RXhwb3J0TmFtZXMoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zb3J0ZWRFeHBvcnROYW1lcyA/Pz0gWy4uLnRoaXMuZXhwb3J0c0J5TmFtZS5rZXlzKCldLnNvcnQoKSk7XG4gICAgfVxuICAgIGdldEZpbGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxlTmFtZSB8fCB0aGlzLmdldFByZWxpbWluYXJ5RmlsZU5hbWUoKS5maWxlTmFtZTtcbiAgICB9XG4gICAgZ2V0SW1wb3J0UGF0aChpbXBvcnRlcikge1xuICAgICAgICByZXR1cm4gZXNjYXBlSWQoZ2V0SW1wb3J0UGF0aChpbXBvcnRlciwgdGhpcy5nZXRGaWxlTmFtZSgpLCB0aGlzLm91dHB1dE9wdGlvbnMuZm9ybWF0ID09PSAnYW1kJyAmJiAhdGhpcy5vdXRwdXRPcHRpb25zLmFtZC5mb3JjZUpzRXh0ZW5zaW9uRm9ySW1wb3J0cywgdHJ1ZSkpO1xuICAgIH1cbiAgICBnZXRQcmVsaW1pbmFyeUZpbGVOYW1lKCkge1xuICAgICAgICBpZiAodGhpcy5wcmVsaW1pbmFyeUZpbGVOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVsaW1pbmFyeUZpbGVOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWxlTmFtZTtcbiAgICAgICAgbGV0IGhhc2hQbGFjZWhvbGRlciA9IG51bGw7XG4gICAgICAgIGNvbnN0IHsgY2h1bmtGaWxlTmFtZXMsIGVudHJ5RmlsZU5hbWVzLCBmaWxlLCBmb3JtYXQsIHByZXNlcnZlTW9kdWxlcyB9ID0gdGhpcy5vdXRwdXRPcHRpb25zO1xuICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgZmlsZU5hbWUgPSBiYXNlbmFtZShmaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmZpbGVOYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBbcGF0dGVybiwgcGF0dGVybk5hbWVdID0gcHJlc2VydmVNb2R1bGVzIHx8IHRoaXMuZmFjYWRlTW9kdWxlPy5pc1VzZXJEZWZpbmVkRW50cnlQb2ludFxuICAgICAgICAgICAgICAgID8gW2VudHJ5RmlsZU5hbWVzLCAnb3V0cHV0LmVudHJ5RmlsZU5hbWVzJ11cbiAgICAgICAgICAgICAgICA6IFtjaHVua0ZpbGVOYW1lcywgJ291dHB1dC5jaHVua0ZpbGVOYW1lcyddO1xuICAgICAgICAgICAgZmlsZU5hbWUgPSByZW5kZXJOYW1lUGF0dGVybih0eXBlb2YgcGF0dGVybiA9PT0gJ2Z1bmN0aW9uJyA/IHBhdHRlcm4odGhpcy5nZXRQcmVSZW5kZXJlZENodW5rSW5mbygpKSA6IHBhdHRlcm4sIHBhdHRlcm5OYW1lLCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAoKSA9PiBmb3JtYXQsXG4gICAgICAgICAgICAgICAgaGFzaDogc2l6ZSA9PiBoYXNoUGxhY2Vob2xkZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgKGhhc2hQbGFjZWhvbGRlciA9IHRoaXMuZ2V0UGxhY2Vob2xkZXIocGF0dGVybk5hbWUsIHNpemUgfHwgREVGQVVMVF9IQVNIX1NJWkUpKSxcbiAgICAgICAgICAgICAgICBuYW1lOiAoKSA9PiB0aGlzLmdldENodW5rTmFtZSgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghaGFzaFBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgZmlsZU5hbWUgPSBtYWtlVW5pcXVlKGZpbGVOYW1lLCB0aGlzLmJ1bmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaWxlTmFtZSA9IHRoaXMuZmlsZU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNoUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYnVuZGxlW2ZpbGVOYW1lXSA9IEZJTEVfUExBQ0VIT0xERVI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FjaGluZyBpcyBlc3NlbnRpYWwgdG8gbm90IGNvbmZsaWN0IHdpdGggdGhlIGZpbGUgbmFtZSByZXNlcnZhdGlvbiBhYm92ZVxuICAgICAgICByZXR1cm4gKHRoaXMucHJlbGltaW5hcnlGaWxlTmFtZSA9IHsgZmlsZU5hbWUsIGhhc2hQbGFjZWhvbGRlciB9KTtcbiAgICB9XG4gICAgZ2V0UHJlbGltaW5hcnlTb3VyY2VtYXBGaWxlTmFtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJlbGltaW5hcnlTb3VyY2VtYXBGaWxlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlbGltaW5hcnlTb3VyY2VtYXBGaWxlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc291cmNlbWFwRmlsZU5hbWUgPSBudWxsO1xuICAgICAgICBsZXQgaGFzaFBsYWNlaG9sZGVyID0gbnVsbDtcbiAgICAgICAgY29uc3QgeyBzb3VyY2VtYXBGaWxlTmFtZXMsIGZvcm1hdCB9ID0gdGhpcy5vdXRwdXRPcHRpb25zO1xuICAgICAgICBpZiAoc291cmNlbWFwRmlsZU5hbWVzKSB7XG4gICAgICAgICAgICBjb25zdCBbcGF0dGVybiwgcGF0dGVybk5hbWVdID0gW3NvdXJjZW1hcEZpbGVOYW1lcywgJ291dHB1dC5zb3VyY2VtYXBGaWxlTmFtZXMnXTtcbiAgICAgICAgICAgIHNvdXJjZW1hcEZpbGVOYW1lID0gcmVuZGVyTmFtZVBhdHRlcm4odHlwZW9mIHBhdHRlcm4gPT09ICdmdW5jdGlvbicgPyBwYXR0ZXJuKHRoaXMuZ2V0UHJlUmVuZGVyZWRDaHVua0luZm8oKSkgOiBwYXR0ZXJuLCBwYXR0ZXJuTmFtZSwge1xuICAgICAgICAgICAgICAgIGNodW5raGFzaDogKCkgPT4gdGhpcy5nZXRQcmVsaW1pbmFyeUZpbGVOYW1lKCkuaGFzaFBsYWNlaG9sZGVyIHx8ICcnLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogKCkgPT4gZm9ybWF0LFxuICAgICAgICAgICAgICAgIGhhc2g6IHNpemUgPT4gaGFzaFBsYWNlaG9sZGVyIHx8XG4gICAgICAgICAgICAgICAgICAgIChoYXNoUGxhY2Vob2xkZXIgPSB0aGlzLmdldFBsYWNlaG9sZGVyKHBhdHRlcm5OYW1lLCBzaXplIHx8IERFRkFVTFRfSEFTSF9TSVpFKSksXG4gICAgICAgICAgICAgICAgbmFtZTogKCkgPT4gdGhpcy5nZXRDaHVua05hbWUoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWhhc2hQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgIHNvdXJjZW1hcEZpbGVOYW1lID0gbWFrZVVuaXF1ZShzb3VyY2VtYXBGaWxlTmFtZSwgdGhpcy5idW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLnByZWxpbWluYXJ5U291cmNlbWFwRmlsZU5hbWUgPSB7IGZpbGVOYW1lOiBzb3VyY2VtYXBGaWxlTmFtZSwgaGFzaFBsYWNlaG9sZGVyIH0pO1xuICAgIH1cbiAgICBnZXRSZW5kZXJlZENodW5rSW5mbygpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZWRDaHVua0luZm8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVkQ2h1bmtJbmZvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5yZW5kZXJlZENodW5rSW5mbyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuZ2V0UHJlUmVuZGVyZWRDaHVua0luZm8oKSxcbiAgICAgICAgICAgIGR5bmFtaWNJbXBvcnRzOiB0aGlzLmdldER5bmFtaWNEZXBlbmRlbmNpZXMoKS5tYXAocmVzb2x2ZUZpbGVOYW1lKSxcbiAgICAgICAgICAgIGZpbGVOYW1lOiB0aGlzLmdldEZpbGVOYW1lKCksXG4gICAgICAgICAgICBpbXBsaWNpdGx5TG9hZGVkQmVmb3JlOiBBcnJheS5mcm9tKHRoaXMuaW1wbGljaXRseUxvYWRlZEJlZm9yZSwgcmVzb2x2ZUZpbGVOYW1lKSxcbiAgICAgICAgICAgIGltcG9ydGVkQmluZGluZ3M6IGdldEltcG9ydGVkQmluZGluZ3NQZXJEZXBlbmRlbmN5KHRoaXMuZ2V0UmVuZGVyZWREZXBlbmRlbmNpZXMoKSwgcmVzb2x2ZUZpbGVOYW1lKSxcbiAgICAgICAgICAgIGltcG9ydHM6IEFycmF5LmZyb20odGhpcy5kZXBlbmRlbmNpZXMsIHJlc29sdmVGaWxlTmFtZSksXG4gICAgICAgICAgICBtb2R1bGVzOiB0aGlzLnJlbmRlcmVkTW9kdWxlcyxcbiAgICAgICAgICAgIHJlZmVyZW5jZWRGaWxlczogdGhpcy5nZXRSZWZlcmVuY2VkRmlsZXMoKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VmFyaWFibGVFeHBvcnROYW1lKHZhcmlhYmxlKSB7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dE9wdGlvbnMucHJlc2VydmVNb2R1bGVzICYmIHZhcmlhYmxlIGluc3RhbmNlb2YgTmFtZXNwYWNlVmFyaWFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnKic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwb3J0TmFtZXNCeVZhcmlhYmxlLmdldCh2YXJpYWJsZSlbMF07XG4gICAgfVxuICAgIGxpbmsoKSB7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZ2V0U3RhdGljRGVwZW5kZW5jaWVzKHRoaXMsIHRoaXMub3JkZXJlZE1vZHVsZXMsIHRoaXMuY2h1bmtCeU1vZHVsZSwgdGhpcy5leHRlcm5hbENodW5rQnlNb2R1bGUpO1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiB0aGlzLm9yZGVyZWRNb2R1bGVzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEltcGxpY2l0bHlMb2FkZWRCZWZvcmVGcm9tTW9kdWxlKG1vZHVsZSk7XG4gICAgICAgICAgICB0aGlzLnNldFVwQ2h1bmtJbXBvcnRzQW5kRXhwb3J0c0Zvck1vZHVsZShtb2R1bGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBkZXBlbmRlbmNpZXMsIGV4cG9ydE1vZGUsIGZhY2FkZU1vZHVsZSwgaW5wdXRPcHRpb25zOiB7IG9uTG9nIH0sIG91dHB1dE9wdGlvbnMsIHBsdWdpbkRyaXZlciwgc25pcHBldHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgZm9ybWF0LCBob2lzdFRyYW5zaXRpdmVJbXBvcnRzLCBwcmVzZXJ2ZU1vZHVsZXMgfSA9IG91dHB1dE9wdGlvbnM7XG4gICAgICAgIC8vIGZvciBzdGF0aWMgYW5kIGR5bmFtaWMgZW50cnkgcG9pbnRzLCBhZGQgdHJhbnNpdGl2ZSBkZXBlbmRlbmNpZXMgdG8gdGhpc1xuICAgICAgICAvLyBjaHVuaydzIGRlcGVuZGVuY2llcyB0byBhdm9pZCBsb2FkaW5nIGxhdGVuY3lcbiAgICAgICAgaWYgKGhvaXN0VHJhbnNpdGl2ZUltcG9ydHMgJiYgIXByZXNlcnZlTW9kdWxlcyAmJiBmYWNhZGVNb2R1bGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVwIG9mIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgIGlmIChkZXAgaW5zdGFuY2VvZiBDaHVuaylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVDaHVua0RlcGVuZGVuY2llcyhkZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWxpbWluYXJ5RmlsZU5hbWUgPSB0aGlzLmdldFByZWxpbWluYXJ5RmlsZU5hbWUoKTtcbiAgICAgICAgY29uc3QgcHJlbGltaW5hcnlTb3VyY2VtYXBGaWxlTmFtZSA9IHRoaXMuZ2V0UHJlbGltaW5hcnlTb3VyY2VtYXBGaWxlTmFtZSgpO1xuICAgICAgICBjb25zdCB7IGFjY2Vzc2VkR2xvYmFscywgaW5kZW50LCBtYWdpY1N0cmluZywgcmVuZGVyZWRTb3VyY2UsIHVzZWRNb2R1bGVzLCB1c2VzVG9wTGV2ZWxBd2FpdCB9ID0gdGhpcy5yZW5kZXJNb2R1bGVzKHByZWxpbWluYXJ5RmlsZU5hbWUuZmlsZU5hbWUpO1xuICAgICAgICBjb25zdCByZW5kZXJlZERlcGVuZGVuY2llcyA9IFsuLi50aGlzLmdldFJlbmRlcmVkRGVwZW5kZW5jaWVzKCkudmFsdWVzKCldO1xuICAgICAgICBjb25zdCByZW5kZXJlZEV4cG9ydHMgPSBleHBvcnRNb2RlID09PSAnbm9uZScgPyBbXSA6IHRoaXMuZ2V0Q2h1bmtFeHBvcnREZWNsYXJhdGlvbnMoZm9ybWF0KTtcbiAgICAgICAgbGV0IGhhc0V4cG9ydHMgPSByZW5kZXJlZEV4cG9ydHMubGVuZ3RoID4gMDtcbiAgICAgICAgbGV0IGhhc0RlZmF1bHRFeHBvcnQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCByZW5kZXJlZERlcGVuZGVuY3kgb2YgcmVuZGVyZWREZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVleHBvcnRzIH0gPSByZW5kZXJlZERlcGVuZGVuY3k7XG4gICAgICAgICAgICBpZiAocmVleHBvcnRzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBoYXNFeHBvcnRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0RlZmF1bHRFeHBvcnQgJiYgcmVleHBvcnRzLnNvbWUocmVleHBvcnQgPT4gcmVleHBvcnQucmVleHBvcnRlZCA9PT0gJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNEZWZhdWx0RXhwb3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2VzJykge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZERlcGVuZGVuY3kucmVleHBvcnRzID0gcmVleHBvcnRzLmZpbHRlcigoeyByZWV4cG9ydGVkIH0pID0+ICFyZW5kZXJlZEV4cG9ydHMuZmluZCgoeyBleHBvcnRlZCB9KSA9PiBleHBvcnRlZCA9PT0gcmVleHBvcnRlZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0RlZmF1bHRFeHBvcnQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBleHBvcnRlZCB9IG9mIHJlbmRlcmVkRXhwb3J0cykge1xuICAgICAgICAgICAgICAgIGlmIChleHBvcnRlZCA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0RlZmF1bHRFeHBvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpbnRybywgb3V0cm8sIGJhbm5lciwgZm9vdGVyIH0gPSBhd2FpdCBjcmVhdGVBZGRvbnMob3V0cHV0T3B0aW9ucywgcGx1Z2luRHJpdmVyLCB0aGlzLmdldFJlbmRlcmVkQ2h1bmtJbmZvKCkpO1xuICAgICAgICBmaW5hbGlzZXJzW2Zvcm1hdF0ocmVuZGVyZWRTb3VyY2UsIHtcbiAgICAgICAgICAgIGFjY2Vzc2VkR2xvYmFscyxcbiAgICAgICAgICAgIGRlcGVuZGVuY2llczogcmVuZGVyZWREZXBlbmRlbmNpZXMsXG4gICAgICAgICAgICBleHBvcnRzOiByZW5kZXJlZEV4cG9ydHMsXG4gICAgICAgICAgICBoYXNEZWZhdWx0RXhwb3J0LFxuICAgICAgICAgICAgaGFzRXhwb3J0cyxcbiAgICAgICAgICAgIGlkOiBwcmVsaW1pbmFyeUZpbGVOYW1lLmZpbGVOYW1lLFxuICAgICAgICAgICAgaW5kZW50LFxuICAgICAgICAgICAgaW50cm8sXG4gICAgICAgICAgICBpc0VudHJ5RmFjYWRlOiBwcmVzZXJ2ZU1vZHVsZXMgfHwgKGZhY2FkZU1vZHVsZSAhPT0gbnVsbCAmJiBmYWNhZGVNb2R1bGUuaW5mby5pc0VudHJ5KSxcbiAgICAgICAgICAgIGlzTW9kdWxlRmFjYWRlOiBmYWNhZGVNb2R1bGUgIT09IG51bGwsXG4gICAgICAgICAgICBsb2c6IG9uTG9nLFxuICAgICAgICAgICAgbmFtZWRFeHBvcnRzTW9kZTogZXhwb3J0TW9kZSAhPT0gJ2RlZmF1bHQnLFxuICAgICAgICAgICAgb3V0cm8sXG4gICAgICAgICAgICBzbmlwcGV0cyxcbiAgICAgICAgICAgIHVzZXNUb3BMZXZlbEF3YWl0XG4gICAgICAgIH0sIG91dHB1dE9wdGlvbnMpO1xuICAgICAgICBpZiAoYmFubmVyKVxuICAgICAgICAgICAgbWFnaWNTdHJpbmcucHJlcGVuZChiYW5uZXIpO1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnZXMnIHx8IGZvcm1hdCA9PT0gJ2NqcycpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoZWJhbmcgPSBmYWNhZGVNb2R1bGUgIT09IG51bGwgJiYgZmFjYWRlTW9kdWxlLmluZm8uaXNFbnRyeSAmJiBmYWNhZGVNb2R1bGUuc2hlYmFuZztcbiAgICAgICAgICAgIGlmIChzaGViYW5nKSB7XG4gICAgICAgICAgICAgICAgbWFnaWNTdHJpbmcucHJlcGVuZChgIyEke3NoZWJhbmd9XFxuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvb3RlcilcbiAgICAgICAgICAgIG1hZ2ljU3RyaW5nLmFwcGVuZChmb290ZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2h1bms6IHRoaXMsXG4gICAgICAgICAgICBtYWdpY1N0cmluZyxcbiAgICAgICAgICAgIHByZWxpbWluYXJ5RmlsZU5hbWUsXG4gICAgICAgICAgICBwcmVsaW1pbmFyeVNvdXJjZW1hcEZpbGVOYW1lLFxuICAgICAgICAgICAgdXNlZE1vZHVsZXNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYWRkSW1wbGljaXRseUxvYWRlZEJlZm9yZUZyb21Nb2R1bGUoYmFzZU1vZHVsZSkge1xuICAgICAgICBjb25zdCB7IGNodW5rQnlNb2R1bGUsIGltcGxpY2l0bHlMb2FkZWRCZWZvcmUgfSA9IHRoaXM7XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIGJhc2VNb2R1bGUuaW1wbGljaXRseUxvYWRlZEJlZm9yZSkge1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBjaHVua0J5TW9kdWxlLmdldChtb2R1bGUpO1xuICAgICAgICAgICAgaWYgKGNodW5rICYmIGNodW5rICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgaW1wbGljaXRseUxvYWRlZEJlZm9yZS5hZGQoY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFkZE5lY2Vzc2FyeUltcG9ydHNGb3JGYWNhZGVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IFttb2R1bGUsIHZhcmlhYmxlc10gb2YgdGhpcy5pbmNsdWRlZFJlZXhwb3J0c0J5TW9kdWxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmNsdWRlZE5hbWVzcGFjZXMuaGFzKG1vZHVsZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhcmlhYmxlIG9mIHZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydHMuYWRkKHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduRmFjYWRlTmFtZSh7IGZpbGVOYW1lLCBuYW1lIH0sIGZhY2FkZWRNb2R1bGUsIHByZXNlcnZlUGF0aCkge1xuICAgICAgICBpZiAoZmlsZU5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZU5hbWUgPSBmaWxlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IHRoaXMub3V0cHV0T3B0aW9ucy5zYW5pdGl6ZUZpbGVOYW1lKG5hbWUgfHxcbiAgICAgICAgICAgICAgICAocHJlc2VydmVQYXRoXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5nZXRQcmVzZXJ2ZU1vZHVsZXNDaHVua05hbWVGcm9tTW9kdWxlKGZhY2FkZWRNb2R1bGUpXG4gICAgICAgICAgICAgICAgICAgIDogZ2V0Q2h1bmtOYW1lRnJvbU1vZHVsZShmYWNhZGVkTW9kdWxlKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrQ2lyY3VsYXJEZXBlbmRlbmN5SW1wb3J0KHZhcmlhYmxlLCBpbXBvcnRpbmdNb2R1bGUpIHtcbiAgICAgICAgY29uc3QgdmFyaWFibGVNb2R1bGUgPSB2YXJpYWJsZS5tb2R1bGU7XG4gICAgICAgIGlmICh2YXJpYWJsZU1vZHVsZSBpbnN0YW5jZW9mIE1vZHVsZSkge1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0Q2h1bmsgPSB0aGlzLmNodW5rQnlNb2R1bGUuZ2V0KHZhcmlhYmxlTW9kdWxlKTtcbiAgICAgICAgICAgIGxldCBhbHRlcm5hdGl2ZVJlZXhwb3J0TW9kdWxlO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlUmVleHBvcnRNb2R1bGUgPSBpbXBvcnRpbmdNb2R1bGUuYWx0ZXJuYXRpdmVSZWV4cG9ydE1vZHVsZXMuZ2V0KHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICBpZiAoYWx0ZXJuYXRpdmVSZWV4cG9ydE1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBvcnRpbmdDaHVuayA9IHRoaXMuY2h1bmtCeU1vZHVsZS5nZXQoYWx0ZXJuYXRpdmVSZWV4cG9ydE1vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBvcnRpbmdDaHVuayAhPT0gZXhwb3J0Q2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRPcHRpb25zLm9uTG9nKExPR0xFVkVMX1dBUk4sIGxvZ0N5Y2xpY0Nyb3NzQ2h1bmtSZWV4cG9ydChcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5hbWVzcGFjZXMgZG8gbm90IGhhdmUgYW4gZXhwb3J0IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlTW9kdWxlLmdldEV4cG9ydE5hbWVzQnlWYXJpYWJsZSgpLmdldCh2YXJpYWJsZSk/LlswXSB8fCAnKicsIHZhcmlhYmxlTW9kdWxlLmlkLCBhbHRlcm5hdGl2ZVJlZXhwb3J0TW9kdWxlLmlkLCBpbXBvcnRpbmdNb2R1bGUuaWQsIHRoaXMub3V0cHV0T3B0aW9ucy5wcmVzZXJ2ZU1vZHVsZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRpbmdNb2R1bGUgPSBhbHRlcm5hdGl2ZVJlZXhwb3J0TW9kdWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGFsdGVybmF0aXZlUmVleHBvcnRNb2R1bGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVuc3VyZVJlZXhwb3J0c0FyZUF2YWlsYWJsZUZvck1vZHVsZShtb2R1bGUpIHtcbiAgICAgICAgY29uc3QgaW5jbHVkZWRSZWV4cG9ydHMgPSBbXTtcbiAgICAgICAgY29uc3QgbWFwID0gbW9kdWxlLmdldEV4cG9ydE5hbWVzQnlWYXJpYWJsZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGV4cG9ydGVkVmFyaWFibGUgb2YgbWFwLmtleXMoKSkge1xuICAgICAgICAgICAgY29uc3QgaXNTeW50aGV0aWMgPSBleHBvcnRlZFZhcmlhYmxlIGluc3RhbmNlb2YgU3ludGhldGljTmFtZWRFeHBvcnRWYXJpYWJsZTtcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydGVkVmFyaWFibGUgPSBpc1N5bnRoZXRpYyA/IGV4cG9ydGVkVmFyaWFibGUuZ2V0QmFzZVZhcmlhYmxlKCkgOiBleHBvcnRlZFZhcmlhYmxlO1xuICAgICAgICAgICAgdGhpcy5jaGVja0NpcmN1bGFyRGVwZW5kZW5jeUltcG9ydChpbXBvcnRlZFZhcmlhYmxlLCBtb2R1bGUpO1xuICAgICAgICAgICAgLy8gV2hlbiBwcmVzZXJ2aW5nIG1vZHVsZXMsIHdlIGRvIG5vdCBjcmVhdGUgbmFtZXNwYWNlIG9iamVjdHMgYnV0IGRpcmVjdGx5XG4gICAgICAgICAgICAvLyB1c2UgdGhlIGFjdHVhbCBuYW1lc3BhY2VzLCB3aGljaCB3b3VsZCBiZSBicm9rZW4gYnkgdGhpcyBsb2dpYy5cbiAgICAgICAgICAgIGlmICghKGltcG9ydGVkVmFyaWFibGUgaW5zdGFuY2VvZiBOYW1lc3BhY2VWYXJpYWJsZSAmJiB0aGlzLm91dHB1dE9wdGlvbnMucHJlc2VydmVNb2R1bGVzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cG9ydGluZ01vZHVsZSA9IGltcG9ydGVkVmFyaWFibGUubW9kdWxlO1xuICAgICAgICAgICAgICAgIGlmIChleHBvcnRpbmdNb2R1bGUgaW5zdGFuY2VvZiBNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLmNodW5rQnlNb2R1bGUuZ2V0KGV4cG9ydGluZ01vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuayAmJiBjaHVuayAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsuZXhwb3J0cy5hZGQoaW1wb3J0ZWRWYXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlZFJlZXhwb3J0cy5wdXNoKGltcG9ydGVkVmFyaWFibGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3ludGhldGljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRzLmFkZChpbXBvcnRlZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZWRSZWV4cG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5pbmNsdWRlZFJlZXhwb3J0c0J5TW9kdWxlLnNldChtb2R1bGUsIGluY2x1ZGVkUmVleHBvcnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZW5lcmF0ZVZhcmlhYmxlTmFtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFudWFsQ2h1bmtBbGlhcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFudWFsQ2h1bmtBbGlhcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2R1bGVGb3JOYW1pbmcgPSB0aGlzLmVudHJ5TW9kdWxlc1swXSB8fFxuICAgICAgICAgICAgdGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlc1swXSB8fFxuICAgICAgICAgICAgdGhpcy5keW5hbWljRW50cnlNb2R1bGVzWzBdIHx8XG4gICAgICAgICAgICB0aGlzLm9yZGVyZWRNb2R1bGVzW3RoaXMub3JkZXJlZE1vZHVsZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChtb2R1bGVGb3JOYW1pbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDaHVua05hbWVGcm9tTW9kdWxlKG1vZHVsZUZvck5hbWluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdjaHVuayc7XG4gICAgfVxuICAgIGdldENodW5rRXhwb3J0RGVjbGFyYXRpb25zKGZvcm1hdCkge1xuICAgICAgICBjb25zdCBleHBvcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZXhwb3J0TmFtZSBvZiB0aGlzLmdldEV4cG9ydE5hbWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChleHBvcnROYW1lWzBdID09PSAnKicpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCB2YXJpYWJsZSA9IHRoaXMuZXhwb3J0c0J5TmFtZS5nZXQoZXhwb3J0TmFtZSk7XG4gICAgICAgICAgICBpZiAoISh2YXJpYWJsZSBpbnN0YW5jZW9mIFN5bnRoZXRpY05hbWVkRXhwb3J0VmFyaWFibGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gdmFyaWFibGUubW9kdWxlO1xuICAgICAgICAgICAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLmNodW5rQnlNb2R1bGUuZ2V0KG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuayAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaHVuayB8fCBmb3JtYXQgIT09ICdlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rRGVwID0gdGhpcy5yZW5kZXJlZERlcGVuZGVuY2llcy5nZXQoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaHVua0RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpbXBvcnRzLCByZWV4cG9ydHMgfSA9IGNodW5rRGVwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1wb3J0ZWRCeVJlZXhwb3J0ZWQgPSByZWV4cG9ydHM/LmZpbmQoKHsgcmVleHBvcnRlZCB9KSA9PiByZWV4cG9ydGVkID09PSBleHBvcnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzSW1wb3J0ZWQgPSBpbXBvcnRzPy5maW5kKCh7IGltcG9ydGVkIH0pID0+IGltcG9ydGVkID09PSBpbXBvcnRlZEJ5UmVleHBvcnRlZD8uaW1wb3J0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0ltcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZXhwcmVzc2lvbiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgaG9pc3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGxvY2FsID0gdmFyaWFibGUuZ2V0TmFtZSh0aGlzLnNuaXBwZXRzLmdldFByb3BlcnR5QWNjZXNzKTtcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZSBpbnN0YW5jZW9mIExvY2FsVmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY2xhcmF0aW9uIG9mIHZhcmlhYmxlLmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVjbGFyYXRpb24ucGFyZW50IGluc3RhbmNlb2YgRnVuY3Rpb25EZWNsYXJhdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGRlY2xhcmF0aW9uIGluc3RhbmNlb2YgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24uZGVjbGFyYXRpb24gaW5zdGFuY2VvZiBGdW5jdGlvbkRlY2xhcmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhcmlhYmxlIGluc3RhbmNlb2YgU3ludGhldGljTmFtZWRFeHBvcnRWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBsb2NhbDtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsID0gdmFyaWFibGUucmVuZGVyTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBvcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGV4cG9ydGVkOiBleHBvcnROYW1lLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgaG9pc3RlZCxcbiAgICAgICAgICAgICAgICBsb2NhbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgfVxuICAgIGdldERlcGVuZGVuY2llc1RvQmVEZWNvbmZsaWN0ZWQoYWRkTm9uTmFtZXNwYWNlc0FuZEludGVyb3BIZWxwZXJzLCBhZGREZXBlbmRlbmNpZXNXaXRob3V0QmluZGluZ3MsIGludGVyb3ApIHtcbiAgICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBkZWNvbmZsaWN0ZWREZWZhdWx0ID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBkZWNvbmZsaWN0ZWROYW1lc3BhY2UgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgWy4uLnRoaXMuZXhwb3J0TmFtZXNCeVZhcmlhYmxlLmtleXMoKSwgLi4udGhpcy5pbXBvcnRzXSkge1xuICAgICAgICAgICAgaWYgKGFkZE5vbk5hbWVzcGFjZXNBbmRJbnRlcm9wSGVscGVycyB8fCB2YXJpYWJsZS5pc05hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IHZhcmlhYmxlLm1vZHVsZTtcbiAgICAgICAgICAgICAgICBpZiAobW9kdWxlIGluc3RhbmNlb2YgRXh0ZXJuYWxNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLmV4dGVybmFsQ2h1bmtCeU1vZHVsZS5nZXQobW9kdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLmFkZChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGROb25OYW1lc3BhY2VzQW5kSW50ZXJvcEhlbHBlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZS5uYW1lID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdEludGVyb3BIZWxwZXJzQnlJbnRlcm9wVHlwZVtpbnRlcm9wKG1vZHVsZS5pZCldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29uZmxpY3RlZERlZmF1bHQuYWRkKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YXJpYWJsZS5pc05hbWVzcGFjZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZUludGVyb3BIZWxwZXJzQnlJbnRlcm9wVHlwZVtpbnRlcm9wKG1vZHVsZS5pZCldICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuaW1wb3J0cy5oYXModmFyaWFibGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLmV4cG9ydE5hbWVzQnlWYXJpYWJsZS5nZXQodmFyaWFibGUpPy5ldmVyeShuYW1lID0+IG5hbWUuc3RhcnRzV2l0aCgnKicpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gZGVjb25mbGljdCBpdCBpZiB0aGUgbmFtZXNwYWNlIGlzIGFjdHVhbGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlZCBhcyBhIHZhcmlhYmxlLCBpLmUuIGJlY2F1c2UgaXQgaXMgdXNlZCBpbnRlcm5hbGx5IG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBpdCBpcyByZWV4cG9ydGVkIGFzIGFuIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29uZmxpY3RlZE5hbWVzcGFjZS5hZGQoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuY2h1bmtCeU1vZHVsZS5nZXQobW9kdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMuYWRkKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGROb25OYW1lc3BhY2VzQW5kSW50ZXJvcEhlbHBlcnMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5leHBvcnRNb2RlID09PSAnZGVmYXVsdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZS5pc05hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29uZmxpY3RlZE5hbWVzcGFjZS5hZGQoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhZGREZXBlbmRlbmNpZXNXaXRob3V0QmluZGluZ3MpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVwZW5kZW5jeSBvZiB0aGlzLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5hZGQoZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGVjb25mbGljdGVkRGVmYXVsdCwgZGVjb25mbGljdGVkTmFtZXNwYWNlLCBkZXBlbmRlbmNpZXMgfTtcbiAgICB9XG4gICAgZ2V0RHluYW1pY0RlcGVuZGVuY2llcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5jbHVkZWREeW5hbWljSW1wb3J0cygpXG4gICAgICAgICAgICAubWFwKHJlc29sdmVkRHluYW1pY0ltcG9ydCA9PiByZXNvbHZlZER5bmFtaWNJbXBvcnQuZmFjYWRlQ2h1bmsgfHxcbiAgICAgICAgICAgIHJlc29sdmVkRHluYW1pY0ltcG9ydC5jaHVuayB8fFxuICAgICAgICAgICAgcmVzb2x2ZWREeW5hbWljSW1wb3J0LmV4dGVybmFsQ2h1bmsgfHxcbiAgICAgICAgICAgIHJlc29sdmVkRHluYW1pY0ltcG9ydC5yZXNvbHV0aW9uKVxuICAgICAgICAgICAgLmZpbHRlcigocmVzb2x1dGlvbikgPT4gcmVzb2x1dGlvbiAhPT0gdGhpcyAmJlxuICAgICAgICAgICAgKHJlc29sdXRpb24gaW5zdGFuY2VvZiBDaHVuayB8fCByZXNvbHV0aW9uIGluc3RhbmNlb2YgRXh0ZXJuYWxDaHVuaykpO1xuICAgIH1cbiAgICBnZXREeW5hbWljSW1wb3J0U3RyaW5nQW5kQXR0cmlidXRlcyhyZXNvbHV0aW9uLCBmaWxlTmFtZSkge1xuICAgICAgICBpZiAocmVzb2x1dGlvbiBpbnN0YW5jZW9mIEV4dGVybmFsTW9kdWxlKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuZXh0ZXJuYWxDaHVua0J5TW9kdWxlLmdldChyZXNvbHV0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBbYCcke2NodW5rLmdldEltcG9ydFBhdGgoZmlsZU5hbWUpfSdgLCBjaHVuay5nZXRJbXBvcnRBdHRyaWJ1dGVzKHRoaXMuc25pcHBldHMpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcmVzb2x1dGlvbiB8fCAnJyxcbiAgICAgICAgICAgICh0aGlzLm91dHB1dE9wdGlvbnMuZm9ybWF0ID09PSAnZXMnICYmIHRoaXMub3V0cHV0T3B0aW9ucy5leHRlcm5hbEltcG9ydEF0dHJpYnV0ZXMpIHx8IG51bGxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZ2V0RmFsbGJhY2tDaHVua05hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLm1hbnVhbENodW5rQWxpYXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbnVhbENodW5rQWxpYXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmR5bmFtaWNOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpbGVOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWxpYXNOYW1lKHRoaXMuZmlsZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRBbGlhc05hbWUodGhpcy5vcmRlcmVkTW9kdWxlc1t0aGlzLm9yZGVyZWRNb2R1bGVzLmxlbmd0aCAtIDFdLmlkKTtcbiAgICB9XG4gICAgZ2V0SW1wb3J0U3BlY2lmaWVycygpIHtcbiAgICAgICAgY29uc3QgeyBpbnRlcm9wIH0gPSB0aGlzLm91dHB1dE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGltcG9ydHNCeURlcGVuZGVuY3kgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgdGhpcy5pbXBvcnRzKSB7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGUgPSB2YXJpYWJsZS5tb2R1bGU7XG4gICAgICAgICAgICBsZXQgZGVwZW5kZW5jeTtcbiAgICAgICAgICAgIGxldCBpbXBvcnRlZDtcbiAgICAgICAgICAgIGlmIChtb2R1bGUgaW5zdGFuY2VvZiBFeHRlcm5hbE1vZHVsZSkge1xuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmV4dGVybmFsQ2h1bmtCeU1vZHVsZS5nZXQobW9kdWxlKTtcbiAgICAgICAgICAgICAgICBpbXBvcnRlZCA9IHZhcmlhYmxlLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKGltcG9ydGVkICE9PSAnZGVmYXVsdCcgJiYgaW1wb3J0ZWQgIT09ICcqJyAmJiBpbnRlcm9wKG1vZHVsZS5pZCkgPT09ICdkZWZhdWx0T25seScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGxvZ1VuZXhwZWN0ZWROYW1lZEltcG9ydChtb2R1bGUuaWQsIGltcG9ydGVkLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmNodW5rQnlNb2R1bGUuZ2V0KG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgaW1wb3J0ZWQgPSBkZXBlbmRlbmN5LmdldFZhcmlhYmxlRXhwb3J0TmFtZSh2YXJpYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXRPckNyZWF0ZShpbXBvcnRzQnlEZXBlbmRlbmN5LCBkZXBlbmRlbmN5LCBnZXROZXdBcnJheSkucHVzaCh7XG4gICAgICAgICAgICAgICAgaW1wb3J0ZWQsXG4gICAgICAgICAgICAgICAgbG9jYWw6IHZhcmlhYmxlLmdldE5hbWUodGhpcy5zbmlwcGV0cy5nZXRQcm9wZXJ0eUFjY2VzcylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbXBvcnRzQnlEZXBlbmRlbmN5O1xuICAgIH1cbiAgICBnZXRJbmNsdWRlZER5bmFtaWNJbXBvcnRzKCkge1xuICAgICAgICBpZiAodGhpcy5pbmNsdWRlZER5bmFtaWNJbXBvcnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmNsdWRlZER5bmFtaWNJbXBvcnRzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluY2x1ZGVkRHluYW1pY0ltcG9ydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgdGhpcy5vcmRlcmVkTW9kdWxlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IG5vZGUsIHJlc29sdXRpb24gfSBvZiBtb2R1bGUuZHluYW1pY0ltcG9ydHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluY2x1ZGVkRHluYW1pY0ltcG9ydHMucHVzaChyZXNvbHV0aW9uIGluc3RhbmNlb2YgTW9kdWxlXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bms6IHRoaXMuY2h1bmtCeU1vZHVsZS5nZXQocmVzb2x1dGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlcm5hbENodW5rOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjYWRlQ2h1bms6IHRoaXMuZmFjYWRlQ2h1bmtCeU1vZHVsZS5nZXQocmVzb2x1dGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x1dGlvblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogcmVzb2x1dGlvbiBpbnN0YW5jZW9mIEV4dGVybmFsTW9kdWxlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuazogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlcm5hbENodW5rOiB0aGlzLmV4dGVybmFsQ2h1bmtCeU1vZHVsZS5nZXQocmVzb2x1dGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjYWRlQ2h1bms6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHsgY2h1bms6IG51bGwsIGV4dGVybmFsQ2h1bms6IG51bGwsIGZhY2FkZUNodW5rOiBudWxsLCBub2RlLCByZXNvbHV0aW9uIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5pbmNsdWRlZER5bmFtaWNJbXBvcnRzID0gaW5jbHVkZWREeW5hbWljSW1wb3J0cyk7XG4gICAgfVxuICAgIGdldFByZVJlbmRlcmVkQ2h1bmtJbmZvKCkge1xuICAgICAgICBpZiAodGhpcy5wcmVSZW5kZXJlZENodW5rSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlUmVuZGVyZWRDaHVua0luZm87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBkeW5hbWljRW50cnlNb2R1bGVzLCBmYWNhZGVNb2R1bGUsIGltcGxpY2l0RW50cnlNb2R1bGVzLCBvcmRlcmVkTW9kdWxlcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuICh0aGlzLnByZVJlbmRlcmVkQ2h1bmtJbmZvID0ge1xuICAgICAgICAgICAgZXhwb3J0czogdGhpcy5nZXRFeHBvcnROYW1lcygpLFxuICAgICAgICAgICAgZmFjYWRlTW9kdWxlSWQ6IGZhY2FkZU1vZHVsZSAmJiBmYWNhZGVNb2R1bGUuaWQsXG4gICAgICAgICAgICBpc0R5bmFtaWNFbnRyeTogZHluYW1pY0VudHJ5TW9kdWxlcy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgaXNFbnRyeTogISFmYWNhZGVNb2R1bGU/LmluZm8uaXNFbnRyeSxcbiAgICAgICAgICAgIGlzSW1wbGljaXRFbnRyeTogaW1wbGljaXRFbnRyeU1vZHVsZXMubGVuZ3RoID4gMCxcbiAgICAgICAgICAgIG1vZHVsZUlkczogb3JkZXJlZE1vZHVsZXMubWFwKCh7IGlkIH0pID0+IGlkKSxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuZ2V0Q2h1bmtOYW1lKCksXG4gICAgICAgICAgICB0eXBlOiAnY2h1bmsnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRQcmVzZXJ2ZU1vZHVsZXNDaHVua05hbWVGcm9tTW9kdWxlKG1vZHVsZSkge1xuICAgICAgICBjb25zdCBwcmVkZWZpbmVkQ2h1bmtOYW1lID0gZ2V0UHJlZGVmaW5lZENodW5rTmFtZUZyb21Nb2R1bGUobW9kdWxlKTtcbiAgICAgICAgaWYgKHByZWRlZmluZWRDaHVua05hbWUpXG4gICAgICAgICAgICByZXR1cm4gcHJlZGVmaW5lZENodW5rTmFtZTtcbiAgICAgICAgY29uc3QgeyBwcmVzZXJ2ZU1vZHVsZXNSb290LCBzYW5pdGl6ZUZpbGVOYW1lIH0gPSB0aGlzLm91dHB1dE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHNhbml0aXplZElkID0gc2FuaXRpemVGaWxlTmFtZShub3JtYWxpemUobW9kdWxlLmlkLnNwbGl0KFFVRVJZX0hBU0hfUkVHRVgsIDEpWzBdKSk7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbk5hbWUgPSBleHRuYW1lKHNhbml0aXplZElkKTtcbiAgICAgICAgY29uc3QgaWRXaXRob3V0RXh0ZW5zaW9uID0gTk9OX0FTU0VUX0VYVEVOU0lPTlMuaGFzKGV4dGVuc2lvbk5hbWUpXG4gICAgICAgICAgICA/IHNhbml0aXplZElkLnNsaWNlKDAsIC1leHRlbnNpb25OYW1lLmxlbmd0aClcbiAgICAgICAgICAgIDogc2FuaXRpemVkSWQ7XG4gICAgICAgIGlmIChpc0Fic29sdXRlJDEoaWRXaXRob3V0RXh0ZW5zaW9uKSkge1xuICAgICAgICAgICAgaWYgKHByZXNlcnZlTW9kdWxlc1Jvb3QgJiYgcmVzb2x2ZSQxKGlkV2l0aG91dEV4dGVuc2lvbikuc3RhcnRzV2l0aChwcmVzZXJ2ZU1vZHVsZXNSb290KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZFdpdGhvdXRFeHRlbnNpb24uc2xpY2UocHJlc2VydmVNb2R1bGVzUm9vdC5sZW5ndGgpLnJlcGxhY2UoL15bL1xcXFxdLywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGVkZ2UgY2FzZSBpbiBXaW5kb3dzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXRCYXNlID09PSAnLycgJiYgIWlkV2l0aG91dEV4dGVuc2lvbi5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbGF0aXZlJDEodGhpcy5pbnB1dEJhc2UsIGlkV2l0aG91dEV4dGVuc2lvbi5yZXBsYWNlKC9eW2EtekEtWl06Wy9cXFxcXS8sICcvJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVsYXRpdmUkMSh0aGlzLmlucHV0QmFzZSwgaWRXaXRob3V0RXh0ZW5zaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5vdXRwdXRPcHRpb25zLnZpcnR1YWxEaXJuYW1lLnJlcGxhY2UoL1xcLyQvLCAnJykgKyAnLycgKyBiYXNlbmFtZShpZFdpdGhvdXRFeHRlbnNpb24pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSZWV4cG9ydFNwZWNpZmllcnMoKSB7XG4gICAgICAgIGNvbnN0IHsgZXh0ZXJuYWxMaXZlQmluZGluZ3MsIGludGVyb3AgfSA9IHRoaXMub3V0cHV0T3B0aW9ucztcbiAgICAgICAgY29uc3QgcmVleHBvcnRTcGVjaWZpZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBleHBvcnROYW1lIG9mIHRoaXMuZ2V0RXhwb3J0TmFtZXMoKSkge1xuICAgICAgICAgICAgbGV0IGRlcGVuZGVuY3k7XG4gICAgICAgICAgICBsZXQgaW1wb3J0ZWQ7XG4gICAgICAgICAgICBsZXQgbmVlZHNMaXZlQmluZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGV4cG9ydE5hbWVbMF0gPT09ICcqJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gZXhwb3J0TmFtZS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJvcChpZCkgPT09ICdkZWZhdWx0T25seScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dE9wdGlvbnMub25Mb2coTE9HTEVWRUxfV0FSTiwgbG9nVW5leHBlY3RlZE5hbWVzcGFjZVJlZXhwb3J0KGlkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5lZWRzTGl2ZUJpbmRpbmcgPSBleHRlcm5hbExpdmVCaW5kaW5ncztcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5leHRlcm5hbENodW5rQnlNb2R1bGUuZ2V0KHRoaXMubW9kdWxlc0J5SWQuZ2V0KGlkKSk7XG4gICAgICAgICAgICAgICAgaW1wb3J0ZWQgPSBleHBvcnROYW1lID0gJyonO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFyaWFibGUgPSB0aGlzLmV4cG9ydHNCeU5hbWUuZ2V0KGV4cG9ydE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZSBpbnN0YW5jZW9mIFN5bnRoZXRpY05hbWVkRXhwb3J0VmFyaWFibGUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IHZhcmlhYmxlLm1vZHVsZTtcbiAgICAgICAgICAgICAgICBpZiAobW9kdWxlIGluc3RhbmNlb2YgTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmNodW5rQnlNb2R1bGUuZ2V0KG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXBlbmRlbmN5ID09PSB0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGVkID0gZGVwZW5kZW5jeS5nZXRWYXJpYWJsZUV4cG9ydE5hbWUodmFyaWFibGUpO1xuICAgICAgICAgICAgICAgICAgICBuZWVkc0xpdmVCaW5kaW5nID0gdmFyaWFibGUuaXNSZWFzc2lnbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuZXh0ZXJuYWxDaHVua0J5TW9kdWxlLmdldChtb2R1bGUpO1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRlZCA9IHZhcmlhYmxlLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbXBvcnRlZCAhPT0gJ2RlZmF1bHQnICYmIGltcG9ydGVkICE9PSAnKicgJiYgaW50ZXJvcChtb2R1bGUuaWQpID09PSAnZGVmYXVsdE9ubHknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IobG9nVW5leHBlY3RlZE5hbWVkSW1wb3J0KG1vZHVsZS5pZCwgaW1wb3J0ZWQsIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZWVkc0xpdmVCaW5kaW5nID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVybmFsTGl2ZUJpbmRpbmdzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGltcG9ydGVkICE9PSAnZGVmYXVsdCcgfHwgaXNEZWZhdWx0QVByb3BlcnR5KGludGVyb3AobW9kdWxlLmlkKSwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldE9yQ3JlYXRlKHJlZXhwb3J0U3BlY2lmaWVycywgZGVwZW5kZW5jeSwgZ2V0TmV3QXJyYXkpLnB1c2goe1xuICAgICAgICAgICAgICAgIGltcG9ydGVkLFxuICAgICAgICAgICAgICAgIG5lZWRzTGl2ZUJpbmRpbmcsXG4gICAgICAgICAgICAgICAgcmVleHBvcnRlZDogZXhwb3J0TmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZXhwb3J0U3BlY2lmaWVycztcbiAgICB9XG4gICAgZ2V0UmVmZXJlbmNlZEZpbGVzKCkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VkRmlsZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIHRoaXMub3JkZXJlZE1vZHVsZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWV0YSBvZiBtb2R1bGUuaW1wb3J0TWV0YXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IG1ldGEuZ2V0UmVmZXJlbmNlZEZpbGVOYW1lKHRoaXMucGx1Z2luRHJpdmVyKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlZEZpbGVzLmFkZChmaWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4ucmVmZXJlbmNlZEZpbGVzXTtcbiAgICB9XG4gICAgZ2V0UmVuZGVyZWREZXBlbmRlbmNpZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVkRGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlZERlcGVuZGVuY2llcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbXBvcnRTcGVjaWZpZXJzID0gdGhpcy5nZXRJbXBvcnRTcGVjaWZpZXJzKCk7XG4gICAgICAgIGNvbnN0IHJlZXhwb3J0U3BlY2lmaWVycyA9IHRoaXMuZ2V0UmVleHBvcnRTcGVjaWZpZXJzKCk7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVkRGVwZW5kZW5jaWVzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHRoaXMuZ2V0RmlsZU5hbWUoKTtcbiAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIHRoaXMuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBpbXBvcnRzID0gaW1wb3J0U3BlY2lmaWVycy5nZXQoZGVwZW5kZW5jeSkgfHwgbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHJlZXhwb3J0cyA9IHJlZXhwb3J0U3BlY2lmaWVycy5nZXQoZGVwZW5kZW5jeSkgfHwgbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVkRXhwb3J0c01vZGUgPSBkZXBlbmRlbmN5IGluc3RhbmNlb2YgRXh0ZXJuYWxDaHVuayB8fCBkZXBlbmRlbmN5LmV4cG9ydE1vZGUgIT09ICdkZWZhdWx0JztcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydFBhdGggPSBkZXBlbmRlbmN5LmdldEltcG9ydFBhdGgoZmlsZU5hbWUpO1xuICAgICAgICAgICAgcmVuZGVyZWREZXBlbmRlbmNpZXMuc2V0KGRlcGVuZGVuY3ksIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBkZXBlbmRlbmN5IGluc3RhbmNlb2YgRXh0ZXJuYWxDaHVua1xuICAgICAgICAgICAgICAgICAgICA/IGRlcGVuZGVuY3kuZ2V0SW1wb3J0QXR0cmlidXRlcyh0aGlzLnNuaXBwZXRzKVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhcmlhYmxlTmFtZTogZGVwZW5kZW5jeS5kZWZhdWx0VmFyaWFibGVOYW1lLFxuICAgICAgICAgICAgICAgIGdsb2JhbE5hbWU6IGRlcGVuZGVuY3kgaW5zdGFuY2VvZiBFeHRlcm5hbENodW5rICYmXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLm91dHB1dE9wdGlvbnMuZm9ybWF0ID09PSAndW1kJyB8fCB0aGlzLm91dHB1dE9wdGlvbnMuZm9ybWF0ID09PSAnaWlmZScpICYmXG4gICAgICAgICAgICAgICAgICAgIGdldEdsb2JhbE5hbWUoZGVwZW5kZW5jeSwgdGhpcy5vdXRwdXRPcHRpb25zLmdsb2JhbHMsIChpbXBvcnRzIHx8IHJlZXhwb3J0cykgIT09IG51bGwsIHRoaXMuaW5wdXRPcHRpb25zLm9uTG9nKSxcbiAgICAgICAgICAgICAgICBpbXBvcnRQYXRoLFxuICAgICAgICAgICAgICAgIGltcG9ydHMsXG4gICAgICAgICAgICAgICAgaXNDaHVuazogZGVwZW5kZW5jeSBpbnN0YW5jZW9mIENodW5rLFxuICAgICAgICAgICAgICAgIG5hbWU6IGRlcGVuZGVuY3kudmFyaWFibGVOYW1lLFxuICAgICAgICAgICAgICAgIG5hbWVkRXhwb3J0c01vZGUsXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlVmFyaWFibGVOYW1lOiBkZXBlbmRlbmN5Lm5hbWVzcGFjZVZhcmlhYmxlTmFtZSxcbiAgICAgICAgICAgICAgICByZWV4cG9ydHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5yZW5kZXJlZERlcGVuZGVuY2llcyA9IHJlbmRlcmVkRGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgaW5saW5lQ2h1bmtEZXBlbmRlbmNpZXMoY2h1bmspIHtcbiAgICAgICAgZm9yIChjb25zdCBkZXAgb2YgY2h1bmsuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZXBlbmRlbmNpZXMuaGFzKGRlcCkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLmRlcGVuZGVuY2llcy5hZGQoZGVwKTtcbiAgICAgICAgICAgIGlmIChkZXAgaW5zdGFuY2VvZiBDaHVuaykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lQ2h1bmtEZXBlbmRlbmNpZXMoZGVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGlzIG1ldGhvZCBjaGFuZ2VzIHByb3BlcnRpZXMgb24gdGhlIEFTVCBiZWZvcmUgcmVuZGVyaW5nIGFuZCBtdXN0IG5vdCBiZSBhc3luY1xuICAgIHJlbmRlck1vZHVsZXMoZmlsZU5hbWUpIHtcbiAgICAgICAgY29uc3QgeyBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlLCBkZXBlbmRlbmNpZXMsIGV4cG9ydE5hbWVzQnlWYXJpYWJsZSwgaW5jbHVkZWROYW1lc3BhY2VzLCBpbnB1dE9wdGlvbnM6IHsgb25Mb2cgfSwgaXNFbXB0eSwgb3JkZXJlZE1vZHVsZXMsIG91dHB1dE9wdGlvbnMsIHBsdWdpbkRyaXZlciwgcmVuZGVyZWRNb2R1bGVzLCBzbmlwcGV0cyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBjb21wYWN0LCBmb3JtYXQsIGZyZWV6ZSwgZ2VuZXJhdGVkQ29kZTogeyBzeW1ib2xzIH0gfSA9IG91dHB1dE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgXywgY25zdCwgbiB9ID0gc25pcHBldHM7XG4gICAgICAgIHRoaXMuc2V0RHluYW1pY0ltcG9ydFJlc29sdXRpb25zKGZpbGVOYW1lKTtcbiAgICAgICAgdGhpcy5zZXRJbXBvcnRNZXRhUmVzb2x1dGlvbnMoZmlsZU5hbWUpO1xuICAgICAgICB0aGlzLnNldElkZW50aWZpZXJSZW5kZXJSZXNvbHV0aW9ucygpO1xuICAgICAgICBjb25zdCBtYWdpY1N0cmluZyA9IG5ldyBCdW5kbGUkMSh7IHNlcGFyYXRvcjogYCR7bn0ke259YCB9KTtcbiAgICAgICAgY29uc3QgaW5kZW50ID0gZ2V0SW5kZW50U3RyaW5nKG9yZGVyZWRNb2R1bGVzLCBvdXRwdXRPcHRpb25zKTtcbiAgICAgICAgY29uc3QgdXNlZE1vZHVsZXMgPSBbXTtcbiAgICAgICAgbGV0IGhvaXN0ZWRTb3VyY2UgPSAnJztcbiAgICAgICAgY29uc3QgYWNjZXNzZWRHbG9iYWxzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCByZW5kZXJlZE1vZHVsZVNvdXJjZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhY2Nlc3NlZERvY3VtZW50Q3VycmVudFNjcmlwdDogZmFsc2UsXG4gICAgICAgICAgICBleHBvcnROYW1lc0J5VmFyaWFibGUsXG4gICAgICAgICAgICBmb3JtYXQsXG4gICAgICAgICAgICBmcmVlemUsXG4gICAgICAgICAgICBpbmRlbnQsXG4gICAgICAgICAgICBwbHVnaW5Ecml2ZXIsXG4gICAgICAgICAgICBzbmlwcGV0cyxcbiAgICAgICAgICAgIHN5bWJvbHMsXG4gICAgICAgICAgICB1c2VPcmlnaW5hbE5hbWU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHVzZXNUb3BMZXZlbEF3YWl0ID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG9yZGVyZWRNb2R1bGVzKSB7XG4gICAgICAgICAgICBsZXQgcmVuZGVyZWRMZW5ndGggPSAwO1xuICAgICAgICAgICAgbGV0IHNvdXJjZTtcbiAgICAgICAgICAgIGlmIChtb2R1bGUuaXNJbmNsdWRlZCgpIHx8IGluY2x1ZGVkTmFtZXNwYWNlcy5oYXMobW9kdWxlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVkID0gbW9kdWxlLnJlbmRlcihyZW5kZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlbmRlck9wdGlvbnMuYWNjZXNzZWREb2N1bWVudEN1cnJlbnRTY3JpcHQgJiZcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0c01heWJlQWNjZXNzRG9jdW1lbnRDdXJyZW50U2NyaXB0LmluY2x1ZGVzKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY2Nlc3NlZEdsb2JhbHNCeVNjb3BlLmdldChtb2R1bGUuc2NvcGUpPy5kZWxldGUoRE9DVU1FTlRfQ1VSUkVOVF9TQ1JJUFQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW5kZXJPcHRpb25zLmFjY2Vzc2VkRG9jdW1lbnRDdXJyZW50U2NyaXB0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgKHsgc291cmNlIH0gPSByZW5kZXJlZCk7XG4gICAgICAgICAgICAgICAgdXNlc1RvcExldmVsQXdhaXQgfHw9IHJlbmRlcmVkLnVzZXNUb3BMZXZlbEF3YWl0O1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkTGVuZ3RoID0gc291cmNlLmxlbmd0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJlZExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFjdCAmJiBzb3VyY2UubGFzdExpbmUoKS5pbmNsdWRlcygnLy8nKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5hcHBlbmQoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZE1vZHVsZVNvdXJjZXMuc2V0KG1vZHVsZSwgc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgbWFnaWNTdHJpbmcuYWRkU291cmNlKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIHVzZWRNb2R1bGVzLnB1c2gobW9kdWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZXNwYWNlID0gbW9kdWxlLm5hbWVzcGFjZTtcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZWROYW1lc3BhY2VzLmhhcyhtb2R1bGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVkID0gbmFtZXNwYWNlLnJlbmRlckJsb2NrKHJlbmRlck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZXNwYWNlLnJlbmRlckZpcnN0KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGVkU291cmNlICs9IG4gKyByZW5kZXJlZDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFnaWNTdHJpbmcuYWRkU291cmNlKG5ldyBNYWdpY1N0cmluZyhyZW5kZXJlZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhY2Nlc3NlZEdsb2JhbFZhcmlhYmxlcyA9IGFjY2Vzc2VkR2xvYmFsc0J5U2NvcGUuZ2V0KG1vZHVsZS5zY29wZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFjY2Vzc2VkR2xvYmFsVmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBhY2Nlc3NlZEdsb2JhbFZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzZWRHbG9iYWxzLmFkZChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcmVuZGVyZWRFeHBvcnRzLCByZW1vdmVkRXhwb3J0cyB9ID0gbW9kdWxlLmdldFJlbmRlcmVkRXhwb3J0cygpO1xuICAgICAgICAgICAgcmVuZGVyZWRNb2R1bGVzW21vZHVsZS5pZF0gPSB7XG4gICAgICAgICAgICAgICAgZ2V0IGNvZGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2U/LnRvU3RyaW5nKCkgPz8gbnVsbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsTGVuZ3RoOiBtb2R1bGUub3JpZ2luYWxDb2RlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICByZW1vdmVkRXhwb3J0cyxcbiAgICAgICAgICAgICAgICByZW5kZXJlZEV4cG9ydHMsXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRMZW5ndGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvaXN0ZWRTb3VyY2UpXG4gICAgICAgICAgICBtYWdpY1N0cmluZy5wcmVwZW5kKGhvaXN0ZWRTb3VyY2UgKyBuICsgbik7XG4gICAgICAgIGlmICh0aGlzLm5lZWRzRXhwb3J0c1NoaW0pIHtcbiAgICAgICAgICAgIG1hZ2ljU3RyaW5nLnByZXBlbmQoYCR7bn0ke2Nuc3R9ICR7TUlTU0lOR19FWFBPUlRfU0hJTV9WQVJJQUJMRX0ke199PSR7X312b2lkIDA7JHtufSR7bn1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW5kZXJlZFNvdXJjZSA9IGNvbXBhY3QgPyBtYWdpY1N0cmluZyA6IG1hZ2ljU3RyaW5nLnRyaW0oKTtcbiAgICAgICAgaWYgKGlzRW1wdHkgJiYgdGhpcy5nZXRFeHBvcnROYW1lcygpLmxlbmd0aCA9PT0gMCAmJiBkZXBlbmRlbmNpZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgb25Mb2coTE9HTEVWRUxfV0FSTiwgbG9nRW1wdHlDaHVuayh0aGlzLmdldENodW5rTmFtZSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgYWNjZXNzZWRHbG9iYWxzLCBpbmRlbnQsIG1hZ2ljU3RyaW5nLCByZW5kZXJlZFNvdXJjZSwgdXNlZE1vZHVsZXMsIHVzZXNUb3BMZXZlbEF3YWl0IH07XG4gICAgfVxuICAgIHNldER5bmFtaWNJbXBvcnRSZXNvbHV0aW9ucyhmaWxlTmFtZSkge1xuICAgICAgICBjb25zdCB7IGFjY2Vzc2VkR2xvYmFsc0J5U2NvcGUsIG91dHB1dE9wdGlvbnMsIHBsdWdpbkRyaXZlciwgc25pcHBldHMgfSA9IHRoaXM7XG4gICAgICAgIGZvciAoY29uc3QgcmVzb2x2ZWREeW5hbWljSW1wb3J0IG9mIHRoaXMuZ2V0SW5jbHVkZWREeW5hbWljSW1wb3J0cygpKSB7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWREeW5hbWljSW1wb3J0LmNodW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjaHVuaywgZmFjYWRlQ2h1bmssIG5vZGUsIHJlc29sdXRpb24gfSA9IHJlc29sdmVkRHluYW1pY0ltcG9ydDtcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmsgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRJbnRlcm5hbFJlc29sdXRpb24ocmVzb2x1dGlvbi5uYW1lc3BhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRFeHRlcm5hbFJlc29sdXRpb24oKGZhY2FkZUNodW5rIHx8IGNodW5rKS5leHBvcnRNb2RlLCByZXNvbHV0aW9uLCBvdXRwdXRPcHRpb25zLCBzbmlwcGV0cywgcGx1Z2luRHJpdmVyLCBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlLCBgJyR7KGZhY2FkZUNodW5rIHx8IGNodW5rKS5nZXRJbXBvcnRQYXRoKGZpbGVOYW1lKX0nYCwgIWZhY2FkZUNodW5rPy5zdHJpY3RGYWNhZGUgJiYgY2h1bmsuZXhwb3J0TmFtZXNCeVZhcmlhYmxlLmdldChyZXNvbHV0aW9uLm5hbWVzcGFjZSlbMF0sIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZSwgcmVzb2x1dGlvbiB9ID0gcmVzb2x2ZWREeW5hbWljSW1wb3J0O1xuICAgICAgICAgICAgICAgIGNvbnN0IFtyZXNvbHV0aW9uU3RyaW5nLCBhdHRyaWJ1dGVzXSA9IHRoaXMuZ2V0RHluYW1pY0ltcG9ydFN0cmluZ0FuZEF0dHJpYnV0ZXMocmVzb2x1dGlvbiwgZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0RXh0ZXJuYWxSZXNvbHV0aW9uKCdleHRlcm5hbCcsIHJlc29sdXRpb24sIG91dHB1dE9wdGlvbnMsIHNuaXBwZXRzLCBwbHVnaW5Ecml2ZXIsIGFjY2Vzc2VkR2xvYmFsc0J5U2NvcGUsIHJlc29sdXRpb25TdHJpbmcsIGZhbHNlLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRJZGVudGlmaWVyUmVuZGVyUmVzb2x1dGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHsgZm9ybWF0LCBnZW5lcmF0ZWRDb2RlOiB7IHN5bWJvbHMgfSwgaW50ZXJvcCwgcHJlc2VydmVNb2R1bGVzLCBleHRlcm5hbExpdmVCaW5kaW5ncyB9ID0gdGhpcy5vdXRwdXRPcHRpb25zO1xuICAgICAgICBjb25zdCBzeW50aGV0aWNFeHBvcnRzID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGV4cG9ydE5hbWUgb2YgdGhpcy5nZXRFeHBvcnROYW1lcygpKSB7XG4gICAgICAgICAgICBjb25zdCBleHBvcnRWYXJpYWJsZSA9IHRoaXMuZXhwb3J0c0J5TmFtZS5nZXQoZXhwb3J0TmFtZSk7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ICE9PSAnZXMnICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ICE9PSAnc3lzdGVtJyAmJlxuICAgICAgICAgICAgICAgIGV4cG9ydFZhcmlhYmxlLmlzUmVhc3NpZ25lZCAmJlxuICAgICAgICAgICAgICAgICFleHBvcnRWYXJpYWJsZS5pc0lkKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0VmFyaWFibGUuc2V0UmVuZGVyTmFtZXMoJ2V4cG9ydHMnLCBleHBvcnROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV4cG9ydFZhcmlhYmxlIGluc3RhbmNlb2YgU3ludGhldGljTmFtZWRFeHBvcnRWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgIHN5bnRoZXRpY0V4cG9ydHMuYWRkKGV4cG9ydFZhcmlhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4cG9ydFZhcmlhYmxlLnNldFJlbmRlck5hbWVzKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIHRoaXMub3JkZXJlZE1vZHVsZXMpIHtcbiAgICAgICAgICAgIGlmIChtb2R1bGUubmVlZHNFeHBvcnRTaGltKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZWVkc0V4cG9ydHNTaGltID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VkTmFtZXMgPSBuZXcgU2V0KFsnT2JqZWN0JywgJ1Byb21pc2UnXSk7XG4gICAgICAgIGlmICh0aGlzLm5lZWRzRXhwb3J0c1NoaW0pIHtcbiAgICAgICAgICAgIHVzZWROYW1lcy5hZGQoTUlTU0lOR19FWFBPUlRfU0hJTV9WQVJJQUJMRSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN5bWJvbHMpIHtcbiAgICAgICAgICAgIHVzZWROYW1lcy5hZGQoJ1N5bWJvbCcpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlICdzeXN0ZW0nOiB7XG4gICAgICAgICAgICAgICAgdXNlZE5hbWVzLmFkZCgnbW9kdWxlJykuYWRkKCdleHBvcnRzJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdlcyc6IHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2Nqcyc6IHtcbiAgICAgICAgICAgICAgICB1c2VkTmFtZXMuYWRkKCdtb2R1bGUnKS5hZGQoJ3JlcXVpcmUnKS5hZGQoJ19fZmlsZW5hbWUnKS5hZGQoJ19fZGlybmFtZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB1c2VkTmFtZXMuYWRkKCdleHBvcnRzJyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBoZWxwZXIgb2YgSEVMUEVSX05BTUVTKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZWROYW1lcy5hZGQoaGVscGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVjb25mbGljdENodW5rKHRoaXMub3JkZXJlZE1vZHVsZXMsIHRoaXMuZ2V0RGVwZW5kZW5jaWVzVG9CZURlY29uZmxpY3RlZChmb3JtYXQgIT09ICdlcycgJiYgZm9ybWF0ICE9PSAnc3lzdGVtJywgZm9ybWF0ID09PSAnYW1kJyB8fCBmb3JtYXQgPT09ICd1bWQnIHx8IGZvcm1hdCA9PT0gJ2lpZmUnLCBpbnRlcm9wKSwgdGhpcy5pbXBvcnRzLCB1c2VkTmFtZXMsIGZvcm1hdCwgaW50ZXJvcCwgcHJlc2VydmVNb2R1bGVzLCBleHRlcm5hbExpdmVCaW5kaW5ncywgdGhpcy5jaHVua0J5TW9kdWxlLCB0aGlzLmV4dGVybmFsQ2h1bmtCeU1vZHVsZSwgc3ludGhldGljRXhwb3J0cywgdGhpcy5leHBvcnROYW1lc0J5VmFyaWFibGUsIHRoaXMuYWNjZXNzZWRHbG9iYWxzQnlTY29wZSwgdGhpcy5pbmNsdWRlZE5hbWVzcGFjZXMpO1xuICAgIH1cbiAgICBzZXRJbXBvcnRNZXRhUmVzb2x1dGlvbnMoZmlsZU5hbWUpIHtcbiAgICAgICAgY29uc3QgeyBhY2Nlc3NlZEdsb2JhbHNCeVNjb3BlLCBpbmNsdWRlZE5hbWVzcGFjZXMsIG9yZGVyZWRNb2R1bGVzLCBvdXRwdXRPcHRpb25zOiB7IGZvcm1hdCB9IH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBvcmRlcmVkTW9kdWxlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbXBvcnRNZXRhIG9mIG1vZHVsZS5pbXBvcnRNZXRhcykge1xuICAgICAgICAgICAgICAgIGltcG9ydE1ldGEuc2V0UmVzb2x1dGlvbihmb3JtYXQsIGFjY2Vzc2VkR2xvYmFsc0J5U2NvcGUsIGZpbGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmNsdWRlZE5hbWVzcGFjZXMuaGFzKG1vZHVsZSkpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUubmFtZXNwYWNlLnByZXBhcmUoYWNjZXNzZWRHbG9iYWxzQnlTY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0VXBDaHVua0ltcG9ydHNBbmRFeHBvcnRzRm9yTW9kdWxlKG1vZHVsZSkge1xuICAgICAgICBjb25zdCBtb2R1bGVJbXBvcnRzID0gbmV3IFNldChtb2R1bGUuaW5jbHVkZWRJbXBvcnRzKTtcbiAgICAgICAgLy8gd2hlbiB3ZSBhcmUgbm90IHByZXNlcnZpbmcgbW9kdWxlcywgd2UgbmVlZCB0byBtYWtlIGFsbCBuYW1lc3BhY2UgdmFyaWFibGVzIGF2YWlsYWJsZSBmb3JcbiAgICAgICAgLy8gcmVuZGVyaW5nIHRoZSBuYW1lc3BhY2Ugb2JqZWN0XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRPcHRpb25zLnByZXNlcnZlTW9kdWxlcyAmJiB0aGlzLmluY2x1ZGVkTmFtZXNwYWNlcy5oYXMobW9kdWxlKSkge1xuICAgICAgICAgICAgY29uc3QgbWVtYmVyVmFyaWFibGVzID0gbW9kdWxlLm5hbWVzcGFjZS5nZXRNZW1iZXJWYXJpYWJsZXMoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgT2JqZWN0LnZhbHVlcyhtZW1iZXJWYXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlLmluY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUltcG9ydHMuYWRkKHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdmFyaWFibGUgb2YgbW9kdWxlSW1wb3J0cykge1xuICAgICAgICAgICAgaWYgKHZhcmlhYmxlIGluc3RhbmNlb2YgRXhwb3J0RGVmYXVsdFZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZS5nZXRPcmlnaW5hbFZhcmlhYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFyaWFibGUgaW5zdGFuY2VvZiBTeW50aGV0aWNOYW1lZEV4cG9ydFZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZS5nZXRCYXNlVmFyaWFibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5jaHVua0J5TW9kdWxlLmdldCh2YXJpYWJsZS5tb2R1bGUpO1xuICAgICAgICAgICAgaWYgKGNodW5rICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRzLmFkZCh2YXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlLm1vZHVsZSBpbnN0YW5jZW9mIE1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQ2lyY3VsYXJEZXBlbmRlbmN5SW1wb3J0KHZhcmlhYmxlLCBtb2R1bGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHByZXNlcnZpbmcgbW9kdWxlcywgd2UgZG8gbm90IGNyZWF0ZSBuYW1lc3BhY2Ugb2JqZWN0cyBidXQgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBhY3R1YWwgbmFtZXNwYWNlcywgd2hpY2ggd291bGQgYmUgYnJva2VuIGJ5IHRoaXMgbG9naWMuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHZhcmlhYmxlIGluc3RhbmNlb2YgTmFtZXNwYWNlVmFyaWFibGUgJiYgdGhpcy5vdXRwdXRPcHRpb25zLnByZXNlcnZlTW9kdWxlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLmV4cG9ydHMuYWRkKHZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlZE5hbWVzcGFjZXMuaGFzKG1vZHVsZSkgfHxcbiAgICAgICAgICAgIChtb2R1bGUuaW5mby5pc0VudHJ5ICYmIG1vZHVsZS5wcmVzZXJ2ZVNpZ25hdHVyZSAhPT0gZmFsc2UpIHx8XG4gICAgICAgICAgICBtb2R1bGUuaW5jbHVkZWREeW5hbWljSW1wb3J0ZXJzLnNvbWUoaW1wb3J0ZXIgPT4gdGhpcy5jaHVua0J5TW9kdWxlLmdldChpbXBvcnRlcikgIT09IHRoaXMpKSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZVJlZXhwb3J0c0FyZUF2YWlsYWJsZUZvck1vZHVsZShtb2R1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgeyBub2RlLCByZXNvbHV0aW9uIH0gb2YgbW9kdWxlLmR5bmFtaWNJbXBvcnRzKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5pbmNsdWRlZCAmJlxuICAgICAgICAgICAgICAgIHJlc29sdXRpb24gaW5zdGFuY2VvZiBNb2R1bGUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rQnlNb2R1bGUuZ2V0KHJlc29sdXRpb24pID09PSB0aGlzICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaW5jbHVkZWROYW1lc3BhY2VzLmhhcyhyZXNvbHV0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jbHVkZWROYW1lc3BhY2VzLmFkZChyZXNvbHV0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZVJlZXhwb3J0c0FyZUF2YWlsYWJsZUZvck1vZHVsZShyZXNvbHV0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENodW5rTmFtZUZyb21Nb2R1bGUobW9kdWxlKSB7XG4gICAgcmV0dXJuIGdldFByZWRlZmluZWRDaHVua05hbWVGcm9tTW9kdWxlKG1vZHVsZSkgPz8gZ2V0QWxpYXNOYW1lKG1vZHVsZS5pZCk7XG59XG5mdW5jdGlvbiBnZXRQcmVkZWZpbmVkQ2h1bmtOYW1lRnJvbU1vZHVsZShtb2R1bGUpIHtcbiAgICByZXR1cm4gKG1vZHVsZS5jaHVua05hbWVzLmZpbmQoKHsgaXNVc2VyRGVmaW5lZCB9KSA9PiBpc1VzZXJEZWZpbmVkKT8ubmFtZSA/PyBtb2R1bGUuY2h1bmtOYW1lc1swXT8ubmFtZSk7XG59XG5mdW5jdGlvbiBnZXRJbXBvcnRlZEJpbmRpbmdzUGVyRGVwZW5kZW5jeShyZW5kZXJlZERlcGVuZGVuY2llcywgcmVzb2x2ZUZpbGVOYW1lKSB7XG4gICAgY29uc3QgaW1wb3J0ZWRCaW5kaW5nc1BlckRlcGVuZGVuY3kgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtkZXBlbmRlbmN5LCBkZWNsYXJhdGlvbl0gb2YgcmVuZGVyZWREZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgY29uc3Qgc3BlY2lmaWVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgaWYgKGRlY2xhcmF0aW9uLmltcG9ydHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBpbXBvcnRlZCB9IG9mIGRlY2xhcmF0aW9uLmltcG9ydHMpIHtcbiAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLmFkZChpbXBvcnRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY2xhcmF0aW9uLnJlZXhwb3J0cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IGltcG9ydGVkIH0gb2YgZGVjbGFyYXRpb24ucmVleHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lmaWVycy5hZGQoaW1wb3J0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGltcG9ydGVkQmluZGluZ3NQZXJEZXBlbmRlbmN5W3Jlc29sdmVGaWxlTmFtZShkZXBlbmRlbmN5KV0gPSBbLi4uc3BlY2lmaWVyc107XG4gICAgfVxuICAgIHJldHVybiBpbXBvcnRlZEJpbmRpbmdzUGVyRGVwZW5kZW5jeTtcbn1cbmNvbnN0IFFVRVJZX0hBU0hfUkVHRVggPSAvWyM/XS87XG5jb25zdCByZXNvbHZlRmlsZU5hbWUgPSAoZGVwZW5kZW5jeSkgPT4gZGVwZW5kZW5jeS5nZXRGaWxlTmFtZSgpO1xuXG4vKipcbiAqIENvbmNhdGVuYXRlIGEgbnVtYmVyIG9mIGl0ZXJhYmxlcyB0byBhIG5ldyBpdGVyYWJsZSB3aXRob3V0IGZ1bGx5IGV2YWx1YXRpbmdcbiAqIHRoZWlyIGl0ZXJhdG9ycy4gVXNlZnVsIHdoZW4gZS5nLiB3b3JraW5nIHdpdGggbGFyZ2Ugc2V0cyBvciBsaXN0cyBhbmQgd2hlblxuICogdGhlcmUgaXMgYSBjaGFuY2UgdGhhdCB0aGUgaXRlcmF0b3JzIHdpbGwgbm90IGJlIGZ1bGx5IGV4aGF1c3RlZC5cbiAqL1xuZnVuY3Rpb24qIGNvbmNhdExhenkoaXRlcmFibGVzKSB7XG4gICAgZm9yIChjb25zdCBpdGVyYWJsZSBvZiBpdGVyYWJsZXMpIHtcbiAgICAgICAgeWllbGQqIGl0ZXJhYmxlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBdCBpdHMgY29yZSwgdGhlIGFsZ29yaXRobSBmaXJzdCBzdGFydHMgZnJvbSBlYWNoIHN0YXRpYyBvciBkeW5hbWljIGVudHJ5XG4gKiBwb2ludCBhbmQgdGhlbiBhc3NpZ25zIHRoYXQgZW50cnkgcG9pbnQgdG8gYWxsIG1vZHVsZXMgdGhhbiBjYW4gYmUgcmVhY2hlZFxuICogdmlhIHN0YXRpYyBpbXBvcnRzLiBXZSBjYWxsIHRoaXMgdGhlICpkZXBlbmRlbnQgZW50cnkgcG9pbnRzKiBvZiB0aGF0XG4gKiBtb2R1bGUuXG4gKlxuICogVGhlbiB3ZSBncm91cCBhbGwgbW9kdWxlcyB3aXRoIHRoZSBzYW1lIGRlcGVuZGVudCBlbnRyeSBwb2ludHMgaW50byBjaHVua3NcbiAqIGFzIHRob3NlIG1vZHVsZXMgd2lsbCBhbHdheXMgYmUgbG9hZGVkIHRvZ2V0aGVyLlxuICpcbiAqIE9uZSBub24tdHJpdmlhbCBvcHRpbWl6YXRpb24gd2UgY2FuIGFwcGx5IGlzIHRoYXQgZHluYW1pYyBlbnRyaWVzIGFyZVxuICogZGlmZmVyZW50IGZyb20gc3RhdGljIGVudHJpZXMgaW4gc28gZmFyIGFzIHdoZW4gYSBkeW5hbWljIGltcG9ydCBvY2N1cnMsXG4gKiBzb21lIG1vZHVsZXMgYXJlIGFscmVhZHkgaW4gbWVtb3J5LiBJZiBzb21lIG9mIHRoZXNlIG1vZHVsZXMgYXJlIGFsc29cbiAqIGRlcGVuZGVuY2llcyBvZiB0aGUgZHluYW1pYyBlbnRyeSwgdGhlbiBpdCBkb2VzIG5vdCBtYWtlIHNlbnNlIHRvIGNyZWF0ZSBhXG4gKiBzZXBhcmF0ZSBjaHVuayBmb3IgdGhlbS4gSW5zdGVhZCwgdGhlIGR5bmFtaWMgaW1wb3J0IHRhcmdldCBjYW4gbG9hZCB0aGVtXG4gKiBmcm9tIHRoZSBpbXBvcnRpbmcgY2h1bmsuXG4gKlxuICogV2l0aCByZWdhcmQgdG8gY2h1bmtpbmcsIGlmIEIgaXMgaW1wbGljaXRseSBsb2FkZWQgYWZ0ZXIgQSwgdGhlbiB0aGlzIGNhbiBiZVxuICogaGFuZGxlZCB0aGUgc2FtZSB3YXkgYXMgaWYgdGhlcmUgd2FzIGEgZHluYW1pYyBpbXBvcnQgQSA9PiBCLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBBc3N1bWUgQSAtPiBCIChBIGltcG9ydHMgQiksIEEgPT4gQyAoQSBkeW5hbWljYWxseSBpbXBvcnRzIEMpIGFuZCBDIC0+IEIuXG4gKiBUaGVuIHRoZSBpbml0aWFsIGFsZ29yaXRobSB3b3VsZCBhc3NpZ24gQSBpbnRvIHRoZSBBIGNodW5rLCBDIGludG8gdGhlIENcbiAqIGNodW5rIGFuZCBCIGludG8gdGhlIEFDIGNodW5rLCBpLmUuIHRoZSBjaHVuayB3aXRoIHRoZSBkZXBlbmRlbnQgZW50cnlcbiAqIHBvaW50cyBBIGFuZCBDLlxuICogSG93ZXZlciB3ZSBrbm93IHRoYXQgQyBjYW4gb25seSBiZSBsb2FkZWQgZnJvbSBBLCBzbyBBIGFuZCBpdHMgZGVwZW5kZW5jeSBCXG4gKiBtdXN0IGFscmVhZHkgYmUgaW4gbWVtb3J5IHdoZW4gQyBpcyBsb2FkZWQuIFNvIGl0IGlzIGVub3VnaCB0byBjcmVhdGUgb25seVxuICogdHdvIGNodW5rcyBBIGNvbnRhaW5pbmcgW0FCXSBhbmQgQyBjb250YWluaW5nIFtDXS5cbiAqXG4gKiBTbyB3ZSBkbyBub3QgYXNzaWduIHRoZSBkeW5hbWljIGVudHJ5IEMgYXMgZGVwZW5kZW50IGVudHJ5IHBvaW50IHRvIG1vZHVsZXNcbiAqIHRoYXQgYXJlIGFscmVhZHkgbG9hZGVkLlxuICpcbiAqIEluIGEgbW9yZSBjb21wbGV4IGV4YW1wbGUsIGxldCB1cyBhc3N1bWUgdGhhdCB3ZSBoYXZlIGVudHJ5IHBvaW50cyBYIGFuZCBZLlxuICogRnVydGhlciwgbGV0IHVzIGFzc3VtZVxuICogWCAtPiBBLCBYIC0+IEIsIFggLT4gQyxcbiAqIFkgLT4gQSwgWSAtPiBCLFxuICogQSA9PiBELFxuICogRCAtPiBCLCBEIC0+IENcbiAqIFNvIHdpdGhvdXQgZHluYW1pYyBpbXBvcnQgb3B0aW1pemF0aW9uLCB0aGUgZGVwZW5kZW50IGVudHJ5IHBvaW50cyBhcmVcbiAqIEE6IFhZLCBCOiBEWFksIEM6IERYLCBEOiBELCBYOiBYLCBZOiBZLCBzbyB3ZSB3b3VsZCBmb3Igbm93IGNyZWF0ZSBzaXhcbiAqIGNodW5rcy5cbiAqXG4gKiBOb3cgRCBpcyBsb2FkZWQgb25seSBhZnRlciBBIGlzIGxvYWRlZC4gQnV0IEEgaXMgbG9hZGVkIGlmIGVpdGhlciBYIGlzXG4gKiBsb2FkZWQgb3IgWSBpcyBsb2FkZWQuIFNvIHRoZSBtb2R1bGVzIHRoYXQgYXJlIGFscmVhZHkgaW4gbWVtb3J5IHdoZW4gRCBpc1xuICogbG9hZGVkIGFyZSB0aGUgaW50ZXJzZWN0aW9uIG9mIGFsbCBtb2R1bGVzIHRoYXQgWCBkZXBlbmRzIG9uIHdpdGggYWxsXG4gKiBtb2R1bGVzIHRoYXQgWSBkZXBlbmRzIG9uLCB3aGljaCBpbiB0aGlzIGNhc2UgYXJlIHRoZSBtb2R1bGVzIEEgYW5kIEIuXG4gKiBXZSBjb3VsZCBhbHNvIHNheSB0aGV5IGFyZSBhbGwgbW9kdWxlcyB0aGF0IGhhdmUgYm90aCBYIGFuZCBZIGFzIGRlcGVuZGVudFxuICogZW50cnkgcG9pbnRzLlxuICpcbiAqIFNvIHdlIGNhbiByZW1vdmUgRCBhcyBkZXBlbmRlbnQgZW50cnkgcG9pbnQgZnJvbSBBIGFuZCBCLCB3aGljaCBtZWFucyB0aGV5XG4gKiBib3RoIG5vdyBoYXZlIG9ubHkgWFkgYXMgZGVwZW5kZW50IGVudHJ5IHBvaW50cyBhbmQgY2FuIGJlIG1lcmdlZCBpbnRvIHRoZVxuICogc2FtZSBjaHVuay5cbiAqXG4gKiBOb3cgbGV0IHVzIGV4dGVuZCB0aGlzIHRvIHRoZSBtb3N0IGdlbmVyYWwgY2FzZSB3aGVyZSB3ZSBoYXZlIHNldmVyYWxcbiAqIGR5bmFtaWMgaW1wb3J0ZXJzIGZvciBvbmUgZHluYW1pYyBlbnRyeSBwb2ludC5cbiAqXG4gKiBJbiB0aGUgbW9zdCBnZW5lcmFsIGZvcm0sIGl0IHdvcmtzIGxpa2UgdGhpczpcbiAqIEZvciBlYWNoIGR5bmFtaWMgZW50cnkgcG9pbnQsIHdlIGhhdmUgYSBudW1iZXIgb2YgZHluYW1pYyBpbXBvcnRlcnMsIHdoaWNoXG4gKiBhcmUgdGhlIG1vZHVsZXMgaW1wb3J0aW5nIGl0LiBVc2luZyB0aGUgcHJldmlvdXMgaWRlYXMsIHdlIGNhbiBkZXRlcm1pbmVcbiAqIHRoZSBtb2R1bGVzIGFscmVhZHkgaW4gbWVtb3J5IGZvciBlYWNoIGR5bmFtaWMgaW1wb3J0ZXIgYnkgbG9va2luZyBmb3IgYWxsXG4gKiBtb2R1bGVzIHRoYXQgaGF2ZSBhbGwgdGhlIGRlcGVuZGVudCBlbnRyeSBwb2ludHMgb2YgdGhlIGR5bmFtaWMgaW1wb3J0ZXIgYXNcbiAqIGRlcGVuZGVudCBlbnRyeSBwb2ludHMuXG4gKiBTbyB0aGUgbW9kdWxlcyB0aGF0IGFyZSBndWFyYW50ZWVkIHRvIGJlIGluIG1lbW9yeSB3aGVuIHRoZSBkeW5hbWljIGVudHJ5XG4gKiBwb2ludCBpcyBsb2FkZWQgYXJlIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIG1vZHVsZXMgYWxyZWFkeSBpbiBtZW1vcnkgZm9yXG4gKiBlYWNoIGR5bmFtaWMgaW1wb3J0ZXIuXG4gKlxuICogQXNzdW1pbmcgdGhhdCBBID0+IEQgYW5kIEIgPT4gRCBhbmQgQSBoYXMgZGVwZW5kZW50IGVudHJ5IHBvaW50cyBYWSBhbmQgQlxuICogaGFzIGRlcGVuZGVudCBlbnRyeSBwb2ludHMgWVosIHRoZW4gdGhlIG1vZHVsZXMgZ3VhcmFudGVlZCB0byBiZSBpbiBtZW1vcnlcbiAqIGFyZSBhbGwgbW9kdWxlcyB0aGF0IGhhdmUgYXQgbGVhc3QgWFlaIGFzIGRlcGVuZGVudCBlbnRyeSBwb2ludHMuXG4gKiBXZSBjYWxsIFhZWiB0aGUgKmR5bmFtaWNhbGx5IGRlcGVuZGVudCBlbnRyeSBwb2ludHMqIG9mIEQuXG4gKlxuICogTm93IHRoZXJlIGlzIG9uZSBsYXN0IGNhc2UgdG8gY29uc2lkZXI6IElmIG9uZSBvZiB0aGUgZHluYW1pY2FsbHkgZGVwZW5kZW50XG4gKiBlbnRyaWVzIGlzIGl0c2VsZiBhIGR5bmFtaWMgZW50cnksIHRoZW4gYW55IG1vZHVsZSBpcyBpbiBtZW1vcnkgdGhhdCBlaXRoZXJcbiAqIGlzIGEgZGVwZW5kZW5jeSBvZiB0aGF0IGR5bmFtaWMgZW50cnkgb3IgYWdhaW4gaGFzIHRoZSBkeW5hbWljIGRlcGVuZGVudFxuICogZW50cmllcyBvZiB0aGF0IGR5bmFtaWMgZW50cnkgYXMgZGVwZW5kZW50IGVudHJ5IHBvaW50cy5cbiAqXG4gKiBBIG5haXZlIGFsZ29yaXRobSBmb3IgdGhpcyBwcm92ZWQgdG8gYmUgY29zdGx5IGFzIGl0IGNvbnRhaW5lZCBhbiBPKG5eMylcbiAqIGNvbXBsZXhpdHkgd2l0aCByZWdhcmQgdG8gZHluYW1pYyBlbnRyaWVzIHRoYXQgYmxldyB1cCBmb3IgdmVyeSBsYXJnZVxuICogcHJvamVjdHMuXG4gKlxuICogSWYgd2UgaGF2ZSBhbiBlZmZpY2llbnQgd2F5IHRvIGRvIFNldCBvcGVyYXRpb25zLCBhbiBhbHRlcm5hdGl2ZSBhcHByb2FjaFxuICogd291bGQgYmUgdG8gaW5zdGVhZCBjb2xsZWN0IGFscmVhZHkgbG9hZGVkIG1vZHVsZXMgcGVyIGR5bmFtaWMgZW50cnkuIEFuZCBhc1xuICogYWxsIGNodW5rcyBmcm9tIHRoZSBpbml0aWFsIGdyb3VwaW5nIHdvdWxkIGJlaGF2ZSB0aGUgc2FtZSwgd2UgY2FuIGluc3RlYWRcbiAqIGNvbGxlY3QgYWxyZWFkeSBsb2FkZWQgY2h1bmtzIGZvciBhIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50LlxuICpcbiAqIFRvIGRvIHRoYXQgZWZmaWNpZW50bHksIG5lZWRcbiAqIC0gYSBNYXAgb2YgZHluYW1pYyBpbXBvcnRzIHBlciBkeW5hbWljIGVudHJ5LCB3aGljaCBjb250YWlucyBhbGwgZHluYW1pY1xuICogICBpbXBvcnRzIHRoYXQgY2FuIGJlIHRyaWdnZXJlZCBieSBhIGR5bmFtaWMgZW50cnlcbiAqIC0gYSBNYXAgb2Ygc3RhdGljIGRlcGVuZGVuY2llcyBwZXIgZW50cnlcbiAqIC0gYSBNYXAgb2YgYWxyZWFkeSBsb2FkZWQgY2h1bmtzIHBlciBlbnRyeSB0aGF0IHdlIGluaXRpYWxseSBwb3B1bGF0ZSB3aXRoXG4gKiAgIGVtcHR5IFNldHMgZm9yIHN0YXRpYyBlbnRyaWVzIGFuZCBTZXRzIGNvbnRhaW5pbmcgYWxsIGVudHJpZXMgZm9yIGR5bmFtaWNcbiAqICAgZW50cmllc1xuICpcbiAqIEZvciBlZmZpY2llbnQgb3BlcmF0aW9ucywgd2UgYXNzaWduIGVhY2ggZW50cnkgYSBudW1lcmljYWwgaW5kZXggYW5kXG4gKiByZXByZXNlbnQgU2V0cyBvZiBDaHVua3MgYXMgQmlnSW50IHZhbHVlcyB3aGVyZSBlYWNoIGNodW5rIGNvcnJlc3BvbmRzIHRvIGFcbiAqIGJpdCBpbmRleC4gVGhlbiB0aGUgbGFzdCB0d28gbWFwcyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYXJyYXlzIG9mIEJpZ0ludFxuICogdmFsdWVzLlxuICpcbiAqIFRoZW4gd2UgaXRlcmF0ZSB0aHJvdWdoIGVhY2ggZHluYW1pYyBlbnRyeS4gV2Ugc2V0IHRoZSBhbHJlYWR5IGxvYWRlZCBtb2R1bGVzXG4gKiB0byB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSBwcmV2aW91c2x5IGFscmVhZHkgbG9hZGVkIG1vZHVsZXMgd2l0aCB0aGUgdW5pb25cbiAqIG9mIHRoZSBhbHJlYWR5IGxvYWRlZCBtb2R1bGVzIG9mIHRoYXQgY2h1bmsgd2l0aCBpdHMgc3RhdGljIGRlcGVuZGVuY2llcy5cbiAqXG4gKiBJZiB0aGUgYWxyZWFkeSBsb2FkZWQgbW9kdWxlcyBjaGFuZ2VkLCB0aGVuIHdlIHVzZSB0aGUgTWFwIG9mIGR5bmFtaWMgaW1wb3J0c1xuICogcGVyIGR5bmFtaWMgZW50cnkgdG8gbWFya3MgYWxsIGR5bmFtaWMgZW50cnkgZGVwZW5kZW5jaWVzIGFzIFwiZGlydHlcIiBhbmQgcHV0XG4gKiB0aGVtIGJhY2sgaW50byB0aGUgaXRlcmF0aW9uLiBBcyBhbiBhZGRpdGlvbmFsIG9wdGltaXphdGlvbiwgd2Ugbm90ZSBmb3JcbiAqIGVhY2ggZHluYW1pYyBlbnRyeSB3aGljaCBkeW5hbWljIGRlcGVuZGVudCBlbnRyaWVzIGhhdmUgY2hhbmdlZCBhbmQgb25seVxuICogaW50ZXJzZWN0IHRob3NlIGVudHJpZXMgYWdhaW4gb24gc3Vic2VxdWVudCBpbnRlcmF0aW9ucy5cbiAqXG4gKiBUaGVuIHdlIHJlbW92ZSB0aGUgZHluYW1pYyBlbnRyaWVzIGZyb20gdGhlIGxpc3Qgb2YgZGVwZW5kZW50IGVudHJpZXMgZm9yXG4gKiB0aG9zZSBjaHVua3MgdGhhdCBhcmUgYWxyZWFkeSBsb2FkZWQgZm9yIHRoYXQgZHluYW1pYyBlbnRyeSBhbmQgY3JlYXRlXG4gKiBhbm90aGVyIHJvdW5kIG9mIGNodW5rcy5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2h1bmtBc3NpZ25tZW50cyhlbnRyaWVzLCBtYW51YWxDaHVua0FsaWFzQnlFbnRyeSwgbWluQ2h1bmtTaXplLCBsb2cpIHtcbiAgICBjb25zdCB7IGNodW5rRGVmaW5pdGlvbnMsIG1vZHVsZXNJbk1hbnVhbENodW5rcyB9ID0gZ2V0Q2h1bmtEZWZpbml0aW9uc0Zyb21NYW51YWxDaHVua3MobWFudWFsQ2h1bmtBbGlhc0J5RW50cnkpO1xuICAgIGNvbnN0IHsgYWxsRW50cmllcywgZGVwZW5kZW50RW50cmllc0J5TW9kdWxlLCBkeW5hbWljYWxseURlcGVuZGVudEVudHJpZXNCeUR5bmFtaWNFbnRyeSwgZHluYW1pY0ltcG9ydHNCeUVudHJ5IH0gPSBhbmFseXplTW9kdWxlR3JhcGgoZW50cmllcyk7XG4gICAgLy8gRWFjaCBjaHVuayBpcyBpZGVudGlmaWVkIGJ5IGl0cyBwb3NpdGlvbiBpbiB0aGlzIGFycmF5XG4gICAgY29uc3QgY2h1bmtBdG9tcyA9IGdldENodW5rc1dpdGhTYW1lRGVwZW5kZW50RW50cmllcyhnZXRNb2R1bGVzV2l0aERlcGVuZGVudEVudHJpZXMoZGVwZW5kZW50RW50cmllc0J5TW9kdWxlLCBtb2R1bGVzSW5NYW51YWxDaHVua3MpKTtcbiAgICBjb25zdCBzdGF0aWNEZXBlbmRlbmN5QXRvbXNCeUVudHJ5ID0gZ2V0U3RhdGljRGVwZW5kZW5jeUF0b21zQnlFbnRyeShhbGxFbnRyaWVzLCBjaHVua0F0b21zKTtcbiAgICAvLyBXYXJuaW5nOiBUaGlzIHdpbGwgY29uc3VtZSBkeW5hbWljYWxseURlcGVuZGVudEVudHJpZXNCeUR5bmFtaWNFbnRyeS5cbiAgICAvLyBJZiB3ZSBubyBsb25nZXIgd2FudCB0aGlzLCB3ZSBzaG91bGQgbWFrZSBhIGNvcHkgaGVyZS5cbiAgICBjb25zdCBhbHJlYWR5TG9hZGVkQXRvbXNCeUVudHJ5ID0gZ2V0QWxyZWFkeUxvYWRlZEF0b21zQnlFbnRyeShzdGF0aWNEZXBlbmRlbmN5QXRvbXNCeUVudHJ5LCBkeW5hbWljYWxseURlcGVuZGVudEVudHJpZXNCeUR5bmFtaWNFbnRyeSwgZHluYW1pY0ltcG9ydHNCeUVudHJ5LCBhbGxFbnRyaWVzKTtcbiAgICAvLyBUaGlzIG11dGF0ZXMgdGhlIGRlcGVuZGVudEVudHJpZXMgaW4gY2h1bmtBdG9tc1xuICAgIHJlbW92ZVVubmVjZXNzYXJ5RGVwZW5kZW50RW50cmllcyhjaHVua0F0b21zLCBhbHJlYWR5TG9hZGVkQXRvbXNCeUVudHJ5KTtcbiAgICBjb25zdCB7IGNodW5rcywgc2lkZUVmZmVjdEF0b21zLCBzaXplQnlBdG9tIH0gPSBnZXRDaHVua3NXaXRoU2FtZURlcGVuZGVudEVudHJpZXNBbmRDb3JyZWxhdGVkQXRvbXMoY2h1bmtBdG9tcywgc3RhdGljRGVwZW5kZW5jeUF0b21zQnlFbnRyeSwgYWxyZWFkeUxvYWRlZEF0b21zQnlFbnRyeSwgbWluQ2h1bmtTaXplKTtcbiAgICBjaHVua0RlZmluaXRpb25zLnB1c2goLi4uZ2V0T3B0aW1pemVkQ2h1bmtzKGNodW5rcywgbWluQ2h1bmtTaXplLCBzaWRlRWZmZWN0QXRvbXMsIHNpemVCeUF0b20sIGxvZykubWFwKCh7IG1vZHVsZXMgfSkgPT4gKHtcbiAgICAgICAgYWxpYXM6IG51bGwsXG4gICAgICAgIG1vZHVsZXNcbiAgICB9KSkpO1xuICAgIHJldHVybiBjaHVua0RlZmluaXRpb25zO1xufVxuZnVuY3Rpb24gZ2V0Q2h1bmtEZWZpbml0aW9uc0Zyb21NYW51YWxDaHVua3MobWFudWFsQ2h1bmtBbGlhc0J5RW50cnkpIHtcbiAgICBjb25zdCBtb2R1bGVzSW5NYW51YWxDaHVua3MgPSBuZXcgU2V0KG1hbnVhbENodW5rQWxpYXNCeUVudHJ5LmtleXMoKSk7XG4gICAgY29uc3QgbWFudWFsQ2h1bmtNb2R1bGVzQnlBbGlhcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChjb25zdCBbZW50cnksIGFsaWFzXSBvZiBtYW51YWxDaHVua0FsaWFzQnlFbnRyeSkge1xuICAgICAgICBhZGRTdGF0aWNEZXBlbmRlbmNpZXNUb01hbnVhbENodW5rKGVudHJ5LCAobWFudWFsQ2h1bmtNb2R1bGVzQnlBbGlhc1thbGlhc10gfHw9IFtdKSwgbW9kdWxlc0luTWFudWFsQ2h1bmtzKTtcbiAgICB9XG4gICAgY29uc3QgbWFudWFsQ2h1bmtzID0gT2JqZWN0LmVudHJpZXMobWFudWFsQ2h1bmtNb2R1bGVzQnlBbGlhcyk7XG4gICAgY29uc3QgY2h1bmtEZWZpbml0aW9ucyA9IG5ldyBBcnJheShtYW51YWxDaHVua3MubGVuZ3RoKTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgW2FsaWFzLCBtb2R1bGVzXSBvZiBtYW51YWxDaHVua3MpIHtcbiAgICAgICAgY2h1bmtEZWZpbml0aW9uc1tpbmRleCsrXSA9IHsgYWxpYXMsIG1vZHVsZXMgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2h1bmtEZWZpbml0aW9ucywgbW9kdWxlc0luTWFudWFsQ2h1bmtzIH07XG59XG5mdW5jdGlvbiBhZGRTdGF0aWNEZXBlbmRlbmNpZXNUb01hbnVhbENodW5rKGVudHJ5LCBtYW51YWxDaHVua01vZHVsZXMsIG1vZHVsZXNJbk1hbnVhbENodW5rcykge1xuICAgIGNvbnN0IG1vZHVsZXNUb0hhbmRsZSA9IG5ldyBTZXQoW2VudHJ5XSk7XG4gICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlc1RvSGFuZGxlKSB7XG4gICAgICAgIG1vZHVsZXNJbk1hbnVhbENodW5rcy5hZGQobW9kdWxlKTtcbiAgICAgICAgbWFudWFsQ2h1bmtNb2R1bGVzLnB1c2gobW9kdWxlKTtcbiAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIG1vZHVsZS5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGlmICghKGRlcGVuZGVuY3kgaW5zdGFuY2VvZiBFeHRlcm5hbE1vZHVsZSB8fCBtb2R1bGVzSW5NYW51YWxDaHVua3MuaGFzKGRlcGVuZGVuY3kpKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZXNUb0hhbmRsZS5hZGQoZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhbmFseXplTW9kdWxlR3JhcGgoZW50cmllcykge1xuICAgIGNvbnN0IGR5bmFtaWNFbnRyeU1vZHVsZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgZGVwZW5kZW50RW50cmllc0J5TW9kdWxlID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGFsbEVudHJpZXNTZXQgPSBuZXcgU2V0KGVudHJpZXMpO1xuICAgIGNvbnN0IGR5bmFtaWNJbXBvcnRNb2R1bGVzQnlFbnRyeSA9IG5ldyBBcnJheShhbGxFbnRyaWVzU2V0LnNpemUpO1xuICAgIGxldCBlbnRyeUluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGN1cnJlbnRFbnRyeSBvZiBhbGxFbnRyaWVzU2V0KSB7XG4gICAgICAgIGNvbnN0IGR5bmFtaWNJbXBvcnRzRm9yQ3VycmVudEVudHJ5ID0gbmV3IFNldCgpO1xuICAgICAgICBkeW5hbWljSW1wb3J0TW9kdWxlc0J5RW50cnlbZW50cnlJbmRleF0gPSBkeW5hbWljSW1wb3J0c0ZvckN1cnJlbnRFbnRyeTtcbiAgICAgICAgY29uc3QgbW9kdWxlc1RvSGFuZGxlID0gbmV3IFNldChbY3VycmVudEVudHJ5XSk7XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZXNUb0hhbmRsZSkge1xuICAgICAgICAgICAgZ2V0T3JDcmVhdGUoZGVwZW5kZW50RW50cmllc0J5TW9kdWxlLCBtb2R1bGUsIChnZXROZXdTZXQpKS5hZGQoZW50cnlJbmRleCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgbW9kdWxlLmdldERlcGVuZGVuY2llc1RvQmVJbmNsdWRlZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZGVwZW5kZW5jeSBpbnN0YW5jZW9mIEV4dGVybmFsTW9kdWxlKSkge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVzVG9IYW5kbGUuYWRkKGRlcGVuZGVuY3kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgeyByZXNvbHV0aW9uIH0gb2YgbW9kdWxlLmR5bmFtaWNJbXBvcnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdXRpb24gaW5zdGFuY2VvZiBNb2R1bGUgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x1dGlvbi5pbmNsdWRlZER5bmFtaWNJbXBvcnRlcnMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICAhYWxsRW50cmllc1NldC5oYXMocmVzb2x1dGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY0VudHJ5TW9kdWxlcy5hZGQocmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGFsbEVudHJpZXNTZXQuYWRkKHJlc29sdXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljSW1wb3J0c0ZvckN1cnJlbnRFbnRyeS5hZGQocmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIG1vZHVsZS5pbXBsaWNpdGx5TG9hZGVkQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxFbnRyaWVzU2V0LmhhcyhkZXBlbmRlbmN5KSkge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljRW50cnlNb2R1bGVzLmFkZChkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgICAgICAgICAgYWxsRW50cmllc1NldC5hZGQoZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVudHJ5SW5kZXgrKztcbiAgICB9XG4gICAgY29uc3QgYWxsRW50cmllcyA9IFsuLi5hbGxFbnRyaWVzU2V0XTtcbiAgICBjb25zdCB7IGR5bmFtaWNFbnRyaWVzLCBkeW5hbWljSW1wb3J0c0J5RW50cnkgfSA9IGdldER5bmFtaWNFbnRyaWVzKGFsbEVudHJpZXMsIGR5bmFtaWNFbnRyeU1vZHVsZXMsIGR5bmFtaWNJbXBvcnRNb2R1bGVzQnlFbnRyeSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWxsRW50cmllcyxcbiAgICAgICAgZGVwZW5kZW50RW50cmllc0J5TW9kdWxlLFxuICAgICAgICBkeW5hbWljYWxseURlcGVuZGVudEVudHJpZXNCeUR5bmFtaWNFbnRyeTogZ2V0RHluYW1pY2FsbHlEZXBlbmRlbnRFbnRyaWVzQnlEeW5hbWljRW50cnkoZGVwZW5kZW50RW50cmllc0J5TW9kdWxlLCBkeW5hbWljRW50cmllcywgYWxsRW50cmllcyksXG4gICAgICAgIGR5bmFtaWNJbXBvcnRzQnlFbnRyeVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXREeW5hbWljRW50cmllcyhhbGxFbnRyaWVzLCBkeW5hbWljRW50cnlNb2R1bGVzLCBkeW5hbWljSW1wb3J0TW9kdWxlc0J5RW50cnkpIHtcbiAgICBjb25zdCBlbnRyeUluZGV4QnlNb2R1bGUgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZHluYW1pY0VudHJpZXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBbZW50cnlJbmRleCwgZW50cnldIG9mIGFsbEVudHJpZXMuZW50cmllcygpKSB7XG4gICAgICAgIGVudHJ5SW5kZXhCeU1vZHVsZS5zZXQoZW50cnksIGVudHJ5SW5kZXgpO1xuICAgICAgICBpZiAoZHluYW1pY0VudHJ5TW9kdWxlcy5oYXMoZW50cnkpKSB7XG4gICAgICAgICAgICBkeW5hbWljRW50cmllcy5hZGQoZW50cnlJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZHluYW1pY0ltcG9ydHNCeUVudHJ5ID0gbmV3IEFycmF5KGR5bmFtaWNJbXBvcnRNb2R1bGVzQnlFbnRyeS5sZW5ndGgpO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBkeW5hbWljSW1wb3J0TW9kdWxlcyBvZiBkeW5hbWljSW1wb3J0TW9kdWxlc0J5RW50cnkpIHtcbiAgICAgICAgY29uc3QgZHluYW1pY0ltcG9ydHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgZHluYW1pY0VudHJ5IG9mIGR5bmFtaWNJbXBvcnRNb2R1bGVzKSB7XG4gICAgICAgICAgICBkeW5hbWljSW1wb3J0cy5hZGQoZW50cnlJbmRleEJ5TW9kdWxlLmdldChkeW5hbWljRW50cnkpKTtcbiAgICAgICAgfVxuICAgICAgICBkeW5hbWljSW1wb3J0c0J5RW50cnlbaW5kZXgrK10gPSBkeW5hbWljSW1wb3J0cztcbiAgICB9XG4gICAgcmV0dXJuIHsgZHluYW1pY0VudHJpZXMsIGR5bmFtaWNJbXBvcnRzQnlFbnRyeSB9O1xufVxuZnVuY3Rpb24gZ2V0RHluYW1pY2FsbHlEZXBlbmRlbnRFbnRyaWVzQnlEeW5hbWljRW50cnkoZGVwZW5kZW50RW50cmllc0J5TW9kdWxlLCBkeW5hbWljRW50cmllcywgYWxsRW50cmllcykge1xuICAgIGNvbnN0IGR5bmFtaWNhbGx5RGVwZW5kZW50RW50cmllc0J5RHluYW1pY0VudHJ5ID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgZHluYW1pY0VudHJ5SW5kZXggb2YgZHluYW1pY0VudHJpZXMpIHtcbiAgICAgICAgY29uc3QgZHluYW1pY2FsbHlEZXBlbmRlbnRFbnRyaWVzID0gZ2V0T3JDcmVhdGUoZHluYW1pY2FsbHlEZXBlbmRlbnRFbnRyaWVzQnlEeW5hbWljRW50cnksIGR5bmFtaWNFbnRyeUluZGV4LCAoZ2V0TmV3U2V0KSk7XG4gICAgICAgIGNvbnN0IGR5bmFtaWNFbnRyeSA9IGFsbEVudHJpZXNbZHluYW1pY0VudHJ5SW5kZXhdO1xuICAgICAgICBmb3IgKGNvbnN0IGltcG9ydGVyIG9mIGNvbmNhdExhenkoW1xuICAgICAgICAgICAgZHluYW1pY0VudHJ5LmluY2x1ZGVkRHluYW1pY0ltcG9ydGVycyxcbiAgICAgICAgICAgIGR5bmFtaWNFbnRyeS5pbXBsaWNpdGx5TG9hZGVkQWZ0ZXJcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZGVwZW5kZW50RW50cmllc0J5TW9kdWxlLmdldChpbXBvcnRlcikpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljYWxseURlcGVuZGVudEVudHJpZXMuYWRkKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZHluYW1pY2FsbHlEZXBlbmRlbnRFbnRyaWVzQnlEeW5hbWljRW50cnk7XG59XG5mdW5jdGlvbiBnZXRDaHVua3NXaXRoU2FtZURlcGVuZGVudEVudHJpZXMobW9kdWxlc1dpdGhEZXBlbmRlbnRFbnRyaWVzKSB7XG4gICAgY29uc3QgY2h1bmtNb2R1bGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGNvbnN0IHsgZGVwZW5kZW50RW50cmllcywgbW9kdWxlcyB9IG9mIG1vZHVsZXNXaXRoRGVwZW5kZW50RW50cmllcykge1xuICAgICAgICBsZXQgY2h1bmtTaWduYXR1cmUgPSAwbjtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeUluZGV4IG9mIGRlcGVuZGVudEVudHJpZXMpIHtcbiAgICAgICAgICAgIGNodW5rU2lnbmF0dXJlIHw9IDFuIDw8IEJpZ0ludChlbnRyeUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAoY2h1bmtNb2R1bGVzW1N0cmluZyhjaHVua1NpZ25hdHVyZSldIHx8PSB7XG4gICAgICAgICAgICBkZXBlbmRlbnRFbnRyaWVzOiBuZXcgU2V0KGRlcGVuZGVudEVudHJpZXMpLFxuICAgICAgICAgICAgbW9kdWxlczogW11cbiAgICAgICAgfSkubW9kdWxlcy5wdXNoKC4uLm1vZHVsZXMpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhjaHVua01vZHVsZXMpO1xufVxuZnVuY3Rpb24qIGdldE1vZHVsZXNXaXRoRGVwZW5kZW50RW50cmllcyhkZXBlbmRlbnRFbnRyaWVzQnlNb2R1bGUsIG1vZHVsZXNJbk1hbnVhbENodW5rcykge1xuICAgIGZvciAoY29uc3QgW21vZHVsZSwgZGVwZW5kZW50RW50cmllc10gb2YgZGVwZW5kZW50RW50cmllc0J5TW9kdWxlKSB7XG4gICAgICAgIGlmICghbW9kdWxlc0luTWFudWFsQ2h1bmtzLmhhcyhtb2R1bGUpKSB7XG4gICAgICAgICAgICB5aWVsZCB7IGRlcGVuZGVudEVudHJpZXMsIG1vZHVsZXM6IFttb2R1bGVdIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTdGF0aWNEZXBlbmRlbmN5QXRvbXNCeUVudHJ5KGFsbEVudHJpZXMsIGNodW5rQXRvbXMpIHtcbiAgICAvLyBUaGUgaW5kaWNlcyBjb3JyZXNwb25kIHRvIHRoZSBpbmRpY2VzIGluIGFsbEVudHJpZXMuIFRoZSBhdG9tcyBjb3JyZXNwb25kXG4gICAgLy8gdG8gYml0cyBpbiB0aGUgYmlnaW50IHZhbHVlcyB3aGVyZSBjaHVuayAwIGlzIHRoZSBsb3dlc3QgYml0LlxuICAgIGNvbnN0IHN0YXRpY0RlcGVuZGVuY3lBdG9tc0J5RW50cnkgPSBhbGxFbnRyaWVzLm1hcCgoKSA9PiAwbik7XG4gICAgLy8gVGhpcyB0b2dnbGVzIHRoZSBiaXRzIGZvciBlYWNoIGF0b20gdGhhdCBpcyBhIGRlcGVuZGVuY3kgb2YgYW4gZW50cnlcbiAgICBsZXQgYXRvbU1hc2sgPSAxbjtcbiAgICBmb3IgKGNvbnN0IHsgZGVwZW5kZW50RW50cmllcyB9IG9mIGNodW5rQXRvbXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeUluZGV4IG9mIGRlcGVuZGVudEVudHJpZXMpIHtcbiAgICAgICAgICAgIHN0YXRpY0RlcGVuZGVuY3lBdG9tc0J5RW50cnlbZW50cnlJbmRleF0gfD0gYXRvbU1hc2s7XG4gICAgICAgIH1cbiAgICAgICAgYXRvbU1hc2sgPDw9IDFuO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGljRGVwZW5kZW5jeUF0b21zQnlFbnRyeTtcbn1cbi8vIFdhcm5pbmc6IFRoaXMgd2lsbCBjb25zdW1lIGR5bmFtaWNhbGx5RGVwZW5kZW50RW50cmllc0J5RHluYW1pY0VudHJ5LlxuZnVuY3Rpb24gZ2V0QWxyZWFkeUxvYWRlZEF0b21zQnlFbnRyeShzdGF0aWNEZXBlbmRlbmN5QXRvbXNCeUVudHJ5LCBkeW5hbWljYWxseURlcGVuZGVudEVudHJpZXNCeUR5bmFtaWNFbnRyeSwgZHluYW1pY0ltcG9ydHNCeUVudHJ5LCBhbGxFbnRyaWVzKSB7XG4gICAgLy8gRHluYW1pYyBlbnRyaWVzIGhhdmUgYWxsIGF0b21zIGFzIGFscmVhZHkgbG9hZGVkIGluaXRpYWxseSBiZWNhdXNlIHdlIHRoZW5cbiAgICAvLyBpbnRlcnNlY3Qgd2l0aCB0aGUgc3RhdGljIGRlcGVuZGVuY3kgYXRvbXMgb2YgYWxsIGR5bmFtaWMgaW1wb3J0ZXJzLlxuICAgIC8vIFN0YXRpYyBlbnRyaWVzIGNhbm5vdCBoYXZlIGFscmVhZHkgbG9hZGVkIGF0b21zLlxuICAgIGNvbnN0IGFscmVhZHlMb2FkZWRBdG9tc0J5RW50cnkgPSBhbGxFbnRyaWVzLm1hcCgoX2VudHJ5LCBlbnRyeUluZGV4KSA9PiBkeW5hbWljYWxseURlcGVuZGVudEVudHJpZXNCeUR5bmFtaWNFbnRyeS5oYXMoZW50cnlJbmRleCkgPyAtMW4gOiAwbik7XG4gICAgZm9yIChjb25zdCBbZHluYW1pY0VudHJ5SW5kZXgsIGR5bmFtaWNhbGx5RGVwZW5kZW50RW50cmllc10gb2YgZHluYW1pY2FsbHlEZXBlbmRlbnRFbnRyaWVzQnlEeW5hbWljRW50cnkpIHtcbiAgICAgICAgLy8gV2UgZGVsZXRlIGhlcmUgc28gdGhhdCB0aGV5IGNhbiBiZSBhZGRlZCBhZ2FpbiBpZiBuZWNlc3NhcnkgdG8gYmUgaGFuZGxlZFxuICAgICAgICAvLyBhZ2FpbiBieSB0aGUgbG9vcFxuICAgICAgICBkeW5hbWljYWxseURlcGVuZGVudEVudHJpZXNCeUR5bmFtaWNFbnRyeS5kZWxldGUoZHluYW1pY0VudHJ5SW5kZXgpO1xuICAgICAgICBjb25zdCBrbm93bkxvYWRlZEF0b21zID0gYWxyZWFkeUxvYWRlZEF0b21zQnlFbnRyeVtkeW5hbWljRW50cnlJbmRleF07XG4gICAgICAgIGxldCB1cGRhdGVkTG9hZGVkQXRvbXMgPSBrbm93bkxvYWRlZEF0b21zO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5SW5kZXggb2YgZHluYW1pY2FsbHlEZXBlbmRlbnRFbnRyaWVzKSB7XG4gICAgICAgICAgICB1cGRhdGVkTG9hZGVkQXRvbXMgJj1cbiAgICAgICAgICAgICAgICBzdGF0aWNEZXBlbmRlbmN5QXRvbXNCeUVudHJ5W2VudHJ5SW5kZXhdIHwgYWxyZWFkeUxvYWRlZEF0b21zQnlFbnRyeVtlbnRyeUluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUga25vd25Mb2FkZWRBdG9tcyBjaGFuZ2VkLCBhbGwgZGVwZW5kZW50IGR5bmFtaWMgZW50cmllcyBuZWVkIHRvIGJlXG4gICAgICAgIC8vIHVwZGF0ZWQgYWdhaW5cbiAgICAgICAgaWYgKHVwZGF0ZWRMb2FkZWRBdG9tcyAhPT0ga25vd25Mb2FkZWRBdG9tcykge1xuICAgICAgICAgICAgYWxyZWFkeUxvYWRlZEF0b21zQnlFbnRyeVtkeW5hbWljRW50cnlJbmRleF0gPSB1cGRhdGVkTG9hZGVkQXRvbXM7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGR5bmFtaWNJbXBvcnQgb2YgZHluYW1pY0ltcG9ydHNCeUVudHJ5W2R5bmFtaWNFbnRyeUluZGV4XSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgYWRkcyBhbiBlbnRyeSB0aGF0IHdhcyBkZWxldGVkIGJlZm9yZSwgaXQgd2lsbCBiZSBoYW5kbGVkXG4gICAgICAgICAgICAgICAgLy8gYWdhaW4uIFRoaXMgaXMgdGhlIHJlYXNvbiB3aHkgd2UgZGVsZXRlIGV2ZXJ5IGVudHJ5IGZyb20gdGhpcyBtYXBcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdlIHByb2Nlc3NlZC5cbiAgICAgICAgICAgICAgICBnZXRPckNyZWF0ZShkeW5hbWljYWxseURlcGVuZGVudEVudHJpZXNCeUR5bmFtaWNFbnRyeSwgZHluYW1pY0ltcG9ydCwgKGdldE5ld1NldCkpLmFkZChkeW5hbWljRW50cnlJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFscmVhZHlMb2FkZWRBdG9tc0J5RW50cnk7XG59XG4vKipcbiAqIFRoaXMgcmVtb3ZlcyBhbGwgdW5uZWNlc3NhcnkgZHluYW1pYyBlbnRyaWVzIGZyb20gdGhlIGRlcGVuZGVudEVudHJpZXMgaW4gaXRzXG4gKiBmaXJzdCBhcmd1bWVudCBpZiBhIGNodW5rIGlzIGFscmVhZHkgbG9hZGVkIHdpdGhvdXQgdGhhdCBlbnRyeS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlVW5uZWNlc3NhcnlEZXBlbmRlbnRFbnRyaWVzKGNodW5rQXRvbXMsIGFscmVhZHlMb2FkZWRBdG9tc0J5RW50cnkpIHtcbiAgICAvLyBSZW1vdmUgZW50cmllcyBmcm9tIGRlcGVuZGVudCBlbnRyaWVzIGlmIGEgY2h1bmsgaXMgYWxyZWFkeSBsb2FkZWQgd2l0aG91dFxuICAgIC8vIHRoYXQgZW50cnkuXG4gICAgbGV0IGNodW5rTWFzayA9IDFuO1xuICAgIGZvciAoY29uc3QgeyBkZXBlbmRlbnRFbnRyaWVzIH0gb2YgY2h1bmtBdG9tcykge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5SW5kZXggb2YgZGVwZW5kZW50RW50cmllcykge1xuICAgICAgICAgICAgaWYgKChhbHJlYWR5TG9hZGVkQXRvbXNCeUVudHJ5W2VudHJ5SW5kZXhdICYgY2h1bmtNYXNrKSA9PT0gY2h1bmtNYXNrKSB7XG4gICAgICAgICAgICAgICAgZGVwZW5kZW50RW50cmllcy5kZWxldGUoZW50cnlJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtNYXNrIDw8PSAxbjtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDaHVua3NXaXRoU2FtZURlcGVuZGVudEVudHJpZXNBbmRDb3JyZWxhdGVkQXRvbXMoY2h1bmtBdG9tcywgc3RhdGljRGVwZW5kZW5jeUF0b21zQnlFbnRyeSwgYWxyZWFkeUxvYWRlZEF0b21zQnlFbnRyeSwgbWluQ2h1bmtTaXplKSB7XG4gICAgY29uc3QgY2h1bmtzQnlTaWduYXR1cmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IGNodW5rQnlNb2R1bGUgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgc2l6ZUJ5QXRvbSA9IG5ldyBBcnJheShjaHVua0F0b21zLmxlbmd0aCk7XG4gICAgbGV0IHNpZGVFZmZlY3RBdG9tcyA9IDBuO1xuICAgIGxldCBhdG9tTWFzayA9IDFuO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCB7IGRlcGVuZGVudEVudHJpZXMsIG1vZHVsZXMgfSBvZiBjaHVua0F0b21zKSB7XG4gICAgICAgIGxldCBjaHVua1NpZ25hdHVyZSA9IDBuO1xuICAgICAgICBsZXQgY29ycmVsYXRlZEF0b21zID0gLTFuO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5SW5kZXggb2YgZGVwZW5kZW50RW50cmllcykge1xuICAgICAgICAgICAgY2h1bmtTaWduYXR1cmUgfD0gMW4gPDwgQmlnSW50KGVudHJ5SW5kZXgpO1xuICAgICAgICAgICAgLy8gQ29ycmVsYXRlZCBhdG9tcyBhcmUgdGhlIGF0b21zIHRoYXQgYXJlIGd1YXJhbnRlZWQgdG8gYmUgbG9hZGVkIGFzXG4gICAgICAgICAgICAvLyB3ZWxsIHdoZW4gYSBnaXZlbiBhdG9tIGlzIGxvYWRlZC4gSXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgYWxyZWFkeVxuICAgICAgICAgICAgLy8gbG9hZGVkIG1vZHVsZXMgb2YgZWFjaCBjaHVuayBtZXJnZWQgd2l0aCBpdHMgc3RhdGljIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgIGNvcnJlbGF0ZWRBdG9tcyAmPVxuICAgICAgICAgICAgICAgIHN0YXRpY0RlcGVuZGVuY3lBdG9tc0J5RW50cnlbZW50cnlJbmRleF0gfCBhbHJlYWR5TG9hZGVkQXRvbXNCeUVudHJ5W2VudHJ5SW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNodW5rID0gKGNodW5rc0J5U2lnbmF0dXJlW1N0cmluZyhjaHVua1NpZ25hdHVyZSldIHx8PSB7XG4gICAgICAgICAgICBjb250YWluZWRBdG9tczogMG4sXG4gICAgICAgICAgICBjb3JyZWxhdGVkQXRvbXMsXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIGRlcGVuZGVudENodW5rczogbmV3IFNldCgpLFxuICAgICAgICAgICAgZGVwZW5kZW50RW50cmllczogbmV3IFNldChkZXBlbmRlbnRFbnRyaWVzKSxcbiAgICAgICAgICAgIG1vZHVsZXM6IFtdLFxuICAgICAgICAgICAgcHVyZTogdHJ1ZSxcbiAgICAgICAgICAgIHNpemU6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBhdG9tU2l6ZSA9IDA7XG4gICAgICAgIGxldCBwdXJlID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlcykge1xuICAgICAgICAgICAgY2h1bmtCeU1vZHVsZS5zZXQobW9kdWxlLCBjaHVuayk7XG4gICAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCB3ZSBjYW5ub3QgdGFrZSB0cmVlLXNoYWtpbmcgaW50byBhY2NvdW50IGhlcmUgYmVjYXVzZVxuICAgICAgICAgICAgLy8gcmVuZGVyaW5nIGRpZCBub3QgaGFwcGVuIHlldCwgYnV0IHdlIGNhbiBkZXRlY3QgZW1wdHkgbW9kdWxlc1xuICAgICAgICAgICAgaWYgKG1vZHVsZS5pc0luY2x1ZGVkKCkpIHtcbiAgICAgICAgICAgICAgICBwdXJlICYmPSAhbW9kdWxlLmhhc0VmZmVjdHMoKTtcbiAgICAgICAgICAgICAgICAvLyB3ZSB1c2UgYSB0cml2aWFsIHNpemUgZm9yIHRoZSBkZWZhdWx0IG1pbkNodW5rU2l6ZSB0byBpbXByb3ZlXG4gICAgICAgICAgICAgICAgLy8gcGVyZm9ybWFuY2VcbiAgICAgICAgICAgICAgICBhdG9tU2l6ZSArPSBtaW5DaHVua1NpemUgPiAxID8gbW9kdWxlLmVzdGltYXRlU2l6ZSgpIDogMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXB1cmUpIHtcbiAgICAgICAgICAgIHNpZGVFZmZlY3RBdG9tcyB8PSBhdG9tTWFzaztcbiAgICAgICAgfVxuICAgICAgICBzaXplQnlBdG9tW2luZGV4KytdID0gYXRvbVNpemU7XG4gICAgICAgIGNodW5rLmNvbnRhaW5lZEF0b21zIHw9IGF0b21NYXNrO1xuICAgICAgICBjaHVuay5tb2R1bGVzLnB1c2goLi4ubW9kdWxlcyk7XG4gICAgICAgIGNodW5rLnB1cmUgJiY9IHB1cmU7XG4gICAgICAgIGNodW5rLnNpemUgKz0gYXRvbVNpemU7XG4gICAgICAgIGF0b21NYXNrIDw8PSAxbjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtzID0gT2JqZWN0LnZhbHVlcyhjaHVua3NCeVNpZ25hdHVyZSk7XG4gICAgc2lkZUVmZmVjdEF0b21zIHw9IGFkZENodW5rRGVwZW5kZW5jaWVzQW5kR2V0RXh0ZXJuYWxTaWRlRWZmZWN0QXRvbXMoY2h1bmtzLCBjaHVua0J5TW9kdWxlLCBhdG9tTWFzayk7XG4gICAgcmV0dXJuIHsgY2h1bmtzLCBzaWRlRWZmZWN0QXRvbXMsIHNpemVCeUF0b20gfTtcbn1cbmZ1bmN0aW9uIGFkZENodW5rRGVwZW5kZW5jaWVzQW5kR2V0RXh0ZXJuYWxTaWRlRWZmZWN0QXRvbXMoY2h1bmtzLCBjaHVua0J5TW9kdWxlLCBuZXh0QXZhaWxhYmxlQXRvbU1hc2spIHtcbiAgICBjb25zdCBzaWduYXR1cmVCeUV4dGVybmFsTW9kdWxlID0gbmV3IE1hcCgpO1xuICAgIGxldCBleHRlcm5hbFNpZGVFZmZlY3RBdG9tcyA9IDBuO1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICAgIGNvbnN0IHsgZGVwZW5kZW5jaWVzLCBtb2R1bGVzIH0gPSBjaHVuaztcbiAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIG1vZHVsZS5nZXREZXBlbmRlbmNpZXNUb0JlSW5jbHVkZWQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChkZXBlbmRlbmN5IGluc3RhbmNlb2YgRXh0ZXJuYWxNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3kuaW5mby5tb2R1bGVTaWRlRWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gZ2V0T3JDcmVhdGUoc2lnbmF0dXJlQnlFeHRlcm5hbE1vZHVsZSwgZGVwZW5kZW5jeSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IG5leHRBdmFpbGFibGVBdG9tTWFzaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0QXZhaWxhYmxlQXRvbU1hc2sgPDw9IDFuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVybmFsU2lkZUVmZmVjdEF0b21zIHw9IHNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5jb250YWluZWRBdG9tcyB8PSBzaWduYXR1cmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5jb3JyZWxhdGVkQXRvbXMgfD0gc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXBlbmRlbmN5Q2h1bmsgPSBjaHVua0J5TW9kdWxlLmdldChkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3lDaHVuayAmJiBkZXBlbmRlbmN5Q2h1bmsgIT09IGNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMuYWRkKGRlcGVuZGVuY3lDaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5Q2h1bmsuZGVwZW5kZW50Q2h1bmtzLmFkZChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4dGVybmFsU2lkZUVmZmVjdEF0b21zO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWVzIHRvIGdldCByaWQgb2Ygc21hbGwgY2h1bmtzIGJ5IG1lcmdpbmcgdGhlbSB3aXRoIG90aGVyXG4gKiBjaHVua3MuXG4gKlxuICogV2UgY2FuIG9ubHkgbWVyZ2UgY2h1bmtzIHNhZmVseSBpZiBhZnRlciB0aGUgbWVyZ2UsIGxvYWRpbmcgYW55IGVudHJ5IHBvaW50XG4gKiBpbiBhbnkgYWxsb3dlZCBvcmRlciB3aWxsIG5vdCB0cmlnZ2VyIHNpZGUgZWZmZWN0cyB0aGF0IHNob3VsZCBub3QgaGF2ZSBiZWVuXG4gKiB0cmlnZ2VyZWQuIFdoaWxlIHNpZGUgZWZmZWN0cyBhcmUgdXN1YWxseSB0aGluZ3MgbGlrZSBnbG9iYWwgZnVuY3Rpb24gY2FsbHMsXG4gKiBnbG9iYWwgdmFyaWFibGUgbXV0YXRpb25zIG9yIHBvdGVudGlhbGx5IHRocm93biBlcnJvcnMsIGRldGFpbHMgZG8gbm90XG4gKiBtYXR0ZXIgaGVyZSwgYW5kIHdlIGp1c3QgZGlzY2VybiBjaHVua3Mgd2l0aG91dCBzaWRlIGVmZmVjdHMgKHB1cmUgY2h1bmtzKVxuICogZnJvbSBvdGhlciBjaHVua3MuXG4gKlxuICogQXMgYSBmaXJzdCBzdGVwLCB3ZSBhc3NpZ24gZWFjaCBwcmUtZ2VuZXJhdGVkIGNodW5rIHdpdGggc2lkZSBlZmZlY3RzIGFcbiAqIGxhYmVsLiBJLmUuIHdlIGhhdmUgc2lkZSBlZmZlY3QgXCJBXCIgaWYgdGhlIG5vbi1wdXJlIGNodW5rIFwiQVwiIGlzIGxvYWRlZC5cbiAqXG4gKiBOb3cgdG8gZGV0ZXJtaW5lIHRoZSBzaWRlIGVmZmVjdHMgb2YgbG9hZGluZyBhIGNodW5rLCBvbmUgYWxzbyBoYXMgdG8gdGFrZVxuICogdGhlIHNpZGUgZWZmZWN0cyBvZiBpdHMgZGVwZW5kZW5jaWVzIGludG8gYWNjb3VudC4gU28gaWYgQSBkZXBlbmRzIG9uIEJcbiAqIChBIC0+IEIpIGFuZCBib3RoIGhhdmUgc2lkZSBlZmZlY3RzLCBsb2FkaW5nIEEgdHJpZ2dlcnMgZWZmZWN0cyBBQi5cbiAqXG4gKiBOb3cgZnJvbSB0aGUgcHJldmlvdXMgc3RlcCB3ZSBrbm93IHRoYXQgZWFjaCBjaHVuayBpcyB1bmlxdWVseSBkZXRlcm1pbmUgYnlcbiAqIHRoZSBlbnRyeSBwb2ludHMgdGhhdCBkZXBlbmQgb24gaXQgYW5kIGNhdXNlIGl0IHRvIGxvYWQsIHdoaWNoIHdlIHdpbGwgY2FsbFxuICogaXRzIGRlcGVuZGVudCBlbnRyeSBwb2ludHMuXG4gKlxuICogRS5nLiBpZiBYIC0+IEEgYW5kIFkgLT4gQSwgdGhlbiB0aGUgZGVwZW5kZW50IGVudHJ5IHBvaW50cyBvZiBBIGFyZSBYWS5cbiAqIFN0YXJ0aW5nIGZyb20gdGhhdCBpZGVhLCB3ZSBjYW4gZGV0ZXJtaW5lIGEgc2V0IG9mIGNodW5rc+KAlGFuZCB0aHVzIGEgc2V0XG4gKiBvZiBzaWRlIGVmZmVjdHPigJR0aGF0IG11c3QgaGF2ZSBiZWVuIHRyaWdnZXJlZCBpZiBhIGNlcnRhaW4gY2h1bmsgaGFzIGJlZW5cbiAqIGxvYWRlZC4gQmFzaWNhbGx5LCBpdCBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIGFsbCBjaHVua3MgbG9hZGVkIGJ5IHRoZVxuICogZGVwZW5kZW50IGVudHJ5IHBvaW50cyBvZiBhIGdpdmVuIGNodW5rLiBXZSBjYWxsIHRoZSBjb3JyZXNwb25kaW5nIHNpZGVcbiAqIGVmZmVjdHMgdGhlIGNvcnJlbGF0ZWQgc2lkZSBlZmZlY3RzIG9mIHRoYXQgY2h1bmsuXG4gKlxuICogRXhhbXBsZTpcbiAqIFggLT4gQUJDLCBZIC0+IEFERSwgQS0+IEYsIEIgLT4gRFxuICogVGhlbiB0YWtpbmcgZGVwZW5kZW5jaWVzIGludG8gYWNjb3VudCwgWCAtPiBBQkNERiwgWSAtPiBBREVGXG4gKiBUaGUgaW50ZXJzZWN0aW9uIGlzIEFERi4gU28gd2Uga25vdyB0aGF0IHdoZW4gQSBpcyBsb2FkZWQsIEQgYW5kIEYgbXVzdCBhbHNvXG4gKiBiZSBpbiBtZW1vcnkgZXZlbiB0aG91Z2ggbmVpdGhlciBEIG5vciBBIGlzIGEgZGVwZW5kZW5jeSBvZiB0aGUgb3RoZXIuXG4gKiBJZiBhbGwgaGF2ZSBzaWRlIGVmZmVjdHMsIHdlIGNhbGwgQURGIHRoZSBjb3JyZWxhdGVkIHNpZGUgZWZmZWN0cyBvZiBBLiBUaGVcbiAqIGNvcnJlbGF0ZWQgc2lkZSBlZmZlY3RzIG5lZWQgdG8gcmVtYWluIGNvbnN0YW50IHdoZW4gbWVyZ2luZyBjaHVua3MuXG4gKlxuICogSW4gY29udHJhc3QsIHdlIGhhdmUgdGhlIGRlcGVuZGVuY3kgc2lkZSBlZmZlY3RzIG9mIEEsIHdoaWNoIHJlcHJlc2VudHNcbiAqIHRoZSBzaWRlIGVmZmVjdHMgd2UgdHJpZ2dlciBpZiB3ZSBkaXJlY3RseSBsb2FkIEEuIEluIHRoaXMgZXhhbXBsZSwgdGhlXG4gKiBkZXBlbmRlbmN5IHNpZGUgZWZmZWN0cyBhcmUgQUYuXG4gKiBGb3IgZW50cnkgY2h1bmtzLCBkZXBlbmRlbmN5IGFuZCBjb3JyZWxhdGVkIHNpZGUgZWZmZWN0cyBhcmUgdGhlIHNhbWUuXG4gKlxuICogV2l0aCB0aGVzZSBjb25jZXB0cywgbWVyZ2luZyBjaHVua3MgaXMgYWxsb3dlZCBpZiB0aGUgY29ycmVsYXRlZCBzaWRlXG4gKiBlZmZlY3RzIG9mIGVhY2ggZW50cnkgZG8gbm90IGNoYW5nZS4gVGh1cywgd2UgYXJlIGFsbG93ZWQgdG8gbWVyZ2UgdHdvXG4gKiBjaHVua3MgaWZcbiAqXG4gKiBhKSB0aGUgZGVwZW5kZW5jeSBzaWRlIGVmZmVjdHMgb2YgZWFjaCBjaHVuayBhcmUgYSBzdWJzZXQgb2YgdGhlIGNvcnJlbGF0ZWRcbiAqICAgIHNpZGUgZWZmZWN0cyBvZiB0aGUgb3RoZXIgY2h1bmssIHNvIG5vIGFkZGl0aW9uYWwgc2lkZSBlZmZlY3RzIGFyZVxuICogICAgdHJpZ2dlcmVkIGZvciBhbnkgZW50cnksIG9yXG4gKiBiKSBUaGUgZGVwZW5kZW50IGVudHJ5IHBvaW50cyBvZiBjaHVuayBBIGFyZSBhIHN1YnNldCBvZiB0aGUgZGVwZW5kZW50IGVudHJ5XG4gKiAgICBwb2ludHMgb2YgY2h1bmsgQiB3aGlsZSB0aGUgZGVwZW5kZW5jeSBzaWRlIGVmZmVjdHMgb2YgQSBhcmUgYSBzdWJzZXQgb2ZcbiAqICAgIHRoZSBjb3JyZWxhdGVkIHNpZGUgZWZmZWN0cyBvZiBCLiBCZWNhdXNlIGluIHRoYXQgc2NlbmFyaW8sIHdoZW5ldmVyIEEgaXNcbiAqICAgIGxvYWRlZCwgQiBpcyBsb2FkZWQgYXMgd2VsbC4gQnV0IHRoZXJlIGFyZSBjYXNlcyB3aGVuIEIgaXMgbG9hZGVkIHdoZXJlIEFcbiAqICAgIGlzIG5vdCBsb2FkZWQuIFNvIGlmIHdlIG1lcmdlIHRoZSBjaHVua3MsIGFsbCBkZXBlbmRlbmN5IHNpZGUgZWZmZWN0cyBvZlxuICogICAgQSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjb3JyZWxhdGVkIHNpZGUgZWZmZWN0cyBvZiBCLCBhbmQgYXMgdGhlIGxhdHRlciBpc1xuICogICAgbm90IGFsbG93ZWQgdG8gY2hhbmdlLCB0aGUgZm9ybWVyIG5lZWQgdG8gYmUgYSBzdWJzZXQgb2YgdGhlIGxhdHRlci5cbiAqXG4gKiBBbm90aGVyIGNvbnNpZGVyYXRpb24gd2hlbiBtZXJnaW5nIHNtYWxsIGNodW5rcyBpbnRvIG90aGVyIGNodW5rcyBpcyB0b1xuICogYXZvaWRcbiAqIHRoYXQgdG9vIG11Y2ggYWRkaXRpb25hbCBjb2RlIGlzIGxvYWRlZC4gVGhpcyBpcyBhY2hpZXZlZCB3aGVuIHRoZSBkZXBlbmRlbnRcbiAqIGVudHJpZXMgb2YgdGhlIHNtYWxsIGNodW5rIGFyZSBhIHN1YnNldCBvZiB0aGUgZGVwZW5kZW50IGVudHJpZXMgb2YgdGhlXG4gKiBvdGhlclxuICogY2h1bmsuIEJlY2F1c2UgdGhlbiB3aGVuIHRoZSBzbWFsbCBjaHVuayBpcyBsb2FkZWQsIHRoZSBvdGhlciBjaHVuayB3YXNcbiAqIGxvYWRlZC9pbiBtZW1vcnkgYW55d2F5LCBzbyBhdCBtb3N0IHdoZW4gdGhlIG90aGVyIGNodW5rIGlzIGxvYWRlZCwgdGhlXG4gKiBhZGRpdGlvbmFsIHNpemUgb2YgdGhlIHNtYWxsIGNodW5rIGlzIGxvYWRlZCB1bm5lY2Vzc2FyaWx5LlxuICpcbiAqIFNvIHRoZSBhbGdvcml0aG0gcGVyZm9ybXMgbWVyZ2VzIGluIHR3byBwYXNzZXM6XG4gKlxuICogMS4gRmlyc3Qgd2UgdHJ5IHRvIG1lcmdlIHNtYWxsIGNodW5rcyBBIG9ubHkgaW50byBvdGhlciBjaHVua3MgQiBpZiB0aGVcbiAqICAgIGRlcGVuZGVudCBlbnRyaWVzIG9mIEEgYXJlIGEgc3Vic2V0IG9mIHRoZSBkZXBlbmRlbnQgZW50cmllcyBvZiBCIGFuZCB0aGVcbiAqICAgIGRlcGVuZGVuY3kgc2lkZSBlZmZlY3RzIG9mIEEgYXJlIGEgc3Vic2V0IG9mIHRoZSBjb3JyZWxhdGVkIHNpZGUgZWZmZWN0c1xuICogICAgb2YgQi5cbiAqIDIuIE9ubHkgdGhlbiBmb3IgYWxsIHJlbWFpbmluZyBzbWFsbCBjaHVua3MsIHdlIGxvb2sgZm9yIGFyYml0cmFyeSBtZXJnZXNcbiAqICAgIGZvbGxvd2luZyB0aGUgcnVsZSAoYSksIHN0YXJ0aW5nIHdpdGggdGhlIHNtYWxsZXN0IGNodW5rcyB0byBsb29rIGZvclxuICogICAgcG9zc2libGUgbWVyZ2UgdGFyZ2V0cy5cbiAqL1xuZnVuY3Rpb24gZ2V0T3B0aW1pemVkQ2h1bmtzKGNodW5rcywgbWluQ2h1bmtTaXplLCBzaWRlRWZmZWN0QXRvbXMsIHNpemVCeUF0b20sIGxvZykge1xuICAgIHRpbWVTdGFydCgnb3B0aW1pemUgY2h1bmtzJywgMyk7XG4gICAgY29uc3QgY2h1bmtQYXJ0aXRpb24gPSBnZXRQYXJ0aXRpb25lZENodW5rcyhjaHVua3MsIG1pbkNodW5rU2l6ZSk7XG4gICAgaWYgKCFjaHVua1BhcnRpdGlvbikge1xuICAgICAgICB0aW1lRW5kKCdvcHRpbWl6ZSBjaHVua3MnLCAzKTtcbiAgICAgICAgcmV0dXJuIGNodW5rczsgLy8gdGhlIGFjdHVhbCBtb2R1bGVzXG4gICAgfVxuICAgIGlmIChtaW5DaHVua1NpemUgPiAxKSB7XG4gICAgICAgIGxvZygnaW5mbycsIGxvZ09wdGltaXplQ2h1bmtTdGF0dXMoY2h1bmtzLmxlbmd0aCwgY2h1bmtQYXJ0aXRpb24uc21hbGwuc2l6ZSwgJ0luaXRpYWxseScpKTtcbiAgICB9XG4gICAgbWVyZ2VDaHVua3MoY2h1bmtQYXJ0aXRpb24sIG1pbkNodW5rU2l6ZSwgc2lkZUVmZmVjdEF0b21zLCBzaXplQnlBdG9tKTtcbiAgICBpZiAobWluQ2h1bmtTaXplID4gMSkge1xuICAgICAgICBsb2coJ2luZm8nLCBsb2dPcHRpbWl6ZUNodW5rU3RhdHVzKGNodW5rUGFydGl0aW9uLnNtYWxsLnNpemUgKyBjaHVua1BhcnRpdGlvbi5iaWcuc2l6ZSwgY2h1bmtQYXJ0aXRpb24uc21hbGwuc2l6ZSwgJ0FmdGVyIG1lcmdpbmcgY2h1bmtzJykpO1xuICAgIH1cbiAgICB0aW1lRW5kKCdvcHRpbWl6ZSBjaHVua3MnLCAzKTtcbiAgICByZXR1cm4gWy4uLmNodW5rUGFydGl0aW9uLnNtYWxsLCAuLi5jaHVua1BhcnRpdGlvbi5iaWddO1xufVxuZnVuY3Rpb24gZ2V0UGFydGl0aW9uZWRDaHVua3MoY2h1bmtzLCBtaW5DaHVua1NpemUpIHtcbiAgICBjb25zdCBzbWFsbENodW5rcyA9IFtdO1xuICAgIGNvbnN0IGJpZ0NodW5rcyA9IFtdO1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICAgIChjaHVuay5zaXplIDwgbWluQ2h1bmtTaXplID8gc21hbGxDaHVua3MgOiBiaWdDaHVua3MpLnB1c2goY2h1bmspO1xuICAgIH1cbiAgICBpZiAoc21hbGxDaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzbWFsbENodW5rcy5zb3J0KGNvbXBhcmVDaHVua1NpemUpO1xuICAgIGJpZ0NodW5rcy5zb3J0KGNvbXBhcmVDaHVua1NpemUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJpZzogbmV3IFNldChiaWdDaHVua3MpLFxuICAgICAgICBzbWFsbDogbmV3IFNldChzbWFsbENodW5rcylcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGFyZUNodW5rU2l6ZSh7IHNpemU6IHNpemVBIH0sIHsgc2l6ZTogc2l6ZUIgfSkge1xuICAgIHJldHVybiBzaXplQSAtIHNpemVCO1xufVxuZnVuY3Rpb24gbWVyZ2VDaHVua3MoY2h1bmtQYXJ0aXRpb24sIG1pbkNodW5rU2l6ZSwgc2lkZUVmZmVjdEF0b21zLCBzaXplQnlBdG9tKSB7XG4gICAgY29uc3QgeyBzbWFsbCB9ID0gY2h1bmtQYXJ0aXRpb247XG4gICAgZm9yIChjb25zdCBtZXJnZWRDaHVuayBvZiBzbWFsbCkge1xuICAgICAgICBjb25zdCBiZXN0VGFyZ2V0Q2h1bmsgPSBmaW5kQmVzdE1lcmdlVGFyZ2V0KG1lcmdlZENodW5rLCBjaHVua1BhcnRpdGlvbiwgc2lkZUVmZmVjdEF0b21zLCBzaXplQnlBdG9tLCBcbiAgICAgICAgLy8gSW4gdGhlIGRlZmF1bHQgY2FzZSwgd2UgZG8gbm90IGFjY2VwdCBzaXplIGluY3JlYXNlc1xuICAgICAgICBtaW5DaHVua1NpemUgPD0gMSA/IDEgOiBJbmZpbml0eSk7XG4gICAgICAgIGlmIChiZXN0VGFyZ2V0Q2h1bmspIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVkQXRvbXMsIGNvcnJlbGF0ZWRBdG9tcywgbW9kdWxlcywgcHVyZSwgc2l6ZSB9ID0gbWVyZ2VkQ2h1bms7XG4gICAgICAgICAgICBzbWFsbC5kZWxldGUobWVyZ2VkQ2h1bmspO1xuICAgICAgICAgICAgZ2V0Q2h1bmtzSW5QYXJ0aXRpb24oYmVzdFRhcmdldENodW5rLCBtaW5DaHVua1NpemUsIGNodW5rUGFydGl0aW9uKS5kZWxldGUoYmVzdFRhcmdldENodW5rKTtcbiAgICAgICAgICAgIGJlc3RUYXJnZXRDaHVuay5tb2R1bGVzLnB1c2goLi4ubW9kdWxlcyk7XG4gICAgICAgICAgICBiZXN0VGFyZ2V0Q2h1bmsuc2l6ZSArPSBzaXplO1xuICAgICAgICAgICAgYmVzdFRhcmdldENodW5rLnB1cmUgJiY9IHB1cmU7XG4gICAgICAgICAgICBjb25zdCB7IGRlcGVuZGVuY2llcywgZGVwZW5kZW50Q2h1bmtzLCBkZXBlbmRlbnRFbnRyaWVzIH0gPSBiZXN0VGFyZ2V0Q2h1bms7XG4gICAgICAgICAgICBiZXN0VGFyZ2V0Q2h1bmsuY29ycmVsYXRlZEF0b21zICY9IGNvcnJlbGF0ZWRBdG9tcztcbiAgICAgICAgICAgIGJlc3RUYXJnZXRDaHVuay5jb250YWluZWRBdG9tcyB8PSBjb250YWluZWRBdG9tcztcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgbWVyZ2VkQ2h1bmsuZGVwZW5kZW50RW50cmllcykge1xuICAgICAgICAgICAgICAgIGRlcGVuZGVudEVudHJpZXMuYWRkKGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVwZW5kZW5jeSBvZiBtZXJnZWRDaHVuay5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMuYWRkKGRlcGVuZGVuY3kpO1xuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kuZGVwZW5kZW50Q2h1bmtzLmRlbGV0ZShtZXJnZWRDaHVuayk7XG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeS5kZXBlbmRlbnRDaHVua3MuYWRkKGJlc3RUYXJnZXRDaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVudENodW5rIG9mIG1lcmdlZENodW5rLmRlcGVuZGVudENodW5rcykge1xuICAgICAgICAgICAgICAgIGRlcGVuZGVudENodW5rcy5hZGQoZGVwZW5kZW50Q2h1bmspO1xuICAgICAgICAgICAgICAgIGRlcGVuZGVudENodW5rLmRlcGVuZGVuY2llcy5kZWxldGUobWVyZ2VkQ2h1bmspO1xuICAgICAgICAgICAgICAgIGRlcGVuZGVudENodW5rLmRlcGVuZGVuY2llcy5hZGQoYmVzdFRhcmdldENodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5kZWxldGUoYmVzdFRhcmdldENodW5rKTtcbiAgICAgICAgICAgIGRlcGVuZGVudENodW5rcy5kZWxldGUoYmVzdFRhcmdldENodW5rKTtcbiAgICAgICAgICAgIGdldENodW5rc0luUGFydGl0aW9uKGJlc3RUYXJnZXRDaHVuaywgbWluQ2h1bmtTaXplLCBjaHVua1BhcnRpdGlvbikuYWRkKGJlc3RUYXJnZXRDaHVuayk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kQmVzdE1lcmdlVGFyZ2V0KG1lcmdlZENodW5rLCB7IGJpZywgc21hbGwgfSwgc2lkZUVmZmVjdEF0b21zLCBzaXplQnlBdG9tLCBzbWFsbGVzdEFkZGl0aW9uYWxTaXplKSB7XG4gICAgbGV0IGJlc3RUYXJnZXRDaHVuayA9IG51bGw7XG4gICAgLy8gSW4gdGhlIGRlZmF1bHQgY2FzZSwgd2UgZG8gbm90IGFjY2VwdCBzaXplIGluY3JlYXNlc1xuICAgIGZvciAoY29uc3QgdGFyZ2V0Q2h1bmsgb2YgY29uY2F0TGF6eShbc21hbGwsIGJpZ10pKSB7XG4gICAgICAgIGlmIChtZXJnZWRDaHVuayA9PT0gdGFyZ2V0Q2h1bmspXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbFNpemVBZnRlck1lcmdlID0gZ2V0QWRkaXRpb25hbFNpemVBZnRlck1lcmdlKG1lcmdlZENodW5rLCB0YXJnZXRDaHVuaywgc21hbGxlc3RBZGRpdGlvbmFsU2l6ZSwgc2lkZUVmZmVjdEF0b21zLCBzaXplQnlBdG9tKTtcbiAgICAgICAgaWYgKGFkZGl0aW9uYWxTaXplQWZ0ZXJNZXJnZSA8IHNtYWxsZXN0QWRkaXRpb25hbFNpemUpIHtcbiAgICAgICAgICAgIGJlc3RUYXJnZXRDaHVuayA9IHRhcmdldENodW5rO1xuICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxTaXplQWZ0ZXJNZXJnZSA9PT0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHNtYWxsZXN0QWRkaXRpb25hbFNpemUgPSBhZGRpdGlvbmFsU2l6ZUFmdGVyTWVyZ2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJlc3RUYXJnZXRDaHVuaztcbn1cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBhZGRpdGlvbmFsIHVudXNlZCBjb2RlIHNpemUgdGhhdCB3b3VsZCBiZSBhZGRlZCBieSBtZXJnaW5nIHRoZVxuICogdHdvIGNodW5rcy4gVGhpcyBpcyBub3QgYW4gZXhhY3QgbWVhc3VyZW1lbnQgYnV0IHJhdGhlciBhbiB1cHBlciBib3VuZC4gSWZcbiAqIHRoZSBtZXJnZSBwcm9kdWNlcyBjeWNsZXMgb3IgYWRkcyBub24tY29ycmVsYXRlZCBzaWRlIGVmZmVjdHMsIGBJbmZpbml0eWBcbiAqIGlzIHJldHVybmVkLlxuICogTWVyZ2luZyB3aWxsIG5vdCBwcm9kdWNlIGN5Y2xlcyBpZiBub25lIG9mIHRoZSBkaXJlY3Qgbm9uLW1lcmdlZFxuICogZGVwZW5kZW5jaWVzIG9mIGEgY2h1bmsgaGF2ZSB0aGUgb3RoZXIgY2h1bmsgYXMgYSB0cmFuc2l0aXZlIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIGdldEFkZGl0aW9uYWxTaXplQWZ0ZXJNZXJnZShtZXJnZWRDaHVuaywgdGFyZ2V0Q2h1bmssIFxuLy8gVGhlIG1heGltdW0gYWRkaXRpb25hbCB1bnVzZWQgY29kZSBzaXplIGFsbG93ZWQgdG8gYmUgYWRkZWQgYnkgdGhlIG1lcmdlLFxuLy8gdGFraW5nIGRlcGVuZGVuY2llcyBpbnRvIGFjY291bnQsIG5lZWRzIHRvIGJlIGJlbG93IHRoaXMgbnVtYmVyXG5jdXJyZW50QWRkaXRpb25hbFNpemUsIHNpZGVFZmZlY3RBdG9tcywgc2l6ZUJ5QXRvbSkge1xuICAgIGNvbnN0IGZpcnN0U2l6ZSA9IGdldEFkZGl0aW9uYWxTaXplSWZOb1RyYW5zaXRpdmVEZXBlbmRlbmN5T3JOb25Db3JyZWxhdGVkU2lkZUVmZmVjdChtZXJnZWRDaHVuaywgdGFyZ2V0Q2h1bmssIGN1cnJlbnRBZGRpdGlvbmFsU2l6ZSwgc2lkZUVmZmVjdEF0b21zLCBzaXplQnlBdG9tKTtcbiAgICByZXR1cm4gZmlyc3RTaXplIDwgY3VycmVudEFkZGl0aW9uYWxTaXplXG4gICAgICAgID8gZmlyc3RTaXplICtcbiAgICAgICAgICAgIGdldEFkZGl0aW9uYWxTaXplSWZOb1RyYW5zaXRpdmVEZXBlbmRlbmN5T3JOb25Db3JyZWxhdGVkU2lkZUVmZmVjdCh0YXJnZXRDaHVuaywgbWVyZ2VkQ2h1bmssIGN1cnJlbnRBZGRpdGlvbmFsU2l6ZSAtIGZpcnN0U2l6ZSwgc2lkZUVmZmVjdEF0b21zLCBzaXplQnlBdG9tKVxuICAgICAgICA6IEluZmluaXR5O1xufVxuZnVuY3Rpb24gZ2V0QWRkaXRpb25hbFNpemVJZk5vVHJhbnNpdGl2ZURlcGVuZGVuY3lPck5vbkNvcnJlbGF0ZWRTaWRlRWZmZWN0KGRlcGVuZGVudENodW5rLCBkZXBlbmRlbmN5Q2h1bmssIGN1cnJlbnRBZGRpdGlvbmFsU2l6ZSwgc2lkZUVmZmVjdEF0b21zLCBzaXplQnlBdG9tKSB7XG4gICAgY29uc3QgeyBjb3JyZWxhdGVkQXRvbXMgfSA9IGRlcGVuZGVuY3lDaHVuaztcbiAgICBsZXQgZGVwZW5kZW5jeUF0b21zID0gZGVwZW5kZW50Q2h1bmsuY29udGFpbmVkQXRvbXM7XG4gICAgY29uc3QgZGVwZW5kZW50Q29udGFpbmVkU2lkZUVmZmVjdHMgPSBkZXBlbmRlbmN5QXRvbXMgJiBzaWRlRWZmZWN0QXRvbXM7XG4gICAgaWYgKChjb3JyZWxhdGVkQXRvbXMgJiBkZXBlbmRlbnRDb250YWluZWRTaWRlRWZmZWN0cykgIT09IGRlcGVuZGVudENvbnRhaW5lZFNpZGVFZmZlY3RzKSB7XG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtzVG9DaGVjayA9IG5ldyBTZXQoZGVwZW5kZW50Q2h1bmsuZGVwZW5kZW5jaWVzKTtcbiAgICBmb3IgKGNvbnN0IHsgZGVwZW5kZW5jaWVzLCBjb250YWluZWRBdG9tcyB9IG9mIGNodW5rc1RvQ2hlY2spIHtcbiAgICAgICAgZGVwZW5kZW5jeUF0b21zIHw9IGNvbnRhaW5lZEF0b21zO1xuICAgICAgICBjb25zdCBjb250YWluZWRTaWRlRWZmZWN0cyA9IGNvbnRhaW5lZEF0b21zICYgc2lkZUVmZmVjdEF0b21zO1xuICAgICAgICBpZiAoKGNvcnJlbGF0ZWRBdG9tcyAmIGNvbnRhaW5lZFNpZGVFZmZlY3RzKSAhPT0gY29udGFpbmVkU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gZGVwZW5kZW5jeUNodW5rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2h1bmtzVG9DaGVjay5hZGQoZGVwZW5kZW5jeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdldEF0b21zU2l6ZUlmQmVsb3dMaW1pdChkZXBlbmRlbmN5QXRvbXMgJiB+Y29ycmVsYXRlZEF0b21zLCBjdXJyZW50QWRkaXRpb25hbFNpemUsIHNpemVCeUF0b20pO1xufVxuZnVuY3Rpb24gZ2V0QXRvbXNTaXplSWZCZWxvd0xpbWl0KGF0b21zLCBjdXJyZW50QWRkaXRpb25hbFNpemUsIHNpemVCeUF0b20pIHtcbiAgICBsZXQgc2l6ZSA9IDA7XG4gICAgbGV0IGF0b21JbmRleCA9IDA7XG4gICAgbGV0IGF0b21TaWduYXR1cmUgPSAxbjtcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gc2l6ZUJ5QXRvbTtcbiAgICBmb3IgKDsgYXRvbUluZGV4IDwgbGVuZ3RoOyBhdG9tSW5kZXgrKykge1xuICAgICAgICBpZiAoKGF0b21zICYgYXRvbVNpZ25hdHVyZSkgPT09IGF0b21TaWduYXR1cmUpIHtcbiAgICAgICAgICAgIHNpemUgKz0gc2l6ZUJ5QXRvbVthdG9tSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGF0b21TaWduYXR1cmUgPDw9IDFuO1xuICAgICAgICBpZiAoc2l6ZSA+PSBjdXJyZW50QWRkaXRpb25hbFNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn1cbmZ1bmN0aW9uIGdldENodW5rc0luUGFydGl0aW9uKGNodW5rLCBtaW5DaHVua1NpemUsIGNodW5rUGFydGl0aW9uKSB7XG4gICAgcmV0dXJuIGNodW5rLnNpemUgPCBtaW5DaHVua1NpemUgPyBjaHVua1BhcnRpdGlvbi5zbWFsbCA6IGNodW5rUGFydGl0aW9uLmJpZztcbn1cblxuLy8gcG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL25vZGUtY29tbW9uZGlyXG5mdW5jdGlvbiBjb21tb25kaXIoZmlsZXMpIHtcbiAgICBpZiAoZmlsZXMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gJy8nO1xuICAgIGlmIChmaWxlcy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBkaXJuYW1lKGZpbGVzWzBdKTtcbiAgICBjb25zdCBjb21tb25TZWdtZW50cyA9IGZpbGVzLnNsaWNlKDEpLnJlZHVjZSgoY29tbW9uU2VnbWVudHMsIGZpbGUpID0+IHtcbiAgICAgICAgY29uc3QgcGF0aFNlZ21lbnRzID0gZmlsZS5zcGxpdCgvXFwvK3xcXFxcKy8pO1xuICAgICAgICBsZXQgaW5kZXg7XG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBjb21tb25TZWdtZW50c1tpbmRleF0gPT09IHBhdGhTZWdtZW50c1tpbmRleF0gJiZcbiAgICAgICAgICAgIGluZGV4IDwgTWF0aC5taW4oY29tbW9uU2VnbWVudHMubGVuZ3RoLCBwYXRoU2VnbWVudHMubGVuZ3RoKTsgaW5kZXgrKylcbiAgICAgICAgICAgIDtcbiAgICAgICAgcmV0dXJuIGNvbW1vblNlZ21lbnRzLnNsaWNlKDAsIGluZGV4KTtcbiAgICB9LCBmaWxlc1swXS5zcGxpdCgvXFwvK3xcXFxcKy8pKTtcbiAgICAvLyBXaW5kb3dzIGNvcnJlY3RseSBoYW5kbGVzIHBhdGhzIHdpdGggZm9yd2FyZC1zbGFzaGVzXG4gICAgcmV0dXJuIGNvbW1vblNlZ21lbnRzLmxlbmd0aCA+IDEgPyBjb21tb25TZWdtZW50cy5qb2luKCcvJykgOiAnLyc7XG59XG5cbmNvbnN0IGNvbXBhcmVFeGVjSW5kZXggPSAodW5pdEEsIHVuaXRCKSA9PiB1bml0QS5leGVjSW5kZXggPiB1bml0Qi5leGVjSW5kZXggPyAxIDogLTE7XG5mdW5jdGlvbiBzb3J0QnlFeGVjdXRpb25PcmRlcih1bml0cykge1xuICAgIHVuaXRzLnNvcnQoY29tcGFyZUV4ZWNJbmRleCk7XG59XG4vLyBUaGlzIHByb2Nlc3MgaXMgY3VycmVudGx5IGZhdWx0eSBpbiBzbyBmYXIgYXMgaXQgb25seSB0YWtlcyB0aGUgZmlyc3QgZW50cnlcbi8vIG1vZHVsZSBpbnRvIGFjY291bnQgYW5kIGFzc3VtZXMgdGhhdCBkeW5hbWljIGltcG9ydHMgYXJlIGltcG9ydGVkIGluIGFcbi8vIGNlcnRhaW4gb3JkZXIuXG4vLyBBIGJldHRlciBhbGdvcml0aG0gd291bGQgZm9sbG93IGV2ZXJ5IHBvc3NpYmxlIGV4ZWN1dGlvbiBwYXRoIGFuZCBtYXJrIHdoaWNoXG4vLyBtb2R1bGVzIGFyZSBleGVjdXRlZCBiZWZvcmUgb3IgYWZ0ZXIgd2hpY2ggb3RoZXIgbW9kdWxlcy4gVEhlbiB0aGUgY2h1bmtpbmdcbi8vIHdvdWxkIG5lZWQgdG8gdGFrZSBjYXJlIHRoYXQgaW4gZWFjaCBjaHVuaywgYWxsIG1vZHVsZXMgYXJlIGFsd2F5cyBleGVjdXRlZFxuLy8gaW4gdGhlIHNhbWUgc2VxdWVuY2UuXG5mdW5jdGlvbiBhbmFseXNlTW9kdWxlRXhlY3V0aW9uKGVudHJ5TW9kdWxlcykge1xuICAgIGxldCBuZXh0RXhlY0luZGV4ID0gMDtcbiAgICBjb25zdCBjeWNsZVBhdGhzID0gW107XG4gICAgY29uc3QgYW5hbHlzZWRNb2R1bGVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGR5bmFtaWNJbXBvcnRzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHBhcmVudHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgb3JkZXJlZE1vZHVsZXMgPSBbXTtcbiAgICBjb25zdCBhbmFseXNlTW9kdWxlID0gKG1vZHVsZSkgPT4ge1xuICAgICAgICBpZiAobW9kdWxlIGluc3RhbmNlb2YgTW9kdWxlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgbW9kdWxlLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRzLmhhcyhkZXBlbmRlbmN5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFuYWx5c2VkTW9kdWxlcy5oYXMoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5Y2xlUGF0aHMucHVzaChnZXRDeWNsZVBhdGgoZGVwZW5kZW5jeSwgbW9kdWxlLCBwYXJlbnRzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudHMuc2V0KGRlcGVuZGVuY3ksIG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgYW5hbHlzZU1vZHVsZShkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVwZW5kZW5jeSBvZiBtb2R1bGUuaW1wbGljaXRseUxvYWRlZEJlZm9yZSkge1xuICAgICAgICAgICAgICAgIGR5bmFtaWNJbXBvcnRzLmFkZChkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgeyByZXNvbHV0aW9uIH0gb2YgbW9kdWxlLmR5bmFtaWNJbXBvcnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdXRpb24gaW5zdGFuY2VvZiBNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY0ltcG9ydHMuYWRkKHJlc29sdXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9yZGVyZWRNb2R1bGVzLnB1c2gobW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgICBtb2R1bGUuZXhlY0luZGV4ID0gbmV4dEV4ZWNJbmRleCsrO1xuICAgICAgICBhbmFseXNlZE1vZHVsZXMuYWRkKG1vZHVsZSk7XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGN1cnJlbnRFbnRyeSBvZiBlbnRyeU1vZHVsZXMpIHtcbiAgICAgICAgaWYgKCFwYXJlbnRzLmhhcyhjdXJyZW50RW50cnkpKSB7XG4gICAgICAgICAgICBwYXJlbnRzLnNldChjdXJyZW50RW50cnksIG51bGwpO1xuICAgICAgICAgICAgYW5hbHlzZU1vZHVsZShjdXJyZW50RW50cnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgY3VycmVudEVudHJ5IG9mIGR5bmFtaWNJbXBvcnRzKSB7XG4gICAgICAgIGlmICghcGFyZW50cy5oYXMoY3VycmVudEVudHJ5KSkge1xuICAgICAgICAgICAgcGFyZW50cy5zZXQoY3VycmVudEVudHJ5LCBudWxsKTtcbiAgICAgICAgICAgIGFuYWx5c2VNb2R1bGUoY3VycmVudEVudHJ5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBjeWNsZVBhdGhzLCBvcmRlcmVkTW9kdWxlcyB9O1xufVxuZnVuY3Rpb24gZ2V0Q3ljbGVQYXRoKG1vZHVsZSwgcGFyZW50LCBwYXJlbnRzKSB7XG4gICAgY29uc3QgY3ljbGVTeW1ib2wgPSBTeW1ib2wobW9kdWxlLmlkKTtcbiAgICBjb25zdCBwYXRoID0gW21vZHVsZS5pZF07XG4gICAgbGV0IG5leHRNb2R1bGUgPSBwYXJlbnQ7XG4gICAgbW9kdWxlLmN5Y2xlcy5hZGQoY3ljbGVTeW1ib2wpO1xuICAgIHdoaWxlIChuZXh0TW9kdWxlICE9PSBtb2R1bGUpIHtcbiAgICAgICAgbmV4dE1vZHVsZS5jeWNsZXMuYWRkKGN5Y2xlU3ltYm9sKTtcbiAgICAgICAgcGF0aC5wdXNoKG5leHRNb2R1bGUuaWQpO1xuICAgICAgICBuZXh0TW9kdWxlID0gcGFyZW50cy5nZXQobmV4dE1vZHVsZSk7XG4gICAgfVxuICAgIHBhdGgucHVzaChwYXRoWzBdKTtcbiAgICBwYXRoLnJldmVyc2UoKTtcbiAgICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gZ2V0R2VuZXJhdGVDb2RlU25pcHBldHMoeyBjb21wYWN0LCBnZW5lcmF0ZWRDb2RlOiB7IGFycm93RnVuY3Rpb25zLCBjb25zdEJpbmRpbmdzLCBvYmplY3RTaG9ydGhhbmQsIHJlc2VydmVkTmFtZXNBc1Byb3BzIH0gfSkge1xuICAgIGNvbnN0IHsgXywgbiwgcyB9ID0gY29tcGFjdCA/IHsgXzogJycsIG46ICcnLCBzOiAnJyB9IDogeyBfOiAnICcsIG46ICdcXG4nLCBzOiAnOycgfTtcbiAgICBjb25zdCBjbnN0ID0gY29uc3RCaW5kaW5ncyA/ICdjb25zdCcgOiAndmFyJztcbiAgICBjb25zdCBnZXROb25BcnJvd0Z1bmN0aW9uSW50cm8gPSAocGFyYW1ldGVycywgeyBpc0FzeW5jLCBuYW1lIH0pID0+IGAke2lzQXN5bmMgPyBgYXN5bmMgYCA6ICcnfWZ1bmN0aW9uJHtuYW1lID8gYCAke25hbWV9YCA6ICcnfSR7X30oJHtwYXJhbWV0ZXJzLmpvaW4oYCwke199YCl9KSR7X31gO1xuICAgIGNvbnN0IGdldEZ1bmN0aW9uSW50cm8gPSBhcnJvd0Z1bmN0aW9uc1xuICAgICAgICA/IChwYXJhbWV0ZXJzLCB7IGlzQXN5bmMsIG5hbWUgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2luZ2xlUGFyYW1ldGVyID0gcGFyYW1ldGVycy5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICBjb25zdCBhc3luY1N0cmluZyA9IGlzQXN5bmMgPyBgYXN5bmMke3NpbmdsZVBhcmFtZXRlciA/ICcgJyA6IF99YCA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuIGAke25hbWUgPyBgJHtjbnN0fSAke25hbWV9JHtffT0ke199YCA6ICcnfSR7YXN5bmNTdHJpbmd9JHtzaW5nbGVQYXJhbWV0ZXIgPyBwYXJhbWV0ZXJzWzBdIDogYCgke3BhcmFtZXRlcnMuam9pbihgLCR7X31gKX0pYH0ke199PT4ke199YDtcbiAgICAgICAgfVxuICAgICAgICA6IGdldE5vbkFycm93RnVuY3Rpb25JbnRybztcbiAgICBjb25zdCBnZXREaXJlY3RSZXR1cm5GdW5jdGlvbiA9IChwYXJhbWV0ZXJzLCB7IGZ1bmN0aW9uUmV0dXJuLCBsaW5lQnJlYWtJbmRlbnQsIG5hbWUgfSkgPT4gW1xuICAgICAgICBgJHtnZXRGdW5jdGlvbkludHJvKHBhcmFtZXRlcnMsIHtcbiAgICAgICAgICAgIGlzQXN5bmM6IGZhbHNlLFxuICAgICAgICAgICAgbmFtZVxuICAgICAgICB9KX0ke2Fycm93RnVuY3Rpb25zXG4gICAgICAgICAgICA/IGxpbmVCcmVha0luZGVudFxuICAgICAgICAgICAgICAgID8gYCR7bn0ke2xpbmVCcmVha0luZGVudC5iYXNlfSR7bGluZUJyZWFrSW5kZW50LnR9YFxuICAgICAgICAgICAgICAgIDogJydcbiAgICAgICAgICAgIDogYHske2xpbmVCcmVha0luZGVudCA/IGAke259JHtsaW5lQnJlYWtJbmRlbnQuYmFzZX0ke2xpbmVCcmVha0luZGVudC50fWAgOiBffSR7ZnVuY3Rpb25SZXR1cm4gPyAncmV0dXJuICcgOiAnJ31gfWAsXG4gICAgICAgIGFycm93RnVuY3Rpb25zXG4gICAgICAgICAgICA/IGAke25hbWUgPyAnOycgOiAnJ30ke2xpbmVCcmVha0luZGVudCA/IGAke259JHtsaW5lQnJlYWtJbmRlbnQuYmFzZX1gIDogJyd9YFxuICAgICAgICAgICAgOiBgJHtzfSR7bGluZUJyZWFrSW5kZW50ID8gYCR7bn0ke2xpbmVCcmVha0luZGVudC5iYXNlfWAgOiBffX1gXG4gICAgXTtcbiAgICBjb25zdCBpc1ZhbGlkUHJvcGVydHlOYW1lID0gcmVzZXJ2ZWROYW1lc0FzUHJvcHNcbiAgICAgICAgPyAobmFtZSkgPT4gVkFMSURfSURFTlRJRklFUl9SRUdFWFAudGVzdChuYW1lKVxuICAgICAgICA6IChuYW1lKSA9PiAhUkVTRVJWRURfTkFNRVMuaGFzKG5hbWUpICYmIFZBTElEX0lERU5USUZJRVJfUkVHRVhQLnRlc3QobmFtZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgXyxcbiAgICAgICAgY25zdCxcbiAgICAgICAgZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb24sXG4gICAgICAgIGdldERpcmVjdFJldHVybklpZmVMZWZ0OiAocGFyYW1ldGVycywgcmV0dXJuZWQsIHsgbmVlZHNBcnJvd1JldHVyblBhcmVucywgbmVlZHNXcmFwcGVkRnVuY3Rpb24gfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGdldERpcmVjdFJldHVybkZ1bmN0aW9uKHBhcmFtZXRlcnMsIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvblJldHVybjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsaW5lQnJlYWtJbmRlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgbmFtZTogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYCR7d3JhcElmTmVlZGVkKGAke2xlZnR9JHt3cmFwSWZOZWVkZWQocmV0dXJuZWQsIGFycm93RnVuY3Rpb25zICYmIG5lZWRzQXJyb3dSZXR1cm5QYXJlbnMpfSR7cmlnaHR9YCwgYXJyb3dGdW5jdGlvbnMgfHwgbmVlZHNXcmFwcGVkRnVuY3Rpb24pfShgO1xuICAgICAgICB9LFxuICAgICAgICBnZXRGdW5jdGlvbkludHJvLFxuICAgICAgICBnZXROb25BcnJvd0Z1bmN0aW9uSW50cm8sXG4gICAgICAgIGdldE9iamVjdChmaWVsZHMsIHsgbGluZUJyZWFrSW5kZW50IH0pIHtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IGxpbmVCcmVha0luZGVudCA/IGAke259JHtsaW5lQnJlYWtJbmRlbnQuYmFzZX0ke2xpbmVCcmVha0luZGVudC50fWAgOiBfO1xuICAgICAgICAgICAgcmV0dXJuIGB7JHtmaWVsZHNcbiAgICAgICAgICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7cHJlZml4fSR7dmFsdWV9YDtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbk9iamVjdCA9IHN0cmluZ2lmeU9iamVjdEtleUlmTmVlZGVkKGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleSA9PT0gdmFsdWUgJiYgb2JqZWN0U2hvcnRoYW5kICYmIGtleSA9PT0ga2V5SW5PYmplY3RcbiAgICAgICAgICAgICAgICAgICAgPyBwcmVmaXggKyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiBgJHtwcmVmaXh9JHtrZXlJbk9iamVjdH06JHtffSR7dmFsdWV9YDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oYCxgKX0ke2ZpZWxkcy5sZW5ndGggPT09IDAgPyAnJyA6IGxpbmVCcmVha0luZGVudCA/IGAke259JHtsaW5lQnJlYWtJbmRlbnQuYmFzZX1gIDogX319YDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UHJvcGVydHlBY2Nlc3M6IChuYW1lKSA9PiBpc1ZhbGlkUHJvcGVydHlOYW1lKG5hbWUpID8gYC4ke25hbWV9YCA6IGBbJHtKU09OLnN0cmluZ2lmeShuYW1lKX1dYCxcbiAgICAgICAgbixcbiAgICAgICAgc1xuICAgIH07XG59XG5jb25zdCB3cmFwSWZOZWVkZWQgPSAoY29kZSwgbmVlZHNQYXJlbnMpID0+IG5lZWRzUGFyZW5zID8gYCgke2NvZGV9KWAgOiBjb2RlO1xuXG5jbGFzcyBTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKGZpbGVuYW1lLCBjb250ZW50KSB7XG4gICAgICAgIHRoaXMuaXNPcmlnaW5hbCA9IHRydWU7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB9XG4gICAgdHJhY2VTZWdtZW50KGxpbmUsIGNvbHVtbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4geyBjb2x1bW4sIGxpbmUsIG5hbWUsIHNvdXJjZTogdGhpcyB9O1xuICAgIH1cbn1cbmNsYXNzIExpbmsge1xuICAgIGNvbnN0cnVjdG9yKG1hcCwgc291cmNlcykge1xuICAgICAgICB0aGlzLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgICAgICB0aGlzLm5hbWVzID0gbWFwLm5hbWVzO1xuICAgICAgICB0aGlzLm1hcHBpbmdzID0gbWFwLm1hcHBpbmdzO1xuICAgIH1cbiAgICB0cmFjZU1hcHBpbmdzKCkge1xuICAgICAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgICAgIGNvbnN0IHNvdXJjZUluZGV4TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBzb3VyY2VzQ29udGVudCA9IFtdO1xuICAgICAgICBjb25zdCBuYW1lcyA9IFtdO1xuICAgICAgICBjb25zdCBuYW1lSW5kZXhNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IG1hcHBpbmdzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLm1hcHBpbmdzKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFjZWRMaW5lID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgbGluZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2VzW3NlZ21lbnRbMV1dO1xuICAgICAgICAgICAgICAgIGlmICghc291cmNlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFjZWQgPSBzb3VyY2UudHJhY2VTZWdtZW50KHNlZ21lbnRbMl0sIHNlZ21lbnRbM10sIHNlZ21lbnQubGVuZ3RoID09PSA1ID8gdGhpcy5uYW1lc1tzZWdtZW50WzRdXSA6ICcnKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY29sdW1uLCBsaW5lLCBuYW1lLCBzb3VyY2U6IHsgY29udGVudCwgZmlsZW5hbWUgfSB9ID0gdHJhY2VkO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc291cmNlSW5kZXggPSBzb3VyY2VJbmRleE1hcC5nZXQoZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlSW5kZXggPSBzb3VyY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZXMucHVzaChmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VJbmRleE1hcC5zZXQoZmlsZW5hbWUsIHNvdXJjZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZXNDb250ZW50W3NvdXJjZUluZGV4XSA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlc0NvbnRlbnRbc291cmNlSW5kZXhdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZXNDb250ZW50W3NvdXJjZUluZGV4XSA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGVudCAhPSBudWxsICYmIHNvdXJjZXNDb250ZW50W3NvdXJjZUluZGV4XSAhPT0gY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGxvZ0NvbmZsaWN0aW5nU291cmNlbWFwU291cmNlcyhmaWxlbmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNlZFNlZ21lbnQgPSBbc2VnbWVudFswXSwgc291cmNlSW5kZXgsIGxpbmUsIGNvbHVtbl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZUluZGV4ID0gbmFtZUluZGV4TWFwLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVJbmRleCA9IG5hbWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVJbmRleE1hcC5zZXQobmFtZSwgbmFtZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlZFNlZ21lbnRbNF0gPSBuYW1lSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJhY2VkTGluZS5wdXNoKHRyYWNlZFNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcHBpbmdzLnB1c2godHJhY2VkTGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWFwcGluZ3MsIG5hbWVzLCBzb3VyY2VzLCBzb3VyY2VzQ29udGVudCB9O1xuICAgIH1cbiAgICB0cmFjZVNlZ21lbnQobGluZSwgY29sdW1uLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5tYXBwaW5nc1tsaW5lXTtcbiAgICAgICAgaWYgKCFzZWdtZW50cylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvLyBiaW5hcnkgc2VhcmNoIHRocm91Z2ggc2VnbWVudHMgZm9yIHRoZSBnaXZlbiBjb2x1bW5cbiAgICAgICAgbGV0IHNlYXJjaFN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IHNlYXJjaEVuZCA9IHNlZ21lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChzZWFyY2hTdGFydCA8PSBzZWFyY2hFbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSAoc2VhcmNoU3RhcnQgKyBzZWFyY2hFbmQpID4+IDE7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbbV07XG4gICAgICAgICAgICAvLyBJZiBhIHNvdXJjZW1hcCBkb2VzIG5vdCBoYXZlIHN1ZmZpY2llbnQgcmVzb2x1dGlvbiB0byBjb250YWluIGFcbiAgICAgICAgICAgIC8vIG5lY2Vzc2FyeSBtYXBwaW5nLCBlLmcuIGJlY2F1c2UgaXQgb25seSBjb250YWlucyBsaW5lIGluZm9ybWF0aW9uLCB3ZVxuICAgICAgICAgICAgLy8gdXNlIHRoZSBiZXN0IGFwcHJveGltYXRpb24gd2UgY291bGQgZmluZFxuICAgICAgICAgICAgaWYgKHNlZ21lbnRbMF0gPT09IGNvbHVtbiB8fCBzZWFyY2hTdGFydCA9PT0gc2VhcmNoRW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlc1tzZWdtZW50WzFdXTtcbiAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS50cmFjZVNlZ21lbnQoc2VnbWVudFsyXSwgc2VnbWVudFszXSwgc2VnbWVudC5sZW5ndGggPT09IDUgPyB0aGlzLm5hbWVzW3NlZ21lbnRbNF1dIDogbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VnbWVudFswXSA+IGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHNlYXJjaEVuZCA9IG0gLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoU3RhcnQgPSBtICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRMaW5rTWFwKGxvZykge1xuICAgIHJldHVybiBmdW5jdGlvbiBsaW5rTWFwKHNvdXJjZSwgbWFwKSB7XG4gICAgICAgIGlmICghbWFwLm1pc3NpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGluayhtYXAsIFtzb3VyY2VdKTtcbiAgICAgICAgfVxuICAgICAgICBsb2coTE9HTEVWRUxfV0FSTiwgbG9nU291cmNlbWFwQnJva2VuKG1hcC5wbHVnaW4pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rKHtcbiAgICAgICAgICAgIG1hcHBpbmdzOiBbXSxcbiAgICAgICAgICAgIG5hbWVzOiBbXVxuICAgICAgICB9LCBbc291cmNlXSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldENvbGxhcHNlZFNvdXJjZW1hcChpZCwgb3JpZ2luYWxDb2RlLCBvcmlnaW5hbFNvdXJjZW1hcCwgc291cmNlbWFwQ2hhaW4sIGxpbmtNYXApIHtcbiAgICBsZXQgc291cmNlO1xuICAgIGlmIChvcmlnaW5hbFNvdXJjZW1hcCkge1xuICAgICAgICBjb25zdCBzb3VyY2VzID0gb3JpZ2luYWxTb3VyY2VtYXAuc291cmNlcztcbiAgICAgICAgY29uc3Qgc291cmNlc0NvbnRlbnQgPSBvcmlnaW5hbFNvdXJjZW1hcC5zb3VyY2VzQ29udGVudCB8fCBbXTtcbiAgICAgICAgY29uc3QgZGlyZWN0b3J5ID0gZGlybmFtZShpZCkgfHwgJy4nO1xuICAgICAgICBjb25zdCBzb3VyY2VSb290ID0gb3JpZ2luYWxTb3VyY2VtYXAuc291cmNlUm9vdCB8fCAnLic7XG4gICAgICAgIGNvbnN0IGJhc2VTb3VyY2VzID0gc291cmNlcy5tYXAoKHNvdXJjZSwgaW5kZXgpID0+IG5ldyBTb3VyY2UocmVzb2x2ZSQxKGRpcmVjdG9yeSwgc291cmNlUm9vdCwgc291cmNlKSwgc291cmNlc0NvbnRlbnRbaW5kZXhdKSk7XG4gICAgICAgIHNvdXJjZSA9IG5ldyBMaW5rKG9yaWdpbmFsU291cmNlbWFwLCBiYXNlU291cmNlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzb3VyY2UgPSBuZXcgU291cmNlKGlkLCBvcmlnaW5hbENvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlbWFwQ2hhaW4ucmVkdWNlKGxpbmtNYXAsIHNvdXJjZSk7XG59XG5mdW5jdGlvbiBjb2xsYXBzZVNvdXJjZW1hcHMoZmlsZSwgbWFwLCBtb2R1bGVzLCBidW5kbGVTb3VyY2VtYXBDaGFpbiwgZXhjbHVkZUNvbnRlbnQsIGxvZykge1xuICAgIGNvbnN0IGxpbmtNYXAgPSBnZXRMaW5rTWFwKGxvZyk7XG4gICAgY29uc3QgbW9kdWxlU291cmNlcyA9IG1vZHVsZXNcbiAgICAgICAgLmZpbHRlcihtb2R1bGUgPT4gIW1vZHVsZS5leGNsdWRlRnJvbVNvdXJjZW1hcClcbiAgICAgICAgLm1hcChtb2R1bGUgPT4gZ2V0Q29sbGFwc2VkU291cmNlbWFwKG1vZHVsZS5pZCwgbW9kdWxlLm9yaWdpbmFsQ29kZSwgbW9kdWxlLm9yaWdpbmFsU291cmNlbWFwLCBtb2R1bGUuc291cmNlbWFwQ2hhaW4sIGxpbmtNYXApKTtcbiAgICBjb25zdCBsaW5rID0gbmV3IExpbmsobWFwLCBtb2R1bGVTb3VyY2VzKTtcbiAgICBjb25zdCBzb3VyY2UgPSBidW5kbGVTb3VyY2VtYXBDaGFpbi5yZWR1Y2UobGlua01hcCwgbGluayk7XG4gICAgbGV0IHsgc291cmNlcywgc291cmNlc0NvbnRlbnQsIG5hbWVzLCBtYXBwaW5ncyB9ID0gc291cmNlLnRyYWNlTWFwcGluZ3MoKTtcbiAgICBpZiAoZmlsZSkge1xuICAgICAgICBjb25zdCBkaXJlY3RvcnkgPSBkaXJuYW1lKGZpbGUpO1xuICAgICAgICBzb3VyY2VzID0gc291cmNlcy5tYXAoKHNvdXJjZSkgPT4gcmVsYXRpdmUoZGlyZWN0b3J5LCBzb3VyY2UpKTtcbiAgICAgICAgZmlsZSA9IGJhc2VuYW1lKGZpbGUpO1xuICAgIH1cbiAgICBzb3VyY2VzQ29udGVudCA9IChleGNsdWRlQ29udGVudCA/IG51bGwgOiBzb3VyY2VzQ29udGVudCk7XG4gICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlcykge1xuICAgICAgICByZXNldFNvdXJjZW1hcENhY2hlKG1vZHVsZS5vcmlnaW5hbFNvdXJjZW1hcCwgbW9kdWxlLnNvdXJjZW1hcENoYWluKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTb3VyY2VNYXAoeyBmaWxlLCBtYXBwaW5ncywgbmFtZXMsIHNvdXJjZXMsIHNvdXJjZXNDb250ZW50IH0pO1xufVxuZnVuY3Rpb24gY29sbGFwc2VTb3VyY2VtYXAoaWQsIG9yaWdpbmFsQ29kZSwgb3JpZ2luYWxTb3VyY2VtYXAsIHNvdXJjZW1hcENoYWluLCBsb2cpIHtcbiAgICBpZiAoc291cmNlbWFwQ2hhaW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFNvdXJjZW1hcDtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gZ2V0Q29sbGFwc2VkU291cmNlbWFwKGlkLCBvcmlnaW5hbENvZGUsIG9yaWdpbmFsU291cmNlbWFwLCBzb3VyY2VtYXBDaGFpbiwgZ2V0TGlua01hcChsb2cpKTtcbiAgICBjb25zdCBtYXAgPSBzb3VyY2UudHJhY2VNYXBwaW5ncygpO1xuICAgIHJldHVybiBkZWNvZGVkU291cmNlbWFwKHsgdmVyc2lvbjogMywgLi4ubWFwIH0pO1xufVxuXG5sZXQgdGV4dEVuY29kZXI7XG5jb25zdCBnZXRIYXNoNjQgPSBpbnB1dCA9PiB4eGhhc2hCYXNlNjRVcmwoZW5zdXJlQnVmZmVyKGlucHV0KSk7XG5jb25zdCBnZXRIYXNoMzYgPSBpbnB1dCA9PiB4eGhhc2hCYXNlMzYoZW5zdXJlQnVmZmVyKGlucHV0KSk7XG5jb25zdCBnZXRIYXNoMTYgPSBpbnB1dCA9PiB4eGhhc2hCYXNlMTYoZW5zdXJlQnVmZmVyKGlucHV0KSk7XG5jb25zdCBoYXNoZXJCeVR5cGUgPSB7XG4gICAgYmFzZTM2OiBnZXRIYXNoMzYsXG4gICAgYmFzZTY0OiBnZXRIYXNoNjQsXG4gICAgaGV4OiBnZXRIYXNoMTZcbn07XG5mdW5jdGlvbiBlbnN1cmVCdWZmZXIoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRleHRFbmNvZGVyID8/PSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0RW5jb2Rlci5lbmNvZGUoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dDtcbn1cblxuLy8gdGhpcyBsb29rcyByaWRpY3Vsb3VzLCBidXQgaXQgcHJldmVudHMgc291cmNlbWFwIHRvb2xpbmcgZnJvbSBtaXN0YWtpbmdcbi8vIHRoaXMgZm9yIGFuIGFjdHVhbCBzb3VyY2VNYXBwaW5nVVJMXG5sZXQgU09VUkNFTUFQUElOR19VUkwgPSAnc291cmNlTWEnO1xuU09VUkNFTUFQUElOR19VUkwgKz0gJ3BwaW5nVVJMJztcblxuYXN5bmMgZnVuY3Rpb24gcmVuZGVyQ2h1bmtzKGNodW5rcywgYnVuZGxlLCBwbHVnaW5Ecml2ZXIsIG91dHB1dE9wdGlvbnMsIGxvZykge1xuICAgIHRpbWVTdGFydCgncmVuZGVyIGNodW5rcycsIDIpO1xuICAgIHJlc2VydmVFbnRyeUNodW5rc0luQnVuZGxlKGNodW5rcyk7XG4gICAgY29uc3QgcmVuZGVyZWRDaHVua3MgPSBhd2FpdCBQcm9taXNlLmFsbChjaHVua3MubWFwKGNodW5rID0+IGNodW5rLnJlbmRlcigpKSk7XG4gICAgdGltZUVuZCgncmVuZGVyIGNodW5rcycsIDIpO1xuICAgIHRpbWVTdGFydCgndHJhbnNmb3JtIGNodW5rcycsIDIpO1xuICAgIGNvbnN0IGdldEhhc2ggPSBoYXNoZXJCeVR5cGVbb3V0cHV0T3B0aW9ucy5oYXNoQ2hhcmFjdGVyc107XG4gICAgY29uc3QgY2h1bmtHcmFwaCA9IGdldENodW5rR3JhcGgoY2h1bmtzKTtcbiAgICBjb25zdCB7IGhhc2hEZXBlbmRlbmNpZXNCeVBsYWNlaG9sZGVyLCBpbml0aWFsSGFzaGVzQnlQbGFjZWhvbGRlciwgbm9uSGFzaGVkQ2h1bmtzV2l0aFBsYWNlaG9sZGVycywgcGxhY2Vob2xkZXJzLCByZW5kZXJlZENodW5rc0J5UGxhY2Vob2xkZXIgfSA9IGF3YWl0IHRyYW5zZm9ybUNodW5rc0FuZEdlbmVyYXRlQ29udGVudEhhc2hlcyhyZW5kZXJlZENodW5rcywgY2h1bmtHcmFwaCwgb3V0cHV0T3B0aW9ucywgcGx1Z2luRHJpdmVyLCBnZXRIYXNoLCBsb2cpO1xuICAgIGNvbnN0IGhhc2hlc0J5UGxhY2Vob2xkZXIgPSBnZW5lcmF0ZUZpbmFsSGFzaGVzKHJlbmRlcmVkQ2h1bmtzQnlQbGFjZWhvbGRlciwgaGFzaERlcGVuZGVuY2llc0J5UGxhY2Vob2xkZXIsIGluaXRpYWxIYXNoZXNCeVBsYWNlaG9sZGVyLCBwbGFjZWhvbGRlcnMsIGJ1bmRsZSwgZ2V0SGFzaCk7XG4gICAgYWRkQ2h1bmtzVG9CdW5kbGUocmVuZGVyZWRDaHVua3NCeVBsYWNlaG9sZGVyLCBoYXNoZXNCeVBsYWNlaG9sZGVyLCBidW5kbGUsIG5vbkhhc2hlZENodW5rc1dpdGhQbGFjZWhvbGRlcnMsIHBsdWdpbkRyaXZlciwgb3V0cHV0T3B0aW9ucyk7XG4gICAgdGltZUVuZCgndHJhbnNmb3JtIGNodW5rcycsIDIpO1xufVxuZnVuY3Rpb24gcmVzZXJ2ZUVudHJ5Q2h1bmtzSW5CdW5kbGUoY2h1bmtzKSB7XG4gICAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgICAgaWYgKGNodW5rLmZhY2FkZU1vZHVsZSAmJiBjaHVuay5mYWNhZGVNb2R1bGUuaXNVc2VyRGVmaW5lZEVudHJ5UG9pbnQpIHtcbiAgICAgICAgICAgIC8vIHJlc2VydmVzIG5hbWUgaW4gYnVuZGxlIGFzIHNpZGUgZWZmZWN0IGlmIGl0IGRvZXMgbm90IGNvbnRhaW4gYSBoYXNoXG4gICAgICAgICAgICBjaHVuay5nZXRQcmVsaW1pbmFyeUZpbGVOYW1lKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDaHVua0dyYXBoKGNodW5rcykge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoY2h1bmtzLm1hcChjaHVuayA9PiB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVkQ2h1bmtJbmZvID0gY2h1bmsuZ2V0UmVuZGVyZWRDaHVua0luZm8oKTtcbiAgICAgICAgcmV0dXJuIFtyZW5kZXJlZENodW5rSW5mby5maWxlTmFtZSwgcmVuZGVyZWRDaHVua0luZm9dO1xuICAgIH0pKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHRyYW5zZm9ybUNodW5rKG1hZ2ljU3RyaW5nLCBmaWxlTmFtZSwgdXNlZE1vZHVsZXMsIGNodW5rR3JhcGgsIG9wdGlvbnMsIG91dHB1dFBsdWdpbkRyaXZlciwgbG9nKSB7XG4gICAgbGV0IG1hcCA9IG51bGw7XG4gICAgY29uc3Qgc291cmNlbWFwQ2hhaW4gPSBbXTtcbiAgICBsZXQgY29kZSA9IGF3YWl0IG91dHB1dFBsdWdpbkRyaXZlci5ob29rUmVkdWNlQXJnMCgncmVuZGVyQ2h1bmsnLCBbbWFnaWNTdHJpbmcudG9TdHJpbmcoKSwgY2h1bmtHcmFwaFtmaWxlTmFtZV0sIG9wdGlvbnMsIHsgY2h1bmtzOiBjaHVua0dyYXBoIH1dLCAoY29kZSwgcmVzdWx0LCBwbHVnaW4pID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgbWFwOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIC8vIHN0cmljdCBudWxsIGNoZWNrIGFsbG93cyAnbnVsbCcgbWFwcyB0byBub3QgYmUgcHVzaGVkIHRvIHRoZSBjaGFpbiwgd2hpbGUgJ3VuZGVmaW5lZCcgZ2V0cyB0aGUgbWlzc2luZyBtYXAgd2FybmluZ1xuICAgICAgICBpZiAocmVzdWx0Lm1hcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbWFwID0gZGVjb2RlZFNvdXJjZW1hcChyZXN1bHQubWFwKTtcbiAgICAgICAgICAgIHNvdXJjZW1hcENoYWluLnB1c2gobWFwIHx8IHsgbWlzc2luZzogdHJ1ZSwgcGx1Z2luOiBwbHVnaW4ubmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmNvZGU7XG4gICAgfSk7XG4gICAgY29uc3QgeyBjb21wYWN0LCBkaXIsIGZpbGUsIHNvdXJjZW1hcCwgc291cmNlbWFwRXhjbHVkZVNvdXJjZXMsIHNvdXJjZW1hcEZpbGUsIHNvdXJjZW1hcFBhdGhUcmFuc2Zvcm0sIHNvdXJjZW1hcElnbm9yZUxpc3QgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFjb21wYWN0ICYmIGNvZGVbY29kZS5sZW5ndGggLSAxXSAhPT0gJ1xcbicpXG4gICAgICAgIGNvZGUgKz0gJ1xcbic7XG4gICAgaWYgKHNvdXJjZW1hcCkge1xuICAgICAgICB0aW1lU3RhcnQoJ3NvdXJjZW1hcHMnLCAzKTtcbiAgICAgICAgbGV0IHJlc3VsdGluZ0ZpbGU7XG4gICAgICAgIGlmIChmaWxlKVxuICAgICAgICAgICAgcmVzdWx0aW5nRmlsZSA9IHJlc29sdmUkMShzb3VyY2VtYXBGaWxlIHx8IGZpbGUpO1xuICAgICAgICBlbHNlIGlmIChkaXIpXG4gICAgICAgICAgICByZXN1bHRpbmdGaWxlID0gcmVzb2x2ZSQxKGRpciwgZmlsZU5hbWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXN1bHRpbmdGaWxlID0gcmVzb2x2ZSQxKGZpbGVOYW1lKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZE1hcCA9IG1hZ2ljU3RyaW5nLmdlbmVyYXRlRGVjb2RlZE1hcCh7fSk7XG4gICAgICAgIG1hcCA9IGNvbGxhcHNlU291cmNlbWFwcyhyZXN1bHRpbmdGaWxlLCBkZWNvZGVkTWFwLCB1c2VkTW9kdWxlcywgc291cmNlbWFwQ2hhaW4sIHNvdXJjZW1hcEV4Y2x1ZGVTb3VyY2VzLCBsb2cpO1xuICAgICAgICBmb3IgKGxldCBzb3VyY2VzSW5kZXggPSAwOyBzb3VyY2VzSW5kZXggPCBtYXAuc291cmNlcy5sZW5ndGg7ICsrc291cmNlc0luZGV4KSB7XG4gICAgICAgICAgICBsZXQgc291cmNlUGF0aCA9IG1hcC5zb3VyY2VzW3NvdXJjZXNJbmRleF07XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VtYXBQYXRoID0gYCR7cmVzdWx0aW5nRmlsZX0ubWFwYDtcbiAgICAgICAgICAgIGNvbnN0IGlnbm9yZUxpc3QgPSBzb3VyY2VtYXBJZ25vcmVMaXN0KHNvdXJjZVBhdGgsIHNvdXJjZW1hcFBhdGgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZ25vcmVMaXN0ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihsb2dGYWlsZWRWYWxpZGF0aW9uKCdzb3VyY2VtYXBJZ25vcmVMaXN0IGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgYm9vbGVhbi4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWdub3JlTGlzdCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXAueF9nb29nbGVfaWdub3JlTGlzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcC54X2dvb2dsZV9pZ25vcmVMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbWFwLnhfZ29vZ2xlX2lnbm9yZUxpc3QuaW5jbHVkZXMoc291cmNlc0luZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBtYXAueF9nb29nbGVfaWdub3JlTGlzdC5wdXNoKHNvdXJjZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZW1hcFBhdGhUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VQYXRoID0gc291cmNlbWFwUGF0aFRyYW5zZm9ybShzb3VyY2VQYXRoLCBzb3VyY2VtYXBQYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGxvZ0ZhaWxlZFZhbGlkYXRpb24oYHNvdXJjZW1hcFBhdGhUcmFuc2Zvcm0gZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBzdHJpbmcuYCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcC5zb3VyY2VzW3NvdXJjZXNJbmRleF0gPSBub3JtYWxpemUoc291cmNlUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGltZUVuZCgnc291cmNlbWFwcycsIDMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlLFxuICAgICAgICBtYXBcbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gdHJhbnNmb3JtQ2h1bmtzQW5kR2VuZXJhdGVDb250ZW50SGFzaGVzKHJlbmRlcmVkQ2h1bmtzLCBjaHVua0dyYXBoLCBvdXRwdXRPcHRpb25zLCBwbHVnaW5Ecml2ZXIsIGdldEhhc2gsIGxvZykge1xuICAgIGNvbnN0IG5vbkhhc2hlZENodW5rc1dpdGhQbGFjZWhvbGRlcnMgPSBbXTtcbiAgICBjb25zdCByZW5kZXJlZENodW5rc0J5UGxhY2Vob2xkZXIgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgaGFzaERlcGVuZGVuY2llc0J5UGxhY2Vob2xkZXIgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgaW5pdGlhbEhhc2hlc0J5UGxhY2Vob2xkZXIgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgeyBwcmVsaW1pbmFyeUZpbGVOYW1lOiB7IGhhc2hQbGFjZWhvbGRlciB9IH0gb2YgcmVuZGVyZWRDaHVua3MpIHtcbiAgICAgICAgaWYgKGhhc2hQbGFjZWhvbGRlcilcbiAgICAgICAgICAgIHBsYWNlaG9sZGVycy5hZGQoaGFzaFBsYWNlaG9sZGVyKTtcbiAgICB9XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocmVuZGVyZWRDaHVua3MubWFwKGFzeW5jICh7IGNodW5rLCBwcmVsaW1pbmFyeUZpbGVOYW1lOiB7IGZpbGVOYW1lLCBoYXNoUGxhY2Vob2xkZXIgfSwgcHJlbGltaW5hcnlTb3VyY2VtYXBGaWxlTmFtZSwgbWFnaWNTdHJpbmcsIHVzZWRNb2R1bGVzIH0pID0+IHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRDaHVuayA9IHtcbiAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgZmlsZU5hbWUsXG4gICAgICAgICAgICBzb3VyY2VtYXBGaWxlTmFtZTogcHJlbGltaW5hcnlTb3VyY2VtYXBGaWxlTmFtZT8uZmlsZU5hbWUgPz8gbnVsbCxcbiAgICAgICAgICAgIC4uLihhd2FpdCB0cmFuc2Zvcm1DaHVuayhtYWdpY1N0cmluZywgZmlsZU5hbWUsIHVzZWRNb2R1bGVzLCBjaHVua0dyYXBoLCBvdXRwdXRPcHRpb25zLCBwbHVnaW5Ecml2ZXIsIGxvZykpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgY29kZSwgbWFwIH0gPSB0cmFuc2Zvcm1lZENodW5rO1xuICAgICAgICBpZiAoaGFzaFBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAvLyBUbyBjcmVhdGUgYSByZXByb2R1Y2libGUgY29udGVudC1vbmx5IGhhc2gsIGFsbCBwbGFjZWhvbGRlcnMgYXJlXG4gICAgICAgICAgICAvLyByZXBsYWNlZCB3aXRoIHRoZSBzYW1lIHZhbHVlIGJlZm9yZSBoYXNoaW5nXG4gICAgICAgICAgICBjb25zdCB7IGNvbnRhaW5lZFBsYWNlaG9sZGVycywgdHJhbnNmb3JtZWRDb2RlIH0gPSByZXBsYWNlUGxhY2Vob2xkZXJzV2l0aERlZmF1bHRBbmRHZXRDb250YWluZWRQbGFjZWhvbGRlcnMoY29kZSwgcGxhY2Vob2xkZXJzKTtcbiAgICAgICAgICAgIGxldCBjb250ZW50VG9IYXNoID0gdHJhbnNmb3JtZWRDb2RlO1xuICAgICAgICAgICAgY29uc3QgaGFzaEF1Z21lbnRhdGlvbiA9IHBsdWdpbkRyaXZlci5ob29rUmVkdWNlVmFsdWVTeW5jKCdhdWdtZW50Q2h1bmtIYXNoJywgJycsIFtjaHVuay5nZXRSZW5kZXJlZENodW5rSW5mbygpXSwgKGF1Z21lbnRhdGlvbiwgcGx1Z2luSGFzaCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5IYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGF1Z21lbnRhdGlvbiArPSBwbHVnaW5IYXNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXVnbWVudGF0aW9uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaGFzaEF1Z21lbnRhdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUb0hhc2ggKz0gaGFzaEF1Z21lbnRhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbmRlcmVkQ2h1bmtzQnlQbGFjZWhvbGRlci5zZXQoaGFzaFBsYWNlaG9sZGVyLCB0cmFuc2Zvcm1lZENodW5rKTtcbiAgICAgICAgICAgIGhhc2hEZXBlbmRlbmNpZXNCeVBsYWNlaG9sZGVyLnNldChoYXNoUGxhY2Vob2xkZXIsIHtcbiAgICAgICAgICAgICAgICBjb250YWluZWRQbGFjZWhvbGRlcnMsXG4gICAgICAgICAgICAgICAgY29udGVudEhhc2g6IGdldEhhc2goY29udGVudFRvSGFzaClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9uSGFzaGVkQ2h1bmtzV2l0aFBsYWNlaG9sZGVycy5wdXNoKHRyYW5zZm9ybWVkQ2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZW1hcEhhc2hQbGFjZWhvbGRlciA9IHByZWxpbWluYXJ5U291cmNlbWFwRmlsZU5hbWU/Lmhhc2hQbGFjZWhvbGRlcjtcbiAgICAgICAgaWYgKG1hcCAmJiBzb3VyY2VtYXBIYXNoUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIGluaXRpYWxIYXNoZXNCeVBsYWNlaG9sZGVyLnNldChwcmVsaW1pbmFyeVNvdXJjZW1hcEZpbGVOYW1lLmhhc2hQbGFjZWhvbGRlciwgZ2V0SGFzaChtYXAudG9TdHJpbmcoKSkuc2xpY2UoMCwgcHJlbGltaW5hcnlTb3VyY2VtYXBGaWxlTmFtZS5oYXNoUGxhY2Vob2xkZXIubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICB9KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaERlcGVuZGVuY2llc0J5UGxhY2Vob2xkZXIsXG4gICAgICAgIGluaXRpYWxIYXNoZXNCeVBsYWNlaG9sZGVyLFxuICAgICAgICBub25IYXNoZWRDaHVua3NXaXRoUGxhY2Vob2xkZXJzLFxuICAgICAgICBwbGFjZWhvbGRlcnMsXG4gICAgICAgIHJlbmRlcmVkQ2h1bmtzQnlQbGFjZWhvbGRlclxuICAgIH07XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUZpbmFsSGFzaGVzKHJlbmRlcmVkQ2h1bmtzQnlQbGFjZWhvbGRlciwgaGFzaERlcGVuZGVuY2llc0J5UGxhY2Vob2xkZXIsIGluaXRpYWxIYXNoZXNCeVBsYWNlaG9sZGVyLCBwbGFjZWhvbGRlcnMsIGJ1bmRsZSwgZ2V0SGFzaCkge1xuICAgIGNvbnN0IGhhc2hlc0J5UGxhY2Vob2xkZXIgPSBuZXcgTWFwKGluaXRpYWxIYXNoZXNCeVBsYWNlaG9sZGVyKTtcbiAgICBmb3IgKGNvbnN0IHBsYWNlaG9sZGVyIG9mIHBsYWNlaG9sZGVycykge1xuICAgICAgICBjb25zdCB7IGZpbGVOYW1lIH0gPSByZW5kZXJlZENodW5rc0J5UGxhY2Vob2xkZXIuZ2V0KHBsYWNlaG9sZGVyKTtcbiAgICAgICAgbGV0IGNvbnRlbnRUb0hhc2ggPSAnJztcbiAgICAgICAgY29uc3QgaGFzaERlcGVuZGVuY3lQbGFjZWhvbGRlcnMgPSBuZXcgU2V0KFtwbGFjZWhvbGRlcl0pO1xuICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3lQbGFjZWhvbGRlciBvZiBoYXNoRGVwZW5kZW5jeVBsYWNlaG9sZGVycykge1xuICAgICAgICAgICAgY29uc3QgeyBjb250YWluZWRQbGFjZWhvbGRlcnMsIGNvbnRlbnRIYXNoIH0gPSBoYXNoRGVwZW5kZW5jaWVzQnlQbGFjZWhvbGRlci5nZXQoZGVwZW5kZW5jeVBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIGNvbnRlbnRUb0hhc2ggKz0gY29udGVudEhhc2g7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRhaW5lZFBsYWNlaG9sZGVyIG9mIGNvbnRhaW5lZFBsYWNlaG9sZGVycykge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gbG9vcGluZyBvdmVyIGEgbWFwLCBzZXR0aW5nIGFuIGVudHJ5IG9ubHkgY2F1c2VzIGEgbmV3IGl0ZXJhdGlvbiBpZiB0aGUga2V5IGlzIG5ld1xuICAgICAgICAgICAgICAgIGhhc2hEZXBlbmRlbmN5UGxhY2Vob2xkZXJzLmFkZChjb250YWluZWRQbGFjZWhvbGRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpbmFsRmlsZU5hbWU7XG4gICAgICAgIGxldCBmaW5hbEhhc2g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgYSBoYXNoIGNvbGxpc2lvbiwgY3JlYXRlIGEgaGFzaCBvZiB0aGUgaGFzaFxuICAgICAgICAgICAgaWYgKGZpbmFsSGFzaCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUb0hhc2ggPSBmaW5hbEhhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbEhhc2ggPSBnZXRIYXNoKGNvbnRlbnRUb0hhc2gpLnNsaWNlKDAsIHBsYWNlaG9sZGVyLmxlbmd0aCk7XG4gICAgICAgICAgICBmaW5hbEZpbGVOYW1lID0gcmVwbGFjZVNpbmdsZVBsYWNlaG9sZGVyKGZpbGVOYW1lLCBwbGFjZWhvbGRlciwgZmluYWxIYXNoKTtcbiAgICAgICAgfSB3aGlsZSAoYnVuZGxlW2xvd2VyY2FzZUJ1bmRsZUtleXNdLmhhcyhmaW5hbEZpbGVOYW1lLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgYnVuZGxlW2ZpbmFsRmlsZU5hbWVdID0gRklMRV9QTEFDRUhPTERFUjtcbiAgICAgICAgaGFzaGVzQnlQbGFjZWhvbGRlci5zZXQocGxhY2Vob2xkZXIsIGZpbmFsSGFzaCk7XG4gICAgfVxuICAgIHJldHVybiBoYXNoZXNCeVBsYWNlaG9sZGVyO1xufVxuZnVuY3Rpb24gYWRkQ2h1bmtzVG9CdW5kbGUocmVuZGVyZWRDaHVua3NCeVBsYWNlaG9sZGVyLCBoYXNoZXNCeVBsYWNlaG9sZGVyLCBidW5kbGUsIG5vbkhhc2hlZENodW5rc1dpdGhQbGFjZWhvbGRlcnMsIHBsdWdpbkRyaXZlciwgb3B0aW9ucykge1xuICAgIGZvciAoY29uc3QgeyBjaHVuaywgY29kZSwgZmlsZU5hbWUsIHNvdXJjZW1hcEZpbGVOYW1lLCBtYXAgfSBvZiByZW5kZXJlZENodW5rc0J5UGxhY2Vob2xkZXIudmFsdWVzKCkpIHtcbiAgICAgICAgbGV0IHVwZGF0ZWRDb2RlID0gcmVwbGFjZVBsYWNlaG9sZGVycyhjb2RlLCBoYXNoZXNCeVBsYWNlaG9sZGVyKTtcbiAgICAgICAgY29uc3QgZmluYWxGaWxlTmFtZSA9IHJlcGxhY2VQbGFjZWhvbGRlcnMoZmlsZU5hbWUsIGhhc2hlc0J5UGxhY2Vob2xkZXIpO1xuICAgICAgICBsZXQgZmluYWxTb3VyY2VtYXBGaWxlTmFtZSA9IG51bGw7XG4gICAgICAgIGlmIChtYXApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNvdXJjZW1hcERlYnVnSWRzKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZENvZGUgKz0gY2FsY3VsYXRlRGVidWdJZEFuZEdldENvbW1lbnQodXBkYXRlZENvZGUsIG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbFNvdXJjZW1hcEZpbGVOYW1lID0gc291cmNlbWFwRmlsZU5hbWVcbiAgICAgICAgICAgICAgICA/IHJlcGxhY2VQbGFjZWhvbGRlcnMoc291cmNlbWFwRmlsZU5hbWUsIGhhc2hlc0J5UGxhY2Vob2xkZXIpXG4gICAgICAgICAgICAgICAgOiBgJHtmaW5hbEZpbGVOYW1lfS5tYXBgO1xuICAgICAgICAgICAgbWFwLmZpbGUgPSByZXBsYWNlUGxhY2Vob2xkZXJzKG1hcC5maWxlLCBoYXNoZXNCeVBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIHVwZGF0ZWRDb2RlICs9IGVtaXRTb3VyY2VNYXBBbmRHZXRDb21tZW50KGZpbmFsU291cmNlbWFwRmlsZU5hbWUsIG1hcCwgcGx1Z2luRHJpdmVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBidW5kbGVbZmluYWxGaWxlTmFtZV0gPSBjaHVuay5maW5hbGl6ZUNodW5rKHVwZGF0ZWRDb2RlLCBtYXAsIGZpbmFsU291cmNlbWFwRmlsZU5hbWUsIGhhc2hlc0J5UGxhY2Vob2xkZXIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHsgY2h1bmssIGNvZGUsIGZpbGVOYW1lLCBzb3VyY2VtYXBGaWxlTmFtZSwgbWFwIH0gb2Ygbm9uSGFzaGVkQ2h1bmtzV2l0aFBsYWNlaG9sZGVycykge1xuICAgICAgICBsZXQgdXBkYXRlZENvZGUgPSBoYXNoZXNCeVBsYWNlaG9sZGVyLnNpemUgPiAwID8gcmVwbGFjZVBsYWNlaG9sZGVycyhjb2RlLCBoYXNoZXNCeVBsYWNlaG9sZGVyKSA6IGNvZGU7XG4gICAgICAgIGxldCBmaW5hbFNvdXJjZW1hcEZpbGVOYW1lID0gbnVsbDtcbiAgICAgICAgaWYgKG1hcCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlbWFwRGVidWdJZHMpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkQ29kZSArPSBjYWxjdWxhdGVEZWJ1Z0lkQW5kR2V0Q29tbWVudCh1cGRhdGVkQ29kZSwgbWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsU291cmNlbWFwRmlsZU5hbWUgPSBzb3VyY2VtYXBGaWxlTmFtZVxuICAgICAgICAgICAgICAgID8gcmVwbGFjZVBsYWNlaG9sZGVycyhzb3VyY2VtYXBGaWxlTmFtZSwgaGFzaGVzQnlQbGFjZWhvbGRlcilcbiAgICAgICAgICAgICAgICA6IGAke2ZpbGVOYW1lfS5tYXBgO1xuICAgICAgICAgICAgdXBkYXRlZENvZGUgKz0gZW1pdFNvdXJjZU1hcEFuZEdldENvbW1lbnQoZmluYWxTb3VyY2VtYXBGaWxlTmFtZSwgbWFwLCBwbHVnaW5Ecml2ZXIsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGJ1bmRsZVtmaWxlTmFtZV0gPSBjaHVuay5maW5hbGl6ZUNodW5rKHVwZGF0ZWRDb2RlLCBtYXAsIGZpbmFsU291cmNlbWFwRmlsZU5hbWUsIGhhc2hlc0J5UGxhY2Vob2xkZXIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVtaXRTb3VyY2VNYXBBbmRHZXRDb21tZW50KGZpbGVOYW1lLCBtYXAsIHBsdWdpbkRyaXZlciwgeyBzb3VyY2VtYXAsIHNvdXJjZW1hcEJhc2VVcmwgfSkge1xuICAgIGxldCB1cmw7XG4gICAgaWYgKHNvdXJjZW1hcCA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgdXJsID0gbWFwLnRvVXJsKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzb3VyY2VtYXBGaWxlTmFtZSA9IGJhc2VuYW1lKGZpbGVOYW1lKTtcbiAgICAgICAgdXJsID0gc291cmNlbWFwQmFzZVVybFxuICAgICAgICAgICAgPyBuZXcgVVJMKHNvdXJjZW1hcEZpbGVOYW1lLCBzb3VyY2VtYXBCYXNlVXJsKS50b1N0cmluZygpXG4gICAgICAgICAgICA6IHNvdXJjZW1hcEZpbGVOYW1lO1xuICAgICAgICBwbHVnaW5Ecml2ZXIuZW1pdEZpbGUoe1xuICAgICAgICAgICAgZmlsZU5hbWUsXG4gICAgICAgICAgICBvcmlnaW5hbEZpbGVOYW1lOiBudWxsLFxuICAgICAgICAgICAgc291cmNlOiBtYXAudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHR5cGU6ICdhc3NldCdcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VtYXAgPT09ICdoaWRkZW4nID8gJycgOiBgLy8jICR7U09VUkNFTUFQUElOR19VUkx9PSR7dXJsfVxcbmA7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWJ1Z0lkQW5kR2V0Q29tbWVudChjb2RlLCBtYXApIHtcbiAgICBjb25zdCBoYXNoID0gaGFzaGVyQnlUeXBlLmhleChjb2RlKTtcbiAgICBjb25zdCBkZWJ1Z0lkID0gW1xuICAgICAgICBoYXNoLnNsaWNlKDAsIDgpLFxuICAgICAgICBoYXNoLnNsaWNlKDgsIDEyKSxcbiAgICAgICAgJzQnICsgaGFzaC5zbGljZSgxMiwgMTUpLFxuICAgICAgICAoKHBhcnNlSW50KGhhc2guc2xpY2UoMTUsIDE2KSwgMTYpICYgMykgfCA4KS50b1N0cmluZygxNikgKyBoYXNoLnNsaWNlKDE3LCAyMCksXG4gICAgICAgIGhhc2guc2xpY2UoMjAsIDMyKVxuICAgIF0uam9pbignLScpO1xuICAgIG1hcC5kZWJ1Z0lkID0gZGVidWdJZDtcbiAgICByZXR1cm4gJy8vIyBkZWJ1Z0lkPScgKyBkZWJ1Z0lkICsgJ1xcbic7XG59XG5cbmNsYXNzIEJ1bmRsZSB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0T3B0aW9ucywgdW5zZXRPcHRpb25zLCBpbnB1dE9wdGlvbnMsIHBsdWdpbkRyaXZlciwgZ3JhcGgpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRPcHRpb25zID0gb3V0cHV0T3B0aW9ucztcbiAgICAgICAgdGhpcy51bnNldE9wdGlvbnMgPSB1bnNldE9wdGlvbnM7XG4gICAgICAgIHRoaXMuaW5wdXRPcHRpb25zID0gaW5wdXRPcHRpb25zO1xuICAgICAgICB0aGlzLnBsdWdpbkRyaXZlciA9IHBsdWdpbkRyaXZlcjtcbiAgICAgICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICAgICAgICB0aGlzLmZhY2FkZUNodW5rQnlNb2R1bGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaW5jbHVkZWROYW1lc3BhY2VzID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZShpc1dyaXRlKSB7XG4gICAgICAgIHRpbWVTdGFydCgnR0VORVJBVEUnLCAxKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0QnVuZGxlQmFzZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGNvbnN0IG91dHB1dEJ1bmRsZSA9IGdldE91dHB1dEJ1bmRsZShvdXRwdXRCdW5kbGVCYXNlKTtcbiAgICAgICAgdGhpcy5wbHVnaW5Ecml2ZXIuc2V0T3V0cHV0QnVuZGxlKG91dHB1dEJ1bmRsZSwgdGhpcy5vdXRwdXRPcHRpb25zKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRpbWVTdGFydCgnaW5pdGlhbGl6ZSByZW5kZXInLCAyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luRHJpdmVyLmhvb2tQYXJhbGxlbCgncmVuZGVyU3RhcnQnLCBbdGhpcy5vdXRwdXRPcHRpb25zLCB0aGlzLmlucHV0T3B0aW9uc10pO1xuICAgICAgICAgICAgdGltZUVuZCgnaW5pdGlhbGl6ZSByZW5kZXInLCAyKTtcbiAgICAgICAgICAgIHRpbWVTdGFydCgnZ2VuZXJhdGUgY2h1bmtzJywgMik7XG4gICAgICAgICAgICBjb25zdCBnZXRIYXNoUGxhY2Vob2xkZXIgPSBnZXRIYXNoUGxhY2Vob2xkZXJHZW5lcmF0b3IoKTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVDaHVua3Mob3V0cHV0QnVuZGxlLCBnZXRIYXNoUGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgaWYgKGNodW5rcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVPcHRpb25zRm9yTXVsdGlDaHVua091dHB1dCh0aGlzLm91dHB1dE9wdGlvbnMsIHRoaXMuaW5wdXRPcHRpb25zLm9uTG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGx1Z2luRHJpdmVyLnNldENodW5rSW5mb3JtYXRpb24odGhpcy5mYWNhZGVDaHVua0J5TW9kdWxlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsuZ2VuZXJhdGVFeHBvcnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aW1lRW5kKCdnZW5lcmF0ZSBjaHVua3MnLCAyKTtcbiAgICAgICAgICAgIGF3YWl0IHJlbmRlckNodW5rcyhjaHVua3MsIG91dHB1dEJ1bmRsZSwgdGhpcy5wbHVnaW5Ecml2ZXIsIHRoaXMub3V0cHV0T3B0aW9ucywgdGhpcy5pbnB1dE9wdGlvbnMub25Mb2cpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcl8pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luRHJpdmVyLmhvb2tQYXJhbGxlbCgncmVuZGVyRXJyb3InLCBbZXJyb3JfXSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcl87XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlVW5yZWZlcmVuY2VkQXNzZXRzKG91dHB1dEJ1bmRsZSk7XG4gICAgICAgIHRpbWVTdGFydCgnZ2VuZXJhdGUgYnVuZGxlJywgMik7XG4gICAgICAgIGF3YWl0IHRoaXMucGx1Z2luRHJpdmVyLmhvb2tTZXEoJ2dlbmVyYXRlQnVuZGxlJywgW1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRPcHRpb25zLFxuICAgICAgICAgICAgb3V0cHV0QnVuZGxlLFxuICAgICAgICAgICAgaXNXcml0ZVxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5maW5hbGlzZUFzc2V0cyhvdXRwdXRCdW5kbGUpO1xuICAgICAgICB0aW1lRW5kKCdnZW5lcmF0ZSBidW5kbGUnLCAyKTtcbiAgICAgICAgdGltZUVuZCgnR0VORVJBVEUnLCAxKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dEJ1bmRsZUJhc2U7XG4gICAgfVxuICAgIGFzeW5jIGFkZE1hbnVhbENodW5rcyhtYW51YWxDaHVua3MpIHtcbiAgICAgICAgY29uc3QgbWFudWFsQ2h1bmtBbGlhc0J5RW50cnkgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGNodW5rRW50cmllcyA9IGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5lbnRyaWVzKG1hbnVhbENodW5rcykubWFwKGFzeW5jIChbYWxpYXMsIGZpbGVzXSkgPT4gKHtcbiAgICAgICAgICAgIGFsaWFzLFxuICAgICAgICAgICAgZW50cmllczogYXdhaXQgdGhpcy5ncmFwaC5tb2R1bGVMb2FkZXIuYWRkQWRkaXRpb25hbE1vZHVsZXMoZmlsZXMsIHRydWUpXG4gICAgICAgIH0pKSk7XG4gICAgICAgIGZvciAoY29uc3QgeyBhbGlhcywgZW50cmllcyB9IG9mIGNodW5rRW50cmllcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgYWRkTW9kdWxlVG9NYW51YWxDaHVuayhhbGlhcywgZW50cnksIG1hbnVhbENodW5rQWxpYXNCeUVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFudWFsQ2h1bmtBbGlhc0J5RW50cnk7XG4gICAgfVxuICAgIGFzc2lnbk1hbnVhbENodW5rcyhnZXRNYW51YWxDaHVuaykge1xuICAgICAgICBjb25zdCBtYW51YWxDaHVua0FsaWFzZXNXaXRoRW50cnkgPSBbXTtcbiAgICAgICAgY29uc3QgbWFudWFsQ2h1bmtzQXBpID0ge1xuICAgICAgICAgICAgZ2V0TW9kdWxlSWRzOiAoKSA9PiB0aGlzLmdyYXBoLm1vZHVsZXNCeUlkLmtleXMoKSxcbiAgICAgICAgICAgIGdldE1vZHVsZUluZm86IHRoaXMuZ3JhcGguZ2V0TW9kdWxlSW5mb1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiB0aGlzLmdyYXBoLm1vZHVsZXNCeUlkLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAobW9kdWxlIGluc3RhbmNlb2YgTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFudWFsQ2h1bmtBbGlhcyA9IGdldE1hbnVhbENodW5rKG1vZHVsZS5pZCwgbWFudWFsQ2h1bmtzQXBpKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1hbnVhbENodW5rQWxpYXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hbnVhbENodW5rQWxpYXNlc1dpdGhFbnRyeS5wdXNoKFttYW51YWxDaHVua0FsaWFzLCBtb2R1bGVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFudWFsQ2h1bmtBbGlhc2VzV2l0aEVudHJ5LnNvcnQoKFthbGlhc0FdLCBbYWxpYXNCXSkgPT4gYWxpYXNBID4gYWxpYXNCID8gMSA6IGFsaWFzQSA8IGFsaWFzQiA/IC0xIDogMCk7XG4gICAgICAgIGNvbnN0IG1hbnVhbENodW5rQWxpYXNCeUVudHJ5ID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFthbGlhcywgbW9kdWxlXSBvZiBtYW51YWxDaHVua0FsaWFzZXNXaXRoRW50cnkpIHtcbiAgICAgICAgICAgIGFkZE1vZHVsZVRvTWFudWFsQ2h1bmsoYWxpYXMsIG1vZHVsZSwgbWFudWFsQ2h1bmtBbGlhc0J5RW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW51YWxDaHVua0FsaWFzQnlFbnRyeTtcbiAgICB9XG4gICAgZmluYWxpc2VBc3NldHMoYnVuZGxlKSB7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dE9wdGlvbnMudmFsaWRhdGUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBPYmplY3QudmFsdWVzKGJ1bmRsZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoJ2NvZGUnIGluIGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQXN0KGZpbGUuY29kZSwgeyBqc3g6IHRoaXMuaW5wdXRPcHRpb25zLmpzeCAhPT0gZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dE9wdGlvbnMub25Mb2coTE9HTEVWRUxfV0FSTiwgbG9nQ2h1bmtJbnZhbGlkKGZpbGUsIGVycm9yXykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGx1Z2luRHJpdmVyLmZpbmFsaXNlQXNzZXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlQ2h1bmtzKGJ1bmRsZSwgZ2V0SGFzaFBsYWNlaG9sZGVyKSB7XG4gICAgICAgIGNvbnN0IHsgZXhwZXJpbWVudGFsTWluQ2h1bmtTaXplLCBpbmxpbmVEeW5hbWljSW1wb3J0cywgbWFudWFsQ2h1bmtzLCBwcmVzZXJ2ZU1vZHVsZXMgfSA9IHRoaXMub3V0cHV0T3B0aW9ucztcbiAgICAgICAgY29uc3QgbWFudWFsQ2h1bmtBbGlhc0J5RW50cnkgPSB0eXBlb2YgbWFudWFsQ2h1bmtzID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyBhd2FpdCB0aGlzLmFkZE1hbnVhbENodW5rcyhtYW51YWxDaHVua3MpXG4gICAgICAgICAgICA6IHRoaXMuYXNzaWduTWFudWFsQ2h1bmtzKG1hbnVhbENodW5rcyk7XG4gICAgICAgIGNvbnN0IHNuaXBwZXRzID0gZ2V0R2VuZXJhdGVDb2RlU25pcHBldHModGhpcy5vdXRwdXRPcHRpb25zKTtcbiAgICAgICAgY29uc3QgaW5jbHVkZWRNb2R1bGVzID0gZ2V0SW5jbHVkZWRNb2R1bGVzKHRoaXMuZ3JhcGgubW9kdWxlc0J5SWQpO1xuICAgICAgICBjb25zdCBpbnB1dEJhc2UgPSBjb21tb25kaXIoZ2V0QWJzb2x1dGVFbnRyeU1vZHVsZVBhdGhzKGluY2x1ZGVkTW9kdWxlcywgcHJlc2VydmVNb2R1bGVzKSk7XG4gICAgICAgIGNvbnN0IGV4dGVybmFsQ2h1bmtCeU1vZHVsZSA9IGdldEV4dGVybmFsQ2h1bmtCeU1vZHVsZSh0aGlzLmdyYXBoLm1vZHVsZXNCeUlkLCB0aGlzLm91dHB1dE9wdGlvbnMsIGlucHV0QmFzZSk7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGFibGVNb2R1bGUgPSBpbmxpbmVEeW5hbWljSW1wb3J0c1xuICAgICAgICAgICAgPyBbeyBhbGlhczogbnVsbCwgbW9kdWxlczogaW5jbHVkZWRNb2R1bGVzIH1dXG4gICAgICAgICAgICA6IHByZXNlcnZlTW9kdWxlc1xuICAgICAgICAgICAgICAgID8gaW5jbHVkZWRNb2R1bGVzLm1hcChtb2R1bGUgPT4gKHsgYWxpYXM6IG51bGwsIG1vZHVsZXM6IFttb2R1bGVdIH0pKVxuICAgICAgICAgICAgICAgIDogZ2V0Q2h1bmtBc3NpZ25tZW50cyh0aGlzLmdyYXBoLmVudHJ5TW9kdWxlcywgbWFudWFsQ2h1bmtBbGlhc0J5RW50cnksIGV4cGVyaW1lbnRhbE1pbkNodW5rU2l6ZSwgdGhpcy5pbnB1dE9wdGlvbnMub25Mb2cpO1xuICAgICAgICBjb25zdCBjaHVua3MgPSBuZXcgQXJyYXkoZXhlY3V0YWJsZU1vZHVsZS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBjaHVua0J5TW9kdWxlID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHsgYWxpYXMsIG1vZHVsZXMgfSBvZiBleGVjdXRhYmxlTW9kdWxlKSB7XG4gICAgICAgICAgICBzb3J0QnlFeGVjdXRpb25PcmRlcihtb2R1bGVzKTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gbmV3IENodW5rKG1vZHVsZXMsIHRoaXMuaW5wdXRPcHRpb25zLCB0aGlzLm91dHB1dE9wdGlvbnMsIHRoaXMudW5zZXRPcHRpb25zLCB0aGlzLnBsdWdpbkRyaXZlciwgdGhpcy5ncmFwaC5tb2R1bGVzQnlJZCwgY2h1bmtCeU1vZHVsZSwgZXh0ZXJuYWxDaHVua0J5TW9kdWxlLCB0aGlzLmZhY2FkZUNodW5rQnlNb2R1bGUsIHRoaXMuaW5jbHVkZWROYW1lc3BhY2VzLCBhbGlhcywgZ2V0SGFzaFBsYWNlaG9sZGVyLCBidW5kbGUsIGlucHV0QmFzZSwgc25pcHBldHMpO1xuICAgICAgICAgICAgY2h1bmtzW2luZGV4KytdID0gY2h1bms7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgICAgICAgIGNodW5rLmxpbmsoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWNhZGVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICAgICAgICBmYWNhZGVzLnB1c2goLi4uY2h1bmsuZ2VuZXJhdGVGYWNhZGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4uY2h1bmtzLCAuLi5mYWNhZGVzXTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnNGb3JNdWx0aUNodW5rT3V0cHV0KG91dHB1dE9wdGlvbnMsIGxvZykge1xuICAgIGlmIChvdXRwdXRPcHRpb25zLmZvcm1hdCA9PT0gJ3VtZCcgfHwgb3V0cHV0T3B0aW9ucy5mb3JtYXQgPT09ICdpaWZlJylcbiAgICAgICAgcmV0dXJuIGVycm9yKGxvZ0ludmFsaWRPcHRpb24oJ291dHB1dC5mb3JtYXQnLCBVUkxfT1VUUFVUX0ZPUk1BVCwgJ1VNRCBhbmQgSUlGRSBvdXRwdXQgZm9ybWF0cyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgY29kZS1zcGxpdHRpbmcgYnVpbGRzJywgb3V0cHV0T3B0aW9ucy5mb3JtYXQpKTtcbiAgICBpZiAodHlwZW9mIG91dHB1dE9wdGlvbnMuZmlsZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBlcnJvcihsb2dJbnZhbGlkT3B0aW9uKCdvdXRwdXQuZmlsZScsIFVSTF9PVVRQVVRfRElSLCAnd2hlbiBidWlsZGluZyBtdWx0aXBsZSBjaHVua3MsIHRoZSBcIm91dHB1dC5kaXJcIiBvcHRpb24gbXVzdCBiZSB1c2VkLCBub3QgXCJvdXRwdXQuZmlsZVwiLiBUbyBpbmxpbmUgZHluYW1pYyBpbXBvcnRzLCBzZXQgdGhlIFwiaW5saW5lRHluYW1pY0ltcG9ydHNcIiBvcHRpb24nKSk7XG4gICAgaWYgKG91dHB1dE9wdGlvbnMuc291cmNlbWFwRmlsZSlcbiAgICAgICAgcmV0dXJuIGVycm9yKGxvZ0ludmFsaWRPcHRpb24oJ291dHB1dC5zb3VyY2VtYXBGaWxlJywgVVJMX09VVFBVVF9TT1VSQ0VNQVBGSUxFLCAnXCJvdXRwdXQuc291cmNlbWFwRmlsZVwiIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBzaW5nbGUtZmlsZSBidWlsZHMnKSk7XG4gICAgaWYgKCFvdXRwdXRPcHRpb25zLmFtZC5hdXRvSWQgJiYgb3V0cHV0T3B0aW9ucy5hbWQuaWQpXG4gICAgICAgIGxvZyhMT0dMRVZFTF9XQVJOLCBsb2dJbnZhbGlkT3B0aW9uKCdvdXRwdXQuYW1kLmlkJywgVVJMX09VVFBVVF9BTURfSUQsICd0aGlzIG9wdGlvbiBpcyBvbmx5IHByb3Blcmx5IHN1cHBvcnRlZCBmb3Igc2luZ2xlLWZpbGUgYnVpbGRzLiBVc2UgXCJvdXRwdXQuYW1kLmF1dG9JZFwiIGFuZCBcIm91dHB1dC5hbWQuYmFzZVBhdGhcIiBpbnN0ZWFkJykpO1xufVxuZnVuY3Rpb24gZ2V0SW5jbHVkZWRNb2R1bGVzKG1vZHVsZXNCeUlkKSB7XG4gICAgY29uc3QgaW5jbHVkZWRNb2R1bGVzID0gW107XG4gICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlc0J5SWQudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKG1vZHVsZSBpbnN0YW5jZW9mIE1vZHVsZSAmJlxuICAgICAgICAgICAgKG1vZHVsZS5pc0luY2x1ZGVkKCkgfHwgbW9kdWxlLmluZm8uaXNFbnRyeSB8fCBtb2R1bGUuaW5jbHVkZWREeW5hbWljSW1wb3J0ZXJzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICBpbmNsdWRlZE1vZHVsZXMucHVzaChtb2R1bGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmNsdWRlZE1vZHVsZXM7XG59XG5mdW5jdGlvbiBnZXRBYnNvbHV0ZUVudHJ5TW9kdWxlUGF0aHMoaW5jbHVkZWRNb2R1bGVzLCBwcmVzZXJ2ZU1vZHVsZXMpIHtcbiAgICBjb25zdCBhYnNvbHV0ZUVudHJ5TW9kdWxlUGF0aHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBpbmNsdWRlZE1vZHVsZXMpIHtcbiAgICAgICAgaWYgKChtb2R1bGUuaW5mby5pc0VudHJ5IHx8IHByZXNlcnZlTW9kdWxlcykgJiYgaXNBYnNvbHV0ZSQxKG1vZHVsZS5pZCkpIHtcbiAgICAgICAgICAgIGFic29sdXRlRW50cnlNb2R1bGVQYXRocy5wdXNoKG1vZHVsZS5pZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFic29sdXRlRW50cnlNb2R1bGVQYXRocztcbn1cbmZ1bmN0aW9uIGdldEV4dGVybmFsQ2h1bmtCeU1vZHVsZShtb2R1bGVzQnlJZCwgb3V0cHV0T3B0aW9ucywgaW5wdXRCYXNlKSB7XG4gICAgY29uc3QgZXh0ZXJuYWxDaHVua0J5TW9kdWxlID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZXNCeUlkLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChtb2R1bGUgaW5zdGFuY2VvZiBFeHRlcm5hbE1vZHVsZSkge1xuICAgICAgICAgICAgZXh0ZXJuYWxDaHVua0J5TW9kdWxlLnNldChtb2R1bGUsIG5ldyBFeHRlcm5hbENodW5rKG1vZHVsZSwgb3V0cHV0T3B0aW9ucywgaW5wdXRCYXNlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4dGVybmFsQ2h1bmtCeU1vZHVsZTtcbn1cbmZ1bmN0aW9uIGFkZE1vZHVsZVRvTWFudWFsQ2h1bmsoYWxpYXMsIG1vZHVsZSwgbWFudWFsQ2h1bmtBbGlhc0J5RW50cnkpIHtcbiAgICBjb25zdCBleGlzdGluZ0FsaWFzID0gbWFudWFsQ2h1bmtBbGlhc0J5RW50cnkuZ2V0KG1vZHVsZSk7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZ0FsaWFzID09PSAnc3RyaW5nJyAmJiBleGlzdGluZ0FsaWFzICE9PSBhbGlhcykge1xuICAgICAgICByZXR1cm4gZXJyb3IobG9nQ2Fubm90QXNzaWduTW9kdWxlVG9DaHVuayhtb2R1bGUuaWQsIGFsaWFzLCBleGlzdGluZ0FsaWFzKSk7XG4gICAgfVxuICAgIG1hbnVhbENodW5rQWxpYXNCeUVudHJ5LnNldChtb2R1bGUsIGFsaWFzKTtcbn1cblxuZnVuY3Rpb24gZmxydSAobWF4KSB7XG5cdHZhciBudW0sIGN1cnIsIHByZXY7XG5cdHZhciBsaW1pdCA9IG1heDtcblxuXHRmdW5jdGlvbiBrZWVwKGtleSwgdmFsdWUpIHtcblx0XHRpZiAoKytudW0gPiBsaW1pdCkge1xuXHRcdFx0cHJldiA9IGN1cnI7XG5cdFx0XHRyZXNldCgxKTtcblx0XHRcdCsrbnVtO1xuXHRcdH1cblx0XHRjdXJyW2tleV0gPSB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlc2V0KGlzUGFydGlhbCkge1xuXHRcdG51bSA9IDA7XG5cdFx0Y3VyciA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0aXNQYXJ0aWFsIHx8IChwcmV2PU9iamVjdC5jcmVhdGUobnVsbCkpO1xuXHR9XG5cblx0cmVzZXQoKTtcblxuXHRyZXR1cm4ge1xuXHRcdGNsZWFyOiByZXNldCxcblx0XHRoYXM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHJldHVybiBjdXJyW2tleV0gIT09IHZvaWQgMCB8fCBwcmV2W2tleV0gIT09IHZvaWQgMDtcblx0XHR9LFxuXHRcdGdldDogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0dmFyIHZhbCA9IGN1cnJba2V5XTtcblx0XHRcdGlmICh2YWwgIT09IHZvaWQgMCkgcmV0dXJuIHZhbDtcblx0XHRcdGlmICgodmFsPXByZXZba2V5XSkgIT09IHZvaWQgMCkge1xuXHRcdFx0XHRrZWVwKGtleSwgdmFsKTtcblx0XHRcdFx0cmV0dXJuIHZhbDtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRcdGlmIChjdXJyW2tleV0gIT09IHZvaWQgMCkge1xuXHRcdFx0XHRjdXJyW2tleV0gPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtlZXAoa2V5LCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5jbGFzcyBHbG9iYWxTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcy5zZXQoJ3VuZGVmaW5lZCcsIG5ldyBVbmRlZmluZWRWYXJpYWJsZSgpKTtcbiAgICB9XG4gICAgZmluZFZhcmlhYmxlKG5hbWUpIHtcbiAgICAgICAgbGV0IHZhcmlhYmxlID0gdGhpcy52YXJpYWJsZXMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgICAgICB2YXJpYWJsZSA9IG5ldyBHbG9iYWxWYXJpYWJsZShuYW1lKTtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVzLnNldChuYW1lLCB2YXJpYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUlkVmlhUGx1Z2lucyhzb3VyY2UsIGltcG9ydGVyLCBwbHVnaW5Ecml2ZXIsIG1vZHVsZUxvYWRlclJlc29sdmVJZCwgc2tpcCwgY3VzdG9tT3B0aW9ucywgaXNFbnRyeSwgYXR0cmlidXRlcykge1xuICAgIGxldCBza2lwcGVkID0gbnVsbDtcbiAgICBsZXQgcmVwbGFjZUNvbnRleHQgPSBudWxsO1xuICAgIGlmIChza2lwKSB7XG4gICAgICAgIHNraXBwZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3Qgc2tpcHBlZENhbGwgb2Ygc2tpcCkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZSA9PT0gc2tpcHBlZENhbGwuc291cmNlICYmIGltcG9ydGVyID09PSBza2lwcGVkQ2FsbC5pbXBvcnRlcikge1xuICAgICAgICAgICAgICAgIHNraXBwZWQuYWRkKHNraXBwZWRDYWxsLnBsdWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZUNvbnRleHQgPSAocGx1Z2luQ29udGV4dCwgcGx1Z2luKSA9PiAoe1xuICAgICAgICAgICAgLi4ucGx1Z2luQ29udGV4dCxcbiAgICAgICAgICAgIHJlc29sdmU6IChzb3VyY2UsIGltcG9ydGVyLCB7IGF0dHJpYnV0ZXMsIGN1c3RvbSwgaXNFbnRyeSwgc2tpcFNlbGYgfSA9IEJMQU5LKSA9PiB7XG4gICAgICAgICAgICAgICAgc2tpcFNlbGYgPz89IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZUxvYWRlclJlc29sdmVJZChzb3VyY2UsIGltcG9ydGVyLCBjdXN0b20sIGlzRW50cnksIGF0dHJpYnV0ZXMgfHwgRU1QVFlfT0JKRUNULCBza2lwU2VsZiA/IFsuLi5za2lwLCB7IGltcG9ydGVyLCBwbHVnaW4sIHNvdXJjZSB9XSA6IHNraXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBsdWdpbkRyaXZlci5ob29rRmlyc3RBbmRHZXRQbHVnaW4oJ3Jlc29sdmVJZCcsIFtzb3VyY2UsIGltcG9ydGVyLCB7IGF0dHJpYnV0ZXMsIGN1c3RvbTogY3VzdG9tT3B0aW9ucywgaXNFbnRyeSB9XSwgcmVwbGFjZUNvbnRleHQsIHNraXBwZWQpO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlSWQoc291cmNlLCBpbXBvcnRlciwgcHJlc2VydmVTeW1saW5rcywgcGx1Z2luRHJpdmVyLCBtb2R1bGVMb2FkZXJSZXNvbHZlSWQsIHNraXAsIGN1c3RvbU9wdGlvbnMsIGlzRW50cnksIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBwbHVnaW5SZXN1bHQgPSBhd2FpdCByZXNvbHZlSWRWaWFQbHVnaW5zKHNvdXJjZSwgaW1wb3J0ZXIsIHBsdWdpbkRyaXZlciwgbW9kdWxlTG9hZGVyUmVzb2x2ZUlkLCBza2lwLCBjdXN0b21PcHRpb25zLCBpc0VudHJ5LCBhdHRyaWJ1dGVzKTtcbiAgICBpZiAocGx1Z2luUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgW3Jlc29sdmVJZFJlc3VsdCwgcGx1Z2luXSA9IHBsdWdpblJlc3VsdDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlSWRSZXN1bHQgPT09ICdvYmplY3QnICYmICFyZXNvbHZlSWRSZXN1bHQucmVzb2x2ZWRCeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5yZXNvbHZlSWRSZXN1bHQsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRCeTogcGx1Z2luLm5hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlSWRSZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiByZXNvbHZlSWRSZXN1bHQsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRCeTogcGx1Z2luLm5hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVJZFJlc3VsdDtcbiAgICB9XG4gICAgLy8gZXh0ZXJuYWwgbW9kdWxlcyAobm9uLWVudHJ5IG1vZHVsZXMgdGhhdCBzdGFydCB3aXRoIG5laXRoZXIgJy4nIG9yICcvJylcbiAgICAvLyBhcmUgc2tpcHBlZCBhdCB0aGlzIHN0YWdlLlxuICAgIGlmIChpbXBvcnRlciAhPT0gdW5kZWZpbmVkICYmICFpc0Fic29sdXRlJDEoc291cmNlKSAmJiBzb3VyY2VbMF0gIT09ICcuJylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gYHJlc29sdmVgIHByb2Nlc3NlcyBwYXRocyBmcm9tIHJpZ2h0IHRvIGxlZnQsIHByZXBlbmRpbmcgdGhlbSB1bnRpbCBhblxuICAgIC8vIGFic29sdXRlIHBhdGggaXMgY3JlYXRlZC4gQWJzb2x1dGUgaW1wb3J0ZWVzIHRoZXJlZm9yZSBzaG9ydGNpcmN1aXQgdGhlXG4gICAgLy8gcmVzb2x2ZSBjYWxsIGFuZCByZXF1aXJlIG5vIHNwZWNpYWwgaGFuZGluZyBvbiBvdXIgcGFydC5cbiAgICAvLyBTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wYXRoLmh0bWwjcGF0aF9wYXRoX3Jlc29sdmVfcGF0aHNcbiAgICByZXR1cm4gYWRkSnNFeHRlbnNpb25JZk5lY2Vzc2FyeShpbXBvcnRlciA/IHJlc29sdmUkMShkaXJuYW1lKGltcG9ydGVyKSwgc291cmNlKSA6IHJlc29sdmUkMShzb3VyY2UpLCBwcmVzZXJ2ZVN5bWxpbmtzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFkZEpzRXh0ZW5zaW9uSWZOZWNlc3NhcnkoZmlsZSwgcHJlc2VydmVTeW1saW5rcykge1xuICAgIHJldHVybiAoKGF3YWl0IGZpbmRGaWxlKGZpbGUsIHByZXNlcnZlU3ltbGlua3MpKSA/P1xuICAgICAgICAoYXdhaXQgZmluZEZpbGUoZmlsZSArICcubWpzJywgcHJlc2VydmVTeW1saW5rcykpID8/XG4gICAgICAgIChhd2FpdCBmaW5kRmlsZShmaWxlICsgJy5qcycsIHByZXNlcnZlU3ltbGlua3MpKSk7XG59XG5hc3luYyBmdW5jdGlvbiBmaW5kRmlsZShmaWxlLCBwcmVzZXJ2ZVN5bWxpbmtzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBsc3RhdChmaWxlKTtcbiAgICAgICAgaWYgKCFwcmVzZXJ2ZVN5bWxpbmtzICYmIHN0YXRzLmlzU3ltYm9saWNMaW5rKCkpXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZmluZEZpbGUoYXdhaXQgcmVhbHBhdGgoZmlsZSksIHByZXNlcnZlU3ltbGlua3MpO1xuICAgICAgICBpZiAoKHByZXNlcnZlU3ltbGlua3MgJiYgc3RhdHMuaXNTeW1ib2xpY0xpbmsoKSkgfHwgc3RhdHMuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGNhc2VcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBiYXNlbmFtZShmaWxlKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgcmVhZGRpcihkaXJuYW1lKGZpbGUpKTtcbiAgICAgICAgICAgIGlmIChmaWxlcy5pbmNsdWRlcyhuYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIC8vIHN1cHByZXNzXG4gICAgfVxufVxuXG5jb25zdCBBTk9OWU1PVVNfUExVR0lOX1BSRUZJWCA9ICdhdCBwb3NpdGlvbiAnO1xuY29uc3QgQU5PTllNT1VTX09VVFBVVF9QTFVHSU5fUFJFRklYID0gJ2F0IG91dHB1dCBwb3NpdGlvbiAnO1xuXG5mdW5jdGlvbiBjcmVhdGVQbHVnaW5DYWNoZShjYWNoZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGV0ZShpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSBjYWNoZVtpZF07XG4gICAgICAgIH0sXG4gICAgICAgIGdldChpZCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGNhY2hlW2lkXTtcbiAgICAgICAgICAgIGlmICghaXRlbSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpdGVtWzBdID0gMDtcbiAgICAgICAgICAgIHJldHVybiBpdGVtWzFdO1xuICAgICAgICB9LFxuICAgICAgICBoYXMoaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBjYWNoZVtpZF07XG4gICAgICAgICAgICBpZiAoIWl0ZW0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaXRlbVswXSA9IDA7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KGlkLCB2YWx1ZSkge1xuICAgICAgICAgICAgY2FjaGVbaWRdID0gWzAsIHZhbHVlXTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRUcmFja2VkUGx1Z2luQ2FjaGUocGx1Z2luQ2FjaGUsIG9uVXNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsZXRlKGlkKSB7XG4gICAgICAgICAgICBvblVzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHBsdWdpbkNhY2hlLmRlbGV0ZShpZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldChpZCkge1xuICAgICAgICAgICAgb25Vc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBwbHVnaW5DYWNoZS5nZXQoaWQpO1xuICAgICAgICB9LFxuICAgICAgICBoYXMoaWQpIHtcbiAgICAgICAgICAgIG9uVXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gcGx1Z2luQ2FjaGUuaGFzKGlkKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KGlkLCB2YWx1ZSkge1xuICAgICAgICAgICAgb25Vc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBwbHVnaW5DYWNoZS5zZXQoaWQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBOT19DQUNIRSA9IHtcbiAgICBkZWxldGUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIGhhcygpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgc2V0KCkgeyB9XG59O1xuZnVuY3Rpb24gdW5jYWNoZWFibGVQbHVnaW5FcnJvcihwbHVnaW5OYW1lKSB7XG4gICAgaWYgKHBsdWdpbk5hbWUuc3RhcnRzV2l0aChBTk9OWU1PVVNfUExVR0lOX1BSRUZJWCkgfHxcbiAgICAgICAgcGx1Z2luTmFtZS5zdGFydHNXaXRoKEFOT05ZTU9VU19PVVRQVVRfUExVR0lOX1BSRUZJWCkpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKGxvZ0Fub255bW91c1BsdWdpbkNhY2hlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3IobG9nRHVwbGljYXRlUGx1Z2luTmFtZShwbHVnaW5OYW1lKSk7XG59XG5mdW5jdGlvbiBnZXRDYWNoZUZvclVuY2FjaGVhYmxlUGx1Z2luKHBsdWdpbk5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxldGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5jYWNoZWFibGVQbHVnaW5FcnJvcihwbHVnaW5OYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuY2FjaGVhYmxlUGx1Z2luRXJyb3IocGx1Z2luTmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmNhY2hlYWJsZVBsdWdpbkVycm9yKHBsdWdpbk5hbWUpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5jYWNoZWFibGVQbHVnaW5FcnJvcihwbHVnaW5OYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGFzeW5jRmxhdHRlbihhcnJheSkge1xuICAgIGRvIHtcbiAgICAgICAgYXJyYXkgPSAoYXdhaXQgUHJvbWlzZS5hbGwoYXJyYXkpKS5mbGF0KEluZmluaXR5KTtcbiAgICB9IHdoaWxlIChhcnJheS5zb21lKCh2KSA9PiB2Py50aGVuKSk7XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG5jb25zdCBnZXRPbkxvZyA9IChjb25maWcsIGxvZ0xldmVsLCBwcmludExvZyA9IGRlZmF1bHRQcmludExvZykgPT4ge1xuICAgIGNvbnN0IHsgb253YXJuLCBvbkxvZyB9ID0gY29uZmlnO1xuICAgIGNvbnN0IGRlZmF1bHRPbkxvZyA9IGdldERlZmF1bHRPbkxvZyhwcmludExvZywgb253YXJuKTtcbiAgICBpZiAob25Mb2cpIHtcbiAgICAgICAgY29uc3QgbWluaW1hbFByaW9yaXR5ID0gbG9nTGV2ZWxQcmlvcml0eVtsb2dMZXZlbF07XG4gICAgICAgIHJldHVybiAobGV2ZWwsIGxvZykgPT4gb25Mb2cobGV2ZWwsIGFkZExvZ1RvU3RyaW5nKGxvZyksIChsZXZlbCwgaGFuZGxlZExvZykgPT4ge1xuICAgICAgICAgICAgaWYgKGxldmVsID09PSBMT0dMRVZFTF9FUlJPUikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihub3JtYWxpemVMb2coaGFuZGxlZExvZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvZ0xldmVsUHJpb3JpdHlbbGV2ZWxdID49IG1pbmltYWxQcmlvcml0eSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRPbkxvZyhsZXZlbCwgbm9ybWFsaXplTG9nKGhhbmRsZWRMb2cpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0T25Mb2c7XG59O1xuY29uc3QgZ2V0RGVmYXVsdE9uTG9nID0gKHByaW50TG9nLCBvbndhcm4pID0+IG9ud2FyblxuICAgID8gKGxldmVsLCBsb2cpID0+IHtcbiAgICAgICAgaWYgKGxldmVsID09PSBMT0dMRVZFTF9XQVJOKSB7XG4gICAgICAgICAgICBvbndhcm4oYWRkTG9nVG9TdHJpbmcobG9nKSwgd2FybmluZyA9PiBwcmludExvZyhMT0dMRVZFTF9XQVJOLCBub3JtYWxpemVMb2cod2FybmluZykpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByaW50TG9nKGxldmVsLCBsb2cpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDogcHJpbnRMb2c7XG5jb25zdCBhZGRMb2dUb1N0cmluZyA9IChsb2cpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobG9nLCAndG9TdHJpbmcnLCB7XG4gICAgICAgIHZhbHVlOiAoKSA9PiBsb2cubWVzc2FnZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gbG9nO1xufTtcbmNvbnN0IG5vcm1hbGl6ZUxvZyA9IChsb2cpID0+IHR5cGVvZiBsb2cgPT09ICdzdHJpbmcnXG4gICAgPyB7IG1lc3NhZ2U6IGxvZyB9XG4gICAgOiB0eXBlb2YgbG9nID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gbm9ybWFsaXplTG9nKGxvZygpKVxuICAgICAgICA6IGxvZztcbmNvbnN0IGRlZmF1bHRQcmludExvZyA9IChsZXZlbCwgeyBtZXNzYWdlIH0pID0+IHtcbiAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICAgIGNhc2UgTE9HTEVWRUxfV0FSTjoge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIExPR0xFVkVMX0RFQlVHOiB7XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS5kZWJ1ZyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS5pbmZvKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmZ1bmN0aW9uIHdhcm5Vbmtub3duT3B0aW9ucyhwYXNzZWRPcHRpb25zLCB2YWxpZE9wdGlvbnMsIG9wdGlvblR5cGUsIGxvZywgaWdub3JlZEtleXMgPSAvJC4vKSB7XG4gICAgY29uc3QgdmFsaWRPcHRpb25TZXQgPSBuZXcgU2V0KHZhbGlkT3B0aW9ucyk7XG4gICAgY29uc3QgdW5rbm93bk9wdGlvbnMgPSBPYmplY3Qua2V5cyhwYXNzZWRPcHRpb25zKS5maWx0ZXIoa2V5ID0+ICEodmFsaWRPcHRpb25TZXQuaGFzKGtleSkgfHwgaWdub3JlZEtleXMudGVzdChrZXkpKSk7XG4gICAgaWYgKHVua25vd25PcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbG9nKExPR0xFVkVMX1dBUk4sIGxvZ1Vua25vd25PcHRpb24ob3B0aW9uVHlwZSwgdW5rbm93bk9wdGlvbnMsIFsuLi52YWxpZE9wdGlvblNldF0uc29ydCgpKSk7XG4gICAgfVxufVxuY29uc3QgdHJlZXNoYWtlUHJlc2V0cyA9IHtcbiAgICByZWNvbW1lbmRlZDoge1xuICAgICAgICBhbm5vdGF0aW9uczogdHJ1ZSxcbiAgICAgICAgY29ycmVjdFZhclZhbHVlQmVmb3JlRGVjbGFyYXRpb246IGZhbHNlLFxuICAgICAgICBtYW51YWxQdXJlRnVuY3Rpb25zOiBFTVBUWV9BUlJBWSxcbiAgICAgICAgbW9kdWxlU2lkZUVmZmVjdHM6ICgpID0+IHRydWUsXG4gICAgICAgIHByb3BlcnR5UmVhZFNpZGVFZmZlY3RzOiB0cnVlLFxuICAgICAgICB0cnlDYXRjaERlb3B0aW1pemF0aW9uOiB0cnVlLFxuICAgICAgICB1bmtub3duR2xvYmFsU2lkZUVmZmVjdHM6IGZhbHNlXG4gICAgfSxcbiAgICBzYWZlc3Q6IHtcbiAgICAgICAgYW5ub3RhdGlvbnM6IHRydWUsXG4gICAgICAgIGNvcnJlY3RWYXJWYWx1ZUJlZm9yZURlY2xhcmF0aW9uOiB0cnVlLFxuICAgICAgICBtYW51YWxQdXJlRnVuY3Rpb25zOiBFTVBUWV9BUlJBWSxcbiAgICAgICAgbW9kdWxlU2lkZUVmZmVjdHM6ICgpID0+IHRydWUsXG4gICAgICAgIHByb3BlcnR5UmVhZFNpZGVFZmZlY3RzOiB0cnVlLFxuICAgICAgICB0cnlDYXRjaERlb3B0aW1pemF0aW9uOiB0cnVlLFxuICAgICAgICB1bmtub3duR2xvYmFsU2lkZUVmZmVjdHM6IHRydWVcbiAgICB9LFxuICAgIHNtYWxsZXN0OiB7XG4gICAgICAgIGFubm90YXRpb25zOiB0cnVlLFxuICAgICAgICBjb3JyZWN0VmFyVmFsdWVCZWZvcmVEZWNsYXJhdGlvbjogZmFsc2UsXG4gICAgICAgIG1hbnVhbFB1cmVGdW5jdGlvbnM6IEVNUFRZX0FSUkFZLFxuICAgICAgICBtb2R1bGVTaWRlRWZmZWN0czogKCkgPT4gZmFsc2UsXG4gICAgICAgIHByb3BlcnR5UmVhZFNpZGVFZmZlY3RzOiBmYWxzZSxcbiAgICAgICAgdHJ5Q2F0Y2hEZW9wdGltaXphdGlvbjogZmFsc2UsXG4gICAgICAgIHVua25vd25HbG9iYWxTaWRlRWZmZWN0czogZmFsc2VcbiAgICB9XG59O1xuY29uc3QganN4UHJlc2V0cyA9IHtcbiAgICBwcmVzZXJ2ZToge1xuICAgICAgICBmYWN0b3J5OiBudWxsLFxuICAgICAgICBmcmFnbWVudDogbnVsbCxcbiAgICAgICAgaW1wb3J0U291cmNlOiBudWxsLFxuICAgICAgICBtb2RlOiAncHJlc2VydmUnXG4gICAgfSxcbiAgICAncHJlc2VydmUtcmVhY3QnOiB7XG4gICAgICAgIGZhY3Rvcnk6ICdSZWFjdC5jcmVhdGVFbGVtZW50JyxcbiAgICAgICAgZnJhZ21lbnQ6ICdSZWFjdC5GcmFnbWVudCcsXG4gICAgICAgIGltcG9ydFNvdXJjZTogJ3JlYWN0JyxcbiAgICAgICAgbW9kZTogJ3ByZXNlcnZlJ1xuICAgIH0sXG4gICAgcmVhY3Q6IHtcbiAgICAgICAgZmFjdG9yeTogJ1JlYWN0LmNyZWF0ZUVsZW1lbnQnLFxuICAgICAgICBmcmFnbWVudDogJ1JlYWN0LkZyYWdtZW50JyxcbiAgICAgICAgaW1wb3J0U291cmNlOiAncmVhY3QnLFxuICAgICAgICBtb2RlOiAnY2xhc3NpYydcbiAgICB9LFxuICAgICdyZWFjdC1qc3gnOiB7XG4gICAgICAgIGZhY3Rvcnk6ICdSZWFjdC5jcmVhdGVFbGVtZW50JyxcbiAgICAgICAgaW1wb3J0U291cmNlOiAncmVhY3QnLFxuICAgICAgICBqc3hJbXBvcnRTb3VyY2U6ICdyZWFjdC9qc3gtcnVudGltZScsXG4gICAgICAgIG1vZGU6ICdhdXRvbWF0aWMnXG4gICAgfVxufTtcbmNvbnN0IGdlbmVyYXRlZENvZGVQcmVzZXRzID0ge1xuICAgIGVzMjAxNToge1xuICAgICAgICBhcnJvd0Z1bmN0aW9uczogdHJ1ZSxcbiAgICAgICAgY29uc3RCaW5kaW5nczogdHJ1ZSxcbiAgICAgICAgb2JqZWN0U2hvcnRoYW5kOiB0cnVlLFxuICAgICAgICByZXNlcnZlZE5hbWVzQXNQcm9wczogdHJ1ZSxcbiAgICAgICAgc3ltYm9sczogdHJ1ZVxuICAgIH0sXG4gICAgZXM1OiB7XG4gICAgICAgIGFycm93RnVuY3Rpb25zOiBmYWxzZSxcbiAgICAgICAgY29uc3RCaW5kaW5nczogZmFsc2UsXG4gICAgICAgIG9iamVjdFNob3J0aGFuZDogZmFsc2UsXG4gICAgICAgIHJlc2VydmVkTmFtZXNBc1Byb3BzOiB0cnVlLFxuICAgICAgICBzeW1ib2xzOiBmYWxzZVxuICAgIH1cbn07XG5jb25zdCBvYmplY3RpZnlPcHRpb24gPSAodmFsdWUpID0+IHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB2YWx1ZSA6IHt9O1xuY29uc3Qgb2JqZWN0aWZ5T3B0aW9uV2l0aFByZXNldHMgPSAocHJlc2V0cywgb3B0aW9uTmFtZSwgdXJsU25pcHBldCwgYWRkaXRpb25hbFZhbHVlcykgPT4gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgcHJlc2V0ID0gcHJlc2V0c1t2YWx1ZV07XG4gICAgICAgIGlmIChwcmVzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IobG9nSW52YWxpZE9wdGlvbihvcHRpb25OYW1lLCB1cmxTbmlwcGV0LCBgdmFsaWQgdmFsdWVzIGFyZSAke2FkZGl0aW9uYWxWYWx1ZXN9JHtwcmludFF1b3RlZFN0cmluZ0xpc3QoT2JqZWN0LmtleXMocHJlc2V0cykpfS4gWW91IGNhbiBhbHNvIHN1cHBseSBhbiBvYmplY3QgZm9yIG1vcmUgZmluZS1ncmFpbmVkIGNvbnRyb2xgLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0aWZ5T3B0aW9uKHZhbHVlKTtcbn07XG5jb25zdCBnZXRPcHRpb25XaXRoUHJlc2V0ID0gKHZhbHVlLCBwcmVzZXRzLCBvcHRpb25OYW1lLCB1cmxTbmlwcGV0LCBhZGRpdGlvbmFsVmFsdWVzKSA9PiB7XG4gICAgY29uc3QgcHJlc2V0TmFtZSA9IHZhbHVlPy5wcmVzZXQ7XG4gICAgaWYgKHByZXNldE5hbWUpIHtcbiAgICAgICAgY29uc3QgcHJlc2V0ID0gcHJlc2V0c1twcmVzZXROYW1lXTtcbiAgICAgICAgaWYgKHByZXNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4ucHJlc2V0LCAuLi52YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IobG9nSW52YWxpZE9wdGlvbihgJHtvcHRpb25OYW1lfS5wcmVzZXRgLCB1cmxTbmlwcGV0LCBgdmFsaWQgdmFsdWVzIGFyZSAke3ByaW50UXVvdGVkU3RyaW5nTGlzdChPYmplY3Qua2V5cyhwcmVzZXRzKSl9YCwgcHJlc2V0TmFtZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RpZnlPcHRpb25XaXRoUHJlc2V0cyhwcmVzZXRzLCBvcHRpb25OYW1lLCB1cmxTbmlwcGV0LCBhZGRpdGlvbmFsVmFsdWVzKSh2YWx1ZSk7XG59O1xuY29uc3Qgbm9ybWFsaXplUGx1Z2luT3B0aW9uID0gYXN5bmMgKHBsdWdpbnMpID0+IChhd2FpdCBhc3luY0ZsYXR0ZW4oW3BsdWdpbnNdKSkuZmlsdGVyKEJvb2xlYW4pO1xuXG5hc3luYyBmdW5jdGlvbiB0cmFuc2Zvcm0oc291cmNlLCBtb2R1bGUsIHBsdWdpbkRyaXZlciwgbG9nKSB7XG4gICAgY29uc3QgaWQgPSBtb2R1bGUuaWQ7XG4gICAgY29uc3Qgc291cmNlbWFwQ2hhaW4gPSBbXTtcbiAgICBsZXQgb3JpZ2luYWxTb3VyY2VtYXAgPSBzb3VyY2UubWFwID09PSBudWxsID8gbnVsbCA6IGRlY29kZWRTb3VyY2VtYXAoc291cmNlLm1hcCk7XG4gICAgY29uc3Qgb3JpZ2luYWxDb2RlID0gc291cmNlLmNvZGU7XG4gICAgbGV0IGFzdCA9IHNvdXJjZS5hc3Q7XG4gICAgY29uc3QgdHJhbnNmb3JtRGVwZW5kZW5jaWVzID0gW107XG4gICAgY29uc3QgZW1pdHRlZEZpbGVzID0gW107XG4gICAgbGV0IGN1c3RvbVRyYW5zZm9ybUNhY2hlID0gZmFsc2U7XG4gICAgY29uc3QgdXNlQ3VzdG9tVHJhbnNmb3JtQ2FjaGUgPSAoKSA9PiAoY3VzdG9tVHJhbnNmb3JtQ2FjaGUgPSB0cnVlKTtcbiAgICBsZXQgcGx1Z2luTmFtZSA9ICcnO1xuICAgIGxldCBjdXJyZW50U291cmNlID0gc291cmNlLmNvZGU7XG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtUmVkdWNlcihwcmV2aW91c0NvZGUsIHJlc3VsdCwgcGx1Z2luKSB7XG4gICAgICAgIGxldCBjb2RlO1xuICAgICAgICBsZXQgbWFwO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvZGUgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBtb2R1bGUudXBkYXRlT3B0aW9ucyhyZXN1bHQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5jb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1hcCB8fCByZXN1bHQuYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhMT0dMRVZFTF9XQVJOLCBsb2dOb1RyYW5zZm9ybU1hcE9yQXN0V2l0aG91dENvZGUocGx1Z2luLm5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzQ29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICh7IGNvZGUsIG1hcCwgYXN0IH0gPSByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzQ29kZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdHJpY3QgbnVsbCBjaGVjayBhbGxvd3MgJ251bGwnIG1hcHMgdG8gbm90IGJlIHB1c2hlZCB0byB0aGUgY2hhaW4sXG4gICAgICAgIC8vIHdoaWxlICd1bmRlZmluZWQnIGdldHMgdGhlIG1pc3NpbmcgbWFwIHdhcm5pbmdcbiAgICAgICAgaWYgKG1hcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlbWFwQ2hhaW4ucHVzaChkZWNvZGVkU291cmNlbWFwKHR5cGVvZiBtYXAgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShtYXApIDogbWFwKSB8fCB7XG4gICAgICAgICAgICAgICAgbWlzc2luZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwbHVnaW46IHBsdWdpbi5uYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50U291cmNlID0gY29kZTtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIGNvbnN0IGdldExvZ0hhbmRsZXIgPSAoaGFuZGxlcikgPT4gKGxvZywgcG9zKSA9PiB7XG4gICAgICAgIGxvZyA9IG5vcm1hbGl6ZUxvZyhsb2cpO1xuICAgICAgICBpZiAocG9zKVxuICAgICAgICAgICAgYXVnbWVudENvZGVMb2NhdGlvbihsb2csIHBvcywgY3VycmVudFNvdXJjZSwgaWQpO1xuICAgICAgICBsb2cuaWQgPSBpZDtcbiAgICAgICAgbG9nLmhvb2sgPSAndHJhbnNmb3JtJztcbiAgICAgICAgaGFuZGxlcihsb2cpO1xuICAgIH07XG4gICAgbGV0IGNvZGU7XG4gICAgdHJ5IHtcbiAgICAgICAgY29kZSA9IGF3YWl0IHBsdWdpbkRyaXZlci5ob29rUmVkdWNlQXJnMCgndHJhbnNmb3JtJywgW2N1cnJlbnRTb3VyY2UsIGlkXSwgdHJhbnNmb3JtUmVkdWNlciwgKHBsdWdpbkNvbnRleHQsIHBsdWdpbikgPT4ge1xuICAgICAgICAgICAgcGx1Z2luTmFtZSA9IHBsdWdpbi5uYW1lO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5wbHVnaW5Db250ZXh0LFxuICAgICAgICAgICAgICAgIGFkZFdhdGNoRmlsZShpZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1EZXBlbmRlbmNpZXMucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbkNvbnRleHQuYWRkV2F0Y2hGaWxlKGlkKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhY2hlOiBjdXN0b21UcmFuc2Zvcm1DYWNoZVxuICAgICAgICAgICAgICAgICAgICA/IHBsdWdpbkNvbnRleHQuY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgOiBnZXRUcmFja2VkUGx1Z2luQ2FjaGUocGx1Z2luQ29udGV4dC5jYWNoZSwgdXNlQ3VzdG9tVHJhbnNmb3JtQ2FjaGUpLFxuICAgICAgICAgICAgICAgIGRlYnVnOiBnZXRMb2dIYW5kbGVyKHBsdWdpbkNvbnRleHQuZGVidWcpLFxuICAgICAgICAgICAgICAgIGVtaXRGaWxlKGVtaXR0ZWRGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZWRGaWxlcy5wdXNoKGVtaXR0ZWRGaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbkRyaXZlci5lbWl0RmlsZShlbWl0dGVkRmlsZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcihlcnJvcl8sIHBvcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yXyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8gPSB7IG1lc3NhZ2U6IGVycm9yXyB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXVnbWVudENvZGVMb2NhdGlvbihlcnJvcl8sIHBvcywgY3VycmVudFNvdXJjZSwgaWQpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvcl8uaWQgPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JfLmhvb2sgPSAndHJhbnNmb3JtJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbkNvbnRleHQuZXJyb3IoZXJyb3JfKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldENvbWJpbmVkU291cmNlbWFwKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21iaW5lZE1hcCA9IGNvbGxhcHNlU291cmNlbWFwKGlkLCBvcmlnaW5hbENvZGUsIG9yaWdpbmFsU291cmNlbWFwLCBzb3VyY2VtYXBDaGFpbiwgbG9nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21iaW5lZE1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFnaWNTdHJpbmcgPSBuZXcgTWFnaWNTdHJpbmcob3JpZ2luYWxDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWdpY1N0cmluZy5nZW5lcmF0ZU1hcCh7IGhpcmVzOiB0cnVlLCBpbmNsdWRlQ29udGVudDogdHJ1ZSwgc291cmNlOiBpZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxTb3VyY2VtYXAgIT09IGNvbWJpbmVkTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFNvdXJjZW1hcCA9IGNvbWJpbmVkTWFwO1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlbWFwQ2hhaW4ubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNvdXJjZU1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jb21iaW5lZE1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VzQ29udGVudDogY29tYmluZWRNYXAuc291cmNlc0NvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmZvOiBnZXRMb2dIYW5kbGVyKHBsdWdpbkNvbnRleHQuaW5mbyksXG4gICAgICAgICAgICAgICAgc2V0QXNzZXRTb3VyY2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKGxvZ0ludmFsaWRTZXRBc3NldFNvdXJjZUNhbGwoKSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3YXJuOiBnZXRMb2dIYW5kbGVyKHBsdWdpbkNvbnRleHQud2FybilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3JfKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihsb2dQbHVnaW5FcnJvcihlcnJvcl8sIHBsdWdpbk5hbWUsIHsgaG9vazogJ3RyYW5zZm9ybScsIGlkIH0pKTtcbiAgICB9XG4gICAgaWYgKCFjdXN0b21UcmFuc2Zvcm1DYWNoZSAmJiAvLyBmaWxlcyBlbWl0dGVkIGJ5IGEgdHJhbnNmb3JtIGhvb2sgbmVlZCB0byBiZSBlbWl0dGVkIGFnYWluIGlmIHRoZSBob29rIGlzIHNraXBwZWRcbiAgICAgICAgZW1pdHRlZEZpbGVzLmxlbmd0aCA+IDApXG4gICAgICAgIG1vZHVsZS50cmFuc2Zvcm1GaWxlcyA9IGVtaXR0ZWRGaWxlcztcbiAgICByZXR1cm4ge1xuICAgICAgICBhc3QsXG4gICAgICAgIGNvZGUsXG4gICAgICAgIGN1c3RvbVRyYW5zZm9ybUNhY2hlLFxuICAgICAgICBvcmlnaW5hbENvZGUsXG4gICAgICAgIG9yaWdpbmFsU291cmNlbWFwLFxuICAgICAgICBzb3VyY2VtYXBDaGFpbixcbiAgICAgICAgdHJhbnNmb3JtRGVwZW5kZW5jaWVzXG4gICAgfTtcbn1cblxuY29uc3QgUkVTT0xWRV9ERVBFTkRFTkNJRVMgPSAncmVzb2x2ZURlcGVuZGVuY2llcyc7XG5jbGFzcyBNb2R1bGVMb2FkZXIge1xuICAgIGNvbnN0cnVjdG9yKGdyYXBoLCBtb2R1bGVzQnlJZCwgb3B0aW9ucywgcGx1Z2luRHJpdmVyKSB7XG4gICAgICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgICAgICAgdGhpcy5tb2R1bGVzQnlJZCA9IG1vZHVsZXNCeUlkO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnBsdWdpbkRyaXZlciA9IHBsdWdpbkRyaXZlcjtcbiAgICAgICAgdGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5pbmRleGVkRW50cnlNb2R1bGVzID0gW107XG4gICAgICAgIHRoaXMubGF0ZXN0TG9hZE1vZHVsZXNQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMubW9kdWxlTG9hZFByb21pc2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm1vZHVsZXNXaXRoTG9hZGVkRGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLm5leHRDaHVua05hbWVQcmlvcml0eSA9IDA7XG4gICAgICAgIHRoaXMubmV4dEVudHJ5TW9kdWxlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnJlc29sdmVJZCA9IGFzeW5jIChzb3VyY2UsIGltcG9ydGVyLCBjdXN0b21PcHRpb25zLCBpc0VudHJ5LCBhdHRyaWJ1dGVzLCBza2lwID0gbnVsbCkgPT4gdGhpcy5nZXRSZXNvbHZlZElkV2l0aERlZmF1bHRzKHRoaXMuZ2V0Tm9ybWFsaXplZFJlc29sdmVkSWRXaXRob3V0RGVmYXVsdHModGhpcy5vcHRpb25zLmV4dGVybmFsKHNvdXJjZSwgaW1wb3J0ZXIsIGZhbHNlKVxuICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgOiBhd2FpdCByZXNvbHZlSWQoc291cmNlLCBpbXBvcnRlciwgdGhpcy5vcHRpb25zLnByZXNlcnZlU3ltbGlua3MsIHRoaXMucGx1Z2luRHJpdmVyLCB0aGlzLnJlc29sdmVJZCwgc2tpcCwgY3VzdG9tT3B0aW9ucywgdHlwZW9mIGlzRW50cnkgPT09ICdib29sZWFuJyA/IGlzRW50cnkgOiAhaW1wb3J0ZXIsIGF0dHJpYnV0ZXMpLCBpbXBvcnRlciwgc291cmNlKSwgYXR0cmlidXRlcyk7XG4gICAgICAgIHRoaXMuaGFzTW9kdWxlU2lkZUVmZmVjdHMgPSBvcHRpb25zLnRyZWVzaGFrZVxuICAgICAgICAgICAgPyBvcHRpb25zLnRyZWVzaGFrZS5tb2R1bGVTaWRlRWZmZWN0c1xuICAgICAgICAgICAgOiAoKSA9PiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyBhZGRBZGRpdGlvbmFsTW9kdWxlcyh1bnJlc29sdmVkTW9kdWxlcywgaXNBZGRGb3JNYW51YWxDaHVua3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5leHRlbmRMb2FkTW9kdWxlc1Byb21pc2UoUHJvbWlzZS5hbGwodW5yZXNvbHZlZE1vZHVsZXMubWFwKGlkID0+IHRoaXMubG9hZEVudHJ5TW9kdWxlKGlkLCBmYWxzZSwgdW5kZWZpbmVkLCBudWxsLCBpc0FkZEZvck1hbnVhbENodW5rcykpKSk7XG4gICAgICAgIGF3YWl0IHRoaXMuYXdhaXRMb2FkTW9kdWxlc1Byb21pc2UoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgYWRkRW50cnlNb2R1bGVzKHVucmVzb2x2ZWRFbnRyeU1vZHVsZXMsIGlzVXNlckRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZmlyc3RFbnRyeU1vZHVsZUluZGV4ID0gdGhpcy5uZXh0RW50cnlNb2R1bGVJbmRleDtcbiAgICAgICAgdGhpcy5uZXh0RW50cnlNb2R1bGVJbmRleCArPSB1bnJlc29sdmVkRW50cnlNb2R1bGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZmlyc3RDaHVua05hbWVQcmlvcml0eSA9IHRoaXMubmV4dENodW5rTmFtZVByaW9yaXR5O1xuICAgICAgICB0aGlzLm5leHRDaHVua05hbWVQcmlvcml0eSArPSB1bnJlc29sdmVkRW50cnlNb2R1bGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbmV3RW50cnlNb2R1bGVzID0gYXdhaXQgdGhpcy5leHRlbmRMb2FkTW9kdWxlc1Byb21pc2UoUHJvbWlzZS5hbGwodW5yZXNvbHZlZEVudHJ5TW9kdWxlcy5tYXAoKHsgaWQsIGltcG9ydGVyIH0pID0+IHRoaXMubG9hZEVudHJ5TW9kdWxlKGlkLCB0cnVlLCBpbXBvcnRlciwgbnVsbCkpKS50aGVuKGVudHJ5TW9kdWxlcyA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgZW50cnlNb2R1bGVdIG9mIGVudHJ5TW9kdWxlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBlbnRyeU1vZHVsZS5pc1VzZXJEZWZpbmVkRW50cnlQb2ludCA9XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5TW9kdWxlLmlzVXNlckRlZmluZWRFbnRyeVBvaW50IHx8IGlzVXNlckRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYWRkQ2h1bmtOYW1lc1RvTW9kdWxlKGVudHJ5TW9kdWxlLCB1bnJlc29sdmVkRW50cnlNb2R1bGVzW2luZGV4XSwgaXNVc2VyRGVmaW5lZCwgZmlyc3RDaHVua05hbWVQcmlvcml0eSArIGluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0luZGV4ZWRNb2R1bGUgPSB0aGlzLmluZGV4ZWRFbnRyeU1vZHVsZXMuZmluZChpbmRleGVkTW9kdWxlID0+IGluZGV4ZWRNb2R1bGUubW9kdWxlID09PSBlbnRyeU1vZHVsZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nSW5kZXhlZE1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0luZGV4ZWRNb2R1bGUuaW5kZXggPSBNYXRoLm1pbihleGlzdGluZ0luZGV4ZWRNb2R1bGUuaW5kZXgsIGZpcnN0RW50cnlNb2R1bGVJbmRleCArIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlZEVudHJ5TW9kdWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBmaXJzdEVudHJ5TW9kdWxlSW5kZXggKyBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZTogZW50cnlNb2R1bGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbmRleGVkRW50cnlNb2R1bGVzLnNvcnQoKHsgaW5kZXg6IGluZGV4QSB9LCB7IGluZGV4OiBpbmRleEIgfSkgPT4gaW5kZXhBID4gaW5kZXhCID8gMSA6IC0xKTtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeU1vZHVsZXM7XG4gICAgICAgIH0pKTtcbiAgICAgICAgYXdhaXQgdGhpcy5hd2FpdExvYWRNb2R1bGVzUHJvbWlzZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW50cnlNb2R1bGVzOiB0aGlzLmluZGV4ZWRFbnRyeU1vZHVsZXMubWFwKCh7IG1vZHVsZSB9KSA9PiBtb2R1bGUpLFxuICAgICAgICAgICAgaW1wbGljaXRFbnRyeU1vZHVsZXM6IFsuLi50aGlzLmltcGxpY2l0RW50cnlNb2R1bGVzXSxcbiAgICAgICAgICAgIG5ld0VudHJ5TW9kdWxlc1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBlbWl0Q2h1bmsoeyBmaWxlTmFtZSwgaWQsIGltcG9ydGVyLCBuYW1lLCBpbXBsaWNpdGx5TG9hZGVkQWZ0ZXJPbmVPZiwgcHJlc2VydmVTaWduYXR1cmUgfSkge1xuICAgICAgICBjb25zdCB1bnJlc29sdmVkTW9kdWxlID0ge1xuICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGVOYW1lIHx8IG51bGwsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGltcG9ydGVyLFxuICAgICAgICAgICAgbmFtZTogbmFtZSB8fCBudWxsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IGltcGxpY2l0bHlMb2FkZWRBZnRlck9uZU9mXG4gICAgICAgICAgICA/IGF3YWl0IHRoaXMuYWRkRW50cnlXaXRoSW1wbGljaXREZXBlbmRhbnRzKHVucmVzb2x2ZWRNb2R1bGUsIGltcGxpY2l0bHlMb2FkZWRBZnRlck9uZU9mKVxuICAgICAgICAgICAgOiAoYXdhaXQgdGhpcy5hZGRFbnRyeU1vZHVsZXMoW3VucmVzb2x2ZWRNb2R1bGVdLCBmYWxzZSkpLm5ld0VudHJ5TW9kdWxlc1swXTtcbiAgICAgICAgaWYgKHByZXNlcnZlU2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1vZHVsZS5wcmVzZXJ2ZVNpZ25hdHVyZSA9IHByZXNlcnZlU2lnbmF0dXJlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfVxuICAgIGFzeW5jIHByZWxvYWRNb2R1bGUocmVzb2x2ZWRJZCkge1xuICAgICAgICBjb25zdCBtb2R1bGUgPSBhd2FpdCB0aGlzLmZldGNoTW9kdWxlKHRoaXMuZ2V0UmVzb2x2ZWRJZFdpdGhEZWZhdWx0cyhyZXNvbHZlZElkLCBFTVBUWV9PQkpFQ1QpLCB1bmRlZmluZWQsIGZhbHNlLCByZXNvbHZlZElkLnJlc29sdmVEZXBlbmRlbmNpZXMgPyBSRVNPTFZFX0RFUEVOREVOQ0lFUyA6IHRydWUpO1xuICAgICAgICByZXR1cm4gbW9kdWxlLmluZm87XG4gICAgfVxuICAgIGFkZEVudHJ5V2l0aEltcGxpY2l0RGVwZW5kYW50cyh1bnJlc29sdmVkTW9kdWxlLCBpbXBsaWNpdGx5TG9hZGVkQWZ0ZXIpIHtcbiAgICAgICAgY29uc3QgY2h1bmtOYW1lUHJpb3JpdHkgPSB0aGlzLm5leHRDaHVua05hbWVQcmlvcml0eSsrO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlbmRMb2FkTW9kdWxlc1Byb21pc2UodGhpcy5sb2FkRW50cnlNb2R1bGUodW5yZXNvbHZlZE1vZHVsZS5pZCwgZmFsc2UsIHVucmVzb2x2ZWRNb2R1bGUuaW1wb3J0ZXIsIG51bGwpLnRoZW4oYXN5bmMgKGVudHJ5TW9kdWxlKSA9PiB7XG4gICAgICAgICAgICBhZGRDaHVua05hbWVzVG9Nb2R1bGUoZW50cnlNb2R1bGUsIHVucmVzb2x2ZWRNb2R1bGUsIGZhbHNlLCBjaHVua05hbWVQcmlvcml0eSk7XG4gICAgICAgICAgICBpZiAoIWVudHJ5TW9kdWxlLmluZm8uaXNFbnRyeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGltcGxpY2l0bHlMb2FkZWRBZnRlck1vZHVsZXMgPSBhd2FpdCBQcm9taXNlLmFsbChpbXBsaWNpdGx5TG9hZGVkQWZ0ZXIubWFwKGlkID0+IHRoaXMubG9hZEVudHJ5TW9kdWxlKGlkLCBmYWxzZSwgdW5yZXNvbHZlZE1vZHVsZS5pbXBvcnRlciwgZW50cnlNb2R1bGUuaWQpKSk7XG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhZ2FpbiBpZiB0aGlzIGlzIHN0aWxsIGFuIGVudHJ5IG1vZHVsZSBhcyB0aGVzZVxuICAgICAgICAgICAgICAgIC8vIGNoYW5nZXMgbmVlZCB0byBiZSBwZXJmb3JtZWQgYXRvbWljYWxseSB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc2FtZSBtb2R1bGUgaXMgcmUtZW1pdHRlZCBhcyBhbiBlbnRyeSBtb2R1bGUuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGludmVyc2UgY2hhbmdlcyBoYXBwZW4gaW4gXCJoYW5kbGVFeGlzdGluZ01vZHVsZVwiXG4gICAgICAgICAgICAgICAgaWYgKCFlbnRyeU1vZHVsZS5pbmZvLmlzRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlcy5hZGQoZW50cnlNb2R1bGUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBpbXBsaWNpdGx5TG9hZGVkQWZ0ZXJNb2R1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeU1vZHVsZS5pbXBsaWNpdGx5TG9hZGVkQWZ0ZXIuYWRkKG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXBlbmRhbnQgb2YgZW50cnlNb2R1bGUuaW1wbGljaXRseUxvYWRlZEFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRhbnQuaW1wbGljaXRseUxvYWRlZEJlZm9yZS5hZGQoZW50cnlNb2R1bGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5TW9kdWxlO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIGFkZE1vZHVsZVNvdXJjZShpZCwgaW1wb3J0ZXIsIG1vZHVsZSkge1xuICAgICAgICBsZXQgc291cmNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc291cmNlID0gYXdhaXQgdGhpcy5ncmFwaC5maWxlT3BlcmF0aW9uUXVldWUucnVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5wbHVnaW5Ecml2ZXIuaG9va0ZpcnN0KCdsb2FkJywgW2lkXSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGgud2F0Y2hGaWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCByZWFkRmlsZShpZCwgJ3V0ZjgnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcl8pIHtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gYENvdWxkIG5vdCBsb2FkICR7aWR9YDtcbiAgICAgICAgICAgIGlmIChpbXBvcnRlcilcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGAgKGltcG9ydGVkIGJ5ICR7cmVsYXRpdmVJZChpbXBvcnRlcil9KWA7XG4gICAgICAgICAgICBtZXNzYWdlICs9IGA6ICR7ZXJyb3JfLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIGVycm9yXy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgIHRocm93IGVycm9yXztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2VEZXNjcmlwdGlvbiA9IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IHsgY29kZTogc291cmNlIH1cbiAgICAgICAgICAgIDogc291cmNlICE9IG51bGwgJiYgdHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHNvdXJjZS5jb2RlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gc291cmNlXG4gICAgICAgICAgICAgICAgOiBlcnJvcihsb2dCYWRMb2FkZXIoaWQpKTtcbiAgICAgICAgY29uc3QgY29kZSA9IHNvdXJjZURlc2NyaXB0aW9uLmNvZGU7XG4gICAgICAgIGlmIChjb2RlLmNoYXJDb2RlQXQoMCkgPT09IDB4ZmVfZmYpIHtcbiAgICAgICAgICAgIHNvdXJjZURlc2NyaXB0aW9uLmNvZGUgPSBjb2RlLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhY2hlZE1vZHVsZSA9IHRoaXMuZ3JhcGguY2FjaGVkTW9kdWxlcy5nZXQoaWQpO1xuICAgICAgICBpZiAoY2FjaGVkTW9kdWxlICYmXG4gICAgICAgICAgICAhY2FjaGVkTW9kdWxlLmN1c3RvbVRyYW5zZm9ybUNhY2hlICYmXG4gICAgICAgICAgICBjYWNoZWRNb2R1bGUub3JpZ2luYWxDb2RlID09PSBzb3VyY2VEZXNjcmlwdGlvbi5jb2RlICYmXG4gICAgICAgICAgICAhKGF3YWl0IHRoaXMucGx1Z2luRHJpdmVyLmhvb2tGaXJzdCgnc2hvdWxkVHJhbnNmb3JtQ2FjaGVkTW9kdWxlJywgW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYXN0OiBjYWNoZWRNb2R1bGUuYXN0LFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjYWNoZWRNb2R1bGUuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGNhY2hlZE1vZHVsZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YTogY2FjaGVkTW9kdWxlLm1ldGEsXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZVNpZGVFZmZlY3RzOiBjYWNoZWRNb2R1bGUubW9kdWxlU2lkZUVmZmVjdHMsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkU291cmNlczogY2FjaGVkTW9kdWxlLnJlc29sdmVkSWRzLFxuICAgICAgICAgICAgICAgICAgICBzeW50aGV0aWNOYW1lZEV4cG9ydHM6IGNhY2hlZE1vZHVsZS5zeW50aGV0aWNOYW1lZEV4cG9ydHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdKSkpIHtcbiAgICAgICAgICAgIGlmIChjYWNoZWRNb2R1bGUudHJhbnNmb3JtRmlsZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVtaXR0ZWRGaWxlIG9mIGNhY2hlZE1vZHVsZS50cmFuc2Zvcm1GaWxlcylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5Ecml2ZXIuZW1pdEZpbGUoZW1pdHRlZEZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgbW9kdWxlLnNldFNvdXJjZShjYWNoZWRNb2R1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW9kdWxlLnVwZGF0ZU9wdGlvbnMoc291cmNlRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgYXdhaXQgbW9kdWxlLnNldFNvdXJjZShhd2FpdCB0cmFuc2Zvcm0oc291cmNlRGVzY3JpcHRpb24sIG1vZHVsZSwgdGhpcy5wbHVnaW5Ecml2ZXIsIHRoaXMub3B0aW9ucy5vbkxvZykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGF3YWl0TG9hZE1vZHVsZXNQcm9taXNlKCkge1xuICAgICAgICBsZXQgc3RhcnRpbmdQcm9taXNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBzdGFydGluZ1Byb21pc2UgPSB0aGlzLmxhdGVzdExvYWRNb2R1bGVzUHJvbWlzZTtcbiAgICAgICAgICAgIGF3YWl0IHN0YXJ0aW5nUHJvbWlzZTtcbiAgICAgICAgfSB3aGlsZSAoc3RhcnRpbmdQcm9taXNlICE9PSB0aGlzLmxhdGVzdExvYWRNb2R1bGVzUHJvbWlzZSk7XG4gICAgfVxuICAgIGV4dGVuZExvYWRNb2R1bGVzUHJvbWlzZShsb2FkTmV3TW9kdWxlc1Byb21pc2UpIHtcbiAgICAgICAgdGhpcy5sYXRlc3RMb2FkTW9kdWxlc1Byb21pc2UgPSBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBsb2FkTmV3TW9kdWxlc1Byb21pc2UsXG4gICAgICAgICAgICB0aGlzLmxhdGVzdExvYWRNb2R1bGVzUHJvbWlzZVxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5sYXRlc3RMb2FkTW9kdWxlc1Byb21pc2UuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgLyogQXZvaWQgdW5oYW5kbGVkIFByb21pc2UgcmVqZWN0aW9ucyAqL1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGxvYWROZXdNb2R1bGVzUHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hEeW5hbWljRGVwZW5kZW5jaWVzKG1vZHVsZSwgcmVzb2x2ZUR5bmFtaWNJbXBvcnRQcm9taXNlcykge1xuICAgICAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBhd2FpdCBQcm9taXNlLmFsbChyZXNvbHZlRHluYW1pY0ltcG9ydFByb21pc2VzLm1hcChyZXNvbHZlRHluYW1pY0ltcG9ydFByb21pc2UgPT4gcmVzb2x2ZUR5bmFtaWNJbXBvcnRQcm9taXNlLnRoZW4oYXN5bmMgKFtkeW5hbWljSW1wb3J0LCByZXNvbHZlZElkXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkSWQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc29sdmVkSWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pY0ltcG9ydC5yZXNvbHV0aW9uID0gcmVzb2x2ZWRJZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoZHluYW1pY0ltcG9ydC5yZXNvbHV0aW9uID0gYXdhaXQgdGhpcy5mZXRjaFJlc29sdmVkRGVwZW5kZW5jeShyZWxhdGl2ZUlkKHJlc29sdmVkSWQuaWQpLCBtb2R1bGUuaWQsIHJlc29sdmVkSWQpKTtcbiAgICAgICAgfSkpKTtcbiAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuZHluYW1pY0RlcGVuZGVuY2llcy5hZGQoZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeS5keW5hbWljSW1wb3J0ZXJzLnB1c2gobW9kdWxlLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGlzIGlzIGEgcHJlbG9hZCwgdGhlbiB0aGlzIG1ldGhvZCBhbHdheXMgd2FpdHMgZm9yIHRoZSBkZXBlbmRlbmNpZXMgb2ZcbiAgICAvLyB0aGUgbW9kdWxlIHRvIGJlIHJlc29sdmVkLlxuICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIG1vZHVsZSBkb2VzIG5vdCBleGlzdCwgaXQgd2FpdHMgZm9yIHRoZSBtb2R1bGUgYW5kIGFsbFxuICAgIC8vIGl0cyBkZXBlbmRlbmNpZXMgdG8gYmUgbG9hZGVkLlxuICAgIC8vIE90aGVyd2lzZSwgaXQgcmV0dXJucyBpbW1lZGlhdGVseS5cbiAgICBhc3luYyBmZXRjaE1vZHVsZSh7IGF0dHJpYnV0ZXMsIGlkLCBtZXRhLCBtb2R1bGVTaWRlRWZmZWN0cywgc3ludGhldGljTmFtZWRFeHBvcnRzIH0sIGltcG9ydGVyLCBpc0VudHJ5LCBpc1ByZWxvYWQpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdNb2R1bGUgPSB0aGlzLm1vZHVsZXNCeUlkLmdldChpZCk7XG4gICAgICAgIGlmIChleGlzdGluZ01vZHVsZSBpbnN0YW5jZW9mIE1vZHVsZSkge1xuICAgICAgICAgICAgaWYgKGltcG9ydGVyICYmIGRvQXR0cmlidXRlc0RpZmZlcihhdHRyaWJ1dGVzLCBleGlzdGluZ01vZHVsZS5pbmZvLmF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uTG9nKExPR0xFVkVMX1dBUk4sIGxvZ0luY29uc2lzdGVudEltcG9ydEF0dHJpYnV0ZXMoZXhpc3RpbmdNb2R1bGUuaW5mby5hdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzLCBpZCwgaW1wb3J0ZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlRXhpc3RpbmdNb2R1bGUoZXhpc3RpbmdNb2R1bGUsIGlzRW50cnksIGlzUHJlbG9hZCk7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdNb2R1bGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4aXN0aW5nTW9kdWxlIGluc3RhbmNlb2YgRXh0ZXJuYWxNb2R1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihsb2dFeHRlcm5hbE1vZHVsZXNDYW5ub3RCZVRyYW5zZm9ybWVkVG9Nb2R1bGVzKGV4aXN0aW5nTW9kdWxlLmlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kdWxlID0gbmV3IE1vZHVsZSh0aGlzLmdyYXBoLCBpZCwgdGhpcy5vcHRpb25zLCBpc0VudHJ5LCBtb2R1bGVTaWRlRWZmZWN0cywgc3ludGhldGljTmFtZWRFeHBvcnRzLCBtZXRhLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgdGhpcy5tb2R1bGVzQnlJZC5zZXQoaWQsIG1vZHVsZSk7XG4gICAgICAgIGNvbnN0IGxvYWRQcm9taXNlID0gdGhpcy5hZGRNb2R1bGVTb3VyY2UoaWQsIGltcG9ydGVyLCBtb2R1bGUpLnRoZW4oKCkgPT4gW1xuICAgICAgICAgICAgdGhpcy5nZXRSZXNvbHZlU3RhdGljRGVwZW5kZW5jeVByb21pc2VzKG1vZHVsZSksXG4gICAgICAgICAgICB0aGlzLmdldFJlc29sdmVEeW5hbWljSW1wb3J0UHJvbWlzZXMobW9kdWxlKSxcbiAgICAgICAgICAgIGxvYWRBbmRSZXNvbHZlRGVwZW5kZW5jaWVzUHJvbWlzZVxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgbG9hZEFuZFJlc29sdmVEZXBlbmRlbmNpZXNQcm9taXNlID0gd2FpdEZvckRlcGVuZGVuY3lSZXNvbHV0aW9uKGxvYWRQcm9taXNlKS50aGVuKCgpID0+IHRoaXMucGx1Z2luRHJpdmVyLmhvb2tQYXJhbGxlbCgnbW9kdWxlUGFyc2VkJywgW21vZHVsZS5pbmZvXSkpO1xuICAgICAgICBsb2FkQW5kUmVzb2x2ZURlcGVuZGVuY2llc1Byb21pc2UuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgLyogYXZvaWQgdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9ucyAqL1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb2R1bGVMb2FkUHJvbWlzZXMuc2V0KG1vZHVsZSwgbG9hZFByb21pc2UpO1xuICAgICAgICBjb25zdCByZXNvbHZlRGVwZW5kZW5jeVByb21pc2VzID0gYXdhaXQgbG9hZFByb21pc2U7XG4gICAgICAgIGlmICghaXNQcmVsb2FkKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmZldGNoTW9kdWxlRGVwZW5kZW5jaWVzKG1vZHVsZSwgLi4ucmVzb2x2ZURlcGVuZGVuY3lQcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQcmVsb2FkID09PSBSRVNPTFZFX0RFUEVOREVOQ0lFUykge1xuICAgICAgICAgICAgYXdhaXQgbG9hZEFuZFJlc29sdmVEZXBlbmRlbmNpZXNQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoTW9kdWxlRGVwZW5kZW5jaWVzKG1vZHVsZSwgcmVzb2x2ZVN0YXRpY0RlcGVuZGVuY3lQcm9taXNlcywgcmVzb2x2ZUR5bmFtaWNEZXBlbmRlbmN5UHJvbWlzZXMsIGxvYWRBbmRSZXNvbHZlRGVwZW5kZW5jaWVzUHJvbWlzZSkge1xuICAgICAgICBpZiAodGhpcy5tb2R1bGVzV2l0aExvYWRlZERlcGVuZGVuY2llcy5oYXMobW9kdWxlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kdWxlc1dpdGhMb2FkZWREZXBlbmRlbmNpZXMuYWRkKG1vZHVsZSk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMuZmV0Y2hTdGF0aWNEZXBlbmRlbmNpZXMobW9kdWxlLCByZXNvbHZlU3RhdGljRGVwZW5kZW5jeVByb21pc2VzKSxcbiAgICAgICAgICAgIHRoaXMuZmV0Y2hEeW5hbWljRGVwZW5kZW5jaWVzKG1vZHVsZSwgcmVzb2x2ZUR5bmFtaWNEZXBlbmRlbmN5UHJvbWlzZXMpXG4gICAgICAgIF0pO1xuICAgICAgICBtb2R1bGUubGlua0ltcG9ydHMoKTtcbiAgICAgICAgLy8gVG8gaGFuZGxlIGVycm9ycyB3aGVuIHJlc29sdmluZyBkZXBlbmRlbmNpZXMgb3IgaW4gbW9kdWxlUGFyc2VkXG4gICAgICAgIGF3YWl0IGxvYWRBbmRSZXNvbHZlRGVwZW5kZW5jaWVzUHJvbWlzZTtcbiAgICB9XG4gICAgZmV0Y2hSZXNvbHZlZERlcGVuZGVuY3koc291cmNlLCBpbXBvcnRlciwgcmVzb2x2ZWRJZCkge1xuICAgICAgICBpZiAocmVzb2x2ZWRJZC5leHRlcm5hbCkge1xuICAgICAgICAgICAgY29uc3QgeyBhdHRyaWJ1dGVzLCBleHRlcm5hbCwgaWQsIG1vZHVsZVNpZGVFZmZlY3RzLCBtZXRhIH0gPSByZXNvbHZlZElkO1xuICAgICAgICAgICAgbGV0IGV4dGVybmFsTW9kdWxlID0gdGhpcy5tb2R1bGVzQnlJZC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKCFleHRlcm5hbE1vZHVsZSkge1xuICAgICAgICAgICAgICAgIGV4dGVybmFsTW9kdWxlID0gbmV3IEV4dGVybmFsTW9kdWxlKHRoaXMub3B0aW9ucywgaWQsIG1vZHVsZVNpZGVFZmZlY3RzLCBtZXRhLCBleHRlcm5hbCAhPT0gJ2Fic29sdXRlJyAmJiBpc0Fic29sdXRlJDEoaWQpLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZHVsZXNCeUlkLnNldChpZCwgZXh0ZXJuYWxNb2R1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIShleHRlcm5hbE1vZHVsZSBpbnN0YW5jZW9mIEV4dGVybmFsTW9kdWxlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihsb2dJbnRlcm5hbElkQ2Fubm90QmVFeHRlcm5hbChzb3VyY2UsIGltcG9ydGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb0F0dHJpYnV0ZXNEaWZmZXIoZXh0ZXJuYWxNb2R1bGUuaW5mby5hdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkxvZyhMT0dMRVZFTF9XQVJOLCBsb2dJbmNvbnNpc3RlbnRJbXBvcnRBdHRyaWJ1dGVzKGV4dGVybmFsTW9kdWxlLmluZm8uYXR0cmlidXRlcywgYXR0cmlidXRlcywgc291cmNlLCBpbXBvcnRlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShleHRlcm5hbE1vZHVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hNb2R1bGUocmVzb2x2ZWRJZCwgaW1wb3J0ZXIsIGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoU3RhdGljRGVwZW5kZW5jaWVzKG1vZHVsZSwgcmVzb2x2ZVN0YXRpY0RlcGVuZGVuY3lQcm9taXNlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3kgb2YgYXdhaXQgUHJvbWlzZS5hbGwocmVzb2x2ZVN0YXRpY0RlcGVuZGVuY3lQcm9taXNlcy5tYXAocmVzb2x2ZVN0YXRpY0RlcGVuZGVuY3lQcm9taXNlID0+IHJlc29sdmVTdGF0aWNEZXBlbmRlbmN5UHJvbWlzZS50aGVuKChbc291cmNlLCByZXNvbHZlZElkXSkgPT4gdGhpcy5mZXRjaFJlc29sdmVkRGVwZW5kZW5jeShzb3VyY2UsIG1vZHVsZS5pZCwgcmVzb2x2ZWRJZCkpKSkpIHtcbiAgICAgICAgICAgIG1vZHVsZS5kZXBlbmRlbmNpZXMuYWRkKGRlcGVuZGVuY3kpO1xuICAgICAgICAgICAgZGVwZW5kZW5jeS5pbXBvcnRlcnMucHVzaChtb2R1bGUuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnRyZWVzaGFrZSB8fCBtb2R1bGUuaW5mby5tb2R1bGVTaWRlRWZmZWN0cyA9PT0gJ25vLXRyZWVzaGFrZScpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVwZW5kZW5jeSBvZiBtb2R1bGUuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3kgaW5zdGFuY2VvZiBNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeS5pbXBvcnRlZEZyb21Ob3RUcmVlc2hha2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Tm9ybWFsaXplZFJlc29sdmVkSWRXaXRob3V0RGVmYXVsdHMocmVzb2x2ZUlkUmVzdWx0LCBpbXBvcnRlciwgc291cmNlKSB7XG4gICAgICAgIGNvbnN0IHsgbWFrZUFic29sdXRlRXh0ZXJuYWxzUmVsYXRpdmUgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKHJlc29sdmVJZFJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlSWRSZXN1bHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZXJuYWwgPSByZXNvbHZlSWRSZXN1bHQuZXh0ZXJuYWwgfHwgdGhpcy5vcHRpb25zLmV4dGVybmFsKHJlc29sdmVJZFJlc3VsdC5pZCwgaW1wb3J0ZXIsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnJlc29sdmVJZFJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWw6IGV4dGVybmFsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZXh0ZXJuYWwgPT09ICdyZWxhdGl2ZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXNBYnNvbHV0ZSQxKHJlc29sdmVJZFJlc3VsdC5pZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXh0ZXJuYWwgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOb3RBYnNvbHV0ZUV4dGVybmFsKHJlc29sdmVJZFJlc3VsdC5pZCwgc291cmNlLCBtYWtlQWJzb2x1dGVFeHRlcm5hbHNSZWxhdGl2ZSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Fic29sdXRlJylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXh0ZXJuYWwgPSB0aGlzLm9wdGlvbnMuZXh0ZXJuYWwocmVzb2x2ZUlkUmVzdWx0LCBpbXBvcnRlciwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGV4dGVybmFsOiBleHRlcm5hbCAmJlxuICAgICAgICAgICAgICAgICAgICAoaXNOb3RBYnNvbHV0ZUV4dGVybmFsKHJlc29sdmVJZFJlc3VsdCwgc291cmNlLCBtYWtlQWJzb2x1dGVFeHRlcm5hbHNSZWxhdGl2ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhYnNvbHV0ZScpLFxuICAgICAgICAgICAgICAgIGlkOiBleHRlcm5hbCAmJiBtYWtlQWJzb2x1dGVFeHRlcm5hbHNSZWxhdGl2ZVxuICAgICAgICAgICAgICAgICAgICA/IG5vcm1hbGl6ZVJlbGF0aXZlRXh0ZXJuYWxJZChyZXNvbHZlSWRSZXN1bHQsIGltcG9ydGVyKVxuICAgICAgICAgICAgICAgICAgICA6IHJlc29sdmVJZFJlc3VsdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IG1ha2VBYnNvbHV0ZUV4dGVybmFsc1JlbGF0aXZlXG4gICAgICAgICAgICA/IG5vcm1hbGl6ZVJlbGF0aXZlRXh0ZXJuYWxJZChzb3VyY2UsIGltcG9ydGVyKVxuICAgICAgICAgICAgOiBzb3VyY2U7XG4gICAgICAgIGlmIChyZXNvbHZlSWRSZXN1bHQgIT09IGZhbHNlICYmICF0aGlzLm9wdGlvbnMuZXh0ZXJuYWwoaWQsIGltcG9ydGVyLCB0cnVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4dGVybmFsOiBpc05vdEFic29sdXRlRXh0ZXJuYWwoaWQsIHNvdXJjZSwgbWFrZUFic29sdXRlRXh0ZXJuYWxzUmVsYXRpdmUpIHx8ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICBpZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRSZXNvbHZlRHluYW1pY0ltcG9ydFByb21pc2VzKG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLmR5bmFtaWNJbXBvcnRzLm1hcChhc3luYyAoZHluYW1pY0ltcG9ydCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRJZCA9IGF3YWl0IHRoaXMucmVzb2x2ZUR5bmFtaWNJbXBvcnQobW9kdWxlLCBkeW5hbWljSW1wb3J0LmFyZ3VtZW50LCBtb2R1bGUuaWQsIGdldEF0dHJpYnV0ZXNGcm9tSW1wb3J0RXhwcmVzc2lvbihkeW5hbWljSW1wb3J0Lm5vZGUpKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZElkICYmIHR5cGVvZiByZXNvbHZlZElkID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGR5bmFtaWNJbXBvcnQuaWQgPSByZXNvbHZlZElkLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtkeW5hbWljSW1wb3J0LCByZXNvbHZlZElkXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFJlc29sdmVTdGF0aWNEZXBlbmRlbmN5UHJvbWlzZXMobW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG1vZHVsZS5zb3VyY2VzV2l0aEF0dHJpYnV0ZXMsIGFzeW5jIChbc291cmNlLCBhdHRyaWJ1dGVzXSkgPT4gW1xuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgKG1vZHVsZS5yZXNvbHZlZElkc1tzb3VyY2VdID1cbiAgICAgICAgICAgICAgICBtb2R1bGUucmVzb2x2ZWRJZHNbc291cmNlXSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUludmFsaWRSZXNvbHZlZElkKGF3YWl0IHRoaXMucmVzb2x2ZUlkKHNvdXJjZSwgbW9kdWxlLmlkLCBFTVBUWV9PQkpFQ1QsIGZhbHNlLCBhdHRyaWJ1dGVzKSwgc291cmNlLCBtb2R1bGUuaWQsIGF0dHJpYnV0ZXMpKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgZ2V0UmVzb2x2ZWRJZFdpdGhEZWZhdWx0cyhyZXNvbHZlZElkLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICghcmVzb2x2ZWRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXh0ZXJuYWwgPSByZXNvbHZlZElkLmV4dGVybmFsIHx8IGZhbHNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXR0cmlidXRlczogcmVzb2x2ZWRJZC5hdHRyaWJ1dGVzIHx8IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBleHRlcm5hbCxcbiAgICAgICAgICAgIGlkOiByZXNvbHZlZElkLmlkLFxuICAgICAgICAgICAgbWV0YTogcmVzb2x2ZWRJZC5tZXRhIHx8IHt9LFxuICAgICAgICAgICAgbW9kdWxlU2lkZUVmZmVjdHM6IHJlc29sdmVkSWQubW9kdWxlU2lkZUVmZmVjdHMgPz8gdGhpcy5oYXNNb2R1bGVTaWRlRWZmZWN0cyhyZXNvbHZlZElkLmlkLCAhIWV4dGVybmFsKSxcbiAgICAgICAgICAgIHJlc29sdmVkQnk6IHJlc29sdmVkSWQucmVzb2x2ZWRCeSA/PyAncm9sbHVwJyxcbiAgICAgICAgICAgIHN5bnRoZXRpY05hbWVkRXhwb3J0czogcmVzb2x2ZWRJZC5zeW50aGV0aWNOYW1lZEV4cG9ydHMgPz8gZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlRXhpc3RpbmdNb2R1bGUobW9kdWxlLCBpc0VudHJ5LCBpc1ByZWxvYWQpIHtcbiAgICAgICAgY29uc3QgbG9hZFByb21pc2UgPSB0aGlzLm1vZHVsZUxvYWRQcm9taXNlcy5nZXQobW9kdWxlKTtcbiAgICAgICAgaWYgKGlzUHJlbG9hZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzUHJlbG9hZCA9PT0gUkVTT0xWRV9ERVBFTkRFTkNJRVNcbiAgICAgICAgICAgICAgICA/IHdhaXRGb3JEZXBlbmRlbmN5UmVzb2x1dGlvbihsb2FkUHJvbWlzZSlcbiAgICAgICAgICAgICAgICA6IGxvYWRQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0VudHJ5KSB7XG4gICAgICAgICAgICAvLyBUaGlzIHJldmVydHMgdGhlIGNoYW5nZXMgaW4gYWRkRW50cnlXaXRoSW1wbGljaXREZXBlbmRhbnRzIGFuZCBuZWVkcyB0b1xuICAgICAgICAgICAgLy8gYmUgcGVyZm9ybWVkIGF0b21pY2FsbHlcbiAgICAgICAgICAgIG1vZHVsZS5pbmZvLmlzRW50cnkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlcy5kZWxldGUobW9kdWxlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVwZW5kYW50IG9mIG1vZHVsZS5pbXBsaWNpdGx5TG9hZGVkQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBkZXBlbmRhbnQuaW1wbGljaXRseUxvYWRlZEJlZm9yZS5kZWxldGUobW9kdWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZHVsZS5pbXBsaWNpdGx5TG9hZGVkQWZ0ZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaE1vZHVsZURlcGVuZGVuY2llcyhtb2R1bGUsIC4uLihhd2FpdCBsb2FkUHJvbWlzZSkpO1xuICAgIH1cbiAgICBoYW5kbGVJbnZhbGlkUmVzb2x2ZWRJZChyZXNvbHZlZElkLCBzb3VyY2UsIGltcG9ydGVyLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZElkID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaXNSZWxhdGl2ZShzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGxvZ1VucmVzb2x2ZWRJbXBvcnQoc291cmNlLCBpbXBvcnRlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uTG9nKExPR0xFVkVMX1dBUk4sIGxvZ1VucmVzb2x2ZWRJbXBvcnRUcmVhdGVkQXNFeHRlcm5hbChzb3VyY2UsIGltcG9ydGVyKSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgaWQ6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICBtZXRhOiB7fSxcbiAgICAgICAgICAgICAgICBtb2R1bGVTaWRlRWZmZWN0czogdGhpcy5oYXNNb2R1bGVTaWRlRWZmZWN0cyhzb3VyY2UsIHRydWUpLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkQnk6ICdyb2xsdXAnLFxuICAgICAgICAgICAgICAgIHN5bnRoZXRpY05hbWVkRXhwb3J0czogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzb2x2ZWRJZC5leHRlcm5hbCAmJiByZXNvbHZlZElkLnN5bnRoZXRpY05hbWVkRXhwb3J0cykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uTG9nKExPR0xFVkVMX1dBUk4sIGxvZ0V4dGVybmFsU3ludGhldGljRXhwb3J0cyhzb3VyY2UsIGltcG9ydGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkSWQ7XG4gICAgfVxuICAgIGFzeW5jIGxvYWRFbnRyeU1vZHVsZSh1bnJlc29sdmVkSWQsIGlzRW50cnksIGltcG9ydGVyLCBpbXBsaWNpdGx5TG9hZGVkQmVmb3JlLCBpc0xvYWRGb3JNYW51YWxDaHVua3MgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCByZXNvbHZlSWRSZXN1bHQgPSBhd2FpdCByZXNvbHZlSWQodW5yZXNvbHZlZElkLCBpbXBvcnRlciwgdGhpcy5vcHRpb25zLnByZXNlcnZlU3ltbGlua3MsIHRoaXMucGx1Z2luRHJpdmVyLCB0aGlzLnJlc29sdmVJZCwgbnVsbCwgRU1QVFlfT0JKRUNULCB0cnVlLCBFTVBUWV9PQkpFQ1QpO1xuICAgICAgICBpZiAocmVzb2x2ZUlkUmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihpbXBsaWNpdGx5TG9hZGVkQmVmb3JlID09PSBudWxsXG4gICAgICAgICAgICAgICAgPyBsb2dVbnJlc29sdmVkRW50cnkodW5yZXNvbHZlZElkKVxuICAgICAgICAgICAgICAgIDogbG9nVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kYW50KHVucmVzb2x2ZWRJZCwgaW1wbGljaXRseUxvYWRlZEJlZm9yZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRXh0ZXJuYWxNb2R1bGVzID0gdHlwZW9mIHJlc29sdmVJZFJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzb2x2ZUlkUmVzdWx0LmV4dGVybmFsO1xuICAgICAgICBpZiAocmVzb2x2ZUlkUmVzdWx0ID09PSBmYWxzZSB8fCBpc0V4dGVybmFsTW9kdWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKGltcGxpY2l0bHlMb2FkZWRCZWZvcmUgPT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGlzRXh0ZXJuYWxNb2R1bGVzICYmIGlzTG9hZEZvck1hbnVhbENodW5rc1xuICAgICAgICAgICAgICAgICAgICA/IGxvZ0V4dGVybmFsTW9kdWxlc0Nhbm5vdEJlSW5jbHVkZWRJbk1hbnVhbENodW5rcyh1bnJlc29sdmVkSWQpXG4gICAgICAgICAgICAgICAgICAgIDogbG9nRW50cnlDYW5ub3RCZUV4dGVybmFsKHVucmVzb2x2ZWRJZClcbiAgICAgICAgICAgICAgICA6IGxvZ0ltcGxpY2l0RGVwZW5kYW50Q2Fubm90QmVFeHRlcm5hbCh1bnJlc29sdmVkSWQsIGltcGxpY2l0bHlMb2FkZWRCZWZvcmUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaE1vZHVsZSh0aGlzLmdldFJlc29sdmVkSWRXaXRoRGVmYXVsdHModHlwZW9mIHJlc29sdmVJZFJlc3VsdCA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gcmVzb2x2ZUlkUmVzdWx0XG4gICAgICAgICAgICA6IHsgaWQ6IHJlc29sdmVJZFJlc3VsdCB9LCBFTVBUWV9PQkpFQ1QpLCB1bmRlZmluZWQsIGlzRW50cnksIGZhbHNlKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZUR5bmFtaWNJbXBvcnQobW9kdWxlLCBzcGVjaWZpZXIsIGltcG9ydGVyLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdXRpb24gPSBhd2FpdCB0aGlzLnBsdWdpbkRyaXZlci5ob29rRmlyc3QoJ3Jlc29sdmVEeW5hbWljSW1wb3J0JywgW1xuICAgICAgICAgICAgc3BlY2lmaWVyLFxuICAgICAgICAgICAgaW1wb3J0ZXIsXG4gICAgICAgICAgICB7IGF0dHJpYnV0ZXMgfVxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjaWZpZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc29sdXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc29sdXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJlc29sdmVkSWRXaXRoRGVmYXVsdHMocmVzb2x1dGlvbiwgYXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc29sdXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdSZXNvbHV0aW9uID0gbW9kdWxlLnJlc29sdmVkSWRzW3NwZWNpZmllcl07XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdSZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvQXR0cmlidXRlc0RpZmZlcihleGlzdGluZ1Jlc29sdXRpb24uYXR0cmlidXRlcywgYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uTG9nKExPR0xFVkVMX1dBUk4sIGxvZ0luY29uc2lzdGVudEltcG9ydEF0dHJpYnV0ZXMoZXhpc3RpbmdSZXNvbHV0aW9uLmF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMsIHNwZWNpZmllciwgaW1wb3J0ZXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nUmVzb2x1dGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAobW9kdWxlLnJlc29sdmVkSWRzW3NwZWNpZmllcl0gPSB0aGlzLmhhbmRsZUludmFsaWRSZXNvbHZlZElkKGF3YWl0IHRoaXMucmVzb2x2ZUlkKHNwZWNpZmllciwgbW9kdWxlLmlkLCBFTVBUWV9PQkpFQ1QsIGZhbHNlLCBhdHRyaWJ1dGVzKSwgc3BlY2lmaWVyLCBtb2R1bGUuaWQsIGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVJbnZhbGlkUmVzb2x2ZWRJZCh0aGlzLmdldFJlc29sdmVkSWRXaXRoRGVmYXVsdHModGhpcy5nZXROb3JtYWxpemVkUmVzb2x2ZWRJZFdpdGhvdXREZWZhdWx0cyhyZXNvbHV0aW9uLCBpbXBvcnRlciwgc3BlY2lmaWVyKSwgYXR0cmlidXRlcyksIHNwZWNpZmllciwgaW1wb3J0ZXIsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlbGF0aXZlRXh0ZXJuYWxJZChzb3VyY2UsIGltcG9ydGVyKSB7XG4gICAgcmV0dXJuIGlzUmVsYXRpdmUoc291cmNlKVxuICAgICAgICA/IGltcG9ydGVyXG4gICAgICAgICAgICA/IHJlc29sdmUkMShpbXBvcnRlciwgJy4uJywgc291cmNlKVxuICAgICAgICAgICAgOiByZXNvbHZlJDEoc291cmNlKVxuICAgICAgICA6IHNvdXJjZTtcbn1cbmZ1bmN0aW9uIGFkZENodW5rTmFtZXNUb01vZHVsZShtb2R1bGUsIHsgZmlsZU5hbWUsIG5hbWUgfSwgaXNVc2VyRGVmaW5lZCwgcHJpb3JpdHkpIHtcbiAgICBpZiAoZmlsZU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgbW9kdWxlLmNodW5rRmlsZU5hbWVzLmFkZChmaWxlTmFtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gQWx3YXlzIGtlZXAgY2h1bmtOYW1lcyBzb3J0ZWQgYnkgcHJpb3JpdHlcbiAgICAgICAgbGV0IG5hbWVQb3NpdGlvbiA9IDA7XG4gICAgICAgIHdoaWxlIChtb2R1bGUuY2h1bmtOYW1lc1tuYW1lUG9zaXRpb25dPy5wcmlvcml0eSA8IHByaW9yaXR5KVxuICAgICAgICAgICAgbmFtZVBvc2l0aW9uKys7XG4gICAgICAgIG1vZHVsZS5jaHVua05hbWVzLnNwbGljZShuYW1lUG9zaXRpb24sIDAsIHsgaXNVc2VyRGVmaW5lZCwgbmFtZSwgcHJpb3JpdHkgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNOb3RBYnNvbHV0ZUV4dGVybmFsKGlkLCBzb3VyY2UsIG1ha2VBYnNvbHV0ZUV4dGVybmFsc1JlbGF0aXZlKSB7XG4gICAgcmV0dXJuIChtYWtlQWJzb2x1dGVFeHRlcm5hbHNSZWxhdGl2ZSA9PT0gdHJ1ZSB8fFxuICAgICAgICAobWFrZUFic29sdXRlRXh0ZXJuYWxzUmVsYXRpdmUgPT09ICdpZlJlbGF0aXZlU291cmNlJyAmJiBpc1JlbGF0aXZlKHNvdXJjZSkpIHx8XG4gICAgICAgICFpc0Fic29sdXRlJDEoaWQpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JEZXBlbmRlbmN5UmVzb2x1dGlvbihsb2FkUHJvbWlzZSkge1xuICAgIGNvbnN0IFtyZXNvbHZlU3RhdGljRGVwZW5kZW5jeVByb21pc2VzLCByZXNvbHZlRHluYW1pY0ltcG9ydFByb21pc2VzXSA9IGF3YWl0IGxvYWRQcm9taXNlO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbLi4ucmVzb2x2ZVN0YXRpY0RlcGVuZGVuY3lQcm9taXNlcywgLi4ucmVzb2x2ZUR5bmFtaWNJbXBvcnRQcm9taXNlc10pO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUFzc2V0RmlsZU5hbWUobmFtZSwgbmFtZXMsIHNvdXJjZSwgb3JpZ2luYWxGaWxlTmFtZSwgb3JpZ2luYWxGaWxlTmFtZXMsIHNvdXJjZUhhc2gsIG91dHB1dE9wdGlvbnMsIGJ1bmRsZSwgaW5wdXRPcHRpb25zKSB7XG4gICAgY29uc3QgZW1pdHRlZE5hbWUgPSBvdXRwdXRPcHRpb25zLnNhbml0aXplRmlsZU5hbWUobmFtZSB8fCAnYXNzZXQnKTtcbiAgICByZXR1cm4gbWFrZVVuaXF1ZShyZW5kZXJOYW1lUGF0dGVybih0eXBlb2Ygb3V0cHV0T3B0aW9ucy5hc3NldEZpbGVOYW1lcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG91dHB1dE9wdGlvbnMuYXNzZXRGaWxlTmFtZXMoe1xuICAgICAgICAgICAgLy8gQWRkaXRpb25hbGx5LCB0aGlzIHNob3VsZCBiZSBub24tZW51bWVyYWJsZSBpbiB0aGUgbmV4dCBtYWpvclxuICAgICAgICAgICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgICAgICAgICAgd2FybkRlcHJlY2F0aW9uKCdBY2Nlc3NpbmcgdGhlIFwibmFtZVwiIHByb3BlcnR5IG9mIGVtaXR0ZWQgYXNzZXRzIHdoZW4gZ2VuZXJhdGluZyB0aGUgZmlsZSBuYW1lIGlzIGRlcHJlY2F0ZWQuIFVzZSB0aGUgXCJuYW1lc1wiIHByb3BlcnR5IGluc3RlYWQuJywgVVJMX0dFTkVSQVRFQlVORExFLCBmYWxzZSwgaW5wdXRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lcyxcbiAgICAgICAgICAgIC8vIEFkZGl0aW9uYWxseSwgdGhpcyBzaG91bGQgYmUgbm9uLWVudW1lcmFibGUgaW4gdGhlIG5leHQgbWFqb3JcbiAgICAgICAgICAgIGdldCBvcmlnaW5hbEZpbGVOYW1lKCkge1xuICAgICAgICAgICAgICAgIHdhcm5EZXByZWNhdGlvbignQWNjZXNzaW5nIHRoZSBcIm9yaWdpbmFsRmlsZU5hbWVcIiBwcm9wZXJ0eSBvZiBlbWl0dGVkIGFzc2V0cyB3aGVuIGdlbmVyYXRpbmcgdGhlIGZpbGUgbmFtZSBpcyBkZXByZWNhdGVkLiBVc2UgdGhlIFwib3JpZ2luYWxGaWxlTmFtZXNcIiBwcm9wZXJ0eSBpbnN0ZWFkLicsIFVSTF9HRU5FUkFURUJVTkRMRSwgZmFsc2UsIGlucHV0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsRmlsZU5hbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3JpZ2luYWxGaWxlTmFtZXMsXG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICB0eXBlOiAnYXNzZXQnXG4gICAgICAgIH0pXG4gICAgICAgIDogb3V0cHV0T3B0aW9ucy5hc3NldEZpbGVOYW1lcywgJ291dHB1dC5hc3NldEZpbGVOYW1lcycsIHtcbiAgICAgICAgZXh0OiAoKSA9PiBleHRuYW1lKGVtaXR0ZWROYW1lKS5zbGljZSgxKSxcbiAgICAgICAgZXh0bmFtZTogKCkgPT4gZXh0bmFtZShlbWl0dGVkTmFtZSksXG4gICAgICAgIGhhc2g6IHNpemUgPT4gc291cmNlSGFzaC5zbGljZSgwLCBNYXRoLm1heCgwLCBzaXplIHx8IERFRkFVTFRfSEFTSF9TSVpFKSksXG4gICAgICAgIG5hbWU6ICgpID0+IGVtaXR0ZWROYW1lLnNsaWNlKDAsIE1hdGgubWF4KDAsIGVtaXR0ZWROYW1lLmxlbmd0aCAtIGV4dG5hbWUoZW1pdHRlZE5hbWUpLmxlbmd0aCkpXG4gICAgfSksIGJ1bmRsZSk7XG59XG5mdW5jdGlvbiByZXNlcnZlRmlsZU5hbWVJbkJ1bmRsZShmaWxlTmFtZSwgeyBidW5kbGUgfSwgbG9nKSB7XG4gICAgaWYgKGJ1bmRsZVtsb3dlcmNhc2VCdW5kbGVLZXlzXS5oYXMoZmlsZU5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgbG9nKExPR0xFVkVMX1dBUk4sIGxvZ0ZpbGVOYW1lQ29uZmxpY3QoZmlsZU5hbWUpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJ1bmRsZVtmaWxlTmFtZV0gPSBGSUxFX1BMQUNFSE9MREVSO1xuICAgIH1cbn1cbmNvbnN0IGVtaXR0ZWRGaWxlVHlwZXMgPSBuZXcgU2V0KFsnY2h1bmsnLCAnYXNzZXQnLCAncHJlYnVpbHQtY2h1bmsnXSk7XG5mdW5jdGlvbiBoYXNWYWxpZFR5cGUoZW1pdHRlZEZpbGUpIHtcbiAgICByZXR1cm4gQm9vbGVhbihlbWl0dGVkRmlsZSAmJlxuICAgICAgICBlbWl0dGVkRmlsZVR5cGVzLmhhcyhlbWl0dGVkRmlsZS50eXBlKSk7XG59XG5mdW5jdGlvbiBoYXNWYWxpZE5hbWUoZW1pdHRlZEZpbGUpIHtcbiAgICBjb25zdCB2YWxpZGF0ZWROYW1lID0gZW1pdHRlZEZpbGUuZmlsZU5hbWUgfHwgZW1pdHRlZEZpbGUubmFtZTtcbiAgICByZXR1cm4gIXZhbGlkYXRlZE5hbWUgfHwgKHR5cGVvZiB2YWxpZGF0ZWROYW1lID09PSAnc3RyaW5nJyAmJiAhaXNQYXRoRnJhZ21lbnQodmFsaWRhdGVkTmFtZSkpO1xufVxuZnVuY3Rpb24gZ2V0VmFsaWRTb3VyY2Uoc291cmNlLCBlbWl0dGVkRmlsZSwgZmlsZVJlZmVyZW5jZUlkKSB7XG4gICAgaWYgKCEodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgY29uc3QgYXNzZXROYW1lID0gZW1pdHRlZEZpbGUuZmlsZU5hbWUgfHwgZW1pdHRlZEZpbGUubmFtZSB8fCBmaWxlUmVmZXJlbmNlSWQ7XG4gICAgICAgIHJldHVybiBlcnJvcihsb2dGYWlsZWRWYWxpZGF0aW9uKGBDb3VsZCBub3Qgc2V0IHNvdXJjZSBmb3IgJHt0eXBlb2YgYXNzZXROYW1lID09PSAnc3RyaW5nJyA/IGBhc3NldCBcIiR7YXNzZXROYW1lfVwiYCA6ICd1bm5hbWVkIGFzc2V0J30sIGFzc2V0IHNvdXJjZSBuZWVkcyB0byBiZSBhIHN0cmluZywgVWludDhBcnJheSBvciBCdWZmZXIuYCkpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xufVxuZnVuY3Rpb24gZ2V0QXNzZXRGaWxlTmFtZShmaWxlLCByZWZlcmVuY2VJZCkge1xuICAgIGlmICh0eXBlb2YgZmlsZS5maWxlTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKGxvZ0Fzc2V0Tm90RmluYWxpc2VkRm9yRmlsZU5hbWUoZmlsZS5uYW1lIHx8IHJlZmVyZW5jZUlkKSk7XG4gICAgfVxuICAgIHJldHVybiBmaWxlLmZpbGVOYW1lO1xufVxuZnVuY3Rpb24gZ2V0Q2h1bmtGaWxlTmFtZShmaWxlLCBmYWNhZGVDaHVua0J5TW9kdWxlKSB7XG4gICAgaWYgKGZpbGUuZmlsZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZpbGUuZmlsZU5hbWU7XG4gICAgfVxuICAgIGlmIChmYWNhZGVDaHVua0J5TW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBmYWNhZGVDaHVua0J5TW9kdWxlLmdldChmaWxlLm1vZHVsZSkuZ2V0RmlsZU5hbWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yKGxvZ0NodW5rTm90R2VuZXJhdGVkRm9yRmlsZU5hbWUoZmlsZS5maWxlTmFtZSB8fCBmaWxlLm5hbWUpKTtcbn1cbmNsYXNzIEZpbGVFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihncmFwaCwgb3B0aW9ucywgYmFzZUZpbGVFbWl0dGVyKSB7XG4gICAgICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5mYWNhZGVDaHVua0J5TW9kdWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0SWRCYXNlID0gMTtcbiAgICAgICAgdGhpcy5vdXRwdXQgPSBudWxsO1xuICAgICAgICB0aGlzLm91dHB1dEZpbGVFbWl0dGVycyA9IFtdO1xuICAgICAgICB0aGlzLmVtaXRGaWxlID0gKGVtaXR0ZWRGaWxlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhc1ZhbGlkVHlwZShlbWl0dGVkRmlsZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IobG9nRmFpbGVkVmFsaWRhdGlvbihgRW1pdHRlZCBmaWxlcyBtdXN0IGJlIG9mIHR5cGUgXCJhc3NldFwiLCBcImNodW5rXCIgb3IgXCJwcmVidWlsdC1jaHVua1wiLCByZWNlaXZlZCBcIiR7ZW1pdHRlZEZpbGUgJiYgZW1pdHRlZEZpbGUudHlwZX1cIi5gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW1pdHRlZEZpbGUudHlwZSA9PT0gJ3ByZWJ1aWx0LWNodW5rJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXRQcmVidWlsdENodW5rKGVtaXR0ZWRGaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzVmFsaWROYW1lKGVtaXR0ZWRGaWxlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihsb2dGYWlsZWRWYWxpZGF0aW9uKGBUaGUgXCJmaWxlTmFtZVwiIG9yIFwibmFtZVwiIHByb3BlcnRpZXMgb2YgZW1pdHRlZCBjaHVua3MgYW5kIGFzc2V0cyBtdXN0IGJlIHN0cmluZ3MgdGhhdCBhcmUgbmVpdGhlciBhYnNvbHV0ZSBub3IgcmVsYXRpdmUgcGF0aHMsIHJlY2VpdmVkIFwiJHtlbWl0dGVkRmlsZS5maWxlTmFtZSB8fCBlbWl0dGVkRmlsZS5uYW1lfVwiLmApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbWl0dGVkRmlsZS50eXBlID09PSAnY2h1bmsnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdENodW5rKGVtaXR0ZWRGaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXRBc3NldChlbWl0dGVkRmlsZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmluYWxpc2VBc3NldHMgPSAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtyZWZlcmVuY2VJZCwgZW1pdHRlZEZpbGVdIG9mIHRoaXMuZmlsZXNCeVJlZmVyZW5jZUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVtaXR0ZWRGaWxlLnR5cGUgPT09ICdhc3NldCcgJiYgdHlwZW9mIGVtaXR0ZWRGaWxlLmZpbGVOYW1lICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGxvZ05vQXNzZXRTb3VyY2VTZXQoZW1pdHRlZEZpbGUubmFtZSB8fCByZWZlcmVuY2VJZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEZpbGVOYW1lID0gKGZpbGVSZWZlcmVuY2VJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW1pdHRlZEZpbGUgPSB0aGlzLmZpbGVzQnlSZWZlcmVuY2VJZC5nZXQoZmlsZVJlZmVyZW5jZUlkKTtcbiAgICAgICAgICAgIGlmICghZW1pdHRlZEZpbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGxvZ0ZpbGVSZWZlcmVuY2VJZE5vdEZvdW5kRm9yRmlsZW5hbWUoZmlsZVJlZmVyZW5jZUlkKSk7XG4gICAgICAgICAgICBpZiAoZW1pdHRlZEZpbGUudHlwZSA9PT0gJ2NodW5rJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRDaHVua0ZpbGVOYW1lKGVtaXR0ZWRGaWxlLCB0aGlzLmZhY2FkZUNodW5rQnlNb2R1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVtaXR0ZWRGaWxlLnR5cGUgPT09ICdwcmVidWlsdC1jaHVuaycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1pdHRlZEZpbGUuZmlsZU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0QXNzZXRGaWxlTmFtZShlbWl0dGVkRmlsZSwgZmlsZVJlZmVyZW5jZUlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRBc3NldFNvdXJjZSA9IChyZWZlcmVuY2VJZCwgcmVxdWVzdGVkU291cmNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb25zdW1lZEZpbGUgPSB0aGlzLmZpbGVzQnlSZWZlcmVuY2VJZC5nZXQocmVmZXJlbmNlSWQpO1xuICAgICAgICAgICAgaWYgKCFjb25zdW1lZEZpbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGxvZ0Fzc2V0UmVmZXJlbmNlSWROb3RGb3VuZEZvclNldFNvdXJjZShyZWZlcmVuY2VJZCkpO1xuICAgICAgICAgICAgaWYgKGNvbnN1bWVkRmlsZS50eXBlICE9PSAnYXNzZXQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGxvZ0ZhaWxlZFZhbGlkYXRpb24oYEFzc2V0IHNvdXJjZXMgY2FuIG9ubHkgYmUgc2V0IGZvciBlbWl0dGVkIGFzc2V0cyBidXQgXCIke3JlZmVyZW5jZUlkfVwiIGlzIGFuIGVtaXR0ZWQgY2h1bmsuYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnN1bWVkRmlsZS5zb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihsb2dBc3NldFNvdXJjZUFscmVhZHlTZXQoY29uc3VtZWRGaWxlLm5hbWUgfHwgcmVmZXJlbmNlSWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGdldFZhbGlkU291cmNlKHJlcXVlc3RlZFNvdXJjZSwgY29uc3VtZWRGaWxlLCByZWZlcmVuY2VJZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsaXplQWRkaXRpb25hbEFzc2V0KGNvbnN1bWVkRmlsZSwgc291cmNlLCB0aGlzLm91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdW1lZEZpbGUuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW1pdHRlciBvZiB0aGlzLm91dHB1dEZpbGVFbWl0dGVycykge1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmZpbmFsaXplQWRkaXRpb25hbEFzc2V0KGNvbnN1bWVkRmlsZSwgc291cmNlLCBlbWl0dGVyLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldENodW5rSW5mb3JtYXRpb24gPSAoZmFjYWRlQ2h1bmtCeU1vZHVsZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5mYWNhZGVDaHVua0J5TW9kdWxlID0gZmFjYWRlQ2h1bmtCeU1vZHVsZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRCdW5kbGUgPSAoYnVuZGxlLCBvdXRwdXRPcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnZXRIYXNoID0gaGFzaGVyQnlUeXBlW291dHB1dE9wdGlvbnMuaGFzaENoYXJhY3RlcnNdO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gKHRoaXMub3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgIGJ1bmRsZSxcbiAgICAgICAgICAgICAgICBmaWxlTmFtZXNCeVNvdXJjZUhhc2g6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgICBnZXRIYXNoLFxuICAgICAgICAgICAgICAgIG91dHB1dE9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbWl0dGVkRmlsZSBvZiB0aGlzLmZpbGVzQnlSZWZlcmVuY2VJZC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChlbWl0dGVkRmlsZS5maWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNlcnZlRmlsZU5hbWVJbkJ1bmRsZShlbWl0dGVkRmlsZS5maWxlTmFtZSwgb3V0cHV0LCB0aGlzLm9wdGlvbnMub25Mb2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbnN1bWVkQXNzZXRzQnlIYXNoID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb25zdW1lZEZpbGUgb2YgdGhpcy5maWxlc0J5UmVmZXJlbmNlSWQudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3VtZWRGaWxlLnR5cGUgPT09ICdhc3NldCcgJiYgY29uc3VtZWRGaWxlLnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zdW1lZEZpbGUuZmlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluYWxpemVBZGRpdGlvbmFsQXNzZXQoY29uc3VtZWRGaWxlLCBjb25zdW1lZEZpbGUuc291cmNlLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlSGFzaCA9IGdldEhhc2goY29uc3VtZWRGaWxlLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRPckNyZWF0ZShjb25zdW1lZEFzc2V0c0J5SGFzaCwgc291cmNlSGFzaCwgKCkgPT4gW10pLnB1c2goY29uc3VtZWRGaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25zdW1lZEZpbGUudHlwZSA9PT0gJ3ByZWJ1aWx0LWNodW5rJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dC5idW5kbGVbY29uc3VtZWRGaWxlLmZpbGVOYW1lXSA9IHRoaXMuY3JlYXRlUHJlYnVpbHRDaHVuayhjb25zdW1lZEZpbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgW3NvdXJjZUhhc2gsIGNvbnN1bWVkRmlsZXNdIG9mIGNvbnN1bWVkQXNzZXRzQnlIYXNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5hbGl6ZUFzc2V0c1dpdGhTYW1lU291cmNlKGNvbnN1bWVkRmlsZXMsIHNvdXJjZUhhc2gsIG91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmlsZXNCeVJlZmVyZW5jZUlkID0gYmFzZUZpbGVFbWl0dGVyXG4gICAgICAgICAgICA/IG5ldyBNYXAoYmFzZUZpbGVFbWl0dGVyLmZpbGVzQnlSZWZlcmVuY2VJZClcbiAgICAgICAgICAgIDogbmV3IE1hcCgpO1xuICAgICAgICBiYXNlRmlsZUVtaXR0ZXI/LmFkZE91dHB1dEZpbGVFbWl0dGVyKHRoaXMpO1xuICAgIH1cbiAgICBhZGRPdXRwdXRGaWxlRW1pdHRlcihvdXRwdXRGaWxlRW1pdHRlcikge1xuICAgICAgICB0aGlzLm91dHB1dEZpbGVFbWl0dGVycy5wdXNoKG91dHB1dEZpbGVFbWl0dGVyKTtcbiAgICB9XG4gICAgYXNzaWduUmVmZXJlbmNlSWQoZmlsZSwgaWRCYXNlKSB7XG4gICAgICAgIGxldCByZWZlcmVuY2VJZCA9IGlkQmFzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcmVmZXJlbmNlSWQgPSBnZXRIYXNoNjQocmVmZXJlbmNlSWQpLnNsaWNlKDAsIDgpLnJlcGxhY2VBbGwoJy0nLCAnJCcpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmZpbGVzQnlSZWZlcmVuY2VJZC5oYXMocmVmZXJlbmNlSWQpIHx8XG4gICAgICAgICAgICB0aGlzLm91dHB1dEZpbGVFbWl0dGVycy5zb21lKCh7IGZpbGVzQnlSZWZlcmVuY2VJZCB9KSA9PiBmaWxlc0J5UmVmZXJlbmNlSWQuaGFzKHJlZmVyZW5jZUlkKSkpO1xuICAgICAgICBmaWxlLnJlZmVyZW5jZUlkID0gcmVmZXJlbmNlSWQ7XG4gICAgICAgIHRoaXMuZmlsZXNCeVJlZmVyZW5jZUlkLnNldChyZWZlcmVuY2VJZCwgZmlsZSk7XG4gICAgICAgIGZvciAoY29uc3QgeyBmaWxlc0J5UmVmZXJlbmNlSWQgfSBvZiB0aGlzLm91dHB1dEZpbGVFbWl0dGVycykge1xuICAgICAgICAgICAgZmlsZXNCeVJlZmVyZW5jZUlkLnNldChyZWZlcmVuY2VJZCwgZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUlkO1xuICAgIH1cbiAgICBjcmVhdGVQcmVidWlsdENodW5rKHByZWJ1aWx0Q2h1bmspIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHByZWJ1aWx0Q2h1bmsuY29kZSxcbiAgICAgICAgICAgIGR5bmFtaWNJbXBvcnRzOiBbXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IHByZWJ1aWx0Q2h1bmsuZXhwb3J0cyB8fCBbXSxcbiAgICAgICAgICAgIGZhY2FkZU1vZHVsZUlkOiBudWxsLFxuICAgICAgICAgICAgZmlsZU5hbWU6IHByZWJ1aWx0Q2h1bmsuZmlsZU5hbWUsXG4gICAgICAgICAgICBpbXBsaWNpdGx5TG9hZGVkQmVmb3JlOiBbXSxcbiAgICAgICAgICAgIGltcG9ydGVkQmluZGluZ3M6IHt9LFxuICAgICAgICAgICAgaW1wb3J0czogW10sXG4gICAgICAgICAgICBpc0R5bmFtaWNFbnRyeTogZmFsc2UsXG4gICAgICAgICAgICBpc0VudHJ5OiBmYWxzZSxcbiAgICAgICAgICAgIGlzSW1wbGljaXRFbnRyeTogZmFsc2UsXG4gICAgICAgICAgICBtYXA6IHByZWJ1aWx0Q2h1bmsubWFwIHx8IG51bGwsXG4gICAgICAgICAgICBtb2R1bGVJZHM6IFtdLFxuICAgICAgICAgICAgbW9kdWxlczoge30sXG4gICAgICAgICAgICBuYW1lOiBwcmVidWlsdENodW5rLmZpbGVOYW1lLFxuICAgICAgICAgICAgcHJlbGltaW5hcnlGaWxlTmFtZTogcHJlYnVpbHRDaHVuay5maWxlTmFtZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZWRGaWxlczogW10sXG4gICAgICAgICAgICBzb3VyY2VtYXBGaWxlTmFtZTogcHJlYnVpbHRDaHVuay5zb3VyY2VtYXBGaWxlTmFtZSB8fCBudWxsLFxuICAgICAgICAgICAgdHlwZTogJ2NodW5rJ1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbWl0QXNzZXQoZW1pdHRlZEFzc2V0KSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGVtaXR0ZWRBc3NldC5zb3VyY2UgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogZ2V0VmFsaWRTb3VyY2UoZW1pdHRlZEFzc2V0LnNvdXJjZSwgZW1pdHRlZEFzc2V0LCBudWxsKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxGaWxlTmFtZSA9IGVtaXR0ZWRBc3NldC5vcmlnaW5hbEZpbGVOYW1lIHx8IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxGaWxlTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGgud2F0Y2hGaWxlc1tvcmlnaW5hbEZpbGVOYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uc3VtZWRBc3NldCA9IHtcbiAgICAgICAgICAgIGZpbGVOYW1lOiBlbWl0dGVkQXNzZXQuZmlsZU5hbWUsXG4gICAgICAgICAgICBuYW1lOiBlbWl0dGVkQXNzZXQubmFtZSxcbiAgICAgICAgICAgIG5lZWRzQ29kZVJlZmVyZW5jZTogISFlbWl0dGVkQXNzZXQubmVlZHNDb2RlUmVmZXJlbmNlLFxuICAgICAgICAgICAgb3JpZ2luYWxGaWxlTmFtZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiAnJyxcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIHR5cGU6ICdhc3NldCdcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSWQgPSB0aGlzLmFzc2lnblJlZmVyZW5jZUlkKGNvbnN1bWVkQXNzZXQsIGVtaXR0ZWRBc3NldC5maWxlTmFtZSB8fCBlbWl0dGVkQXNzZXQubmFtZSB8fCBTdHJpbmcodGhpcy5uZXh0SWRCYXNlKyspKTtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0KSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRBc3NldFdpdGhSZWZlcmVuY2VJZChjb25zdW1lZEFzc2V0LCB0aGlzLm91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpbGVFbWl0dGVyIG9mIHRoaXMub3V0cHV0RmlsZUVtaXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgZmlsZUVtaXR0ZXIuZW1pdEFzc2V0V2l0aFJlZmVyZW5jZUlkKGNvbnN1bWVkQXNzZXQsIGZpbGVFbWl0dGVyLm91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUlkO1xuICAgIH1cbiAgICBlbWl0QXNzZXRXaXRoUmVmZXJlbmNlSWQoY29uc3VtZWRBc3NldCwgb3V0cHV0KSB7XG4gICAgICAgIGNvbnN0IHsgZmlsZU5hbWUsIHNvdXJjZSB9ID0gY29uc3VtZWRBc3NldDtcbiAgICAgICAgaWYgKGZpbGVOYW1lKSB7XG4gICAgICAgICAgICByZXNlcnZlRmlsZU5hbWVJbkJ1bmRsZShmaWxlTmFtZSwgb3V0cHV0LCB0aGlzLm9wdGlvbnMub25Mb2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5maW5hbGl6ZUFkZGl0aW9uYWxBc3NldChjb25zdW1lZEFzc2V0LCBzb3VyY2UsIG91dHB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdENodW5rKGVtaXR0ZWRDaHVuaykge1xuICAgICAgICBpZiAodGhpcy5ncmFwaC5waGFzZSA+IEJ1aWxkUGhhc2UuTE9BRF9BTkRfUEFSU0UpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihsb2dJbnZhbGlkUm9sbHVwUGhhc2VGb3JDaHVua0VtaXNzaW9uKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW1pdHRlZENodW5rLmlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKGxvZ0ZhaWxlZFZhbGlkYXRpb24oYEVtaXR0ZWQgY2h1bmtzIG5lZWQgdG8gaGF2ZSBhIHZhbGlkIHN0cmluZyBpZCwgcmVjZWl2ZWQgXCIke2VtaXR0ZWRDaHVuay5pZH1cImApKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25zdW1lZENodW5rID0ge1xuICAgICAgICAgICAgZmlsZU5hbWU6IGVtaXR0ZWRDaHVuay5maWxlTmFtZSxcbiAgICAgICAgICAgIG1vZHVsZTogbnVsbCxcbiAgICAgICAgICAgIG5hbWU6IGVtaXR0ZWRDaHVuay5uYW1lIHx8IGVtaXR0ZWRDaHVuay5pZCxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiAnJyxcbiAgICAgICAgICAgIHR5cGU6ICdjaHVuaydcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ncmFwaC5tb2R1bGVMb2FkZXJcbiAgICAgICAgICAgIC5lbWl0Q2h1bmsoZW1pdHRlZENodW5rKVxuICAgICAgICAgICAgLnRoZW4obW9kdWxlID0+IChjb25zdW1lZENodW5rLm1vZHVsZSA9IG1vZHVsZSkpXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgLy8gQXZvaWQgdW5oYW5kbGVkIFByb21pc2UgcmVqZWN0aW9uIGFzIHRoZSBlcnJvciB3aWxsIGJlIHRocm93biBsYXRlclxuICAgICAgICAgICAgLy8gb25jZSBtb2R1bGUgbG9hZGluZyBoYXMgZmluaXNoZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2lnblJlZmVyZW5jZUlkKGNvbnN1bWVkQ2h1bmssIGVtaXR0ZWRDaHVuay5pZCk7XG4gICAgfVxuICAgIGVtaXRQcmVidWlsdENodW5rKGVtaXRQcmVidWlsdENodW5rKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW1pdFByZWJ1aWx0Q2h1bmsuY29kZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihsb2dGYWlsZWRWYWxpZGF0aW9uKGBFbWl0dGVkIHByZWJ1aWx0IGNodW5rcyBuZWVkIHRvIGhhdmUgYSB2YWxpZCBzdHJpbmcgY29kZSwgcmVjZWl2ZWQgXCIke2VtaXRQcmVidWlsdENodW5rLmNvZGV9XCIuYCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW1pdFByZWJ1aWx0Q2h1bmsuZmlsZU5hbWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICBpc1BhdGhGcmFnbWVudChlbWl0UHJlYnVpbHRDaHVuay5maWxlTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihsb2dGYWlsZWRWYWxpZGF0aW9uKGBUaGUgXCJmaWxlTmFtZVwiIHByb3BlcnR5IG9mIGVtaXR0ZWQgcHJlYnVpbHQgY2h1bmtzIG11c3QgYmUgc3RyaW5ncyB0aGF0IGFyZSBuZWl0aGVyIGFic29sdXRlIG5vciByZWxhdGl2ZSBwYXRocywgcmVjZWl2ZWQgXCIke2VtaXRQcmVidWlsdENodW5rLmZpbGVOYW1lfVwiLmApKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25zdW1lZFByZWJ1aWx0Q2h1bmsgPSB7XG4gICAgICAgICAgICBjb2RlOiBlbWl0UHJlYnVpbHRDaHVuay5jb2RlLFxuICAgICAgICAgICAgZXhwb3J0czogZW1pdFByZWJ1aWx0Q2h1bmsuZXhwb3J0cyxcbiAgICAgICAgICAgIGZpbGVOYW1lOiBlbWl0UHJlYnVpbHRDaHVuay5maWxlTmFtZSxcbiAgICAgICAgICAgIG1hcDogZW1pdFByZWJ1aWx0Q2h1bmsubWFwLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6ICcnLFxuICAgICAgICAgICAgdHlwZTogJ3ByZWJ1aWx0LWNodW5rJ1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJZCA9IHRoaXMuYXNzaWduUmVmZXJlbmNlSWQoY29uc3VtZWRQcmVidWlsdENodW5rLCBjb25zdW1lZFByZWJ1aWx0Q2h1bmsuZmlsZU5hbWUpO1xuICAgICAgICBpZiAodGhpcy5vdXRwdXQpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0LmJ1bmRsZVtjb25zdW1lZFByZWJ1aWx0Q2h1bmsuZmlsZU5hbWVdID1cbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVByZWJ1aWx0Q2h1bmsoY29uc3VtZWRQcmVidWlsdENodW5rKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSWQ7XG4gICAgfVxuICAgIGZpbmFsaXplQWRkaXRpb25hbEFzc2V0KGNvbnN1bWVkRmlsZSwgc291cmNlLCB7IGJ1bmRsZSwgZmlsZU5hbWVzQnlTb3VyY2VIYXNoLCBnZXRIYXNoLCBvdXRwdXRPcHRpb25zIH0pIHtcbiAgICAgICAgbGV0IHsgZmlsZU5hbWUsIG5hbWUsIG5lZWRzQ29kZVJlZmVyZW5jZSwgb3JpZ2luYWxGaWxlTmFtZSwgcmVmZXJlbmNlSWQgfSA9IGNvbnN1bWVkRmlsZTtcbiAgICAgICAgLy8gRGVkdXBsaWNhdGUgYXNzZXRzIGlmIGFuIGV4cGxpY2l0IGZpbGVOYW1lIGlzIG5vdCBwcm92aWRlZFxuICAgICAgICBpZiAoIWZpbGVOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VIYXNoID0gZ2V0SGFzaChzb3VyY2UpO1xuICAgICAgICAgICAgZmlsZU5hbWUgPSBmaWxlTmFtZXNCeVNvdXJjZUhhc2guZ2V0KHNvdXJjZUhhc2gpO1xuICAgICAgICAgICAgaWYgKCFmaWxlTmFtZSkge1xuICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gZ2VuZXJhdGVBc3NldEZpbGVOYW1lKG5hbWUsIG5hbWUgPyBbbmFtZV0gOiBbXSwgc291cmNlLCBvcmlnaW5hbEZpbGVOYW1lLCBvcmlnaW5hbEZpbGVOYW1lID8gW29yaWdpbmFsRmlsZU5hbWVdIDogW10sIHNvdXJjZUhhc2gsIG91dHB1dE9wdGlvbnMsIGJ1bmRsZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBmaWxlTmFtZXNCeVNvdXJjZUhhc2guc2V0KHNvdXJjZUhhc2gsIGZpbGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBtdXN0IG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsIGFzc2V0cyB0byBhdm9pZCBpbnRlcmFjdGlvbiBiZXR3ZWVuIG91dHB1dHNcbiAgICAgICAgY29uc3QgYXNzZXRXaXRoRmlsZU5hbWUgPSB7IC4uLmNvbnN1bWVkRmlsZSwgZmlsZU5hbWUsIHNvdXJjZSB9O1xuICAgICAgICB0aGlzLmZpbGVzQnlSZWZlcmVuY2VJZC5zZXQocmVmZXJlbmNlSWQsIGFzc2V0V2l0aEZpbGVOYW1lKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdBc3NldCA9IGJ1bmRsZVtmaWxlTmFtZV07XG4gICAgICAgIGlmIChleGlzdGluZ0Fzc2V0Py50eXBlID09PSAnYXNzZXQnKSB7XG4gICAgICAgICAgICBleGlzdGluZ0Fzc2V0Lm5lZWRzQ29kZVJlZmVyZW5jZSAmJj0gbmVlZHNDb2RlUmVmZXJlbmNlO1xuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ0Fzc2V0Lm5hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxGaWxlTmFtZSkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nQXNzZXQub3JpZ2luYWxGaWxlTmFtZXMucHVzaChvcmlnaW5hbEZpbGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgICAgIGJ1bmRsZVtmaWxlTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgZmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZGl0aW9uYWxseSwgdGhpcyBzaG91bGQgYmUgbm9uLWVudW1lcmFibGUgaW4gdGhlIG5leHQgbWFqb3JcbiAgICAgICAgICAgICAgICAgICAgd2FybkRlcHJlY2F0aW9uKCdBY2Nlc3NpbmcgdGhlIFwibmFtZVwiIHByb3BlcnR5IG9mIGVtaXR0ZWQgYXNzZXRzIGluIHRoZSBidW5kbGUgaXMgZGVwcmVjYXRlZC4gVXNlIHRoZSBcIm5hbWVzXCIgcHJvcGVydHkgaW5zdGVhZC4nLCBVUkxfR0VORVJBVEVCVU5ETEUsIGZhbHNlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBuYW1lczogbmFtZSA/IFtuYW1lXSA6IFtdLFxuICAgICAgICAgICAgICAgIG5lZWRzQ29kZVJlZmVyZW5jZSxcbiAgICAgICAgICAgICAgICBnZXQgb3JpZ2luYWxGaWxlTmFtZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkaXRpb25hbGx5LCB0aGlzIHNob3VsZCBiZSBub24tZW51bWVyYWJsZSBpbiB0aGUgbmV4dCBtYWpvclxuICAgICAgICAgICAgICAgICAgICB3YXJuRGVwcmVjYXRpb24oJ0FjY2Vzc2luZyB0aGUgXCJvcmlnaW5hbEZpbGVOYW1lXCIgcHJvcGVydHkgb2YgZW1pdHRlZCBhc3NldHMgaW4gdGhlIGJ1bmRsZSBpcyBkZXByZWNhdGVkLiBVc2UgdGhlIFwib3JpZ2luYWxGaWxlTmFtZXNcIiBwcm9wZXJ0eSBpbnN0ZWFkLicsIFVSTF9HRU5FUkFURUJVTkRMRSwgZmFsc2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxGaWxlTmFtZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRmlsZU5hbWVzOiBvcmlnaW5hbEZpbGVOYW1lID8gW29yaWdpbmFsRmlsZU5hbWVdIDogW10sXG4gICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhc3NldCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluYWxpemVBc3NldHNXaXRoU2FtZVNvdXJjZShjb25zdW1lZEZpbGVzLCBzb3VyY2VIYXNoLCB7IGJ1bmRsZSwgZmlsZU5hbWVzQnlTb3VyY2VIYXNoLCBvdXRwdXRPcHRpb25zIH0pIHtcbiAgICAgICAgY29uc3QgeyBuYW1lcywgb3JpZ2luYWxGaWxlTmFtZXMgfSA9IGdldE5hbWVzRnJvbUFzc2V0cyhjb25zdW1lZEZpbGVzKTtcbiAgICAgICAgbGV0IGZpbGVOYW1lID0gJyc7XG4gICAgICAgIGxldCB1c2VkQ29uc3VtZWRGaWxlO1xuICAgICAgICBsZXQgbmVlZHNDb2RlUmVmZXJlbmNlID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBjb25zdW1lZEZpbGUgb2YgY29uc3VtZWRGaWxlcykge1xuICAgICAgICAgICAgbmVlZHNDb2RlUmVmZXJlbmNlICYmPSBjb25zdW1lZEZpbGUubmVlZHNDb2RlUmVmZXJlbmNlO1xuICAgICAgICAgICAgY29uc3QgYXNzZXRGaWxlTmFtZSA9IGdlbmVyYXRlQXNzZXRGaWxlTmFtZShjb25zdW1lZEZpbGUubmFtZSwgbmFtZXMsIGNvbnN1bWVkRmlsZS5zb3VyY2UsIGNvbnN1bWVkRmlsZS5vcmlnaW5hbEZpbGVOYW1lLCBvcmlnaW5hbEZpbGVOYW1lcywgc291cmNlSGFzaCwgb3V0cHV0T3B0aW9ucywgYnVuZGxlLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCFmaWxlTmFtZSB8fFxuICAgICAgICAgICAgICAgIGFzc2V0RmlsZU5hbWUubGVuZ3RoIDwgZmlsZU5hbWUubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgKGFzc2V0RmlsZU5hbWUubGVuZ3RoID09PSBmaWxlTmFtZS5sZW5ndGggJiYgYXNzZXRGaWxlTmFtZSA8IGZpbGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gYXNzZXRGaWxlTmFtZTtcbiAgICAgICAgICAgICAgICB1c2VkQ29uc3VtZWRGaWxlID0gY29uc3VtZWRGaWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbGVOYW1lc0J5U291cmNlSGFzaC5zZXQoc291cmNlSGFzaCwgZmlsZU5hbWUpO1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnN1bWVkRmlsZSBvZiBjb25zdW1lZEZpbGVzKSB7XG4gICAgICAgICAgICAvLyBXZSBtdXN0IG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsIGFzc2V0cyB0byBhdm9pZCBpbnRlcmFjdGlvbiBiZXR3ZWVuIG91dHB1dHNcbiAgICAgICAgICAgIGNvbnN0IGFzc2V0V2l0aEZpbGVOYW1lID0geyAuLi5jb25zdW1lZEZpbGUsIGZpbGVOYW1lIH07XG4gICAgICAgICAgICB0aGlzLmZpbGVzQnlSZWZlcmVuY2VJZC5zZXQoY29uc3VtZWRGaWxlLnJlZmVyZW5jZUlkLCBhc3NldFdpdGhGaWxlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBidW5kbGVbZmlsZU5hbWVdID0ge1xuICAgICAgICAgICAgZmlsZU5hbWUsXG4gICAgICAgICAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGRpdGlvbmFsbHksIHRoaXMgc2hvdWxkIGJlIG5vbi1lbnVtZXJhYmxlIGluIHRoZSBuZXh0IG1ham9yXG4gICAgICAgICAgICAgICAgd2FybkRlcHJlY2F0aW9uKCdBY2Nlc3NpbmcgdGhlIFwibmFtZVwiIHByb3BlcnR5IG9mIGVtaXR0ZWQgYXNzZXRzIGluIHRoZSBidW5kbGUgaXMgZGVwcmVjYXRlZC4gVXNlIHRoZSBcIm5hbWVzXCIgcHJvcGVydHkgaW5zdGVhZC4nLCBVUkxfR0VORVJBVEVCVU5ETEUsIGZhbHNlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlZENvbnN1bWVkRmlsZS5uYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWVzLFxuICAgICAgICAgICAgbmVlZHNDb2RlUmVmZXJlbmNlLFxuICAgICAgICAgICAgZ2V0IG9yaWdpbmFsRmlsZU5hbWUoKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkaXRpb25hbGx5LCB0aGlzIHNob3VsZCBiZSBub24tZW51bWVyYWJsZSBpbiB0aGUgbmV4dCBtYWpvclxuICAgICAgICAgICAgICAgIHdhcm5EZXByZWNhdGlvbignQWNjZXNzaW5nIHRoZSBcIm9yaWdpbmFsRmlsZU5hbWVcIiBwcm9wZXJ0eSBvZiBlbWl0dGVkIGFzc2V0cyBpbiB0aGUgYnVuZGxlIGlzIGRlcHJlY2F0ZWQuIFVzZSB0aGUgXCJvcmlnaW5hbEZpbGVOYW1lc1wiIHByb3BlcnR5IGluc3RlYWQuJywgVVJMX0dFTkVSQVRFQlVORExFLCBmYWxzZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZWRDb25zdW1lZEZpbGUub3JpZ2luYWxGaWxlTmFtZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcmlnaW5hbEZpbGVOYW1lcyxcbiAgICAgICAgICAgIHNvdXJjZTogdXNlZENvbnN1bWVkRmlsZS5zb3VyY2UsXG4gICAgICAgICAgICB0eXBlOiAnYXNzZXQnXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TmFtZXNGcm9tQXNzZXRzKGNvbnN1bWVkRmlsZXMpIHtcbiAgICBjb25zdCBuYW1lcyA9IFtdO1xuICAgIGNvbnN0IG9yaWdpbmFsRmlsZU5hbWVzID0gW107XG4gICAgZm9yIChjb25zdCB7IG5hbWUsIG9yaWdpbmFsRmlsZU5hbWUgfSBvZiBjb25zdW1lZEZpbGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWdpbmFsRmlsZU5hbWUpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsRmlsZU5hbWVzLnB1c2gob3JpZ2luYWxGaWxlTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3JpZ2luYWxGaWxlTmFtZXMuc29ydCgpO1xuICAgIC8vIFNvcnQgYnkgbGVuZ3RoIGZpcnN0IGFuZCB0aGVuIGFscGhhYmV0aWNhbGx5IHNvIHRoYXQgdGhlIG9yZGVyIGlzIHN0YWJsZVxuICAgIC8vIGFuZCB0aGUgc2hvcnRlc3QgbmFtZXMgY29tZSBmaXJzdFxuICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubGVuZ3RoIC0gYi5sZW5ndGggfHwgKGEgPiBiID8gMSA6IGEgPT09IGIgPyAwIDogLTEpKTtcbiAgICByZXR1cm4geyBuYW1lcywgb3JpZ2luYWxGaWxlTmFtZXMgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TG9nSGFuZGxlcihsZXZlbCwgY29kZSwgbG9nZ2VyLCBwbHVnaW5OYW1lLCBsb2dMZXZlbCkge1xuICAgIGlmIChsb2dMZXZlbFByaW9yaXR5W2xldmVsXSA8IGxvZ0xldmVsUHJpb3JpdHlbbG9nTGV2ZWxdKSB7XG4gICAgICAgIHJldHVybiBkb05vdGhpbmc7XG4gICAgfVxuICAgIHJldHVybiAobG9nLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIoTE9HTEVWRUxfV0FSTiwgbG9nSW52YWxpZExvZ1Bvc2l0aW9uKHBsdWdpbk5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBsb2cgPSBub3JtYWxpemVMb2cobG9nKTtcbiAgICAgICAgaWYgKGxvZy5jb2RlICYmICFsb2cucGx1Z2luQ29kZSkge1xuICAgICAgICAgICAgbG9nLnBsdWdpbkNvZGUgPSBsb2cuY29kZTtcbiAgICAgICAgfVxuICAgICAgICBsb2cuY29kZSA9IGNvZGU7XG4gICAgICAgIGxvZy5wbHVnaW4gPSBwbHVnaW5OYW1lO1xuICAgICAgICBsb2dnZXIobGV2ZWwsIGxvZyk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGx1Z2luQ29udGV4dChwbHVnaW4sIHBsdWdpbkNhY2hlLCBncmFwaCwgb3B0aW9ucywgZmlsZUVtaXR0ZXIsIGV4aXN0aW5nUGx1Z2luTmFtZXMpIHtcbiAgICBjb25zdCB7IGxvZ0xldmVsLCBvbkxvZyB9ID0gb3B0aW9ucztcbiAgICBsZXQgY2FjaGVhYmxlID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5jYWNoZUtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHBsdWdpbi5uYW1lLnN0YXJ0c1dpdGgoQU5PTllNT1VTX1BMVUdJTl9QUkVGSVgpIHx8XG4gICAgICAgICAgICBwbHVnaW4ubmFtZS5zdGFydHNXaXRoKEFOT05ZTU9VU19PVVRQVVRfUExVR0lOX1BSRUZJWCkgfHxcbiAgICAgICAgICAgIGV4aXN0aW5nUGx1Z2luTmFtZXMuaGFzKHBsdWdpbi5uYW1lKSkge1xuICAgICAgICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleGlzdGluZ1BsdWdpbk5hbWVzLmFkZChwbHVnaW4ubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNhY2hlSW5zdGFuY2U7XG4gICAgaWYgKCFwbHVnaW5DYWNoZSkge1xuICAgICAgICBjYWNoZUluc3RhbmNlID0gTk9fQ0FDSEU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNhY2hlYWJsZSkge1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IHBsdWdpbi5jYWNoZUtleSB8fCBwbHVnaW4ubmFtZTtcbiAgICAgICAgY2FjaGVJbnN0YW5jZSA9IGNyZWF0ZVBsdWdpbkNhY2hlKHBsdWdpbkNhY2hlW2NhY2hlS2V5XSB8fCAocGx1Z2luQ2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmNyZWF0ZShudWxsKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FjaGVJbnN0YW5jZSA9IGdldENhY2hlRm9yVW5jYWNoZWFibGVQbHVnaW4ocGx1Z2luLm5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRXYXRjaEZpbGUoaWQpIHtcbiAgICAgICAgICAgIGdyYXBoLndhdGNoRmlsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FjaGU6IGNhY2hlSW5zdGFuY2UsXG4gICAgICAgIGRlYnVnOiBnZXRMb2dIYW5kbGVyKExPR0xFVkVMX0RFQlVHLCAnUExVR0lOX0xPRycsIG9uTG9nLCBwbHVnaW4ubmFtZSwgbG9nTGV2ZWwpLFxuICAgICAgICBlbWl0RmlsZTogZmlsZUVtaXR0ZXIuZW1pdEZpbGUuYmluZChmaWxlRW1pdHRlciksXG4gICAgICAgIGVycm9yKGVycm9yXykge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKGxvZ1BsdWdpbkVycm9yKG5vcm1hbGl6ZUxvZyhlcnJvcl8pLCBwbHVnaW4ubmFtZSkpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRGaWxlTmFtZTogZmlsZUVtaXR0ZXIuZ2V0RmlsZU5hbWUsXG4gICAgICAgIGdldE1vZHVsZUlkczogKCkgPT4gZ3JhcGgubW9kdWxlc0J5SWQua2V5cygpLFxuICAgICAgICBnZXRNb2R1bGVJbmZvOiBncmFwaC5nZXRNb2R1bGVJbmZvLFxuICAgICAgICBnZXRXYXRjaEZpbGVzOiAoKSA9PiBPYmplY3Qua2V5cyhncmFwaC53YXRjaEZpbGVzKSxcbiAgICAgICAgaW5mbzogZ2V0TG9nSGFuZGxlcihMT0dMRVZFTF9JTkZPLCAnUExVR0lOX0xPRycsIG9uTG9nLCBwbHVnaW4ubmFtZSwgbG9nTGV2ZWwpLFxuICAgICAgICBsb2FkKHJlc29sdmVkSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBncmFwaC5tb2R1bGVMb2FkZXIucHJlbG9hZE1vZHVsZShyZXNvbHZlZElkKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgcm9sbHVwVmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgICAgIHdhdGNoTW9kZTogZ3JhcGgud2F0Y2hNb2RlXG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlOiBwYXJzZUFzdCxcbiAgICAgICAgcmVzb2x2ZShzb3VyY2UsIGltcG9ydGVyLCB7IGF0dHJpYnV0ZXMsIGN1c3RvbSwgaXNFbnRyeSwgc2tpcFNlbGYgfSA9IEJMQU5LKSB7XG4gICAgICAgICAgICBza2lwU2VsZiA/Pz0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBncmFwaC5tb2R1bGVMb2FkZXIucmVzb2x2ZUlkKHNvdXJjZSwgaW1wb3J0ZXIsIGN1c3RvbSwgaXNFbnRyeSwgYXR0cmlidXRlcyB8fCBFTVBUWV9PQkpFQ1QsIHNraXBTZWxmID8gW3sgaW1wb3J0ZXIsIHBsdWdpbiwgc291cmNlIH1dIDogbnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEFzc2V0U291cmNlOiBmaWxlRW1pdHRlci5zZXRBc3NldFNvdXJjZSxcbiAgICAgICAgd2FybjogZ2V0TG9nSGFuZGxlcihMT0dMRVZFTF9XQVJOLCAnUExVR0lOX1dBUk5JTkcnLCBvbkxvZywgcGx1Z2luLm5hbWUsIGxvZ0xldmVsKVxuICAgIH07XG59XG5cbi8vIFRoaXMgd2lsbCBtYWtlIHN1cmUgbm8gaW5wdXQgaG9vayBpcyBvbWl0dGVkXG5jb25zdCBpbnB1dEhvb2tOYW1lcyA9IHtcbiAgICBidWlsZEVuZDogMSxcbiAgICBidWlsZFN0YXJ0OiAxLFxuICAgIGNsb3NlQnVuZGxlOiAxLFxuICAgIGNsb3NlV2F0Y2hlcjogMSxcbiAgICBsb2FkOiAxLFxuICAgIG1vZHVsZVBhcnNlZDogMSxcbiAgICBvbkxvZzogMSxcbiAgICBvcHRpb25zOiAxLFxuICAgIHJlc29sdmVEeW5hbWljSW1wb3J0OiAxLFxuICAgIHJlc29sdmVJZDogMSxcbiAgICBzaG91bGRUcmFuc2Zvcm1DYWNoZWRNb2R1bGU6IDEsXG4gICAgdHJhbnNmb3JtOiAxLFxuICAgIHdhdGNoQ2hhbmdlOiAxXG59O1xuY29uc3QgaW5wdXRIb29rcyA9IE9iamVjdC5rZXlzKGlucHV0SG9va05hbWVzKTtcbmNsYXNzIFBsdWdpbkRyaXZlciB7XG4gICAgY29uc3RydWN0b3IoZ3JhcGgsIG9wdGlvbnMsIHVzZXJQbHVnaW5zLCBwbHVnaW5DYWNoZSwgYmFzZVBsdWdpbkRyaXZlcikge1xuICAgICAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMucGx1Z2luQ2FjaGUgPSBwbHVnaW5DYWNoZTtcbiAgICAgICAgdGhpcy5zb3J0ZWRQbHVnaW5zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnVuZnVsZmlsbGVkQWN0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5maWxlRW1pdHRlciA9IG5ldyBGaWxlRW1pdHRlcihncmFwaCwgb3B0aW9ucywgYmFzZVBsdWdpbkRyaXZlciAmJiBiYXNlUGx1Z2luRHJpdmVyLmZpbGVFbWl0dGVyKTtcbiAgICAgICAgdGhpcy5lbWl0RmlsZSA9IHRoaXMuZmlsZUVtaXR0ZXIuZW1pdEZpbGUuYmluZCh0aGlzLmZpbGVFbWl0dGVyKTtcbiAgICAgICAgdGhpcy5nZXRGaWxlTmFtZSA9IHRoaXMuZmlsZUVtaXR0ZXIuZ2V0RmlsZU5hbWUuYmluZCh0aGlzLmZpbGVFbWl0dGVyKTtcbiAgICAgICAgdGhpcy5maW5hbGlzZUFzc2V0cyA9IHRoaXMuZmlsZUVtaXR0ZXIuZmluYWxpc2VBc3NldHMuYmluZCh0aGlzLmZpbGVFbWl0dGVyKTtcbiAgICAgICAgdGhpcy5zZXRDaHVua0luZm9ybWF0aW9uID0gdGhpcy5maWxlRW1pdHRlci5zZXRDaHVua0luZm9ybWF0aW9uLmJpbmQodGhpcy5maWxlRW1pdHRlcik7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0QnVuZGxlID0gdGhpcy5maWxlRW1pdHRlci5zZXRPdXRwdXRCdW5kbGUuYmluZCh0aGlzLmZpbGVFbWl0dGVyKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gWy4uLihiYXNlUGx1Z2luRHJpdmVyID8gYmFzZVBsdWdpbkRyaXZlci5wbHVnaW5zIDogW10pLCAuLi51c2VyUGx1Z2luc107XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUGx1Z2luTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMucGx1Z2luQ29udGV4dHMgPSBuZXcgTWFwKHRoaXMucGx1Z2lucy5tYXAocGx1Z2luID0+IFtcbiAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICAgIGdldFBsdWdpbkNvbnRleHQocGx1Z2luLCBwbHVnaW5DYWNoZSwgZ3JhcGgsIG9wdGlvbnMsIHRoaXMuZmlsZUVtaXR0ZXIsIGV4aXN0aW5nUGx1Z2luTmFtZXMpXG4gICAgICAgIF0pKTtcbiAgICAgICAgaWYgKGJhc2VQbHVnaW5Ecml2ZXIpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHVzZXJQbHVnaW5zKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBob29rIG9mIGlucHV0SG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvb2sgaW4gcGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uTG9nKExPR0xFVkVMX1dBUk4sIGxvZ0lucHV0SG9va0luT3V0cHV0UGx1Z2luKHBsdWdpbi5uYW1lLCBob29rKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlT3V0cHV0UGx1Z2luRHJpdmVyKHBsdWdpbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQbHVnaW5Ecml2ZXIodGhpcy5ncmFwaCwgdGhpcy5vcHRpb25zLCBwbHVnaW5zLCB0aGlzLnBsdWdpbkNhY2hlLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0VW5mdWxmaWxsZWRIb29rQWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5mdWxmaWxsZWRBY3Rpb25zO1xuICAgIH1cbiAgICAvLyBjaGFpbnMsIGZpcnN0IG5vbi1udWxsIHJlc3VsdCBzdG9wcyBhbmQgcmV0dXJuc1xuICAgIGhvb2tGaXJzdChob29rTmFtZSwgcGFyYW1ldGVycywgcmVwbGFjZUNvbnRleHQsIHNraXBwZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9va0ZpcnN0QW5kR2V0UGx1Z2luKGhvb2tOYW1lLCBwYXJhbWV0ZXJzLCByZXBsYWNlQ29udGV4dCwgc2tpcHBlZCkudGhlbihyZXN1bHQgPT4gcmVzdWx0ICYmIHJlc3VsdFswXSk7XG4gICAgfVxuICAgIC8vIGNoYWlucywgZmlyc3Qgbm9uLW51bGwgcmVzdWx0IHN0b3BzIGFuZCByZXR1cm5zIHJlc3VsdCBhbmQgbGFzdCBwbHVnaW5cbiAgICBhc3luYyBob29rRmlyc3RBbmRHZXRQbHVnaW4oaG9va05hbWUsIHBhcmFtZXRlcnMsIHJlcGxhY2VDb250ZXh0LCBza2lwcGVkKSB7XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMuZ2V0U29ydGVkUGx1Z2lucyhob29rTmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChza2lwcGVkPy5oYXMocGx1Z2luKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucnVuSG9vayhob29rTmFtZSwgcGFyYW1ldGVycywgcGx1Z2luLCByZXBsYWNlQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtyZXN1bHQsIHBsdWdpbl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIGNoYWlucyBzeW5jaHJvbm91c2x5LCBmaXJzdCBub24tbnVsbCByZXN1bHQgc3RvcHMgYW5kIHJldHVybnNcbiAgICBob29rRmlyc3RTeW5jKGhvb2tOYW1lLCBwYXJhbWV0ZXJzLCByZXBsYWNlQ29udGV4dCkge1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLmdldFNvcnRlZFBsdWdpbnMoaG9va05hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJ1bkhvb2tTeW5jKGhvb2tOYW1lLCBwYXJhbWV0ZXJzLCBwbHVnaW4sIHJlcGxhY2VDb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBwYXJhbGxlbCwgaWdub3JlcyByZXR1cm5zXG4gICAgYXN5bmMgaG9va1BhcmFsbGVsKGhvb2tOYW1lLCBwYXJhbWV0ZXJzLCByZXBsYWNlQ29udGV4dCkge1xuICAgICAgICBjb25zdCBwYXJhbGxlbFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMuZ2V0U29ydGVkUGx1Z2lucyhob29rTmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChwbHVnaW5baG9va05hbWVdLnNlcXVlbnRpYWwpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwYXJhbGxlbFByb21pc2VzKTtcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFByb21pc2VzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rKGhvb2tOYW1lLCBwYXJhbWV0ZXJzLCBwbHVnaW4sIHJlcGxhY2VDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFsbGVsUHJvbWlzZXMucHVzaCh0aGlzLnJ1bkhvb2soaG9va05hbWUsIHBhcmFtZXRlcnMsIHBsdWdpbiwgcmVwbGFjZUNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwYXJhbGxlbFByb21pc2VzKTtcbiAgICB9XG4gICAgLy8gY2hhaW5zLCByZWR1Y2VzIHJldHVybmVkIHZhbHVlLCBoYW5kbGluZyB0aGUgcmVkdWNlZCB2YWx1ZSBhcyB0aGUgZmlyc3QgaG9vayBhcmd1bWVudFxuICAgIGhvb2tSZWR1Y2VBcmcwKGhvb2tOYW1lLCBbYXJndW1lbnQwLCAuLi5yZXN0XSwgcmVkdWNlLCByZXBsYWNlQ29udGV4dCkge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShhcmd1bWVudDApO1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLmdldFNvcnRlZFBsdWdpbnMoaG9va05hbWUpKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGFyZ3VtZW50MCA9PiB0aGlzLnJ1bkhvb2soaG9va05hbWUsIFthcmd1bWVudDAsIC4uLnJlc3RdLCBwbHVnaW4sIHJlcGxhY2VDb250ZXh0KS50aGVuKHJlc3VsdCA9PiByZWR1Y2UuY2FsbCh0aGlzLnBsdWdpbkNvbnRleHRzLmdldChwbHVnaW4pLCBhcmd1bWVudDAsIHJlc3VsdCwgcGx1Z2luKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvLyBjaGFpbnMgc3luY2hyb25vdXNseSwgcmVkdWNlcyByZXR1cm5lZCB2YWx1ZSwgaGFuZGxpbmcgdGhlIHJlZHVjZWQgdmFsdWUgYXMgdGhlIGZpcnN0IGhvb2sgYXJndW1lbnRcbiAgICBob29rUmVkdWNlQXJnMFN5bmMoaG9va05hbWUsIFthcmd1bWVudDAsIC4uLnJlc3RdLCByZWR1Y2UsIHJlcGxhY2VDb250ZXh0KSB7XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMuZ2V0U29ydGVkUGx1Z2lucyhob29rTmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBbYXJndW1lbnQwLCAuLi5yZXN0XTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucnVuSG9va1N5bmMoaG9va05hbWUsIHBhcmFtZXRlcnMsIHBsdWdpbiwgcmVwbGFjZUNvbnRleHQpO1xuICAgICAgICAgICAgYXJndW1lbnQwID0gcmVkdWNlLmNhbGwodGhpcy5wbHVnaW5Db250ZXh0cy5nZXQocGx1Z2luKSwgYXJndW1lbnQwLCByZXN1bHQsIHBsdWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50MDtcbiAgICB9XG4gICAgLy8gY2hhaW5zLCByZWR1Y2VzIHJldHVybmVkIHZhbHVlIHRvIHR5cGUgc3RyaW5nLCBoYW5kbGluZyB0aGUgcmVkdWNlZCB2YWx1ZSBzZXBhcmF0ZWx5LiBwZXJtaXRzIGhvb2tzIGFzIHZhbHVlcy5cbiAgICBhc3luYyBob29rUmVkdWNlVmFsdWUoaG9va05hbWUsIGluaXRpYWxWYWx1ZSwgcGFyYW1ldGVycywgcmVkdWNlcikge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGNvbnN0IHBhcmFsbGVsUmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLmdldFNvcnRlZFBsdWdpbnMoaG9va05hbWUsIHZhbGlkYXRlQWRkb25QbHVnaW5IYW5kbGVyKSkge1xuICAgICAgICAgICAgaWYgKHBsdWdpbltob29rTmFtZV0uc2VxdWVudGlhbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCguLi4oYXdhaXQgUHJvbWlzZS5hbGwocGFyYWxsZWxSZXN1bHRzKSkpO1xuICAgICAgICAgICAgICAgIHBhcmFsbGVsUmVzdWx0cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChhd2FpdCB0aGlzLnJ1bkhvb2soaG9va05hbWUsIHBhcmFtZXRlcnMsIHBsdWdpbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSZXN1bHRzLnB1c2godGhpcy5ydW5Ib29rKGhvb2tOYW1lLCBwYXJhbWV0ZXJzLCBwbHVnaW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRzLnB1c2goLi4uKGF3YWl0IFByb21pc2UuYWxsKHBhcmFsbGVsUmVzdWx0cykpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKHJlZHVjZXIsIGF3YWl0IGluaXRpYWxWYWx1ZSk7XG4gICAgfVxuICAgIC8vIGNoYWlucyBzeW5jaHJvbm91c2x5LCByZWR1Y2VzIHJldHVybmVkIHZhbHVlIHRvIHR5cGUgVCwgaGFuZGxpbmcgdGhlIHJlZHVjZWQgdmFsdWUgc2VwYXJhdGVseS4gcGVybWl0cyBob29rcyBhcyB2YWx1ZXMuXG4gICAgaG9va1JlZHVjZVZhbHVlU3luYyhob29rTmFtZSwgaW5pdGlhbFZhbHVlLCBwYXJhbWV0ZXJzLCByZWR1Y2UsIHJlcGxhY2VDb250ZXh0KSB7XG4gICAgICAgIGxldCBhY2N1bXVsYXRvciA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5nZXRTb3J0ZWRQbHVnaW5zKGhvb2tOYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5ydW5Ib29rU3luYyhob29rTmFtZSwgcGFyYW1ldGVycywgcGx1Z2luLCByZXBsYWNlQ29udGV4dCk7XG4gICAgICAgICAgICBhY2N1bXVsYXRvciA9IHJlZHVjZS5jYWxsKHRoaXMucGx1Z2luQ29udGV4dHMuZ2V0KHBsdWdpbiksIGFjY3VtdWxhdG9yLCByZXN1bHQsIHBsdWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cbiAgICAvLyBjaGFpbnMsIGlnbm9yZXMgcmV0dXJuc1xuICAgIGhvb2tTZXEoaG9va05hbWUsIHBhcmFtZXRlcnMsIHJlcGxhY2VDb250ZXh0KSB7XG4gICAgICAgIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMuZ2V0U29ydGVkUGx1Z2lucyhob29rTmFtZSkpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oKCkgPT4gdGhpcy5ydW5Ib29rKGhvb2tOYW1lLCBwYXJhbWV0ZXJzLCBwbHVnaW4sIHJlcGxhY2VDb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihub1JldHVybik7XG4gICAgfVxuICAgIGdldFNvcnRlZFBsdWdpbnMoaG9va05hbWUsIHZhbGlkYXRlSGFuZGxlcikge1xuICAgICAgICByZXR1cm4gZ2V0T3JDcmVhdGUodGhpcy5zb3J0ZWRQbHVnaW5zLCBob29rTmFtZSwgKCkgPT4gZ2V0U29ydGVkVmFsaWRhdGVkUGx1Z2lucyhob29rTmFtZSwgdGhpcy5wbHVnaW5zLCB2YWxpZGF0ZUhhbmRsZXIpKTtcbiAgICB9XG4gICAgLy8gSW1wbGVtZW50YXRpb24gc2lnbmF0dXJlXG4gICAgcnVuSG9vayhob29rTmFtZSwgcGFyYW1ldGVycywgcGx1Z2luLCByZXBsYWNlQ29udGV4dCkge1xuICAgICAgICAvLyBXZSBhbHdheXMgZmlsdGVyIGZvciBwbHVnaW5zIHRoYXQgc3VwcG9ydCB0aGUgaG9vayBiZWZvcmUgcnVubmluZyBpdFxuICAgICAgICBjb25zdCBob29rID0gcGx1Z2luW2hvb2tOYW1lXTtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHR5cGVvZiBob29rID09PSAnb2JqZWN0JyA/IGhvb2suaGFuZGxlciA6IGhvb2s7XG4gICAgICAgIGxldCBjb250ZXh0ID0gdGhpcy5wbHVnaW5Db250ZXh0cy5nZXQocGx1Z2luKTtcbiAgICAgICAgaWYgKHJlcGxhY2VDb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gcmVwbGFjZUNvbnRleHQoY29udGV4dCwgcGx1Z2luKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWN0aW9uID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWZ1bmN0aW9uLXR5cGVcbiAgICAgICAgICAgIGNvbnN0IGhvb2tSZXN1bHQgPSBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgaWYgKCFob29rUmVzdWx0Py50aGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hvcnQgY2lyY3VpdCBmb3Igbm9uLXRoZW5hYmxlcyBhbmQgbm9uLVByb21pc2VzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvb2tSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUcmFjayBwZW5kaW5nIGhvb2sgYWN0aW9ucyB0byBwcm9wZXJseSBlcnJvciBvdXQgd2hlblxuICAgICAgICAgICAgLy8gdW5mdWxmaWxsZWQgcHJvbWlzZXMgY2F1c2Ugcm9sbHVwIHRvIGFicnVwdGx5IGFuZCBjb25mdXNpbmdseVxuICAgICAgICAgICAgLy8gZXhpdCB3aXRoIGEgc3VjY2Vzc2Z1bCAwIHJldHVybiBjb2RlIGJ1dCB3aXRob3V0IHByb2R1Y2luZyBhbnlcbiAgICAgICAgICAgIC8vIG91dHB1dCwgZXJyb3JzIG9yIHdhcm5pbmdzLlxuICAgICAgICAgICAgYWN0aW9uID0gW3BsdWdpbi5uYW1lLCBob29rTmFtZSwgcGFyYW1ldGVyc107XG4gICAgICAgICAgICB0aGlzLnVuZnVsZmlsbGVkQWN0aW9ucy5hZGQoYWN0aW9uKTtcbiAgICAgICAgICAgIC8vIEFsdGhvdWdoIGl0IHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB0byBqdXN0IHJldHVybiBob29rUmVzdWx0IGhlcmVcbiAgICAgICAgICAgIC8vIGFuZCBwdXQgdGhlIC50aGVuKCkgaGFuZGxlciBqdXN0IGFib3ZlIHRoZSAuY2F0Y2goKSBoYW5kbGVyIGJlbG93LFxuICAgICAgICAgICAgLy8gZG9pbmcgc28gd291bGQgc3VidGx5IGNoYW5nZSB0aGUgZGVmYWN0byBhc3luYyBldmVudCBkaXNwYXRjaCBvcmRlclxuICAgICAgICAgICAgLy8gd2hpY2ggYXQgbGVhc3Qgb25lIHRlc3QgYW5kIHNvbWUgcGx1Z2lucyBpbiB0aGUgd2lsZCBtYXkgZGVwZW5kIG9uLlxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShob29rUmVzdWx0KS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gYWN0aW9uIHdhcyBmdWxmaWxsZWRcbiAgICAgICAgICAgICAgICB0aGlzLnVuZnVsZmlsbGVkQWN0aW9ucy5kZWxldGUoYWN0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3JfID0+IHtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBhY3Rpb24gY29uc2lkZXJlZCB0byBiZSBmdWxmaWxsZWQgc2luY2UgZXJyb3IgYmVpbmcgaGFuZGxlZFxuICAgICAgICAgICAgICAgIHRoaXMudW5mdWxmaWxsZWRBY3Rpb25zLmRlbGV0ZShhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycm9yKGxvZ1BsdWdpbkVycm9yKGVycm9yXywgcGx1Z2luLm5hbWUsIHsgaG9vazogaG9va05hbWUgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVuIGEgc3luYyBwbHVnaW4gaG9vayBhbmQgcmV0dXJuIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIGhvb2tOYW1lIE5hbWUgb2YgdGhlIHBsdWdpbiBob29rLiBNdXN0IGJlIGluIGBQbHVnaW5Ib29rc2AuXG4gICAgICogQHBhcmFtIGFyZ3MgQXJndW1lbnRzIHBhc3NlZCB0byB0aGUgcGx1Z2luIGhvb2suXG4gICAgICogQHBhcmFtIHBsdWdpbiBUaGUgYWN1dGFsIHBsdWdpblxuICAgICAqIEBwYXJhbSByZXBsYWNlQ29udGV4dCBXaGVuIHBhc3NlZCwgdGhlIHBsdWdpbiBjb250ZXh0IGNhbiBiZSBvdmVycmlkZGVuLlxuICAgICAqL1xuICAgIHJ1bkhvb2tTeW5jKGhvb2tOYW1lLCBwYXJhbWV0ZXJzLCBwbHVnaW4sIHJlcGxhY2VDb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGhvb2sgPSBwbHVnaW5baG9va05hbWVdO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdHlwZW9mIGhvb2sgPT09ICdvYmplY3QnID8gaG9vay5oYW5kbGVyIDogaG9vaztcbiAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLnBsdWdpbkNvbnRleHRzLmdldChwbHVnaW4pO1xuICAgICAgICBpZiAocmVwbGFjZUNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSByZXBsYWNlQ29udGV4dChjb250ZXh0LCBwbHVnaW4pO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1mdW5jdGlvbi10eXBlXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlci5hcHBseShjb250ZXh0LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3JfKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IobG9nUGx1Z2luRXJyb3IoZXJyb3JfLCBwbHVnaW4ubmFtZSwgeyBob29rOiBob29rTmFtZSB9KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTb3J0ZWRWYWxpZGF0ZWRQbHVnaW5zKGhvb2tOYW1lLCBwbHVnaW5zLCB2YWxpZGF0ZUhhbmRsZXIgPSB2YWxpZGF0ZUZ1bmN0aW9uUGx1Z2luSGFuZGxlcikge1xuICAgIGNvbnN0IHByZSA9IFtdO1xuICAgIGNvbnN0IG5vcm1hbCA9IFtdO1xuICAgIGNvbnN0IHBvc3QgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICAgIGNvbnN0IGhvb2sgPSBwbHVnaW5baG9va05hbWVdO1xuICAgICAgICBpZiAoaG9vaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBob29rID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlSGFuZGxlcihob29rLmhhbmRsZXIsIGhvb2tOYW1lLCBwbHVnaW4pO1xuICAgICAgICAgICAgICAgIGlmIChob29rLm9yZGVyID09PSAncHJlJykge1xuICAgICAgICAgICAgICAgICAgICBwcmUucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhvb2sub3JkZXIgPT09ICdwb3N0Jykge1xuICAgICAgICAgICAgICAgICAgICBwb3N0LnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVIYW5kbGVyKGhvb2ssIGhvb2tOYW1lLCBwbHVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9ybWFsLnB1c2gocGx1Z2luKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gWy4uLnByZSwgLi4ubm9ybWFsLCAuLi5wb3N0XTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25QbHVnaW5IYW5kbGVyKGhhbmRsZXIsIGhvb2tOYW1lLCBwbHVnaW4pIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IobG9nSW52YWxpZEZ1bmN0aW9uUGx1Z2luSG9vayhob29rTmFtZSwgcGx1Z2luLm5hbWUpKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFkZG9uUGx1Z2luSGFuZGxlcihoYW5kbGVyLCBob29rTmFtZSwgcGx1Z2luKSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZXJyb3IobG9nSW52YWxpZEFkZG9uUGx1Z2luSG9vayhob29rTmFtZSwgcGx1Z2luLm5hbWUpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBub1JldHVybigpIHsgfVxuXG5jbGFzcyBRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IobWF4UGFyYWxsZWwpIHtcbiAgICAgICAgdGhpcy5tYXhQYXJhbGxlbCA9IG1heFBhcmFsbGVsO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMud29ya2VyQ291bnQgPSAwO1xuICAgIH1cbiAgICBydW4odGFzaykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgcmVqZWN0LCByZXNvbHZlLCB0YXNrIH0pO1xuICAgICAgICAgICAgdGhpcy53b3JrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB3b3JrKCkge1xuICAgICAgICBpZiAodGhpcy53b3JrZXJDb3VudCA+PSB0aGlzLm1heFBhcmFsbGVsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLndvcmtlckNvdW50Kys7XG4gICAgICAgIGxldCBlbnRyeTtcbiAgICAgICAgd2hpbGUgKChlbnRyeSA9IHRoaXMucXVldWUuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVqZWN0LCByZXNvbHZlLCB0YXNrIH0gPSBlbnRyeTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGFzaygpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53b3JrZXJDb3VudC0tO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplRW50cnlNb2R1bGVzKGVudHJ5TW9kdWxlcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGVudHJ5TW9kdWxlcykpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5TW9kdWxlcy5tYXAoaWQgPT4gKHtcbiAgICAgICAgICAgIGZpbGVOYW1lOiBudWxsLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBpbXBsaWNpdGx5TG9hZGVkQWZ0ZXI6IFtdLFxuICAgICAgICAgICAgaW1wb3J0ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZW50cnlNb2R1bGVzKS5tYXAoKFtuYW1lLCBpZF0pID0+ICh7XG4gICAgICAgIGZpbGVOYW1lOiBudWxsLFxuICAgICAgICBpZCxcbiAgICAgICAgaW1wbGljaXRseUxvYWRlZEFmdGVyOiBbXSxcbiAgICAgICAgaW1wb3J0ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgbmFtZVxuICAgIH0pKTtcbn1cbmNsYXNzIEdyYXBoIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCB3YXRjaGVyKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYXN0THJ1ID0gZmxydSg1KTtcbiAgICAgICAgdGhpcy5jYWNoZWRNb2R1bGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmRlb3B0aW1pemF0aW9uVHJhY2tlciA9IG5ldyBQYXRoVHJhY2tlcigpO1xuICAgICAgICB0aGlzLmVudHJ5TW9kdWxlcyA9IFtdO1xuICAgICAgICB0aGlzLm1vZHVsZXNCeUlkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm5lZWRzVHJlZXNoYWtpbmdQYXNzID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGhhc2UgPSBCdWlsZFBoYXNlLkxPQURfQU5EX1BBUlNFO1xuICAgICAgICB0aGlzLnNjb3BlID0gbmV3IEdsb2JhbFNjb3BlKCk7XG4gICAgICAgIHRoaXMud2F0Y2hGaWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMud2F0Y2hNb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxNb2R1bGVzID0gW107XG4gICAgICAgIHRoaXMuaW1wbGljaXRFbnRyeU1vZHVsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5tb2R1bGVzID0gW107XG4gICAgICAgIHRoaXMuZ2V0TW9kdWxlSW5mbyA9IChtb2R1bGVJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZm91bmRNb2R1bGUgPSB0aGlzLm1vZHVsZXNCeUlkLmdldChtb2R1bGVJZCk7XG4gICAgICAgICAgICBpZiAoIWZvdW5kTW9kdWxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kTW9kdWxlLmluZm87XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLmNhY2hlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FjaGU/Lm1vZHVsZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBvcHRpb25zLmNhY2hlLm1vZHVsZXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkTW9kdWxlcy5zZXQobW9kdWxlLmlkLCBtb2R1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wbHVnaW5DYWNoZSA9IG9wdGlvbnMuY2FjaGU/LnBsdWdpbnMgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIC8vIGluY3JlbWVudCBhY2Nlc3MgY291bnRlclxuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMucGx1Z2luQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMucGx1Z2luQ2FjaGVbbmFtZV07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBPYmplY3QudmFsdWVzKGNhY2hlKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbMF0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2F0Y2hlcikge1xuICAgICAgICAgICAgdGhpcy53YXRjaE1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQ2hhbmdlID0gKC4uLnBhcmFtZXRlcnMpID0+IHRoaXMucGx1Z2luRHJpdmVyLmhvb2tQYXJhbGxlbCgnd2F0Y2hDaGFuZ2UnLCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNsb3NlID0gKCkgPT4gdGhpcy5wbHVnaW5Ecml2ZXIuaG9va1BhcmFsbGVsKCdjbG9zZVdhdGNoZXInLCBbXSk7XG4gICAgICAgICAgICB3YXRjaGVyLm9uQ3VycmVudFJ1bignY2hhbmdlJywgaGFuZGxlQ2hhbmdlKTtcbiAgICAgICAgICAgIHdhdGNoZXIub25DdXJyZW50UnVuKCdjbG9zZScsIGhhbmRsZUNsb3NlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBsdWdpbkRyaXZlciA9IG5ldyBQbHVnaW5Ecml2ZXIodGhpcywgb3B0aW9ucywgb3B0aW9ucy5wbHVnaW5zLCB0aGlzLnBsdWdpbkNhY2hlKTtcbiAgICAgICAgdGhpcy5tb2R1bGVMb2FkZXIgPSBuZXcgTW9kdWxlTG9hZGVyKHRoaXMsIHRoaXMubW9kdWxlc0J5SWQsIHRoaXMub3B0aW9ucywgdGhpcy5wbHVnaW5Ecml2ZXIpO1xuICAgICAgICB0aGlzLmZpbGVPcGVyYXRpb25RdWV1ZSA9IG5ldyBRdWV1ZShvcHRpb25zLm1heFBhcmFsbGVsRmlsZU9wcyk7XG4gICAgICAgIHRoaXMucHVyZUZ1bmN0aW9ucyA9IGdldFB1cmVGdW5jdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkKCkge1xuICAgICAgICB0aW1lU3RhcnQoJ2dlbmVyYXRlIG1vZHVsZSBncmFwaCcsIDIpO1xuICAgICAgICBhd2FpdCB0aGlzLmdlbmVyYXRlTW9kdWxlR3JhcGgoKTtcbiAgICAgICAgdGltZUVuZCgnZ2VuZXJhdGUgbW9kdWxlIGdyYXBoJywgMik7XG4gICAgICAgIHRpbWVTdGFydCgnc29ydCBhbmQgYmluZCBtb2R1bGVzJywgMik7XG4gICAgICAgIHRoaXMucGhhc2UgPSBCdWlsZFBoYXNlLkFOQUxZU0U7XG4gICAgICAgIHRoaXMuc29ydE1vZHVsZXMoKTtcbiAgICAgICAgdGltZUVuZCgnc29ydCBhbmQgYmluZCBtb2R1bGVzJywgMik7XG4gICAgICAgIHRpbWVTdGFydCgnbWFyayBpbmNsdWRlZCBzdGF0ZW1lbnRzJywgMik7XG4gICAgICAgIHRoaXMuaW5jbHVkZVN0YXRlbWVudHMoKTtcbiAgICAgICAgdGltZUVuZCgnbWFyayBpbmNsdWRlZCBzdGF0ZW1lbnRzJywgMik7XG4gICAgICAgIHRoaXMucGhhc2UgPSBCdWlsZFBoYXNlLkdFTkVSQVRFO1xuICAgIH1cbiAgICBnZXRDYWNoZSgpIHtcbiAgICAgICAgLy8gaGFuZGxlIHBsdWdpbiBjYWNoZSBldmljdGlvblxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5wbHVnaW5DYWNoZSkge1xuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnBsdWdpbkNhY2hlW25hbWVdO1xuICAgICAgICAgICAgbGV0IGFsbERlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoY2FjaGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWzBdID49IHRoaXMub3B0aW9ucy5leHBlcmltZW50YWxDYWNoZUV4cGlyeSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2tleV07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBhbGxEZWxldGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxsRGVsZXRlZClcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wbHVnaW5DYWNoZVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW9kdWxlczogdGhpcy5tb2R1bGVzLm1hcChtb2R1bGUgPT4gbW9kdWxlLnRvSlNPTigpKSxcbiAgICAgICAgICAgIHBsdWdpbnM6IHRoaXMucGx1Z2luQ2FjaGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2VuZXJhdGVNb2R1bGVHcmFwaCgpIHtcbiAgICAgICAgKHsgZW50cnlNb2R1bGVzOiB0aGlzLmVudHJ5TW9kdWxlcywgaW1wbGljaXRFbnRyeU1vZHVsZXM6IHRoaXMuaW1wbGljaXRFbnRyeU1vZHVsZXMgfSA9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm1vZHVsZUxvYWRlci5hZGRFbnRyeU1vZHVsZXMobm9ybWFsaXplRW50cnlNb2R1bGVzKHRoaXMub3B0aW9ucy5pbnB1dCksIHRydWUpKTtcbiAgICAgICAgaWYgKHRoaXMuZW50cnlNb2R1bGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzdXBwbHkgb3B0aW9ucy5pbnB1dCB0byByb2xsdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiB0aGlzLm1vZHVsZXNCeUlkLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBtb2R1bGUuY2FjaGVJbmZvR2V0dGVycygpO1xuICAgICAgICAgICAgaWYgKG1vZHVsZSBpbnN0YW5jZW9mIE1vZHVsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kdWxlcy5wdXNoKG1vZHVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVybmFsTW9kdWxlcy5wdXNoKG1vZHVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5jbHVkZVN0YXRlbWVudHMoKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5TW9kdWxlcyA9IFsuLi50aGlzLmVudHJ5TW9kdWxlcywgLi4udGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlc107XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIGVudHJ5TW9kdWxlcykge1xuICAgICAgICAgICAgbWFya01vZHVsZUFuZEltcHVyZURlcGVuZGVuY2llc0FzRXhlY3V0ZWQobW9kdWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRyZWVzaGFrZSkge1xuICAgICAgICAgICAgbGV0IHRyZWVzaGFraW5nUGFzcyA9IDE7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdGltZVN0YXJ0KGB0cmVlc2hha2luZyBwYXNzICR7dHJlZXNoYWtpbmdQYXNzfWAsIDMpO1xuICAgICAgICAgICAgICAgIHRoaXMubmVlZHNUcmVlc2hha2luZ1Bhc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiB0aGlzLm1vZHVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZHVsZS5pc0V4ZWN1dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUuaGFzVHJlZVNoYWtpbmdQYXNzU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kdWxlLmluZm8ubW9kdWxlU2lkZUVmZmVjdHMgPT09ICduby10cmVlc2hha2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmluY2x1ZGVBbGxJbkJ1bmRsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmluY2x1ZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHJlZXNoYWtpbmdQYXNzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgaW5jbHVkZSBleHBvcnRzIGFmdGVyIHRoZSBmaXJzdCBwYXNzIHRvIGF2b2lkIGlzc3VlcyB3aXRoXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBURFogZGV0ZWN0aW9uIGxvZ2ljXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIGVudHJ5TW9kdWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZHVsZS5wcmVzZXJ2ZVNpZ25hdHVyZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUuaW5jbHVkZUFsbEV4cG9ydHMoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmVlZHNUcmVlc2hha2luZ1Bhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbWVFbmQoYHRyZWVzaGFraW5nIHBhc3MgJHt0cmVlc2hha2luZ1Bhc3MrK31gLCAzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMubmVlZHNUcmVlc2hha2luZ1Bhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgdGhpcy5tb2R1bGVzKVxuICAgICAgICAgICAgICAgIG1vZHVsZS5pbmNsdWRlQWxsSW5CdW5kbGUoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGV4dGVybmFsTW9kdWxlIG9mIHRoaXMuZXh0ZXJuYWxNb2R1bGVzKVxuICAgICAgICAgICAgZXh0ZXJuYWxNb2R1bGUud2FyblVudXNlZEltcG9ydHMoKTtcbiAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgdGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkZXBlbmRhbnQgb2YgbW9kdWxlLmltcGxpY2l0bHlMb2FkZWRBZnRlcikge1xuICAgICAgICAgICAgICAgIGlmICghKGRlcGVuZGFudC5pbmZvLmlzRW50cnkgfHwgZGVwZW5kYW50LmlzSW5jbHVkZWQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IobG9nSW1wbGljaXREZXBlbmRhbnRJc05vdEluY2x1ZGVkKGRlcGVuZGFudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzb3J0TW9kdWxlcygpIHtcbiAgICAgICAgY29uc3QgeyBvcmRlcmVkTW9kdWxlcywgY3ljbGVQYXRocyB9ID0gYW5hbHlzZU1vZHVsZUV4ZWN1dGlvbih0aGlzLmVudHJ5TW9kdWxlcyk7XG4gICAgICAgIGZvciAoY29uc3QgY3ljbGVQYXRoIG9mIGN5Y2xlUGF0aHMpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkxvZyhMT0dMRVZFTF9XQVJOLCBsb2dDaXJjdWxhckRlcGVuZGVuY3koY3ljbGVQYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2R1bGVzID0gb3JkZXJlZE1vZHVsZXM7XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIHRoaXMubW9kdWxlcykge1xuICAgICAgICAgICAgbW9kdWxlLmJpbmRSZWZlcmVuY2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXJuRm9yTWlzc2luZ0V4cG9ydHMoKTtcbiAgICB9XG4gICAgd2FybkZvck1pc3NpbmdFeHBvcnRzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiB0aGlzLm1vZHVsZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW1wb3J0RGVzY3JpcHRpb24gb2YgbW9kdWxlLmltcG9ydERlc2NyaXB0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChpbXBvcnREZXNjcmlwdGlvbi5uYW1lICE9PSAnKicgJiZcbiAgICAgICAgICAgICAgICAgICAgIWltcG9ydERlc2NyaXB0aW9uLm1vZHVsZS5nZXRWYXJpYWJsZUZvckV4cG9ydE5hbWUoaW1wb3J0RGVzY3JpcHRpb24ubmFtZSlbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmxvZyhMT0dMRVZFTF9XQVJOLCBsb2dNaXNzaW5nRXhwb3J0KGltcG9ydERlc2NyaXB0aW9uLm5hbWUsIG1vZHVsZS5pZCwgaW1wb3J0RGVzY3JpcHRpb24ubW9kdWxlLmlkKSwgaW1wb3J0RGVzY3JpcHRpb24uc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0QWN0aW9uKFtwbHVnaW5OYW1lLCBob29rTmFtZSwgcGFyYW1ldGVyc10pIHtcbiAgICBjb25zdCBhY3Rpb24gPSBgKCR7cGx1Z2luTmFtZX0pICR7aG9va05hbWV9YDtcbiAgICBjb25zdCBzID0gSlNPTi5zdHJpbmdpZnk7XG4gICAgc3dpdGNoIChob29rTmFtZSkge1xuICAgICAgICBjYXNlICdyZXNvbHZlSWQnOiB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWN0aW9ufSAke3MocGFyYW1ldGVyc1swXSl9ICR7cyhwYXJhbWV0ZXJzWzFdKX1gO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2xvYWQnOiB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWN0aW9ufSAke3MocGFyYW1ldGVyc1swXSl9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0cmFuc2Zvcm0nOiB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWN0aW9ufSAke3MocGFyYW1ldGVyc1sxXSl9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzaG91bGRUcmFuc2Zvcm1DYWNoZWRNb2R1bGUnOiB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWN0aW9ufSAke3MocGFyYW1ldGVyc1swXS5pZCl9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdtb2R1bGVQYXJzZWQnOiB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWN0aW9ufSAke3MocGFyYW1ldGVyc1swXS5pZCl9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWN0aW9uO1xufVxubGV0IGhhbmRsZUJlZm9yZUV4aXQgPSBudWxsO1xuY29uc3QgcmVqZWN0QnlQbHVnaW5Ecml2ZXIgPSBuZXcgTWFwKCk7XG5hc3luYyBmdW5jdGlvbiBjYXRjaFVuZmluaXNoZWRIb29rQWN0aW9ucyhwbHVnaW5Ecml2ZXIsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW1wdHlFdmVudExvb3BQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICByZWplY3RCeVBsdWdpbkRyaXZlci5zZXQocGx1Z2luRHJpdmVyLCByZWplY3QpO1xuICAgICAgICBpZiAoIWhhbmRsZUJlZm9yZUV4aXQpIHtcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgZXZlciBjcmVhdGUgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIgdG8gYXZvaWQgbWF4IGxpc3RlbmVyIGFuZFxuICAgICAgICAgICAgLy8gb3RoZXIgaXNzdWVzXG4gICAgICAgICAgICBoYW5kbGVCZWZvcmVFeGl0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3BsdWdpbkRyaXZlciwgcmVqZWN0XSBvZiByZWplY3RCeVBsdWdpbkRyaXZlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1bmZ1bGZpbGxlZEFjdGlvbnMgPSBwbHVnaW5Ecml2ZXIuZ2V0VW5mdWxmaWxsZWRIb29rQWN0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBVbmV4cGVjdGVkIGVhcmx5IGV4aXQuIFRoaXMgaGFwcGVucyB3aGVuIFByb21pc2VzIHJldHVybmVkIGJ5IHBsdWdpbnMgY2Fubm90IHJlc29sdmUuIFVuZmluaXNoZWQgaG9vayBhY3Rpb24ocykgb24gZXhpdDpcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFsuLi51bmZ1bGZpbGxlZEFjdGlvbnNdLm1hcChmb3JtYXRBY3Rpb24pLmpvaW4oJ1xcbicpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByb2Nlc3MkMS5vbmNlKCdiZWZvcmVFeGl0JywgaGFuZGxlQmVmb3JlRXhpdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yYWNlKFtjYWxsYmFjaygpLCBlbXB0eUV2ZW50TG9vcFByb21pc2VdKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHJlamVjdEJ5UGx1Z2luRHJpdmVyLmRlbGV0ZShwbHVnaW5Ecml2ZXIpO1xuICAgICAgICBpZiAocmVqZWN0QnlQbHVnaW5Ecml2ZXIuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcHJvY2VzcyQxLm9mZignYmVmb3JlRXhpdCcsIGhhbmRsZUJlZm9yZUV4aXQpO1xuICAgICAgICAgICAgaGFuZGxlQmVmb3JlRXhpdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGluaXRXYXNtKCkgeyB9XG5cbmZ1bmN0aW9uIGdldExvZ2dlcihwbHVnaW5zLCBvbkxvZywgd2F0Y2hNb2RlLCBsb2dMZXZlbCkge1xuICAgIHBsdWdpbnMgPSBnZXRTb3J0ZWRWYWxpZGF0ZWRQbHVnaW5zKCdvbkxvZycsIHBsdWdpbnMpO1xuICAgIGNvbnN0IG1pbmltYWxQcmlvcml0eSA9IGxvZ0xldmVsUHJpb3JpdHlbbG9nTGV2ZWxdO1xuICAgIGNvbnN0IGxvZ2dlciA9IChsZXZlbCwgbG9nLCBza2lwcGVkID0gRU1QVFlfU0VUKSA9PiB7XG4gICAgICAgIGF1Z21lbnRMb2dNZXNzYWdlKGxvZyk7XG4gICAgICAgIGNvbnN0IGxvZ1ByaW9yaXR5ID0gbG9nTGV2ZWxQcmlvcml0eVtsZXZlbF07XG4gICAgICAgIGlmIChsb2dQcmlvcml0eSA8IG1pbmltYWxQcmlvcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICAgICAgICAgIGlmIChza2lwcGVkLmhhcyhwbHVnaW4pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgeyBvbkxvZzogcGx1Z2luT25Mb2cgfSA9IHBsdWdpbjtcbiAgICAgICAgICAgIGNvbnN0IGdldExvZ0hhbmRsZXIgPSAobGV2ZWwpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobG9nTGV2ZWxQcmlvcml0eVtsZXZlbF0gPCBtaW5pbWFsUHJpb3JpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvTm90aGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZyA9PiBsb2dnZXIobGV2ZWwsIG5vcm1hbGl6ZUxvZyhsb2cpLCBuZXcgU2V0KHNraXBwZWQpLmFkZChwbHVnaW4pKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gJ2hhbmRsZXInIGluIHBsdWdpbk9uTG9nID8gcGx1Z2luT25Mb2cuaGFuZGxlciA6IHBsdWdpbk9uTG9nO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgZGVidWc6IGdldExvZ0hhbmRsZXIoTE9HTEVWRUxfREVCVUcpLFxuICAgICAgICAgICAgICAgIGVycm9yOiAobG9nKSA9PiBlcnJvcihub3JtYWxpemVMb2cobG9nKSksXG4gICAgICAgICAgICAgICAgaW5mbzogZ2V0TG9nSGFuZGxlcihMT0dMRVZFTF9JTkZPKSxcbiAgICAgICAgICAgICAgICBtZXRhOiB7IHJvbGx1cFZlcnNpb246IHZlcnNpb24sIHdhdGNoTW9kZSB9LFxuICAgICAgICAgICAgICAgIHdhcm46IGdldExvZ0hhbmRsZXIoTE9HTEVWRUxfV0FSTilcbiAgICAgICAgICAgIH0sIGxldmVsLCBsb2cpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvbkxvZyhsZXZlbCwgbG9nKTtcbiAgICB9O1xuICAgIHJldHVybiBsb2dnZXI7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUFycmF5KGl0ZW1zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgIHJldHVybiBpdGVtcy5maWx0ZXIoQm9vbGVhbik7XG4gICAgfVxuICAgIGlmIChpdGVtcykge1xuICAgICAgICByZXR1cm4gW2l0ZW1zXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuXG5hc3luYyBmdW5jdGlvbiBub3JtYWxpemVJbnB1dE9wdGlvbnMoY29uZmlnLCB3YXRjaE1vZGUpIHtcbiAgICAvLyBUaGVzZSBhcmUgb3B0aW9ucyB0aGF0IG1heSB0cmlnZ2VyIHNwZWNpYWwgd2FybmluZ3Mgb3IgYmVoYXZpb3VyIGxhdGVyXG4gICAgLy8gaWYgdGhlIHVzZXIgZGlkIG5vdCBzZWxlY3QgYW4gZXhwbGljaXQgdmFsdWVcbiAgICBjb25zdCB1bnNldE9wdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgY29udGV4dCA9IGNvbmZpZy5jb250ZXh0ID8/ICd1bmRlZmluZWQnO1xuICAgIGNvbnN0IHBsdWdpbnMgPSBhd2FpdCBub3JtYWxpemVQbHVnaW5PcHRpb24oY29uZmlnLnBsdWdpbnMpO1xuICAgIGNvbnN0IGxvZ0xldmVsID0gY29uZmlnLmxvZ0xldmVsIHx8IExPR0xFVkVMX0lORk87XG4gICAgY29uc3Qgb25Mb2cgPSBnZXRMb2dnZXIocGx1Z2lucywgZ2V0T25Mb2coY29uZmlnLCBsb2dMZXZlbCksIHdhdGNoTW9kZSwgbG9nTGV2ZWwpO1xuICAgIGNvbnN0IHN0cmljdERlcHJlY2F0aW9ucyA9IGNvbmZpZy5zdHJpY3REZXByZWNhdGlvbnMgfHwgZmFsc2U7XG4gICAgY29uc3QgbWF4UGFyYWxsZWxGaWxlT3BzID0gZ2V0TWF4UGFyYWxsZWxGaWxlT3BzKGNvbmZpZyk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgY2FjaGU6IGdldENhY2hlKGNvbmZpZyksXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGV4cGVyaW1lbnRhbENhY2hlRXhwaXJ5OiBjb25maWcuZXhwZXJpbWVudGFsQ2FjaGVFeHBpcnkgPz8gMTAsXG4gICAgICAgIGV4cGVyaW1lbnRhbExvZ1NpZGVFZmZlY3RzOiBjb25maWcuZXhwZXJpbWVudGFsTG9nU2lkZUVmZmVjdHMgfHwgZmFsc2UsXG4gICAgICAgIGV4dGVybmFsOiBnZXRJZE1hdGNoZXIoY29uZmlnLmV4dGVybmFsKSxcbiAgICAgICAgaW5wdXQ6IGdldElucHV0KGNvbmZpZyksXG4gICAgICAgIGpzeDogZ2V0SnN4KGNvbmZpZyksXG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICBtYWtlQWJzb2x1dGVFeHRlcm5hbHNSZWxhdGl2ZTogY29uZmlnLm1ha2VBYnNvbHV0ZUV4dGVybmFsc1JlbGF0aXZlID8/ICdpZlJlbGF0aXZlU291cmNlJyxcbiAgICAgICAgbWF4UGFyYWxsZWxGaWxlT3BzLFxuICAgICAgICBtb2R1bGVDb250ZXh0OiBnZXRNb2R1bGVDb250ZXh0KGNvbmZpZywgY29udGV4dCksXG4gICAgICAgIG9uTG9nLFxuICAgICAgICBwZXJmOiBjb25maWcucGVyZiB8fCBmYWxzZSxcbiAgICAgICAgcGx1Z2lucyxcbiAgICAgICAgcHJlc2VydmVFbnRyeVNpZ25hdHVyZXM6IGNvbmZpZy5wcmVzZXJ2ZUVudHJ5U2lnbmF0dXJlcyA/PyAnZXhwb3J0cy1vbmx5JyxcbiAgICAgICAgcHJlc2VydmVTeW1saW5rczogY29uZmlnLnByZXNlcnZlU3ltbGlua3MgfHwgZmFsc2UsXG4gICAgICAgIHNoaW1NaXNzaW5nRXhwb3J0czogY29uZmlnLnNoaW1NaXNzaW5nRXhwb3J0cyB8fCBmYWxzZSxcbiAgICAgICAgc3RyaWN0RGVwcmVjYXRpb25zLFxuICAgICAgICB0cmVlc2hha2U6IGdldFRyZWVzaGFrZShjb25maWcpXG4gICAgfTtcbiAgICB3YXJuVW5rbm93bk9wdGlvbnMoY29uZmlnLCBbLi4uT2JqZWN0LmtleXMob3B0aW9ucyksICdvbndhcm4nLCAnd2F0Y2gnXSwgJ2lucHV0IG9wdGlvbnMnLCBvbkxvZywgL14ob3V0cHV0KSQvKTtcbiAgICByZXR1cm4geyBvcHRpb25zLCB1bnNldE9wdGlvbnMgfTtcbn1cbmNvbnN0IGdldENhY2hlID0gKGNvbmZpZykgPT4gY29uZmlnLmNhY2hlID09PSB0cnVlIC8vIGB0cnVlYCBpcyB0aGUgZGVmYXVsdFxuICAgID8gdW5kZWZpbmVkXG4gICAgOiBjb25maWcuY2FjaGU/LmNhY2hlIHx8IGNvbmZpZy5jYWNoZTtcbmNvbnN0IGdldElkTWF0Y2hlciA9IChvcHRpb24pID0+IHtcbiAgICBpZiAob3B0aW9uID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gKGlkLCAuLi5wYXJhbWV0ZXJzKSA9PiAoIWlkLnN0YXJ0c1dpdGgoJ1xcMCcpICYmIG9wdGlvbihpZCwgLi4ucGFyYW1ldGVycykpIHx8IGZhbHNlO1xuICAgIH1cbiAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgIGNvbnN0IGlkcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBlbnN1cmVBcnJheShvcHRpb24pKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVycy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlkcy5hZGQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaWQsIC4uLl9hcmd1bWVudHMpID0+IGlkcy5oYXMoaWQpIHx8IG1hdGNoZXJzLnNvbWUobWF0Y2hlciA9PiBtYXRjaGVyLnRlc3QoaWQpKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IGZhbHNlO1xufTtcbmNvbnN0IGdldElucHV0ID0gKGNvbmZpZykgPT4ge1xuICAgIGNvbnN0IGNvbmZpZ0lucHV0ID0gY29uZmlnLmlucHV0O1xuICAgIHJldHVybiBjb25maWdJbnB1dCA9PSBudWxsID8gW10gOiB0eXBlb2YgY29uZmlnSW5wdXQgPT09ICdzdHJpbmcnID8gW2NvbmZpZ0lucHV0XSA6IGNvbmZpZ0lucHV0O1xufTtcbmNvbnN0IGdldEpzeCA9IChjb25maWcpID0+IHtcbiAgICBjb25zdCBjb25maWdKc3ggPSBjb25maWcuanN4O1xuICAgIGlmICghY29uZmlnSnN4KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgY29uZmlnV2l0aFByZXNldCA9IGdldE9wdGlvbldpdGhQcmVzZXQoY29uZmlnSnN4LCBqc3hQcmVzZXRzLCAnanN4JywgVVJMX0pTWCwgJ2ZhbHNlLCAnKTtcbiAgICBjb25zdCB7IGZhY3RvcnksIGltcG9ydFNvdXJjZSwgbW9kZSB9ID0gY29uZmlnV2l0aFByZXNldDtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgY2FzZSAnYXV0b21hdGljJzoge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5OiBmYWN0b3J5IHx8ICdSZWFjdC5jcmVhdGVFbGVtZW50JyxcbiAgICAgICAgICAgICAgICBpbXBvcnRTb3VyY2U6IGltcG9ydFNvdXJjZSB8fCAncmVhY3QnLFxuICAgICAgICAgICAgICAgIGpzeEltcG9ydFNvdXJjZTogY29uZmlnV2l0aFByZXNldC5qc3hJbXBvcnRTb3VyY2UgfHwgJ3JlYWN0L2pzeC1ydW50aW1lJyxcbiAgICAgICAgICAgICAgICBtb2RlOiAnYXV0b21hdGljJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwcmVzZXJ2ZSc6IHtcbiAgICAgICAgICAgIGlmIChpbXBvcnRTb3VyY2UgJiYgIShmYWN0b3J5IHx8IGNvbmZpZ1dpdGhQcmVzZXQuZnJhZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IobG9nSW52YWxpZE9wdGlvbignanN4JywgVVJMX0pTWCwgJ3doZW4gcHJlc2VydmluZyBKU1ggYW5kIHNwZWNpZnlpbmcgYW4gaW1wb3J0U291cmNlLCB5b3UgYWxzbyBuZWVkIHRvIHNwZWNpZnkgYSBmYWN0b3J5IG9yIGZyYWdtZW50JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5OiBmYWN0b3J5IHx8IG51bGwsXG4gICAgICAgICAgICAgICAgZnJhZ21lbnQ6IGNvbmZpZ1dpdGhQcmVzZXQuZnJhZ21lbnQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBpbXBvcnRTb3VyY2U6IGltcG9ydFNvdXJjZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIG1vZGU6ICdwcmVzZXJ2ZSdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FzZSAnY2xhc3NpYyc6XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGlmIChtb2RlICYmIG1vZGUgIT09ICdjbGFzc2ljJykge1xuICAgICAgICAgICAgICAgIGVycm9yKGxvZ0ludmFsaWRPcHRpb24oJ2pzeC5tb2RlJywgVVJMX0pTWCwgJ21vZGUgbXVzdCBiZSBcImF1dG9tYXRpY1wiLCBcImNsYXNzaWNcIiBvciBcInByZXNlcnZlXCInLCBtb2RlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZhY3Rvcnk6IGZhY3RvcnkgfHwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQnLFxuICAgICAgICAgICAgICAgIGZyYWdtZW50OiBjb25maWdXaXRoUHJlc2V0LmZyYWdtZW50IHx8ICdSZWFjdC5GcmFnbWVudCcsXG4gICAgICAgICAgICAgICAgaW1wb3J0U291cmNlOiBpbXBvcnRTb3VyY2UgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBtb2RlOiAnY2xhc3NpYydcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgZ2V0TWF4UGFyYWxsZWxGaWxlT3BzID0gKGNvbmZpZykgPT4ge1xuICAgIGNvbnN0IG1heFBhcmFsbGVsRmlsZU9wcyA9IGNvbmZpZy5tYXhQYXJhbGxlbEZpbGVPcHM7XG4gICAgaWYgKHR5cGVvZiBtYXhQYXJhbGxlbEZpbGVPcHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChtYXhQYXJhbGxlbEZpbGVPcHMgPD0gMClcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgcmV0dXJuIG1heFBhcmFsbGVsRmlsZU9wcztcbiAgICB9XG4gICAgcmV0dXJuIDIwO1xufTtcbmNvbnN0IGdldE1vZHVsZUNvbnRleHQgPSAoY29uZmlnLCBjb250ZXh0KSA9PiB7XG4gICAgY29uc3QgY29uZmlnTW9kdWxlQ29udGV4dCA9IGNvbmZpZy5tb2R1bGVDb250ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uZmlnTW9kdWxlQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaWQgPT4gY29uZmlnTW9kdWxlQ29udGV4dChpZCkgPz8gY29udGV4dDtcbiAgICB9XG4gICAgaWYgKGNvbmZpZ01vZHVsZUNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY29udGV4dEJ5TW9kdWxlSWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIG1vZHVsZUNvbnRleHRdIG9mIE9iamVjdC5lbnRyaWVzKGNvbmZpZ01vZHVsZUNvbnRleHQpKSB7XG4gICAgICAgICAgICBjb250ZXh0QnlNb2R1bGVJZFtyZXNvbHZlJDEoa2V5KV0gPSBtb2R1bGVDb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZCA9PiBjb250ZXh0QnlNb2R1bGVJZFtpZF0gPz8gY29udGV4dDtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IGNvbnRleHQ7XG59O1xuY29uc3QgZ2V0VHJlZXNoYWtlID0gKGNvbmZpZykgPT4ge1xuICAgIGNvbnN0IGNvbmZpZ1RyZWVzaGFrZSA9IGNvbmZpZy50cmVlc2hha2U7XG4gICAgaWYgKGNvbmZpZ1RyZWVzaGFrZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb25maWdXaXRoUHJlc2V0ID0gZ2V0T3B0aW9uV2l0aFByZXNldChjb25maWcudHJlZXNoYWtlLCB0cmVlc2hha2VQcmVzZXRzLCAndHJlZXNoYWtlJywgVVJMX1RSRUVTSEFLRSwgJ2ZhbHNlLCB0cnVlLCAnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhbm5vdGF0aW9uczogY29uZmlnV2l0aFByZXNldC5hbm5vdGF0aW9ucyAhPT0gZmFsc2UsXG4gICAgICAgIGNvcnJlY3RWYXJWYWx1ZUJlZm9yZURlY2xhcmF0aW9uOiBjb25maWdXaXRoUHJlc2V0LmNvcnJlY3RWYXJWYWx1ZUJlZm9yZURlY2xhcmF0aW9uID09PSB0cnVlLFxuICAgICAgICBtYW51YWxQdXJlRnVuY3Rpb25zOiBjb25maWdXaXRoUHJlc2V0Lm1hbnVhbFB1cmVGdW5jdGlvbnMgPz8gRU1QVFlfQVJSQVksXG4gICAgICAgIG1vZHVsZVNpZGVFZmZlY3RzOiBnZXRIYXNNb2R1bGVTaWRlRWZmZWN0cyhjb25maWdXaXRoUHJlc2V0Lm1vZHVsZVNpZGVFZmZlY3RzKSxcbiAgICAgICAgcHJvcGVydHlSZWFkU2lkZUVmZmVjdHM6IGNvbmZpZ1dpdGhQcmVzZXQucHJvcGVydHlSZWFkU2lkZUVmZmVjdHMgPT09ICdhbHdheXMnXG4gICAgICAgICAgICA/ICdhbHdheXMnXG4gICAgICAgICAgICA6IGNvbmZpZ1dpdGhQcmVzZXQucHJvcGVydHlSZWFkU2lkZUVmZmVjdHMgIT09IGZhbHNlLFxuICAgICAgICB0cnlDYXRjaERlb3B0aW1pemF0aW9uOiBjb25maWdXaXRoUHJlc2V0LnRyeUNhdGNoRGVvcHRpbWl6YXRpb24gIT09IGZhbHNlLFxuICAgICAgICB1bmtub3duR2xvYmFsU2lkZUVmZmVjdHM6IGNvbmZpZ1dpdGhQcmVzZXQudW5rbm93bkdsb2JhbFNpZGVFZmZlY3RzICE9PSBmYWxzZVxuICAgIH07XG59O1xuY29uc3QgZ2V0SGFzTW9kdWxlU2lkZUVmZmVjdHMgPSAobW9kdWxlU2lkZUVmZmVjdHNPcHRpb24pID0+IHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZVNpZGVFZmZlY3RzT3B0aW9uID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG1vZHVsZVNpZGVFZmZlY3RzT3B0aW9uO1xuICAgIH1cbiAgICBpZiAobW9kdWxlU2lkZUVmZmVjdHNPcHRpb24gPT09ICduby1leHRlcm5hbCcpIHtcbiAgICAgICAgcmV0dXJuIChfaWQsIGV4dGVybmFsKSA9PiAhZXh0ZXJuYWw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbW9kdWxlU2lkZUVmZmVjdHNPcHRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIChpZCwgZXh0ZXJuYWwpID0+IGlkLnN0YXJ0c1dpdGgoJ1xcMCcpID8gdHJ1ZSA6IG1vZHVsZVNpZGVFZmZlY3RzT3B0aW9uKGlkLCBleHRlcm5hbCkgIT09IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShtb2R1bGVTaWRlRWZmZWN0c09wdGlvbikpIHtcbiAgICAgICAgY29uc3QgaWRzID0gbmV3IFNldChtb2R1bGVTaWRlRWZmZWN0c09wdGlvbik7XG4gICAgICAgIHJldHVybiBpZCA9PiBpZHMuaGFzKGlkKTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZVNpZGVFZmZlY3RzT3B0aW9uKSB7XG4gICAgICAgIGVycm9yKGxvZ0ludmFsaWRPcHRpb24oJ3RyZWVzaGFrZS5tb2R1bGVTaWRlRWZmZWN0cycsIFVSTF9UUkVFU0hBS0VfTU9EVUxFU0lERUVGRkVDVFMsICdwbGVhc2UgdXNlIG9uZSBvZiBmYWxzZSwgXCJuby1leHRlcm5hbFwiLCBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5JykpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4gdHJ1ZTtcbn07XG5cbi8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjMjM5NlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbmNvbnN0IElOVkFMSURfQ0hBUl9SRUdFWCA9IC9bXFx1MDAwMC1cXHUwMDFGXCIjJCUmKissOjs8PT4/W1xcXV5ge3x9XFx1MDA3Rl0vZztcbmNvbnN0IERSSVZFX0xFVFRFUl9SRUdFWCA9IC9eW2Etel06L2k7XG5mdW5jdGlvbiBzYW5pdGl6ZUZpbGVOYW1lKG5hbWUpIHtcbiAgICBjb25zdCBtYXRjaCA9IERSSVZFX0xFVFRFUl9SRUdFWC5leGVjKG5hbWUpO1xuICAgIGNvbnN0IGRyaXZlTGV0dGVyID0gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xuICAgIC8vIEEgYDpgIGlzIG9ubHkgYWxsb3dlZCBhcyBwYXJ0IG9mIGEgd2luZG93cyBkcml2ZSBsZXR0ZXIgKGV4OiBDOlxcZm9vKVxuICAgIC8vIE90aGVyd2lzZSwgYXZvaWQgdGhlbSBiZWNhdXNlIHRoZXkgY2FuIHJlZmVyIHRvIE5URlMgYWx0ZXJuYXRlIGRhdGEgc3RyZWFtcy5cbiAgICByZXR1cm4gZHJpdmVMZXR0ZXIgKyBuYW1lLnNsaWNlKGRyaXZlTGV0dGVyLmxlbmd0aCkucmVwbGFjZShJTlZBTElEX0NIQVJfUkVHRVgsICdfJyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG5vcm1hbGl6ZU91dHB1dE9wdGlvbnMoY29uZmlnLCBpbnB1dE9wdGlvbnMsIHVuc2V0SW5wdXRPcHRpb25zKSB7XG4gICAgLy8gVGhlc2UgYXJlIG9wdGlvbnMgdGhhdCBtYXkgdHJpZ2dlciBzcGVjaWFsIHdhcm5pbmdzIG9yIGJlaGF2aW91ciBsYXRlclxuICAgIC8vIGlmIHRoZSB1c2VyIGRpZCBub3Qgc2VsZWN0IGFuIGV4cGxpY2l0IHZhbHVlXG4gICAgY29uc3QgdW5zZXRPcHRpb25zID0gbmV3IFNldCh1bnNldElucHV0T3B0aW9ucyk7XG4gICAgY29uc3QgY29tcGFjdCA9IGNvbmZpZy5jb21wYWN0IHx8IGZhbHNlO1xuICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChjb25maWcpO1xuICAgIGNvbnN0IGlubGluZUR5bmFtaWNJbXBvcnRzID0gZ2V0SW5saW5lRHluYW1pY0ltcG9ydHMoY29uZmlnLCBpbnB1dE9wdGlvbnMpO1xuICAgIGNvbnN0IHByZXNlcnZlTW9kdWxlcyA9IGdldFByZXNlcnZlTW9kdWxlcyhjb25maWcsIGlubGluZUR5bmFtaWNJbXBvcnRzLCBpbnB1dE9wdGlvbnMpO1xuICAgIGNvbnN0IGZpbGUgPSBnZXRGaWxlKGNvbmZpZywgcHJlc2VydmVNb2R1bGVzLCBpbnB1dE9wdGlvbnMpO1xuICAgIGNvbnN0IGdlbmVyYXRlZENvZGUgPSBnZXRHZW5lcmF0ZWRDb2RlKGNvbmZpZyk7XG4gICAgY29uc3QgZXh0ZXJuYWxJbXBvcnRBdHRyaWJ1dGVzID0gZ2V0RXh0ZXJuYWxJbXBvcnRBdHRyaWJ1dGVzKGNvbmZpZywgaW5wdXRPcHRpb25zKTtcbiAgICBjb25zdCBvdXRwdXRPcHRpb25zID0ge1xuICAgICAgICBhbWQ6IGdldEFtZChjb25maWcpLFxuICAgICAgICBhc3NldEZpbGVOYW1lczogY29uZmlnLmFzc2V0RmlsZU5hbWVzID8/ICdhc3NldHMvW25hbWVdLVtoYXNoXVtleHRuYW1lXScsXG4gICAgICAgIGJhbm5lcjogZ2V0QWRkb24oY29uZmlnLCAnYmFubmVyJyksXG4gICAgICAgIGNodW5rRmlsZU5hbWVzOiBjb25maWcuY2h1bmtGaWxlTmFtZXMgPz8gJ1tuYW1lXS1baGFzaF0uanMnLFxuICAgICAgICBjb21wYWN0LFxuICAgICAgICBkaXI6IGdldERpcihjb25maWcsIGZpbGUpLFxuICAgICAgICBkeW5hbWljSW1wb3J0SW5DanM6IGNvbmZpZy5keW5hbWljSW1wb3J0SW5DanMgPz8gdHJ1ZSxcbiAgICAgICAgZW50cnlGaWxlTmFtZXM6IGdldEVudHJ5RmlsZU5hbWVzKGNvbmZpZywgdW5zZXRPcHRpb25zKSxcbiAgICAgICAgZXNNb2R1bGU6IGNvbmZpZy5lc01vZHVsZSA/PyAnaWYtZGVmYXVsdC1wcm9wJyxcbiAgICAgICAgZXhwZXJpbWVudGFsTWluQ2h1bmtTaXplOiBjb25maWcuZXhwZXJpbWVudGFsTWluQ2h1bmtTaXplID8/IDEsXG4gICAgICAgIGV4cG9ydHM6IGdldEV4cG9ydHMoY29uZmlnLCB1bnNldE9wdGlvbnMpLFxuICAgICAgICBleHRlbmQ6IGNvbmZpZy5leHRlbmQgfHwgZmFsc2UsXG4gICAgICAgIGV4dGVybmFsSW1wb3J0QXNzZXJ0aW9uczogZXh0ZXJuYWxJbXBvcnRBdHRyaWJ1dGVzLFxuICAgICAgICBleHRlcm5hbEltcG9ydEF0dHJpYnV0ZXMsXG4gICAgICAgIGV4dGVybmFsTGl2ZUJpbmRpbmdzOiBjb25maWcuZXh0ZXJuYWxMaXZlQmluZGluZ3MgPz8gdHJ1ZSxcbiAgICAgICAgZmlsZSxcbiAgICAgICAgZm9vdGVyOiBnZXRBZGRvbihjb25maWcsICdmb290ZXInKSxcbiAgICAgICAgZm9ybWF0LFxuICAgICAgICBmcmVlemU6IGNvbmZpZy5mcmVlemUgPz8gdHJ1ZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29kZSxcbiAgICAgICAgZ2xvYmFsczogY29uZmlnLmdsb2JhbHMgfHwge30sXG4gICAgICAgIGhhc2hDaGFyYWN0ZXJzOiBjb25maWcuaGFzaENoYXJhY3RlcnMgPz8gJ2Jhc2U2NCcsXG4gICAgICAgIGhvaXN0VHJhbnNpdGl2ZUltcG9ydHM6IGNvbmZpZy5ob2lzdFRyYW5zaXRpdmVJbXBvcnRzID8/IHRydWUsXG4gICAgICAgIGltcG9ydEF0dHJpYnV0ZXNLZXk6IGNvbmZpZy5pbXBvcnRBdHRyaWJ1dGVzS2V5ID8/ICdhc3NlcnQnLFxuICAgICAgICBpbmRlbnQ6IGdldEluZGVudChjb25maWcsIGNvbXBhY3QpLFxuICAgICAgICBpbmxpbmVEeW5hbWljSW1wb3J0cyxcbiAgICAgICAgaW50ZXJvcDogZ2V0SW50ZXJvcChjb25maWcpLFxuICAgICAgICBpbnRybzogZ2V0QWRkb24oY29uZmlnLCAnaW50cm8nKSxcbiAgICAgICAgbWFudWFsQ2h1bmtzOiBnZXRNYW51YWxDaHVua3MoY29uZmlnLCBpbmxpbmVEeW5hbWljSW1wb3J0cywgcHJlc2VydmVNb2R1bGVzKSxcbiAgICAgICAgbWluaWZ5SW50ZXJuYWxFeHBvcnRzOiBnZXRNaW5pZnlJbnRlcm5hbEV4cG9ydHMoY29uZmlnLCBmb3JtYXQsIGNvbXBhY3QpLFxuICAgICAgICBuYW1lOiBjb25maWcubmFtZSxcbiAgICAgICAgbm9Db25mbGljdDogY29uZmlnLm5vQ29uZmxpY3QgfHwgZmFsc2UsXG4gICAgICAgIG91dHJvOiBnZXRBZGRvbihjb25maWcsICdvdXRybycpLFxuICAgICAgICBwYXRoczogY29uZmlnLnBhdGhzIHx8IHt9LFxuICAgICAgICBwbHVnaW5zOiBhd2FpdCBub3JtYWxpemVQbHVnaW5PcHRpb24oY29uZmlnLnBsdWdpbnMpLFxuICAgICAgICBwcmVzZXJ2ZU1vZHVsZXMsXG4gICAgICAgIHByZXNlcnZlTW9kdWxlc1Jvb3Q6IGdldFByZXNlcnZlTW9kdWxlc1Jvb3QoY29uZmlnKSxcbiAgICAgICAgcmVleHBvcnRQcm90b0Zyb21FeHRlcm5hbDogY29uZmlnLnJlZXhwb3J0UHJvdG9Gcm9tRXh0ZXJuYWwgPz8gdHJ1ZSxcbiAgICAgICAgc2FuaXRpemVGaWxlTmFtZTogdHlwZW9mIGNvbmZpZy5zYW5pdGl6ZUZpbGVOYW1lID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGNvbmZpZy5zYW5pdGl6ZUZpbGVOYW1lXG4gICAgICAgICAgICA6IGNvbmZpZy5zYW5pdGl6ZUZpbGVOYW1lID09PSBmYWxzZVxuICAgICAgICAgICAgICAgID8gaWQgPT4gaWRcbiAgICAgICAgICAgICAgICA6IHNhbml0aXplRmlsZU5hbWUsXG4gICAgICAgIHNvdXJjZW1hcDogY29uZmlnLnNvdXJjZW1hcCB8fCBmYWxzZSxcbiAgICAgICAgc291cmNlbWFwQmFzZVVybDogZ2V0U291cmNlbWFwQmFzZVVybChjb25maWcpLFxuICAgICAgICBzb3VyY2VtYXBEZWJ1Z0lkczogY29uZmlnLnNvdXJjZW1hcERlYnVnSWRzIHx8IGZhbHNlLFxuICAgICAgICBzb3VyY2VtYXBFeGNsdWRlU291cmNlczogY29uZmlnLnNvdXJjZW1hcEV4Y2x1ZGVTb3VyY2VzIHx8IGZhbHNlLFxuICAgICAgICBzb3VyY2VtYXBGaWxlOiBjb25maWcuc291cmNlbWFwRmlsZSxcbiAgICAgICAgc291cmNlbWFwRmlsZU5hbWVzOiBnZXRTb3VyY2VtYXBGaWxlTmFtZXMoY29uZmlnLCB1bnNldE9wdGlvbnMpLFxuICAgICAgICBzb3VyY2VtYXBJZ25vcmVMaXN0OiB0eXBlb2YgY29uZmlnLnNvdXJjZW1hcElnbm9yZUxpc3QgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gY29uZmlnLnNvdXJjZW1hcElnbm9yZUxpc3RcbiAgICAgICAgICAgIDogY29uZmlnLnNvdXJjZW1hcElnbm9yZUxpc3QgPT09IGZhbHNlXG4gICAgICAgICAgICAgICAgPyAoKSA9PiBmYWxzZVxuICAgICAgICAgICAgICAgIDogcmVsYXRpdmVTb3VyY2VQYXRoID0+IHJlbGF0aXZlU291cmNlUGF0aC5pbmNsdWRlcygnbm9kZV9tb2R1bGVzJyksXG4gICAgICAgIHNvdXJjZW1hcFBhdGhUcmFuc2Zvcm06IGNvbmZpZy5zb3VyY2VtYXBQYXRoVHJhbnNmb3JtLFxuICAgICAgICBzdHJpY3Q6IGNvbmZpZy5zdHJpY3QgPz8gdHJ1ZSxcbiAgICAgICAgc3lzdGVtTnVsbFNldHRlcnM6IGNvbmZpZy5zeXN0ZW1OdWxsU2V0dGVycyA/PyB0cnVlLFxuICAgICAgICB2YWxpZGF0ZTogY29uZmlnLnZhbGlkYXRlIHx8IGZhbHNlLFxuICAgICAgICB2aXJ0dWFsRGlybmFtZTogY29uZmlnLnZpcnR1YWxEaXJuYW1lIHx8ICdfdmlydHVhbCdcbiAgICB9O1xuICAgIHdhcm5Vbmtub3duT3B0aW9ucyhjb25maWcsIE9iamVjdC5rZXlzKG91dHB1dE9wdGlvbnMpLCAnb3V0cHV0IG9wdGlvbnMnLCBpbnB1dE9wdGlvbnMub25Mb2cpO1xuICAgIHJldHVybiB7IG9wdGlvbnM6IG91dHB1dE9wdGlvbnMsIHVuc2V0T3B0aW9ucyB9O1xufVxuY29uc3QgZ2V0RmlsZSA9IChjb25maWcsIHByZXNlcnZlTW9kdWxlcywgaW5wdXRPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgeyBmaWxlIH0gPSBjb25maWc7XG4gICAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAocHJlc2VydmVNb2R1bGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IobG9nSW52YWxpZE9wdGlvbignb3V0cHV0LmZpbGUnLCBVUkxfT1VUUFVUX0RJUiwgJ3lvdSBtdXN0IHNldCBcIm91dHB1dC5kaXJcIiBpbnN0ZWFkIG9mIFwib3V0cHV0LmZpbGVcIiB3aGVuIHVzaW5nIHRoZSBcIm91dHB1dC5wcmVzZXJ2ZU1vZHVsZXNcIiBvcHRpb24nKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0T3B0aW9ucy5pbnB1dCkpXG4gICAgICAgICAgICByZXR1cm4gZXJyb3IobG9nSW52YWxpZE9wdGlvbignb3V0cHV0LmZpbGUnLCBVUkxfT1VUUFVUX0RJUiwgJ3lvdSBtdXN0IHNldCBcIm91dHB1dC5kaXJcIiBpbnN0ZWFkIG9mIFwib3V0cHV0LmZpbGVcIiB3aGVuIHByb3ZpZGluZyBuYW1lZCBpbnB1dHMnKSk7XG4gICAgfVxuICAgIHJldHVybiBmaWxlO1xufTtcbmNvbnN0IGdldEZvcm1hdCA9IChjb25maWcpID0+IHtcbiAgICBjb25zdCBjb25maWdGb3JtYXQgPSBjb25maWcuZm9ybWF0O1xuICAgIHN3aXRjaCAoY29uZmlnRm9ybWF0KSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlICdlcyc6XG4gICAgICAgIGNhc2UgJ2VzbSc6XG4gICAgICAgIGNhc2UgJ21vZHVsZSc6IHtcbiAgICAgICAgICAgIHJldHVybiAnZXMnO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Nqcyc6XG4gICAgICAgIGNhc2UgJ2NvbW1vbmpzJzoge1xuICAgICAgICAgICAgcmV0dXJuICdjanMnO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3N5c3RlbSc6XG4gICAgICAgIGNhc2UgJ3N5c3RlbWpzJzoge1xuICAgICAgICAgICAgcmV0dXJuICdzeXN0ZW0nO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2FtZCc6XG4gICAgICAgIGNhc2UgJ2lpZmUnOlxuICAgICAgICBjYXNlICd1bWQnOiB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihsb2dJbnZhbGlkT3B0aW9uKCdvdXRwdXQuZm9ybWF0JywgVVJMX09VVFBVVF9GT1JNQVQsIGBWYWxpZCB2YWx1ZXMgYXJlIFwiYW1kXCIsIFwiY2pzXCIsIFwic3lzdGVtXCIsIFwiZXNcIiwgXCJpaWZlXCIgb3IgXCJ1bWRcImAsIGNvbmZpZ0Zvcm1hdCkpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGdldElubGluZUR5bmFtaWNJbXBvcnRzID0gKGNvbmZpZywgaW5wdXRPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgaW5saW5lRHluYW1pY0ltcG9ydHMgPSBjb25maWcuaW5saW5lRHluYW1pY0ltcG9ydHMgfHwgZmFsc2U7XG4gICAgY29uc3QgeyBpbnB1dCB9ID0gaW5wdXRPcHRpb25zO1xuICAgIGlmIChpbmxpbmVEeW5hbWljSW1wb3J0cyAmJiAoQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IE9iamVjdC5rZXlzKGlucHV0KSkubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gZXJyb3IobG9nSW52YWxpZE9wdGlvbignb3V0cHV0LmlubGluZUR5bmFtaWNJbXBvcnRzJywgVVJMX09VVFBVVF9JTkxJTkVEWU5BTUlDSU1QT1JUUywgJ211bHRpcGxlIGlucHV0cyBhcmUgbm90IHN1cHBvcnRlZCB3aGVuIFwib3V0cHV0LmlubGluZUR5bmFtaWNJbXBvcnRzXCIgaXMgdHJ1ZScpKTtcbiAgICB9XG4gICAgcmV0dXJuIGlubGluZUR5bmFtaWNJbXBvcnRzO1xufTtcbmNvbnN0IGdldFByZXNlcnZlTW9kdWxlcyA9IChjb25maWcsIGlubGluZUR5bmFtaWNJbXBvcnRzLCBpbnB1dE9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBwcmVzZXJ2ZU1vZHVsZXMgPSBjb25maWcucHJlc2VydmVNb2R1bGVzIHx8IGZhbHNlO1xuICAgIGlmIChwcmVzZXJ2ZU1vZHVsZXMpIHtcbiAgICAgICAgaWYgKGlubGluZUR5bmFtaWNJbXBvcnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IobG9nSW52YWxpZE9wdGlvbignb3V0cHV0LmlubGluZUR5bmFtaWNJbXBvcnRzJywgVVJMX09VVFBVVF9JTkxJTkVEWU5BTUlDSU1QT1JUUywgYHRoaXMgb3B0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIFwib3V0cHV0LnByZXNlcnZlTW9kdWxlc1wiYCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dE9wdGlvbnMucHJlc2VydmVFbnRyeVNpZ25hdHVyZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IobG9nSW52YWxpZE9wdGlvbigncHJlc2VydmVFbnRyeVNpZ25hdHVyZXMnLCBVUkxfUFJFU0VSVkVFTlRSWVNJR05BVFVSRVMsICdzZXR0aW5nIHRoaXMgb3B0aW9uIHRvIGZhbHNlIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIFwib3V0cHV0LnByZXNlcnZlTW9kdWxlc1wiJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcmVzZXJ2ZU1vZHVsZXM7XG59O1xuY29uc3QgZ2V0UHJlc2VydmVNb2R1bGVzUm9vdCA9IChjb25maWcpID0+IHtcbiAgICBjb25zdCB7IHByZXNlcnZlTW9kdWxlc1Jvb3QgfSA9IGNvbmZpZztcbiAgICBpZiAocHJlc2VydmVNb2R1bGVzUm9vdCA9PT0gbnVsbCB8fCBwcmVzZXJ2ZU1vZHVsZXNSb290ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmUkMShwcmVzZXJ2ZU1vZHVsZXNSb290KTtcbn07XG5jb25zdCBnZXRBbWQgPSAoY29uZmlnKSA9PiB7XG4gICAgY29uc3QgbWVyZ2VkT3B0aW9uID0ge1xuICAgICAgICBhdXRvSWQ6IGZhbHNlLFxuICAgICAgICBiYXNlUGF0aDogJycsXG4gICAgICAgIGRlZmluZTogJ2RlZmluZScsXG4gICAgICAgIGZvcmNlSnNFeHRlbnNpb25Gb3JJbXBvcnRzOiBmYWxzZSxcbiAgICAgICAgLi4uY29uZmlnLmFtZFxuICAgIH07XG4gICAgaWYgKChtZXJnZWRPcHRpb24uYXV0b0lkIHx8IG1lcmdlZE9wdGlvbi5iYXNlUGF0aCkgJiYgbWVyZ2VkT3B0aW9uLmlkKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihsb2dJbnZhbGlkT3B0aW9uKCdvdXRwdXQuYW1kLmlkJywgVVJMX09VVFBVVF9BTURfSUQsICd0aGlzIG9wdGlvbiBjYW5ub3QgYmUgdXNlZCB0b2dldGhlciB3aXRoIFwib3V0cHV0LmFtZC5hdXRvSWRcIi9cIm91dHB1dC5hbWQuYmFzZVBhdGhcIicpKTtcbiAgICB9XG4gICAgaWYgKG1lcmdlZE9wdGlvbi5iYXNlUGF0aCAmJiAhbWVyZ2VkT3B0aW9uLmF1dG9JZCkge1xuICAgICAgICByZXR1cm4gZXJyb3IobG9nSW52YWxpZE9wdGlvbignb3V0cHV0LmFtZC5iYXNlUGF0aCcsIFVSTF9PVVRQVVRfQU1EX0JBU0VQQVRILCAndGhpcyBvcHRpb24gb25seSB3b3JrcyB3aXRoIFwib3V0cHV0LmFtZC5hdXRvSWRcIicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZE9wdGlvbi5hdXRvSWRcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBhdXRvSWQ6IHRydWUsXG4gICAgICAgICAgICBiYXNlUGF0aDogbWVyZ2VkT3B0aW9uLmJhc2VQYXRoLFxuICAgICAgICAgICAgZGVmaW5lOiBtZXJnZWRPcHRpb24uZGVmaW5lLFxuICAgICAgICAgICAgZm9yY2VKc0V4dGVuc2lvbkZvckltcG9ydHM6IG1lcmdlZE9wdGlvbi5mb3JjZUpzRXh0ZW5zaW9uRm9ySW1wb3J0c1xuICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgYXV0b0lkOiBmYWxzZSxcbiAgICAgICAgICAgIGRlZmluZTogbWVyZ2VkT3B0aW9uLmRlZmluZSxcbiAgICAgICAgICAgIGZvcmNlSnNFeHRlbnNpb25Gb3JJbXBvcnRzOiBtZXJnZWRPcHRpb24uZm9yY2VKc0V4dGVuc2lvbkZvckltcG9ydHMsXG4gICAgICAgICAgICBpZDogbWVyZ2VkT3B0aW9uLmlkXG4gICAgICAgIH07XG59O1xuY29uc3QgZ2V0QWRkb24gPSAoY29uZmlnLCBuYW1lKSA9PiB7XG4gICAgY29uc3QgY29uZmlnQWRkb24gPSBjb25maWdbbmFtZV07XG4gICAgaWYgKHR5cGVvZiBjb25maWdBZGRvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY29uZmlnQWRkb247XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiBjb25maWdBZGRvbiB8fCAnJztcbn07XG5jb25zdCBnZXREaXIgPSAoY29uZmlnLCBmaWxlKSA9PiB7XG4gICAgY29uc3QgeyBkaXIgfSA9IGNvbmZpZztcbiAgICBpZiAodHlwZW9mIGRpciA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihsb2dJbnZhbGlkT3B0aW9uKCdvdXRwdXQuZGlyJywgVVJMX09VVFBVVF9ESVIsICd5b3UgbXVzdCBzZXQgZWl0aGVyIFwib3V0cHV0LmZpbGVcIiBmb3IgYSBzaW5nbGUtZmlsZSBidWlsZCBvciBcIm91dHB1dC5kaXJcIiB3aGVuIGdlbmVyYXRpbmcgbXVsdGlwbGUgY2h1bmtzJykpO1xuICAgIH1cbiAgICByZXR1cm4gZGlyO1xufTtcbmNvbnN0IGdldEVudHJ5RmlsZU5hbWVzID0gKGNvbmZpZywgdW5zZXRPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgY29uZmlnRW50cnlGaWxlTmFtZXMgPSBjb25maWcuZW50cnlGaWxlTmFtZXM7XG4gICAgaWYgKGNvbmZpZ0VudHJ5RmlsZU5hbWVzID09IG51bGwpIHtcbiAgICAgICAgdW5zZXRPcHRpb25zLmFkZCgnZW50cnlGaWxlTmFtZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZ0VudHJ5RmlsZU5hbWVzID8/ICdbbmFtZV0uanMnO1xufTtcbmZ1bmN0aW9uIGdldEV4cG9ydHMoY29uZmlnLCB1bnNldE9wdGlvbnMpIHtcbiAgICBjb25zdCBjb25maWdFeHBvcnRzID0gY29uZmlnLmV4cG9ydHM7XG4gICAgaWYgKGNvbmZpZ0V4cG9ydHMgPT0gbnVsbCkge1xuICAgICAgICB1bnNldE9wdGlvbnMuYWRkKCdleHBvcnRzJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFbJ2RlZmF1bHQnLCAnbmFtZWQnLCAnbm9uZScsICdhdXRvJ10uaW5jbHVkZXMoY29uZmlnRXhwb3J0cykpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKGxvZ0ludmFsaWRFeHBvcnRPcHRpb25WYWx1ZShjb25maWdFeHBvcnRzKSk7XG4gICAgfVxuICAgIHJldHVybiBjb25maWdFeHBvcnRzIHx8ICdhdXRvJztcbn1cbmNvbnN0IGdldEV4dGVybmFsSW1wb3J0QXR0cmlidXRlcyA9IChjb25maWcsIGlucHV0T3B0aW9ucykgPT4ge1xuICAgIGlmIChjb25maWcuZXh0ZXJuYWxJbXBvcnRBc3NlcnRpb25zICE9IHVuZGVmaW5lZCkge1xuICAgICAgICB3YXJuRGVwcmVjYXRpb24oYFRoZSBcIm91dHB1dC5leHRlcm5hbEltcG9ydEFzc2VydGlvbnNcIiBvcHRpb24gaXMgZGVwcmVjYXRlZC4gVXNlIHRoZSBcIm91dHB1dC5leHRlcm5hbEltcG9ydEF0dHJpYnV0ZXNcIiBvcHRpb24gaW5zdGVhZC5gLCBVUkxfT1VUUFVUX0VYVEVSTkFMSU1QT1JUQVRUUklCVVRFUywgdHJ1ZSwgaW5wdXRPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZy5leHRlcm5hbEltcG9ydEF0dHJpYnV0ZXMgPz8gY29uZmlnLmV4dGVybmFsSW1wb3J0QXNzZXJ0aW9ucyA/PyB0cnVlO1xufTtcbmNvbnN0IGdldEdlbmVyYXRlZENvZGUgPSAoY29uZmlnKSA9PiB7XG4gICAgY29uc3QgY29uZmlnV2l0aFByZXNldCA9IGdldE9wdGlvbldpdGhQcmVzZXQoY29uZmlnLmdlbmVyYXRlZENvZGUsIGdlbmVyYXRlZENvZGVQcmVzZXRzLCAnb3V0cHV0LmdlbmVyYXRlZENvZGUnLCBVUkxfT1VUUFVUX0dFTkVSQVRFRENPREUsICcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhcnJvd0Z1bmN0aW9uczogY29uZmlnV2l0aFByZXNldC5hcnJvd0Z1bmN0aW9ucyA9PT0gdHJ1ZSxcbiAgICAgICAgY29uc3RCaW5kaW5nczogY29uZmlnV2l0aFByZXNldC5jb25zdEJpbmRpbmdzID09PSB0cnVlLFxuICAgICAgICBvYmplY3RTaG9ydGhhbmQ6IGNvbmZpZ1dpdGhQcmVzZXQub2JqZWN0U2hvcnRoYW5kID09PSB0cnVlLFxuICAgICAgICByZXNlcnZlZE5hbWVzQXNQcm9wczogY29uZmlnV2l0aFByZXNldC5yZXNlcnZlZE5hbWVzQXNQcm9wcyAhPT0gZmFsc2UsXG4gICAgICAgIHN5bWJvbHM6IGNvbmZpZ1dpdGhQcmVzZXQuc3ltYm9scyA9PT0gdHJ1ZVxuICAgIH07XG59O1xuY29uc3QgZ2V0SW5kZW50ID0gKGNvbmZpZywgY29tcGFjdCkgPT4ge1xuICAgIGlmIChjb21wYWN0KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY29uc3QgY29uZmlnSW5kZW50ID0gY29uZmlnLmluZGVudDtcbiAgICByZXR1cm4gY29uZmlnSW5kZW50ID09PSBmYWxzZSA/ICcnIDogKGNvbmZpZ0luZGVudCA/PyB0cnVlKTtcbn07XG5jb25zdCBBTExPV0VEX0lOVEVST1BfVFlQRVMgPSBuZXcgU2V0KFtcbiAgICAnY29tcGF0JyxcbiAgICAnYXV0bycsXG4gICAgJ2VzTW9kdWxlJyxcbiAgICAnZGVmYXVsdCcsXG4gICAgJ2RlZmF1bHRPbmx5J1xuXSk7XG5jb25zdCBnZXRJbnRlcm9wID0gKGNvbmZpZykgPT4ge1xuICAgIGNvbnN0IGNvbmZpZ0ludGVyb3AgPSBjb25maWcuaW50ZXJvcDtcbiAgICBpZiAodHlwZW9mIGNvbmZpZ0ludGVyb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgaW50ZXJvcFBlcklkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IGRlZmF1bHRJbnRlcm9wID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGlkID0+IGlkID09PSBudWxsXG4gICAgICAgICAgICA/IGRlZmF1bHRJbnRlcm9wIHx8IHZhbGlkYXRlSW50ZXJvcCgoZGVmYXVsdEludGVyb3AgPSBjb25maWdJbnRlcm9wKGlkKSkpXG4gICAgICAgICAgICA6IGlkIGluIGludGVyb3BQZXJJZFxuICAgICAgICAgICAgICAgID8gaW50ZXJvcFBlcklkW2lkXVxuICAgICAgICAgICAgICAgIDogdmFsaWRhdGVJbnRlcm9wKChpbnRlcm9wUGVySWRbaWRdID0gY29uZmlnSW50ZXJvcChpZCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZ0ludGVyb3AgPT09IHVuZGVmaW5lZCA/ICgpID0+ICdkZWZhdWx0JyA6ICgpID0+IHZhbGlkYXRlSW50ZXJvcChjb25maWdJbnRlcm9wKTtcbn07XG5jb25zdCB2YWxpZGF0ZUludGVyb3AgPSAoaW50ZXJvcCkgPT4ge1xuICAgIGlmICghQUxMT1dFRF9JTlRFUk9QX1RZUEVTLmhhcyhpbnRlcm9wKSkge1xuICAgICAgICByZXR1cm4gZXJyb3IobG9nSW52YWxpZE9wdGlvbignb3V0cHV0LmludGVyb3AnLCBVUkxfT1VUUFVUX0lOVEVST1AsIGB1c2Ugb25lIG9mICR7QXJyYXkuZnJvbShBTExPV0VEX0lOVEVST1BfVFlQRVMsIHZhbHVlID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSkuam9pbignLCAnKX1gLCBpbnRlcm9wKSk7XG4gICAgfVxuICAgIHJldHVybiBpbnRlcm9wO1xufTtcbmNvbnN0IGdldE1hbnVhbENodW5rcyA9IChjb25maWcsIGlubGluZUR5bmFtaWNJbXBvcnRzLCBwcmVzZXJ2ZU1vZHVsZXMpID0+IHtcbiAgICBjb25zdCBjb25maWdNYW51YWxDaHVua3MgPSBjb25maWcubWFudWFsQ2h1bmtzO1xuICAgIGlmIChjb25maWdNYW51YWxDaHVua3MpIHtcbiAgICAgICAgaWYgKGlubGluZUR5bmFtaWNJbXBvcnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IobG9nSW52YWxpZE9wdGlvbignb3V0cHV0Lm1hbnVhbENodW5rcycsIFVSTF9PVVRQVVRfTUFOVUFMQ0hVTktTLCAndGhpcyBvcHRpb24gaXMgbm90IHN1cHBvcnRlZCBmb3IgXCJvdXRwdXQuaW5saW5lRHluYW1pY0ltcG9ydHNcIicpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlc2VydmVNb2R1bGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IobG9nSW52YWxpZE9wdGlvbignb3V0cHV0Lm1hbnVhbENodW5rcycsIFVSTF9PVVRQVVRfTUFOVUFMQ0hVTktTLCAndGhpcyBvcHRpb24gaXMgbm90IHN1cHBvcnRlZCBmb3IgXCJvdXRwdXQucHJlc2VydmVNb2R1bGVzXCInKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZ01hbnVhbENodW5rcyB8fCB7fTtcbn07XG5jb25zdCBnZXRNaW5pZnlJbnRlcm5hbEV4cG9ydHMgPSAoY29uZmlnLCBmb3JtYXQsIGNvbXBhY3QpID0+IGNvbmZpZy5taW5pZnlJbnRlcm5hbEV4cG9ydHMgPz8gKGNvbXBhY3QgfHwgZm9ybWF0ID09PSAnZXMnIHx8IGZvcm1hdCA9PT0gJ3N5c3RlbScpO1xuY29uc3QgZ2V0U291cmNlbWFwRmlsZU5hbWVzID0gKGNvbmZpZywgdW5zZXRPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgY29uZmlnU291cmNlbWFwRmlsZU5hbWVzID0gY29uZmlnLnNvdXJjZW1hcEZpbGVOYW1lcztcbiAgICBpZiAoY29uZmlnU291cmNlbWFwRmlsZU5hbWVzID09IG51bGwpIHtcbiAgICAgICAgdW5zZXRPcHRpb25zLmFkZCgnc291cmNlbWFwRmlsZU5hbWVzJyk7XG4gICAgfVxuICAgIHJldHVybiBjb25maWdTb3VyY2VtYXBGaWxlTmFtZXM7XG59O1xuY29uc3QgZ2V0U291cmNlbWFwQmFzZVVybCA9IChjb25maWcpID0+IHtcbiAgICBjb25zdCB7IHNvdXJjZW1hcEJhc2VVcmwgfSA9IGNvbmZpZztcbiAgICBpZiAoc291cmNlbWFwQmFzZVVybCkge1xuICAgICAgICBpZiAoaXNWYWxpZFVybChzb3VyY2VtYXBCYXNlVXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFkZFRyYWlsaW5nU2xhc2hJZk1pc3NlZChzb3VyY2VtYXBCYXNlVXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3IobG9nSW52YWxpZE9wdGlvbignb3V0cHV0LnNvdXJjZW1hcEJhc2VVcmwnLCBVUkxfT1VUUFVUX1NPVVJDRU1BUEJBU0VVUkwsIGBtdXN0IGJlIGEgdmFsaWQgVVJMLCByZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KHNvdXJjZW1hcEJhc2VVcmwpfWApKTtcbiAgICB9XG59O1xuXG4vLyBAdHMtZXhwZWN0LWVycm9yIFRTMjU0MDogdGhlIHBvbHlmaWxsIG9mIGBhc3luY0Rpc3Bvc2VgLlxuU3ltYm9sLmFzeW5jRGlzcG9zZSA/Pz0gU3ltYm9sKCdTeW1ib2wuYXN5bmNEaXNwb3NlJyk7XG5mdW5jdGlvbiByb2xsdXAocmF3SW5wdXRPcHRpb25zKSB7XG4gICAgcmV0dXJuIHJvbGx1cEludGVybmFsKHJhd0lucHV0T3B0aW9ucywgbnVsbCk7XG59XG5hc3luYyBmdW5jdGlvbiByb2xsdXBJbnRlcm5hbChyYXdJbnB1dE9wdGlvbnMsIHdhdGNoZXIpIHtcbiAgICBjb25zdCB7IG9wdGlvbnM6IGlucHV0T3B0aW9ucywgdW5zZXRPcHRpb25zOiB1bnNldElucHV0T3B0aW9ucyB9ID0gYXdhaXQgZ2V0SW5wdXRPcHRpb25zKHJhd0lucHV0T3B0aW9ucywgd2F0Y2hlciAhPT0gbnVsbCk7XG4gICAgaW5pdGlhbGlzZVRpbWVycyhpbnB1dE9wdGlvbnMpO1xuICAgIGF3YWl0IGluaXRXYXNtKCk7XG4gICAgY29uc3QgZ3JhcGggPSBuZXcgR3JhcGgoaW5wdXRPcHRpb25zLCB3YXRjaGVyKTtcbiAgICAvLyByZW1vdmUgdGhlIGNhY2hlIG9iamVjdCBmcm9tIHRoZSBtZW1vcnkgYWZ0ZXIgZ3JhcGggY3JlYXRpb24gKGNhY2hlIGlzIG5vdCB1c2VkIGFueW1vcmUpXG4gICAgY29uc3QgdXNlQ2FjaGUgPSByYXdJbnB1dE9wdGlvbnMuY2FjaGUgIT09IGZhbHNlO1xuICAgIGlmIChyYXdJbnB1dE9wdGlvbnMuY2FjaGUpIHtcbiAgICAgICAgaW5wdXRPcHRpb25zLmNhY2hlID0gdW5kZWZpbmVkO1xuICAgICAgICByYXdJbnB1dE9wdGlvbnMuY2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRpbWVTdGFydCgnQlVJTEQnLCAxKTtcbiAgICBhd2FpdCBjYXRjaFVuZmluaXNoZWRIb29rQWN0aW9ucyhncmFwaC5wbHVnaW5Ecml2ZXIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRpbWVTdGFydCgnaW5pdGlhbGl6ZScsIDIpO1xuICAgICAgICAgICAgYXdhaXQgZ3JhcGgucGx1Z2luRHJpdmVyLmhvb2tQYXJhbGxlbCgnYnVpbGRTdGFydCcsIFtpbnB1dE9wdGlvbnNdKTtcbiAgICAgICAgICAgIHRpbWVFbmQoJ2luaXRpYWxpemUnLCAyKTtcbiAgICAgICAgICAgIGF3YWl0IGdyYXBoLmJ1aWxkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yXykge1xuICAgICAgICAgICAgY29uc3Qgd2F0Y2hGaWxlcyA9IE9iamVjdC5rZXlzKGdyYXBoLndhdGNoRmlsZXMpO1xuICAgICAgICAgICAgaWYgKHdhdGNoRmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGVycm9yXy53YXRjaEZpbGVzID0gd2F0Y2hGaWxlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGdyYXBoLnBsdWdpbkRyaXZlci5ob29rUGFyYWxsZWwoJ2J1aWxkRW5kJywgW2Vycm9yX10pO1xuICAgICAgICAgICAgYXdhaXQgZ3JhcGgucGx1Z2luRHJpdmVyLmhvb2tQYXJhbGxlbCgnY2xvc2VCdW5kbGUnLCBbXSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcl87XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZ3JhcGgucGx1Z2luRHJpdmVyLmhvb2tQYXJhbGxlbCgnYnVpbGRFbmQnLCBbXSk7XG4gICAgfSk7XG4gICAgdGltZUVuZCgnQlVJTEQnLCAxKTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGNhY2hlOiB1c2VDYWNoZSA/IGdyYXBoLmdldENhY2hlKCkgOiB1bmRlZmluZWQsXG4gICAgICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5jbG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcmVzdWx0LmNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICBhd2FpdCBncmFwaC5wbHVnaW5Ecml2ZXIuaG9va1BhcmFsbGVsKCdjbG9zZUJ1bmRsZScsIFtdKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2VkOiBmYWxzZSxcbiAgICAgICAgYXN5bmMgW1N5bWJvbC5hc3luY0Rpc3Bvc2VdKCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZW5lcmF0ZShyYXdPdXRwdXRPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmNsb3NlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IobG9nQWxyZWFkeUNsb3NlZCgpKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVHZW5lcmF0ZVdyaXRlKGZhbHNlLCBpbnB1dE9wdGlvbnMsIHVuc2V0SW5wdXRPcHRpb25zLCByYXdPdXRwdXRPcHRpb25zLCBncmFwaCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCB3YXRjaEZpbGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGdyYXBoLndhdGNoRmlsZXMpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyB3cml0ZShyYXdPdXRwdXRPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmNsb3NlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IobG9nQWxyZWFkeUNsb3NlZCgpKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVHZW5lcmF0ZVdyaXRlKHRydWUsIGlucHV0T3B0aW9ucywgdW5zZXRJbnB1dE9wdGlvbnMsIHJhd091dHB1dE9wdGlvbnMsIGdyYXBoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlucHV0T3B0aW9ucy5wZXJmKVxuICAgICAgICByZXN1bHQuZ2V0VGltaW5ncyA9IGdldFRpbWluZ3M7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldElucHV0T3B0aW9ucyhpbml0aWFsSW5wdXRPcHRpb25zLCB3YXRjaE1vZGUpIHtcbiAgICBpZiAoIWluaXRpYWxJbnB1dE9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzdXBwbHkgYW4gb3B0aW9ucyBvYmplY3QgdG8gcm9sbHVwJyk7XG4gICAgfVxuICAgIGNvbnN0IHByb2Nlc3NlZElucHV0T3B0aW9ucyA9IGF3YWl0IGdldFByb2Nlc3NlZElucHV0T3B0aW9ucyhpbml0aWFsSW5wdXRPcHRpb25zLCB3YXRjaE1vZGUpO1xuICAgIGNvbnN0IHsgb3B0aW9ucywgdW5zZXRPcHRpb25zIH0gPSBhd2FpdCBub3JtYWxpemVJbnB1dE9wdGlvbnMocHJvY2Vzc2VkSW5wdXRPcHRpb25zLCB3YXRjaE1vZGUpO1xuICAgIG5vcm1hbGl6ZVBsdWdpbnMob3B0aW9ucy5wbHVnaW5zLCBBTk9OWU1PVVNfUExVR0lOX1BSRUZJWCk7XG4gICAgcmV0dXJuIHsgb3B0aW9ucywgdW5zZXRPcHRpb25zIH07XG59XG5hc3luYyBmdW5jdGlvbiBnZXRQcm9jZXNzZWRJbnB1dE9wdGlvbnMoaW5wdXRPcHRpb25zLCB3YXRjaE1vZGUpIHtcbiAgICBjb25zdCBwbHVnaW5zID0gZ2V0U29ydGVkVmFsaWRhdGVkUGx1Z2lucygnb3B0aW9ucycsIGF3YWl0IG5vcm1hbGl6ZVBsdWdpbk9wdGlvbihpbnB1dE9wdGlvbnMucGx1Z2lucykpO1xuICAgIGNvbnN0IGxvZ0xldmVsID0gaW5wdXRPcHRpb25zLmxvZ0xldmVsIHx8IExPR0xFVkVMX0lORk87XG4gICAgY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKHBsdWdpbnMsIGdldE9uTG9nKGlucHV0T3B0aW9ucywgbG9nTGV2ZWwpLCB3YXRjaE1vZGUsIGxvZ0xldmVsKTtcbiAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgb3B0aW9ucyB9ID0gcGx1Z2luO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gJ2hhbmRsZXInIGluIG9wdGlvbnMgPyBvcHRpb25zLmhhbmRsZXIgOiBvcHRpb25zO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRPcHRpb25zID0gYXdhaXQgaGFuZGxlci5jYWxsKHtcbiAgICAgICAgICAgIGRlYnVnOiBnZXRMb2dIYW5kbGVyKExPR0xFVkVMX0RFQlVHLCAnUExVR0lOX0xPRycsIGxvZ2dlciwgbmFtZSwgbG9nTGV2ZWwpLFxuICAgICAgICAgICAgZXJyb3I6IChlcnJvcl8pID0+IGVycm9yKGxvZ1BsdWdpbkVycm9yKG5vcm1hbGl6ZUxvZyhlcnJvcl8pLCBuYW1lLCB7IGhvb2s6ICdvbkxvZycgfSkpLFxuICAgICAgICAgICAgaW5mbzogZ2V0TG9nSGFuZGxlcihMT0dMRVZFTF9JTkZPLCAnUExVR0lOX0xPRycsIGxvZ2dlciwgbmFtZSwgbG9nTGV2ZWwpLFxuICAgICAgICAgICAgbWV0YTogeyByb2xsdXBWZXJzaW9uOiB2ZXJzaW9uLCB3YXRjaE1vZGUgfSxcbiAgICAgICAgICAgIHdhcm46IGdldExvZ0hhbmRsZXIoTE9HTEVWRUxfV0FSTiwgJ1BMVUdJTl9XQVJOSU5HJywgbG9nZ2VyLCBuYW1lLCBsb2dMZXZlbClcbiAgICAgICAgfSwgaW5wdXRPcHRpb25zKTtcbiAgICAgICAgaWYgKHByb2Nlc3NlZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlucHV0T3B0aW9ucyA9IHByb2Nlc3NlZE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlucHV0T3B0aW9ucztcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBsdWdpbnMocGx1Z2lucywgYW5vbnltb3VzUHJlZml4KSB7XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIHBsdWdpbl0gb2YgcGx1Z2lucy5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKCFwbHVnaW4ubmFtZSkge1xuICAgICAgICAgICAgcGx1Z2luLm5hbWUgPSBgJHthbm9ueW1vdXNQcmVmaXh9JHtpbmRleCArIDF9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZUdlbmVyYXRlV3JpdGUoaXNXcml0ZSwgaW5wdXRPcHRpb25zLCB1bnNldElucHV0T3B0aW9ucywgcmF3T3V0cHV0T3B0aW9ucywgZ3JhcGgpIHtcbiAgICBjb25zdCB7IG9wdGlvbnM6IG91dHB1dE9wdGlvbnMsIG91dHB1dFBsdWdpbkRyaXZlciwgdW5zZXRPcHRpb25zIH0gPSBhd2FpdCBnZXRPdXRwdXRPcHRpb25zQW5kUGx1Z2luRHJpdmVyKHJhd091dHB1dE9wdGlvbnMsIGdyYXBoLnBsdWdpbkRyaXZlciwgaW5wdXRPcHRpb25zLCB1bnNldElucHV0T3B0aW9ucyk7XG4gICAgcmV0dXJuIGNhdGNoVW5maW5pc2hlZEhvb2tBY3Rpb25zKG91dHB1dFBsdWdpbkRyaXZlciwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBidW5kbGUgPSBuZXcgQnVuZGxlKG91dHB1dE9wdGlvbnMsIHVuc2V0T3B0aW9ucywgaW5wdXRPcHRpb25zLCBvdXRwdXRQbHVnaW5Ecml2ZXIsIGdyYXBoKTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVkID0gYXdhaXQgYnVuZGxlLmdlbmVyYXRlKGlzV3JpdGUpO1xuICAgICAgICBpZiAoaXNXcml0ZSkge1xuICAgICAgICAgICAgdGltZVN0YXJ0KCdXUklURScsIDEpO1xuICAgICAgICAgICAgaWYgKCFvdXRwdXRPcHRpb25zLmRpciAmJiAhb3V0cHV0T3B0aW9ucy5maWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGxvZ01pc3NpbmdGaWxlT3JEaXJPcHRpb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QudmFsdWVzKGdlbmVyYXRlZCkubWFwKGNodW5rID0+IGdyYXBoLmZpbGVPcGVyYXRpb25RdWV1ZS5ydW4oKCkgPT4gd3JpdGVPdXRwdXRGaWxlKGNodW5rLCBvdXRwdXRPcHRpb25zKSkpKTtcbiAgICAgICAgICAgIGF3YWl0IG91dHB1dFBsdWdpbkRyaXZlci5ob29rUGFyYWxsZWwoJ3dyaXRlQnVuZGxlJywgW291dHB1dE9wdGlvbnMsIGdlbmVyYXRlZF0pO1xuICAgICAgICAgICAgdGltZUVuZCgnV1JJVEUnLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlT3V0cHV0KGdlbmVyYXRlZCk7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRPdXRwdXRPcHRpb25zQW5kUGx1Z2luRHJpdmVyKHJhd091dHB1dE9wdGlvbnMsIGlucHV0UGx1Z2luRHJpdmVyLCBpbnB1dE9wdGlvbnMsIHVuc2V0SW5wdXRPcHRpb25zKSB7XG4gICAgaWYgKCFyYXdPdXRwdXRPcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3VwcGx5IGFuIG9wdGlvbnMgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHJhd1BsdWdpbnMgPSBhd2FpdCBub3JtYWxpemVQbHVnaW5PcHRpb24ocmF3T3V0cHV0T3B0aW9ucy5wbHVnaW5zKTtcbiAgICBub3JtYWxpemVQbHVnaW5zKHJhd1BsdWdpbnMsIEFOT05ZTU9VU19PVVRQVVRfUExVR0lOX1BSRUZJWCk7XG4gICAgY29uc3Qgb3V0cHV0UGx1Z2luRHJpdmVyID0gaW5wdXRQbHVnaW5Ecml2ZXIuY3JlYXRlT3V0cHV0UGx1Z2luRHJpdmVyKHJhd1BsdWdpbnMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLihhd2FpdCBnZXRPdXRwdXRPcHRpb25zKGlucHV0T3B0aW9ucywgdW5zZXRJbnB1dE9wdGlvbnMsIHJhd091dHB1dE9wdGlvbnMsIG91dHB1dFBsdWdpbkRyaXZlcikpLFxuICAgICAgICBvdXRwdXRQbHVnaW5Ecml2ZXJcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0T3B0aW9ucyhpbnB1dE9wdGlvbnMsIHVuc2V0SW5wdXRPcHRpb25zLCByYXdPdXRwdXRPcHRpb25zLCBvdXRwdXRQbHVnaW5Ecml2ZXIpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplT3V0cHV0T3B0aW9ucyhvdXRwdXRQbHVnaW5Ecml2ZXIuaG9va1JlZHVjZUFyZzBTeW5jKCdvdXRwdXRPcHRpb25zJywgW3Jhd091dHB1dE9wdGlvbnNdLCAob3V0cHV0T3B0aW9ucywgcmVzdWx0KSA9PiByZXN1bHQgfHwgb3V0cHV0T3B0aW9ucywgcGx1Z2luQ29udGV4dCA9PiB7XG4gICAgICAgIGNvbnN0IGVtaXRFcnJvciA9ICgpID0+IHBsdWdpbkNvbnRleHQuZXJyb3IobG9nQ2Fubm90RW1pdEZyb21PcHRpb25zSG9vaygpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnBsdWdpbkNvbnRleHQsXG4gICAgICAgICAgICBlbWl0RmlsZTogZW1pdEVycm9yLFxuICAgICAgICAgICAgc2V0QXNzZXRTb3VyY2U6IGVtaXRFcnJvclxuICAgICAgICB9O1xuICAgIH0pLCBpbnB1dE9wdGlvbnMsIHVuc2V0SW5wdXRPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU91dHB1dChvdXRwdXRCdW5kbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBvdXRwdXQ6IE9iamVjdC52YWx1ZXMob3V0cHV0QnVuZGxlKS5maWx0ZXIob3V0cHV0RmlsZSA9PiBPYmplY3Qua2V5cyhvdXRwdXRGaWxlKS5sZW5ndGggPiAwKS5zb3J0KChvdXRwdXRGaWxlQSwgb3V0cHV0RmlsZUIpID0+IGdldFNvcnRpbmdGaWxlVHlwZShvdXRwdXRGaWxlQSkgLSBnZXRTb3J0aW5nRmlsZVR5cGUob3V0cHV0RmlsZUIpKVxuICAgIH07XG59XG52YXIgU29ydGluZ0ZpbGVUeXBlO1xuKGZ1bmN0aW9uIChTb3J0aW5nRmlsZVR5cGUpIHtcbiAgICBTb3J0aW5nRmlsZVR5cGVbU29ydGluZ0ZpbGVUeXBlW1wiRU5UUllfQ0hVTktcIl0gPSAwXSA9IFwiRU5UUllfQ0hVTktcIjtcbiAgICBTb3J0aW5nRmlsZVR5cGVbU29ydGluZ0ZpbGVUeXBlW1wiU0VDT05EQVJZX0NIVU5LXCJdID0gMV0gPSBcIlNFQ09OREFSWV9DSFVOS1wiO1xuICAgIFNvcnRpbmdGaWxlVHlwZVtTb3J0aW5nRmlsZVR5cGVbXCJBU1NFVFwiXSA9IDJdID0gXCJBU1NFVFwiO1xufSkoU29ydGluZ0ZpbGVUeXBlIHx8IChTb3J0aW5nRmlsZVR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0U29ydGluZ0ZpbGVUeXBlKGZpbGUpIHtcbiAgICBpZiAoZmlsZS50eXBlID09PSAnYXNzZXQnKSB7XG4gICAgICAgIHJldHVybiBTb3J0aW5nRmlsZVR5cGUuQVNTRVQ7XG4gICAgfVxuICAgIGlmIChmaWxlLmlzRW50cnkpIHtcbiAgICAgICAgcmV0dXJuIFNvcnRpbmdGaWxlVHlwZS5FTlRSWV9DSFVOSztcbiAgICB9XG4gICAgcmV0dXJuIFNvcnRpbmdGaWxlVHlwZS5TRUNPTkRBUllfQ0hVTks7XG59XG5hc3luYyBmdW5jdGlvbiB3cml0ZU91dHB1dEZpbGUob3V0cHV0RmlsZSwgb3V0cHV0T3B0aW9ucykge1xuICAgIGNvbnN0IGZpbGVOYW1lID0gcmVzb2x2ZSQxKG91dHB1dE9wdGlvbnMuZGlyIHx8IGRpcm5hbWUob3V0cHV0T3B0aW9ucy5maWxlKSwgb3V0cHV0RmlsZS5maWxlTmFtZSk7XG4gICAgLy8gJ3JlY3Vyc2l2ZTogdHJ1ZScgZG9lcyBub3QgdGhyb3cgaWYgdGhlIGZvbGRlciBzdHJ1Y3R1cmUsIG9yIHBhcnRzIG9mIGl0LCBhbHJlYWR5IGV4aXN0XG4gICAgYXdhaXQgbWtkaXIoZGlybmFtZShmaWxlTmFtZSksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIHJldHVybiB3cml0ZUZpbGUoZmlsZU5hbWUsIG91dHB1dEZpbGUudHlwZSA9PT0gJ2Fzc2V0JyA/IG91dHB1dEZpbGUuc291cmNlIDogb3V0cHV0RmlsZS5jb2RlKTtcbn1cbi8qKlxuICogQXV4aWxpYXJ5IGZ1bmN0aW9uIGZvciBkZWZpbmluZyByb2xsdXAgY29uZmlndXJhdGlvblxuICogTWFpbmx5IHRvIGZhY2lsaXRhdGUgSURFIGNvZGUgcHJvbXB0cywgYWZ0ZXIgYWxsLCBleHBvcnQgZGVmYXVsdCBkb2VzIG5vdFxuICogcHJvbXB0LCBldmVuIGlmIHlvdSBhZGQgQHR5cGUgYW5ub3RhdGlvbnMsIGl0IGlzIG5vdCBhY2N1cmF0ZVxuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQ29uZmlnKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucztcbn1cblxuY29uc3Qge1xuICBlbnYgPSB7fSxcbiAgYXJndiA9IFtdLFxuICBwbGF0Zm9ybSA9IFwiXCIsXG59ID0gdHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIgPyB7fSA6IHByb2Nlc3M7XG5cbmNvbnN0IGlzRGlzYWJsZWQgPSBcIk5PX0NPTE9SXCIgaW4gZW52IHx8IGFyZ3YuaW5jbHVkZXMoXCItLW5vLWNvbG9yXCIpO1xuY29uc3QgaXNGb3JjZWQgPSBcIkZPUkNFX0NPTE9SXCIgaW4gZW52IHx8IGFyZ3YuaW5jbHVkZXMoXCItLWNvbG9yXCIpO1xuY29uc3QgaXNXaW5kb3dzID0gcGxhdGZvcm0gPT09IFwid2luMzJcIjtcbmNvbnN0IGlzRHVtYlRlcm1pbmFsID0gZW52LlRFUk0gPT09IFwiZHVtYlwiO1xuXG5jb25zdCBpc0NvbXBhdGlibGVUZXJtaW5hbCA9XG4gIHR0eSAmJiB0dHkuaXNhdHR5ICYmIHR0eS5pc2F0dHkoMSkgJiYgZW52LlRFUk0gJiYgIWlzRHVtYlRlcm1pbmFsO1xuXG5jb25zdCBpc0NJID1cbiAgXCJDSVwiIGluIGVudiAmJlxuICAoXCJHSVRIVUJfQUNUSU9OU1wiIGluIGVudiB8fCBcIkdJVExBQl9DSVwiIGluIGVudiB8fCBcIkNJUkNMRUNJXCIgaW4gZW52KTtcblxuY29uc3QgaXNDb2xvclN1cHBvcnRlZCA9XG4gICFpc0Rpc2FibGVkICYmXG4gIChpc0ZvcmNlZCB8fCAoaXNXaW5kb3dzICYmICFpc0R1bWJUZXJtaW5hbCkgfHwgaXNDb21wYXRpYmxlVGVybWluYWwgfHwgaXNDSSk7XG5cbmNvbnN0IHJlcGxhY2VDbG9zZSA9IChcbiAgaW5kZXgsXG4gIHN0cmluZyxcbiAgY2xvc2UsXG4gIHJlcGxhY2UsXG4gIGhlYWQgPSBzdHJpbmcuc3Vic3RyaW5nKDAsIGluZGV4KSArIHJlcGxhY2UsXG4gIHRhaWwgPSBzdHJpbmcuc3Vic3RyaW5nKGluZGV4ICsgY2xvc2UubGVuZ3RoKSxcbiAgbmV4dCA9IHRhaWwuaW5kZXhPZihjbG9zZSlcbikgPT4gaGVhZCArIChuZXh0IDwgMCA/IHRhaWwgOiByZXBsYWNlQ2xvc2UobmV4dCwgdGFpbCwgY2xvc2UsIHJlcGxhY2UpKTtcblxuY29uc3QgY2xlYXJCbGVlZCA9IChpbmRleCwgc3RyaW5nLCBvcGVuLCBjbG9zZSwgcmVwbGFjZSkgPT5cbiAgaW5kZXggPCAwXG4gICAgPyBvcGVuICsgc3RyaW5nICsgY2xvc2VcbiAgICA6IG9wZW4gKyByZXBsYWNlQ2xvc2UoaW5kZXgsIHN0cmluZywgY2xvc2UsIHJlcGxhY2UpICsgY2xvc2U7XG5cbmNvbnN0IGZpbHRlckVtcHR5ID1cbiAgKG9wZW4sIGNsb3NlLCByZXBsYWNlID0gb3BlbiwgYXQgPSBvcGVuLmxlbmd0aCArIDEpID0+XG4gIChzdHJpbmcpID0+XG4gICAgc3RyaW5nIHx8ICEoc3RyaW5nID09PSBcIlwiIHx8IHN0cmluZyA9PT0gdW5kZWZpbmVkKVxuICAgICAgPyBjbGVhckJsZWVkKFxuICAgICAgICAgIChcIlwiICsgc3RyaW5nKS5pbmRleE9mKGNsb3NlLCBhdCksXG4gICAgICAgICAgc3RyaW5nLFxuICAgICAgICAgIG9wZW4sXG4gICAgICAgICAgY2xvc2UsXG4gICAgICAgICAgcmVwbGFjZVxuICAgICAgICApXG4gICAgICA6IFwiXCI7XG5cbmNvbnN0IGluaXQgPSAob3BlbiwgY2xvc2UsIHJlcGxhY2UpID0+XG4gIGZpbHRlckVtcHR5KGBcXHgxYlske29wZW59bWAsIGBcXHgxYlske2Nsb3NlfW1gLCByZXBsYWNlKTtcblxuY29uc3QgY29sb3JzID0ge1xuICByZXNldDogaW5pdCgwLCAwKSxcbiAgYm9sZDogaW5pdCgxLCAyMiwgXCJcXHgxYlsyMm1cXHgxYlsxbVwiKSxcbiAgZGltOiBpbml0KDIsIDIyLCBcIlxceDFiWzIybVxceDFiWzJtXCIpLFxuICBpdGFsaWM6IGluaXQoMywgMjMpLFxuICB1bmRlcmxpbmU6IGluaXQoNCwgMjQpLFxuICBpbnZlcnNlOiBpbml0KDcsIDI3KSxcbiAgaGlkZGVuOiBpbml0KDgsIDI4KSxcbiAgc3RyaWtldGhyb3VnaDogaW5pdCg5LCAyOSksXG4gIGJsYWNrOiBpbml0KDMwLCAzOSksXG4gIHJlZDogaW5pdCgzMSwgMzkpLFxuICBncmVlbjogaW5pdCgzMiwgMzkpLFxuICB5ZWxsb3c6IGluaXQoMzMsIDM5KSxcbiAgYmx1ZTogaW5pdCgzNCwgMzkpLFxuICBtYWdlbnRhOiBpbml0KDM1LCAzOSksXG4gIGN5YW46IGluaXQoMzYsIDM5KSxcbiAgd2hpdGU6IGluaXQoMzcsIDM5KSxcbiAgZ3JheTogaW5pdCg5MCwgMzkpLFxuICBiZ0JsYWNrOiBpbml0KDQwLCA0OSksXG4gIGJnUmVkOiBpbml0KDQxLCA0OSksXG4gIGJnR3JlZW46IGluaXQoNDIsIDQ5KSxcbiAgYmdZZWxsb3c6IGluaXQoNDMsIDQ5KSxcbiAgYmdCbHVlOiBpbml0KDQ0LCA0OSksXG4gIGJnTWFnZW50YTogaW5pdCg0NSwgNDkpLFxuICBiZ0N5YW46IGluaXQoNDYsIDQ5KSxcbiAgYmdXaGl0ZTogaW5pdCg0NywgNDkpLFxuICBibGFja0JyaWdodDogaW5pdCg5MCwgMzkpLFxuICByZWRCcmlnaHQ6IGluaXQoOTEsIDM5KSxcbiAgZ3JlZW5CcmlnaHQ6IGluaXQoOTIsIDM5KSxcbiAgeWVsbG93QnJpZ2h0OiBpbml0KDkzLCAzOSksXG4gIGJsdWVCcmlnaHQ6IGluaXQoOTQsIDM5KSxcbiAgbWFnZW50YUJyaWdodDogaW5pdCg5NSwgMzkpLFxuICBjeWFuQnJpZ2h0OiBpbml0KDk2LCAzOSksXG4gIHdoaXRlQnJpZ2h0OiBpbml0KDk3LCAzOSksXG4gIGJnQmxhY2tCcmlnaHQ6IGluaXQoMTAwLCA0OSksXG4gIGJnUmVkQnJpZ2h0OiBpbml0KDEwMSwgNDkpLFxuICBiZ0dyZWVuQnJpZ2h0OiBpbml0KDEwMiwgNDkpLFxuICBiZ1llbGxvd0JyaWdodDogaW5pdCgxMDMsIDQ5KSxcbiAgYmdCbHVlQnJpZ2h0OiBpbml0KDEwNCwgNDkpLFxuICBiZ01hZ2VudGFCcmlnaHQ6IGluaXQoMTA1LCA0OSksXG4gIGJnQ3lhbkJyaWdodDogaW5pdCgxMDYsIDQ5KSxcbiAgYmdXaGl0ZUJyaWdodDogaW5pdCgxMDcsIDQ5KSxcbn07XG5cbmNvbnN0IGNyZWF0ZUNvbG9ycyA9ICh7IHVzZUNvbG9yID0gaXNDb2xvclN1cHBvcnRlZCB9ID0ge30pID0+XG4gIHVzZUNvbG9yXG4gICAgPyBjb2xvcnNcbiAgICA6IE9iamVjdC5rZXlzKGNvbG9ycykucmVkdWNlKFxuICAgICAgICAoY29sb3JzLCBrZXkpID0+ICh7IC4uLmNvbG9ycywgW2tleV06IFN0cmluZyB9KSxcbiAgICAgICAge31cbiAgICAgICk7XG5cbmNyZWF0ZUNvbG9ycygpO1xuXG4vLyBAc2VlIGh0dHBzOi8vbm8tY29sb3Iub3JnXG4vLyBAc2VlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2NoYWxrXG5jb25zdCB7IGJvbGQsIGN5YW4sIGRpbSwgZ3JheSwgZ3JlZW4sIHJlZCwgdW5kZXJsaW5lLCB5ZWxsb3cgfSA9IGNyZWF0ZUNvbG9ycyh7XG4gICAgdXNlQ29sb3I6IGVudiQxLkZPUkNFX0NPTE9SICE9PSAnMCcgJiYgIWVudiQxLk5PX0NPTE9SXG59KTtcblxuLy8gbG9nIHRvIHN0ZGVyciB0byBrZWVwIGByb2xsdXAgbWFpbi5qcyA+IGJ1bmRsZS5qc2AgZnJvbSBicmVha2luZ1xuY29uc3Qgc3RkZXJyID0gKC4uLnBhcmFtZXRlcnMpID0+IHByb2Nlc3MkMS5zdGRlcnIud3JpdGUoYCR7cGFyYW1ldGVycy5qb2luKCcnKX1cXG5gKTtcbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yLCByZWNvdmVyID0gZmFsc2UpIHtcbiAgICBjb25zdCBuYW1lID0gZXJyb3IubmFtZSB8fCBlcnJvci5jYXVzZT8ubmFtZTtcbiAgICBjb25zdCBuYW1lU2VjdGlvbiA9IG5hbWUgPyBgJHtuYW1lfTogYCA6ICcnO1xuICAgIGNvbnN0IHBsdWdpblNlY3Rpb24gPSBlcnJvci5wbHVnaW4gPyBgKHBsdWdpbiAke2Vycm9yLnBsdWdpbn0pIGAgOiAnJztcbiAgICBjb25zdCBtZXNzYWdlID0gYCR7cGx1Z2luU2VjdGlvbn0ke25hbWVTZWN0aW9ufSR7ZXJyb3IubWVzc2FnZX1gO1xuICAgIGNvbnN0IG91dHB1dExpbmVzID0gW2JvbGQocmVkKGBbIV0gJHtib2xkKG1lc3NhZ2UudG9TdHJpbmcoKSl9YCkpXTtcbiAgICBpZiAoZXJyb3IudXJsKSB7XG4gICAgICAgIG91dHB1dExpbmVzLnB1c2goY3lhbihlcnJvci51cmwpKTtcbiAgICB9XG4gICAgaWYgKGVycm9yLmxvYykge1xuICAgICAgICBvdXRwdXRMaW5lcy5wdXNoKGAke3JlbGF0aXZlSWQoKGVycm9yLmxvYy5maWxlIHx8IGVycm9yLmlkKSl9ICgke2Vycm9yLmxvYy5saW5lfToke2Vycm9yLmxvYy5jb2x1bW59KWApO1xuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5pZCkge1xuICAgICAgICBvdXRwdXRMaW5lcy5wdXNoKHJlbGF0aXZlSWQoZXJyb3IuaWQpKTtcbiAgICB9XG4gICAgaWYgKGVycm9yLmZyYW1lKSB7XG4gICAgICAgIG91dHB1dExpbmVzLnB1c2goZGltKGVycm9yLmZyYW1lKSk7XG4gICAgfVxuICAgIGlmIChlcnJvci5zdGFjaykge1xuICAgICAgICBvdXRwdXRMaW5lcy5wdXNoKGRpbShlcnJvci5zdGFjaz8ucmVwbGFjZShgJHtuYW1lU2VjdGlvbn0ke2Vycm9yLm1lc3NhZ2V9XFxuYCwgJycpKSk7XG4gICAgfVxuICAgIC8vIEVTMjAyMjogRXJyb3IucHJvdG90eXBlLmNhdXNlIGlzIG9wdGlvbmFsXG4gICAgaWYgKGVycm9yLmNhdXNlKSB7XG4gICAgICAgIGxldCBjYXVzZSA9IGVycm9yLmNhdXNlO1xuICAgICAgICBjb25zdCBjYXVzZUVycm9yTGluZXMgPSBbXTtcbiAgICAgICAgbGV0IGluZGVudCA9ICcnO1xuICAgICAgICB3aGlsZSAoY2F1c2UpIHtcbiAgICAgICAgICAgIGluZGVudCArPSAnICAnO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNhdXNlLnN0YWNrIHx8IGNhdXNlO1xuICAgICAgICAgICAgY2F1c2VFcnJvckxpbmVzLnB1c2goLi4uYFtjYXVzZV0gJHttZXNzYWdlfWAuc3BsaXQoJ1xcbicpLm1hcChsaW5lID0+IGluZGVudCArIGxpbmUpKTtcbiAgICAgICAgICAgIGNhdXNlID0gY2F1c2UuY2F1c2U7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0TGluZXMucHVzaChkaW0oY2F1c2VFcnJvckxpbmVzLmpvaW4oJ1xcbicpKSk7XG4gICAgfVxuICAgIG91dHB1dExpbmVzLnB1c2goJycsICcnKTtcbiAgICBzdGRlcnIob3V0cHV0TGluZXMuam9pbignXFxuJykpO1xuICAgIGlmICghcmVjb3ZlcilcbiAgICAgICAgcHJvY2VzcyQxLmV4aXQoMSk7XG59XG5cbmNvbnN0IGNvbW1hbmRBbGlhc2VzID0ge1xuICAgIGM6ICdjb25maWcnLFxuICAgIGQ6ICdkaXInLFxuICAgIGU6ICdleHRlcm5hbCcsXG4gICAgZjogJ2Zvcm1hdCcsXG4gICAgZzogJ2dsb2JhbHMnLFxuICAgIGg6ICdoZWxwJyxcbiAgICBpOiAnaW5wdXQnLFxuICAgIG06ICdzb3VyY2VtYXAnLFxuICAgIG46ICduYW1lJyxcbiAgICBvOiAnZmlsZScsXG4gICAgcDogJ3BsdWdpbicsXG4gICAgdjogJ3ZlcnNpb24nLFxuICAgIHc6ICd3YXRjaCdcbn07XG5jb25zdCBFTVBUWV9DT01NQU5EX09QVElPTlMgPSB7IGV4dGVybmFsOiBbXSwgZ2xvYmFsczogdW5kZWZpbmVkIH07XG5hc3luYyBmdW5jdGlvbiBtZXJnZU9wdGlvbnMoY29uZmlnLCB3YXRjaE1vZGUsIHJhd0NvbW1hbmRPcHRpb25zID0gRU1QVFlfQ09NTUFORF9PUFRJT05TLCBwcmludExvZykge1xuICAgIGNvbnN0IGNvbW1hbmQgPSBnZXRDb21tYW5kT3B0aW9ucyhyYXdDb21tYW5kT3B0aW9ucyk7XG4gICAgY29uc3QgcGx1Z2lucyA9IGF3YWl0IG5vcm1hbGl6ZVBsdWdpbk9wdGlvbihjb25maWcucGx1Z2lucyk7XG4gICAgY29uc3QgbG9nTGV2ZWwgPSBjb25maWcubG9nTGV2ZWwgfHwgTE9HTEVWRUxfSU5GTztcbiAgICBjb25zdCBvbkxvZyA9IGdldE9uTG9nKGNvbmZpZywgbG9nTGV2ZWwsIHByaW50TG9nKTtcbiAgICBjb25zdCBsb2cgPSBnZXRMb2dnZXIocGx1Z2lucywgb25Mb2csIHdhdGNoTW9kZSwgbG9nTGV2ZWwpO1xuICAgIGNvbnN0IGlucHV0T3B0aW9ucyA9IG1lcmdlSW5wdXRPcHRpb25zKGNvbmZpZywgY29tbWFuZCwgcGx1Z2lucywgbG9nLCBvbkxvZyk7XG4gICAgaWYgKGNvbW1hbmQub3V0cHV0KSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29tbWFuZCwgY29tbWFuZC5vdXRwdXQpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXRPcHRpb25zQXJyYXkgPSBlbnN1cmVBcnJheShjb25maWcub3V0cHV0KTtcbiAgICBpZiAob3V0cHV0T3B0aW9uc0FycmF5Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgb3V0cHV0T3B0aW9uc0FycmF5LnB1c2goe30pO1xuICAgIGNvbnN0IG91dHB1dE9wdGlvbnMgPSBhd2FpdCBQcm9taXNlLmFsbChvdXRwdXRPcHRpb25zQXJyYXkubWFwKHNpbmdsZU91dHB1dE9wdGlvbnMgPT4gbWVyZ2VPdXRwdXRPcHRpb25zKHNpbmdsZU91dHB1dE9wdGlvbnMsIGNvbW1hbmQsIGxvZykpKTtcbiAgICB3YXJuVW5rbm93bk9wdGlvbnMoY29tbWFuZCwgW1xuICAgICAgICAuLi5PYmplY3Qua2V5cyhpbnB1dE9wdGlvbnMpLFxuICAgICAgICAuLi5PYmplY3Qua2V5cyhvdXRwdXRPcHRpb25zWzBdKS5maWx0ZXIob3B0aW9uID0+IG9wdGlvbiAhPT0gJ3NvdXJjZW1hcElnbm9yZUxpc3QnICYmIG9wdGlvbiAhPT0gJ3NvdXJjZW1hcFBhdGhUcmFuc2Zvcm0nKSxcbiAgICAgICAgLi4uT2JqZWN0LmtleXMoY29tbWFuZEFsaWFzZXMpLFxuICAgICAgICAnYnVuZGxlQ29uZmlnQXNDanMnLFxuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ2NvbmZpZ1BsdWdpbicsXG4gICAgICAgICdlbnZpcm9ubWVudCcsXG4gICAgICAgICdmYWlsQWZ0ZXJXYXJuaW5ncycsXG4gICAgICAgICdmaWx0ZXJMb2dzJyxcbiAgICAgICAgJ2ZvcmNlRXhpdCcsXG4gICAgICAgICdwbHVnaW4nLFxuICAgICAgICAnc2lsZW50JyxcbiAgICAgICAgJ3N0ZGluJyxcbiAgICAgICAgJ3dhaXRGb3JCdW5kbGVJbnB1dCdcbiAgICBdLCAnQ0xJIGZsYWdzJywgbG9nLCAvXl8kfG91dHB1dCR8Y29uZmlnLyk7XG4gICAgaW5wdXRPcHRpb25zLm91dHB1dCA9IG91dHB1dE9wdGlvbnM7XG4gICAgcmV0dXJuIGlucHV0T3B0aW9ucztcbn1cbmZ1bmN0aW9uIGdldENvbW1hbmRPcHRpb25zKHJhd0NvbW1hbmRPcHRpb25zKSB7XG4gICAgY29uc3QgZXh0ZXJuYWwgPSByYXdDb21tYW5kT3B0aW9ucy5leHRlcm5hbCAmJiB0eXBlb2YgcmF3Q29tbWFuZE9wdGlvbnMuZXh0ZXJuYWwgPT09ICdzdHJpbmcnXG4gICAgICAgID8gcmF3Q29tbWFuZE9wdGlvbnMuZXh0ZXJuYWwuc3BsaXQoJywnKVxuICAgICAgICA6IFtdO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJhd0NvbW1hbmRPcHRpb25zLFxuICAgICAgICBleHRlcm5hbCxcbiAgICAgICAgZ2xvYmFsczogdHlwZW9mIHJhd0NvbW1hbmRPcHRpb25zLmdsb2JhbHMgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IHJhd0NvbW1hbmRPcHRpb25zLmdsb2JhbHMuc3BsaXQoJywnKS5yZWR1Y2UoKGdsb2JhbHMsIGdsb2JhbERlZmluaXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbaWQsIHZhcmlhYmxlTmFtZV0gPSBnbG9iYWxEZWZpbml0aW9uLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgZ2xvYmFsc1tpZF0gPSB2YXJpYWJsZU5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCFleHRlcm5hbC5pbmNsdWRlcyhpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWwucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBnbG9iYWxzO1xuICAgICAgICAgICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlSW5wdXRPcHRpb25zKGNvbmZpZywgb3ZlcnJpZGVzLCBwbHVnaW5zLCBsb2csIG9uTG9nKSB7XG4gICAgY29uc3QgZ2V0T3B0aW9uID0gKG5hbWUpID0+IG92ZXJyaWRlc1tuYW1lXSA/PyBjb25maWdbbmFtZV07XG4gICAgY29uc3QgaW5wdXRPcHRpb25zID0ge1xuICAgICAgICBjYWNoZTogY29uZmlnLmNhY2hlLFxuICAgICAgICBjb250ZXh0OiBnZXRPcHRpb24oJ2NvbnRleHQnKSxcbiAgICAgICAgZXhwZXJpbWVudGFsQ2FjaGVFeHBpcnk6IGdldE9wdGlvbignZXhwZXJpbWVudGFsQ2FjaGVFeHBpcnknKSxcbiAgICAgICAgZXhwZXJpbWVudGFsTG9nU2lkZUVmZmVjdHM6IGdldE9wdGlvbignZXhwZXJpbWVudGFsTG9nU2lkZUVmZmVjdHMnKSxcbiAgICAgICAgZXh0ZXJuYWw6IGdldEV4dGVybmFsKGNvbmZpZywgb3ZlcnJpZGVzKSxcbiAgICAgICAgaW5wdXQ6IGdldE9wdGlvbignaW5wdXQnKSB8fCBbXSxcbiAgICAgICAganN4OiBnZXRPYmplY3RPcHRpb24oY29uZmlnLCBvdmVycmlkZXMsICdqc3gnLCBvYmplY3RpZnlPcHRpb25XaXRoUHJlc2V0cyhqc3hQcmVzZXRzLCAnanN4JywgVVJMX0pTWCwgJ2ZhbHNlLCAnKSksXG4gICAgICAgIGxvZ0xldmVsOiBnZXRPcHRpb24oJ2xvZ0xldmVsJyksXG4gICAgICAgIG1ha2VBYnNvbHV0ZUV4dGVybmFsc1JlbGF0aXZlOiBnZXRPcHRpb24oJ21ha2VBYnNvbHV0ZUV4dGVybmFsc1JlbGF0aXZlJyksXG4gICAgICAgIG1heFBhcmFsbGVsRmlsZU9wczogZ2V0T3B0aW9uKCdtYXhQYXJhbGxlbEZpbGVPcHMnKSxcbiAgICAgICAgbW9kdWxlQ29udGV4dDogZ2V0T3B0aW9uKCdtb2R1bGVDb250ZXh0JyksXG4gICAgICAgIG9uTG9nLFxuICAgICAgICBvbndhcm46IHVuZGVmaW5lZCxcbiAgICAgICAgcGVyZjogZ2V0T3B0aW9uKCdwZXJmJyksXG4gICAgICAgIHBsdWdpbnMsXG4gICAgICAgIHByZXNlcnZlRW50cnlTaWduYXR1cmVzOiBnZXRPcHRpb24oJ3ByZXNlcnZlRW50cnlTaWduYXR1cmVzJyksXG4gICAgICAgIHByZXNlcnZlU3ltbGlua3M6IGdldE9wdGlvbigncHJlc2VydmVTeW1saW5rcycpLFxuICAgICAgICBzaGltTWlzc2luZ0V4cG9ydHM6IGdldE9wdGlvbignc2hpbU1pc3NpbmdFeHBvcnRzJyksXG4gICAgICAgIHN0cmljdERlcHJlY2F0aW9uczogZ2V0T3B0aW9uKCdzdHJpY3REZXByZWNhdGlvbnMnKSxcbiAgICAgICAgdHJlZXNoYWtlOiBnZXRPYmplY3RPcHRpb24oY29uZmlnLCBvdmVycmlkZXMsICd0cmVlc2hha2UnLCBvYmplY3RpZnlPcHRpb25XaXRoUHJlc2V0cyh0cmVlc2hha2VQcmVzZXRzLCAndHJlZXNoYWtlJywgVVJMX1RSRUVTSEFLRSwgJ2ZhbHNlLCB0cnVlLCAnKSksXG4gICAgICAgIHdhdGNoOiBnZXRXYXRjaChjb25maWcsIG92ZXJyaWRlcylcbiAgICB9O1xuICAgIHdhcm5Vbmtub3duT3B0aW9ucyhjb25maWcsIE9iamVjdC5rZXlzKGlucHV0T3B0aW9ucyksICdpbnB1dCBvcHRpb25zJywgbG9nLCAvXm91dHB1dCQvKTtcbiAgICByZXR1cm4gaW5wdXRPcHRpb25zO1xufVxuY29uc3QgZ2V0RXh0ZXJuYWwgPSAoY29uZmlnLCBvdmVycmlkZXMpID0+IHtcbiAgICBjb25zdCBjb25maWdFeHRlcm5hbCA9IGNvbmZpZy5leHRlcm5hbDtcbiAgICByZXR1cm4gdHlwZW9mIGNvbmZpZ0V4dGVybmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gKHNvdXJjZSwgaW1wb3J0ZXIsIGlzUmVzb2x2ZWQpID0+IGNvbmZpZ0V4dGVybmFsKHNvdXJjZSwgaW1wb3J0ZXIsIGlzUmVzb2x2ZWQpIHx8IG92ZXJyaWRlcy5leHRlcm5hbC5pbmNsdWRlcyhzb3VyY2UpXG4gICAgICAgIDogWy4uLmVuc3VyZUFycmF5KGNvbmZpZ0V4dGVybmFsKSwgLi4ub3ZlcnJpZGVzLmV4dGVybmFsXTtcbn07XG5jb25zdCBnZXRPYmplY3RPcHRpb24gPSAoY29uZmlnLCBvdmVycmlkZXMsIG5hbWUsIG9iamVjdGlmeVZhbHVlID0gb2JqZWN0aWZ5T3B0aW9uKSA9PiB7XG4gICAgY29uc3QgY29tbWFuZE9wdGlvbiA9IG5vcm1hbGl6ZU9iamVjdE9wdGlvblZhbHVlKG92ZXJyaWRlc1tuYW1lXSwgb2JqZWN0aWZ5VmFsdWUpO1xuICAgIGNvbnN0IGNvbmZpZ09wdGlvbiA9IG5vcm1hbGl6ZU9iamVjdE9wdGlvblZhbHVlKGNvbmZpZ1tuYW1lXSwgb2JqZWN0aWZ5VmFsdWUpO1xuICAgIGlmIChjb21tYW5kT3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRPcHRpb24gJiYgeyAuLi5jb25maWdPcHRpb24sIC4uLmNvbW1hbmRPcHRpb24gfTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZ09wdGlvbjtcbn07XG5jb25zdCBnZXRXYXRjaCA9IChjb25maWcsIG92ZXJyaWRlcykgPT4gY29uZmlnLndhdGNoICE9PSBmYWxzZSAmJiBnZXRPYmplY3RPcHRpb24oY29uZmlnLCBvdmVycmlkZXMsICd3YXRjaCcpO1xuY29uc3Qgbm9ybWFsaXplT2JqZWN0T3B0aW9uVmFsdWUgPSAob3B0aW9uVmFsdWUsIG9iamVjdGlmeVZhbHVlKSA9PiB7XG4gICAgaWYgKCFvcHRpb25WYWx1ZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9uVmFsdWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvblZhbHVlKSkge1xuICAgICAgICByZXR1cm4gb3B0aW9uVmFsdWUucmVkdWNlKChyZXN1bHQsIHZhbHVlKSA9PiB2YWx1ZSAmJiByZXN1bHQgJiYgeyAuLi5yZXN1bHQsIC4uLm9iamVjdGlmeVZhbHVlKHZhbHVlKSB9LCB7fSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RpZnlWYWx1ZShvcHRpb25WYWx1ZSk7XG59O1xuYXN5bmMgZnVuY3Rpb24gbWVyZ2VPdXRwdXRPcHRpb25zKGNvbmZpZywgb3ZlcnJpZGVzLCBsb2cpIHtcbiAgICBjb25zdCBnZXRPcHRpb24gPSAobmFtZSkgPT4gb3ZlcnJpZGVzW25hbWVdID8/IGNvbmZpZ1tuYW1lXTtcbiAgICBjb25zdCBvdXRwdXRPcHRpb25zID0ge1xuICAgICAgICBhbWQ6IGdldE9iamVjdE9wdGlvbihjb25maWcsIG92ZXJyaWRlcywgJ2FtZCcpLFxuICAgICAgICBhc3NldEZpbGVOYW1lczogZ2V0T3B0aW9uKCdhc3NldEZpbGVOYW1lcycpLFxuICAgICAgICBiYW5uZXI6IGdldE9wdGlvbignYmFubmVyJyksXG4gICAgICAgIGNodW5rRmlsZU5hbWVzOiBnZXRPcHRpb24oJ2NodW5rRmlsZU5hbWVzJyksXG4gICAgICAgIGNvbXBhY3Q6IGdldE9wdGlvbignY29tcGFjdCcpLFxuICAgICAgICBkaXI6IGdldE9wdGlvbignZGlyJyksXG4gICAgICAgIGR5bmFtaWNJbXBvcnRJbkNqczogZ2V0T3B0aW9uKCdkeW5hbWljSW1wb3J0SW5DanMnKSxcbiAgICAgICAgZW50cnlGaWxlTmFtZXM6IGdldE9wdGlvbignZW50cnlGaWxlTmFtZXMnKSxcbiAgICAgICAgZXNNb2R1bGU6IGdldE9wdGlvbignZXNNb2R1bGUnKSxcbiAgICAgICAgZXhwZXJpbWVudGFsTWluQ2h1bmtTaXplOiBnZXRPcHRpb24oJ2V4cGVyaW1lbnRhbE1pbkNodW5rU2l6ZScpLFxuICAgICAgICBleHBvcnRzOiBnZXRPcHRpb24oJ2V4cG9ydHMnKSxcbiAgICAgICAgZXh0ZW5kOiBnZXRPcHRpb24oJ2V4dGVuZCcpLFxuICAgICAgICBleHRlcm5hbEltcG9ydEFzc2VydGlvbnM6IGdldE9wdGlvbignZXh0ZXJuYWxJbXBvcnRBc3NlcnRpb25zJyksXG4gICAgICAgIGV4dGVybmFsSW1wb3J0QXR0cmlidXRlczogZ2V0T3B0aW9uKCdleHRlcm5hbEltcG9ydEF0dHJpYnV0ZXMnKSxcbiAgICAgICAgZXh0ZXJuYWxMaXZlQmluZGluZ3M6IGdldE9wdGlvbignZXh0ZXJuYWxMaXZlQmluZGluZ3MnKSxcbiAgICAgICAgZmlsZTogZ2V0T3B0aW9uKCdmaWxlJyksXG4gICAgICAgIGZvb3RlcjogZ2V0T3B0aW9uKCdmb290ZXInKSxcbiAgICAgICAgZm9ybWF0OiBnZXRPcHRpb24oJ2Zvcm1hdCcpLFxuICAgICAgICBmcmVlemU6IGdldE9wdGlvbignZnJlZXplJyksXG4gICAgICAgIGdlbmVyYXRlZENvZGU6IGdldE9iamVjdE9wdGlvbihjb25maWcsIG92ZXJyaWRlcywgJ2dlbmVyYXRlZENvZGUnLCBvYmplY3RpZnlPcHRpb25XaXRoUHJlc2V0cyhnZW5lcmF0ZWRDb2RlUHJlc2V0cywgJ291dHB1dC5nZW5lcmF0ZWRDb2RlJywgVVJMX09VVFBVVF9HRU5FUkFURURDT0RFLCAnJykpLFxuICAgICAgICBnbG9iYWxzOiBnZXRPcHRpb24oJ2dsb2JhbHMnKSxcbiAgICAgICAgaGFzaENoYXJhY3RlcnM6IGdldE9wdGlvbignaGFzaENoYXJhY3RlcnMnKSxcbiAgICAgICAgaG9pc3RUcmFuc2l0aXZlSW1wb3J0czogZ2V0T3B0aW9uKCdob2lzdFRyYW5zaXRpdmVJbXBvcnRzJyksXG4gICAgICAgIGltcG9ydEF0dHJpYnV0ZXNLZXk6IGdldE9wdGlvbignaW1wb3J0QXR0cmlidXRlc0tleScpLFxuICAgICAgICBpbmRlbnQ6IGdldE9wdGlvbignaW5kZW50JyksXG4gICAgICAgIGlubGluZUR5bmFtaWNJbXBvcnRzOiBnZXRPcHRpb24oJ2lubGluZUR5bmFtaWNJbXBvcnRzJyksXG4gICAgICAgIGludGVyb3A6IGdldE9wdGlvbignaW50ZXJvcCcpLFxuICAgICAgICBpbnRybzogZ2V0T3B0aW9uKCdpbnRybycpLFxuICAgICAgICBtYW51YWxDaHVua3M6IGdldE9wdGlvbignbWFudWFsQ2h1bmtzJyksXG4gICAgICAgIG1pbmlmeUludGVybmFsRXhwb3J0czogZ2V0T3B0aW9uKCdtaW5pZnlJbnRlcm5hbEV4cG9ydHMnKSxcbiAgICAgICAgbmFtZTogZ2V0T3B0aW9uKCduYW1lJyksXG4gICAgICAgIG5vQ29uZmxpY3Q6IGdldE9wdGlvbignbm9Db25mbGljdCcpLFxuICAgICAgICBvdXRybzogZ2V0T3B0aW9uKCdvdXRybycpLFxuICAgICAgICBwYXRoczogZ2V0T3B0aW9uKCdwYXRocycpLFxuICAgICAgICBwbHVnaW5zOiBhd2FpdCBub3JtYWxpemVQbHVnaW5PcHRpb24oY29uZmlnLnBsdWdpbnMpLFxuICAgICAgICBwcmVzZXJ2ZU1vZHVsZXM6IGdldE9wdGlvbigncHJlc2VydmVNb2R1bGVzJyksXG4gICAgICAgIHByZXNlcnZlTW9kdWxlc1Jvb3Q6IGdldE9wdGlvbigncHJlc2VydmVNb2R1bGVzUm9vdCcpLFxuICAgICAgICByZWV4cG9ydFByb3RvRnJvbUV4dGVybmFsOiBnZXRPcHRpb24oJ3JlZXhwb3J0UHJvdG9Gcm9tRXh0ZXJuYWwnKSxcbiAgICAgICAgc2FuaXRpemVGaWxlTmFtZTogZ2V0T3B0aW9uKCdzYW5pdGl6ZUZpbGVOYW1lJyksXG4gICAgICAgIHNvdXJjZW1hcDogZ2V0T3B0aW9uKCdzb3VyY2VtYXAnKSxcbiAgICAgICAgc291cmNlbWFwQmFzZVVybDogZ2V0T3B0aW9uKCdzb3VyY2VtYXBCYXNlVXJsJyksXG4gICAgICAgIHNvdXJjZW1hcERlYnVnSWRzOiBnZXRPcHRpb24oJ3NvdXJjZW1hcERlYnVnSWRzJyksXG4gICAgICAgIHNvdXJjZW1hcEV4Y2x1ZGVTb3VyY2VzOiBnZXRPcHRpb24oJ3NvdXJjZW1hcEV4Y2x1ZGVTb3VyY2VzJyksXG4gICAgICAgIHNvdXJjZW1hcEZpbGU6IGdldE9wdGlvbignc291cmNlbWFwRmlsZScpLFxuICAgICAgICBzb3VyY2VtYXBGaWxlTmFtZXM6IGdldE9wdGlvbignc291cmNlbWFwRmlsZU5hbWVzJyksXG4gICAgICAgIHNvdXJjZW1hcElnbm9yZUxpc3Q6IGdldE9wdGlvbignc291cmNlbWFwSWdub3JlTGlzdCcpLFxuICAgICAgICBzb3VyY2VtYXBQYXRoVHJhbnNmb3JtOiBnZXRPcHRpb24oJ3NvdXJjZW1hcFBhdGhUcmFuc2Zvcm0nKSxcbiAgICAgICAgc3RyaWN0OiBnZXRPcHRpb24oJ3N0cmljdCcpLFxuICAgICAgICBzeXN0ZW1OdWxsU2V0dGVyczogZ2V0T3B0aW9uKCdzeXN0ZW1OdWxsU2V0dGVycycpLFxuICAgICAgICB2YWxpZGF0ZTogZ2V0T3B0aW9uKCd2YWxpZGF0ZScpLFxuICAgICAgICB2aXJ0dWFsRGlybmFtZTogZ2V0T3B0aW9uKCd2aXJ0dWFsRGlybmFtZScpXG4gICAgfTtcbiAgICB3YXJuVW5rbm93bk9wdGlvbnMoY29uZmlnLCBPYmplY3Qua2V5cyhvdXRwdXRPcHRpb25zKSwgJ291dHB1dCBvcHRpb25zJywgbG9nKTtcbiAgICByZXR1cm4gb3V0cHV0T3B0aW9ucztcbn1cblxuY2xhc3MgV2F0Y2hFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50SGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnBlcnNpc3RlbnRIYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIC8vIFdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgUm9sbHVwXG4gICAgYXN5bmMgY2xvc2UoKSB7IH1cbiAgICBlbWl0KGV2ZW50LCAuLi5wYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbLi4udGhpcy5nZXRDdXJyZW50SGFuZGxlcnMoZXZlbnQpLCAuLi50aGlzLmdldFBlcnNpc3RlbnRIYW5kbGVycyhldmVudCldLm1hcChoYW5kbGVyID0+IGhhbmRsZXIoLi4ucGFyYW1ldGVycykpKTtcbiAgICB9XG4gICAgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLnBlcnNpc3RlbnRIYW5kbGVyc1tldmVudF07XG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIC8vIEEgaGFjayBzdG9sZW4gZnJvbSBcIm1pdHRcIjogXCI+Pj4gMFwiIGRvZXMgbm90IGNoYW5nZSBudW1iZXJzID49IDAsIGJ1dCAtMVxuICAgICAgICAgICAgLy8gKHdoaWNoIHdvdWxkIHJlbW92ZSB0aGUgbGFzdCBhcnJheSBlbGVtZW50IGlmIHVzZWQgdW5jaGFuZ2VkKSBpcyB0dXJuZWRcbiAgICAgICAgICAgIC8vIGludG8gbWF4X2ludCwgd2hpY2ggaXMgb3V0c2lkZSB0aGUgYXJyYXkgYW5kIGRvZXMgbm90IGNoYW5nZSBhbnl0aGluZy5cbiAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UobGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpID4+PiAwLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZ2V0UGVyc2lzdGVudEhhbmRsZXJzKGV2ZW50KS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9uQ3VycmVudFJ1bihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50SGFuZGxlcnMoZXZlbnQpLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb25jZShldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc2VsZlJlbW92aW5nTGlzdGVuZXIgPSAoLi4ucGFyYW1ldGVycykgPT4ge1xuICAgICAgICAgICAgdGhpcy5vZmYoZXZlbnQsIHNlbGZSZW1vdmluZ0xpc3RlbmVyKTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lciguLi5wYXJhbWV0ZXJzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbihldmVudCwgc2VsZlJlbW92aW5nTGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyc0ZvckN1cnJlbnRSdW4oKTtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW50SGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXJzRm9yQ3VycmVudFJ1bigpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50SGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0Q3VycmVudEhhbmRsZXJzKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRIYW5kbGVyc1tldmVudF0gfHwgKHRoaXMuY3VycmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdKTtcbiAgICB9XG4gICAgZ2V0UGVyc2lzdGVudEhhbmRsZXJzKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbnRIYW5kbGVyc1tldmVudF0gfHwgKHRoaXMucGVyc2lzdGVudEhhbmRsZXJzW2V2ZW50XSA9IFtdKTtcbiAgICB9XG59XG5cbmxldCBmc0V2ZW50cztcbmxldCBmc0V2ZW50c0ltcG9ydEVycm9yO1xuYXN5bmMgZnVuY3Rpb24gbG9hZEZzRXZlbnRzKCkge1xuICAgIHRyeSB7XG4gICAgICAgICh7IGRlZmF1bHQ6IGZzRXZlbnRzIH0gPSBhd2FpdCBpbXBvcnQoJ2ZzZXZlbnRzJykpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZnNFdmVudHNJbXBvcnRFcnJvciA9IGVycm9yO1xuICAgIH1cbn1cbi8vIEEgY2FsbCB0byB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgaW5qZWN0ZWQgaW50byB0aGUgY2hva2lkYXIgY29kZVxuZnVuY3Rpb24gZ2V0RnNFdmVudHMoKSB7XG4gICAgaWYgKGZzRXZlbnRzSW1wb3J0RXJyb3IpXG4gICAgICAgIHRocm93IGZzRXZlbnRzSW1wb3J0RXJyb3I7XG4gICAgcmV0dXJuIGZzRXZlbnRzO1xufVxuXG5jb25zdCBmc2V2ZW50c0ltcG9ydGVyID0gLyojX19QVVJFX18qL09iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2V0RnNFdmVudHMsXG4gIGxvYWRGc0V2ZW50c1xufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblxuZnVuY3Rpb24gd2F0Y2goY29uZmlncykge1xuICAgIGNvbnN0IGVtaXR0ZXIgPSBuZXcgV2F0Y2hFbWl0dGVyKCk7XG4gICAgd2F0Y2hJbnRlcm5hbChjb25maWdzLCBlbWl0dGVyKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZW1pdHRlcjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdhdGNoSW50ZXJuYWwoY29uZmlncywgZW1pdHRlcikge1xuICAgIGNvbnN0IG9wdGlvbnNMaXN0ID0gYXdhaXQgUHJvbWlzZS5hbGwoZW5zdXJlQXJyYXkoY29uZmlncykubWFwKGNvbmZpZyA9PiBtZXJnZU9wdGlvbnMoY29uZmlnLCB0cnVlKSkpO1xuICAgIGNvbnN0IHdhdGNoT3B0aW9uc0xpc3QgPSBvcHRpb25zTGlzdC5maWx0ZXIoY29uZmlnID0+IGNvbmZpZy53YXRjaCAhPT0gZmFsc2UpO1xuICAgIGlmICh3YXRjaE9wdGlvbnNMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZXJyb3IobG9nSW52YWxpZE9wdGlvbignd2F0Y2gnLCBVUkxfV0FUQ0gsICd0aGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSBjb25maWcgd2hlcmUgXCJ3YXRjaFwiIGlzIG5vdCBzZXQgdG8gXCJmYWxzZVwiJykpO1xuICAgIH1cbiAgICBhd2FpdCBsb2FkRnNFdmVudHMoKTtcbiAgICBjb25zdCB7IFdhdGNoZXIgfSA9IGF3YWl0IGltcG9ydCgnLi93YXRjaC5qcycpO1xuICAgIG5ldyBXYXRjaGVyKHdhdGNoT3B0aW9uc0xpc3QsIGVtaXR0ZXIpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVGaWx0ZXIsIGRlZmluZUNvbmZpZywgZnNldmVudHNJbXBvcnRlciwgZ2V0QXVnbWVudGVkTmFtZXNwYWNlLCBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcywgcm9sbHVwLCByb2xsdXBJbnRlcm5hbCwgdmVyc2lvbiwgd2F0Y2ggfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/rollup/dist/es/shared/node-entry.js\n");

/***/ })

}]);